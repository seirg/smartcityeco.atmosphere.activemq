(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/build/api-deps.js":[function(require,module,exports){

require("../src/Util.js");



require("../src/layers/WMSLayer.js");
require("../src/layers/TileLayer.js");
require("../src/layers/markers/MarkerLayer.js");
require("../src/layers/geometry/GeometryLayer.js");
require("../src/layers/geometry/TiledGeometryLayer.js");
require("../src/layers/Folder.js");

require("../src/providers/WFSProvider.js");
require("../src/layers/markers/WFSMarkerLayer.js");
require("../src/layers/geometry/WFSGeometryLayer.js");
require("../src/layers/geometry/WFSTiledGeometryLayer.js");
require("../src/layers/markers/AtmosphereRTMarkerLayer.js");
require("../src/layers/markers/AtmosphereRTMarkerLayer.js");

require("../src/layers/aggregation/AggregatingLayer.js");
require("../src/layers/history/AggregatingHistoryLayer.js");
require("../src/layers/history/DataHistoryLayer.js");

require("../src/layers/aggregation/MultiModeLayer.js");

require("../src/providers/WFSTProvider.js");
require("../src/layers/EditableLayer.js");
require("../src/layers/markers/WFSTMarkerLayer.js");

require("../src/layers/reloaders/TimerReloadTrigger.js");
require("../src/layers/reloaders/AtmosphereRTReloadTrigger.js");

require("../src/layers/IsochroneLayer.js");
require("../src/controls/IsochroneControl.js");
require("../src/layers/stylers/ParserFunction.js");

//require("../src/providers/SolrHistoryProvider.js");
require("../src/layers/geometry/SolrGeometryHistoryLayer.js");
},{"../src/Util.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/Util.js","../src/controls/IsochroneControl.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/IsochroneControl.js","../src/layers/EditableLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/EditableLayer.js","../src/layers/Folder.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/Folder.js","../src/layers/IsochroneLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/IsochroneLayer.js","../src/layers/TileLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/TileLayer.js","../src/layers/WMSLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/WMSLayer.js","../src/layers/aggregation/AggregatingLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/AggregatingLayer.js","../src/layers/aggregation/MultiModeLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/MultiModeLayer.js","../src/layers/geometry/GeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/GeometryLayer.js","../src/layers/geometry/SolrGeometryHistoryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/SolrGeometryHistoryLayer.js","../src/layers/geometry/TiledGeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/TiledGeometryLayer.js","../src/layers/geometry/WFSGeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/WFSGeometryLayer.js","../src/layers/geometry/WFSTiledGeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/WFSTiledGeometryLayer.js","../src/layers/history/AggregatingHistoryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/AggregatingHistoryLayer.js","../src/layers/history/DataHistoryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/DataHistoryLayer.js","../src/layers/markers/AtmosphereRTMarkerLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/AtmosphereRTMarkerLayer.js","../src/layers/markers/MarkerLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/MarkerLayer.js","../src/layers/markers/WFSMarkerLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/WFSMarkerLayer.js","../src/layers/markers/WFSTMarkerLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/WFSTMarkerLayer.js","../src/layers/reloaders/AtmosphereRTReloadTrigger.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/AtmosphereRTReloadTrigger.js","../src/layers/reloaders/TimerReloadTrigger.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/TimerReloadTrigger.js","../src/layers/stylers/ParserFunction.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/ParserFunction.js","../src/providers/WFSProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSProvider.js","../src/providers/WFSTProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSTProvider.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/LeafletHtmlIcon.js":[function(require,module,exports){
/**
 * Plugin for adding arbitrary HTML markers to a Leaflet map
 * https://github.com/dwnoble/LeafletHtmlIcon
 * 
 * Public domain
 * 
 */

L.HtmlIcon = L.Icon.extend({
	options: {
		/*
		html: (String) (required)
		iconAnchor: (Point)
		popupAnchor: (Point)
		*/
	},

	initialize: function (options) {
		L.Util.setOptions(this, options);
	},

	createIcon: function () {
		var div = document.createElement('div');
		div.innerHTML = this.options.html;
		return div;
	},

	createShadow: function () {
		return null;
	}
});


},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/atmosphere-jquery/jquery.atmosphere.js":[function(require,module,exports){
/*
 * Copyright 2014 Jeanfrancois Arcand
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/**
 * Atmosphere.js
 * https://github.com/Atmosphere/atmosphere-javascript
 * 
 * Requires 
 * - jQuery 2.0.3 http://jquery.com/
 * 
 * API reference
 * https://github.com/Atmosphere/atmosphere/wiki/jQuery.atmosphere.js-API
 * 
 * Highly inspired by 
 * - Portal by Donghwan Kim http://flowersinthesand.github.io/portal/
 */
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else {
        // Browser globals, Window
        factory(jQuery);
    }
}(function(jQuery) {

    jQuery(window).bind("unload.atmosphere", function () {
        jQuery.atmosphere.unsubscribe();
    });

    jQuery(window).bind("offline", function () {
        jQuery.atmosphere.unsubscribe();
    });

    // Prevent ESC to kill the connection from Firefox.
    jQuery(window).keypress(function (e) {
        if (e.keyCode === 27) {
            e.preventDefault();
        }
    });

    var parseHeaders = function (headerString) {
        var match, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, headers = {};
        while (match = rheaders.exec(headerString)) {
            headers[match[1]] = match[2];
        }
        return headers;
    };

    jQuery.atmosphere = {
        version: "2.2.1-jquery",
        uuid : 0,
        requests: [],
        callbacks: [],

        onError: function (response) {
        },
        onClose: function (response) {
        },
        onOpen: function (response) {
        },
        onMessage: function (response) {
        },
        onReconnect: function (request, response) {
        },
        onMessagePublished: function (response) {
        },
        onTransportFailure: function (errorMessage, _request) {
        },
        onLocalMessage: function (response) {
        },
        onClientTimeout: function(request){
        },
        onFailureToReconnect: function (request, response) {
        },

        /**
         * Creates an object based on an atmosphere subscription that exposes functions defined by the Websocket interface.
         *
         * @class WebsocketApiAdapter
         * @param {Object} request the request object to build the underlying subscription
         * @constructor
         */
        WebsocketApiAdapter: function (request) {
            var _socket, _adapter;

            /**
             * Overrides the onMessage callback in given request.
             *
             * @method onMessage
             * @param {Object} e the event object
             */
            request.onMessage = function (e) {
                _adapter.onmessage({data: e.responseBody});
            };


            /**
             * Overrides the onOpen callback in given request to proxy the event to the adapter.
             *
             * @method onOpen
             * @param {Object} e the event object
             */
            request.onOpen = function (e) {
                _adapter.onopen(e);
            };

            _adapter = {
                send: function (data) {
                    _socket.push(data);
                },

                onmessage: function(e) {
                },

                onopen: function(e) {
                },

                onclose: function (e) {
                },

                onerror: function (e) {

                }
            };
            _socket = new $.atmosphere.subscribe(request);

            return _adapter;
        },

        AtmosphereRequest: function (options) {

            /**
             * {Object} Request parameters.
             *
             * @private
             */
            var _request = {
                timeout: 300000,
                method: 'GET',
                headers: {},
                contentType: '',
                callback: null,
                url: '',
                data: '',
                suspend: true,
                maxRequest: -1,
                reconnect: true,
                maxStreamingLength: 10000000,
                lastIndex: 0,
                logLevel: 'info',
                requestCount: 0,
                fallbackMethod: 'GET',
                fallbackTransport: 'streaming',
                transport: 'long-polling',
                webSocketImpl: null,
                webSocketBinaryType: null,
                dispatchUrl: null,
                webSocketPathDelimiter: "@@",
                enableXDR: false,
                rewriteURL: false,
                attachHeadersAsQueryString: true,
                executeCallbackBeforeReconnect: false,
                readyState: 0,
                lastTimestamp: 0,
                withCredentials: false,
                trackMessageLength: false,
                messageDelimiter: '|',
                connectTimeout: -1,
                reconnectInterval: 0,
                dropHeaders: true,
                uuid: 0,
                shared: false,
                readResponsesHeaders: false,
                maxReconnectOnClose: 5,
                enableProtocol: true,
                pollingInterval : 0,
                heartbeat: {
                    client: null,
                    server: null
                },
                ackInterval: 0,
                onError: function (response) {
                },
                onClose: function (response) {
                },
                onOpen: function (response) {
                },
                onMessage: function (response) {
                },
                onReopen: function (request, response) {
                },
                onReconnect: function (request, response) {
                },
                onMessagePublished: function (response) {
                },
                onTransportFailure: function (reason, request) {
                },
                onLocalMessage: function (request) {
                },
                onFailureToReconnect: function (request, response) {
                },
                onClientTimeout: function(request){
                }
            };

            /**
             * {Object} Request's last response.
             *
             * @private
             */
            var _response = {
                status: 200,
                reasonPhrase: "OK",
                responseBody: '',
                messages: [],
                headers: [],
                state: "messageReceived",
                transport: "polling",
                error: null,
                request: null,
                partialMessage: "",
                errorHandled: false,
                closedByClientTimeout: false,
                ffTryingReconnect : false
            };

            /**
             * {websocket} Opened web socket.
             *
             * @private
             */
            var _websocket = null;

            /**
             * {SSE} Opened SSE.
             *
             * @private
             */
            var _sse = null;

            /**
             * {XMLHttpRequest, ActiveXObject} Opened ajax request (in case of http-streaming or long-polling)
             *
             * @private
             */
            var _activeRequest = null;

            /**
             * {Object} Object use for streaming with IE.
             *
             * @private
             */
            var _ieStream = null;

            /**
             * {Object} Object use for jsonp transport.
             *
             * @private
             */
            var _jqxhr = null;

            /**
             * {boolean} If request has been subscribed or not.
             *
             * @private
             */
            var _subscribed = true;

            /**
             * {number} Number of test reconnection.
             *
             * @private
             */
            var _requestCount = 0;

            /**
             * {boolean} If request is currently aborded.
             *
             * @private
             */
            var _abordingConnection = false;

            /**
             * A local "channel' of communication.
             *
             * @private
             */
            var _localSocketF = null;

            /**
             * The storage used.
             *
             * @private
             */
            var _storageService;

            /**
             * Local communication
             *
             * @private
             */
            var _localStorageService = null;

            /**
             * A Unique ID
             *
             * @private
             */
            var guid = jQuery.now();

            /** Trace time */
            var _traceTimer;

            /** Key for connection sharing */
            var _sharingKey;

            // Automatic call to subscribe
            _subscribe(options);

            /**
             * Initialize atmosphere request object.
             *
             * @private
             */
            function _init() {
                _subscribed = true;
                _abordingConnection = false;
                _requestCount = 0;

                _websocket = null;
                _sse = null;
                _activeRequest = null;
                _ieStream = null;
            }

            /**
             * Re-initialize atmosphere object.
             *
             * @private
             */
            function _reinit() {
                _clearState();
                _init();
            }

            /**
             * Subscribe request using request transport. <br>
             * If request is currently opened, this one will be closed.
             *
             * @param {Object} Request parameters.
             * @private
             */
            function _subscribe(options) {
                _reinit();

                _request = jQuery.extend(_request, options);
                // Allow at least 1 request
                _request.mrequest = _request.reconnect;
                if (!_request.reconnect) {
                    _request.reconnect = true;
                }
            }

            /**
             * Check if web socket is supported (check for custom implementation provided by request object or browser implementation).
             *
             * @returns {boolean} True if web socket is supported, false otherwise.
             * @private
             */
            function _supportWebsocket() {
                return _request.webSocketImpl != null || window.WebSocket || window.MozWebSocket;
            }

            /**
             * Check if server side events (SSE) is supported (check for custom implementation provided by request object or browser implementation).
             *
             * @returns {boolean} True if web socket is supported, false otherwise.
             * @private
             */
            function _supportSSE() {
                return window.EventSource;
            }

            /**
             * Open request using request transport. <br>
             * If request transport is 'websocket' but websocket can't be opened, request will automatically reconnect using fallback transport.
             *
             * @private
             */
            function _execute() {
                // Shared across multiple tabs/windows.
                if (_request.shared) {
                    _localStorageService = _local(_request);
                    if (_localStorageService != null) {
                        if (_request.logLevel === 'debug') {
                            jQuery.atmosphere.debug("Storage service available. All communication will be local");
                        }

                        if (_localStorageService.open(_request)) {
                            // Local connection.
                            return;
                        }
                    }

                    if (_request.logLevel === 'debug') {
                        jQuery.atmosphere.debug("No Storage service available.");
                    }
                    // Wasn't local or an error occurred
                    _localStorageService = null;
                }

                // Protocol
                _request.firstMessage = jQuery.atmosphere.uuid == 0 ? true : false;
                _request.isOpen = false;
                _request.ctime = jQuery.now();

                // We carry any UUID set by the user or from a previous connection.
                if (_request.uuid === 0) {
                    _request.uuid = jQuery.atmosphere.uuid;
                }
                _request.closedByClientTimeout = false;

                if (_request.transport !== 'websocket' && _request.transport !== 'sse') {
                    _executeRequest(_request);

                } else if (_request.transport === 'websocket') {
                    if (!_supportWebsocket()) {
                        _reconnectWithFallbackTransport("Websocket is not supported, using request.fallbackTransport (" + _request.fallbackTransport
                            + ")");
                    } else {
                        _executeWebSocket(false);
                    }
                } else if (_request.transport === 'sse') {
                    if (!_supportSSE()) {
                        _reconnectWithFallbackTransport("Server Side Events(SSE) is not supported, using request.fallbackTransport ("
                            + _request.fallbackTransport + ")");
                    } else {
                        _executeSSE(false);
                    }
                }
            }

            function _local(request) {
                var trace, connector, orphan, name = "atmosphere-" + request.url, connectors = {
                    storage: function () {
                        if (!jQuery.atmosphere.supportStorage()) {
                            return;
                        }

                        var storage = window.localStorage, get = function (key) {
                            return jQuery.parseJSON(storage.getItem(name + "-" + key));
                        }, set = function (key, value) {
                            storage.setItem(name + "-" + key, jQuery.stringifyJSON(value));
                        };

                        return {
                            init: function () {
                                set("children", get("children").concat([guid]));
                                jQuery(window).on("storage.socket", function (event) {
                                    event = event.originalEvent;
                                    if (event.key === name && event.newValue) {
                                        listener(event.newValue);
                                    }
                                });
                                return get("opened");
                            },
                            signal: function (type, data) {
                                storage.setItem(name, jQuery.stringifyJSON({
                                    target: "p",
                                    type: type,
                                    data: data
                                }));
                            },
                            close: function () {
                                var index, children = get("children");

                                jQuery(window).off("storage.socket");
                                if (children) {
                                    index = jQuery.inArray(request.id, children);
                                    if (index > -1) {
                                        children.splice(index, 1);
                                        set("children", children);
                                    }
                                }
                            }
                        };
                    },
                    windowref: function () {
                        var win = window.open("", name.replace(/\W/g, ""));

                        if (!win || win.closed || !win.callbacks) {
                            return;
                        }

                        return {
                            init: function () {
                                win.callbacks.push(listener);
                                win.children.push(guid);
                                return win.opened;
                            },
                            signal: function (type, data) {
                                if (!win.closed && win.fire) {
                                    win.fire(jQuery.stringifyJSON({
                                        target: "p",
                                        type: type,
                                        data: data
                                    }));
                                }
                            },
                            close: function () {
                                function remove(array, e) {
                                    var index = jQuery.inArray(e, array);
                                    if (index > -1) {
                                        array.splice(index, 1);
                                    }
                                }

                                // Removes traces only if the parent is alive
                                if (!orphan) {
                                    remove(win.callbacks, listener);
                                    remove(win.children, guid);
                                }
                            }

                        };
                    }
                };

                // Receives open, close and message command from the parent
                function listener(string) {
                    var command = jQuery.parseJSON(string), data = command.data;

                    if (command.target === "c") {
                        switch (command.type) {
                            case "open":
                                _open("opening", 'local', _request);
                                break;
                            case "close":
                                if (!orphan) {
                                    orphan = true;
                                    if (data.reason === "aborted") {
                                        _close();
                                    } else {
                                        // Gives the heir some time to reconnect
                                        if (data.heir === guid) {
                                            _execute();
                                        } else {
                                            setTimeout(function () {
                                                _execute();
                                            }, 100);
                                        }
                                    }
                                }
                                break;
                            case "message":
                                _prepareCallback(data, "messageReceived", 200, request.transport);
                                break;
                            case "localMessage":
                                _localMessage(data);
                                break;
                        }
                    }
                }

                function findTrace() {
                    var matcher = new RegExp("(?:^|; )(" + encodeURIComponent(name) + ")=([^;]*)").exec(document.cookie);
                    if (matcher) {
                        return jQuery.parseJSON(decodeURIComponent(matcher[2]));
                    }
                }

                // Finds and validates the parent socket's trace from the cookie
                trace = findTrace();
                if (!trace || jQuery.now() - trace.ts > 1000) {
                    return;
                }

                // Chooses a connector
                connector = connectors.storage() || connectors.windowref();
                if (!connector) {
                    return;
                }

                return {
                    open: function () {
                        var parentOpened;

                        // Checks the shared one is alive
                        _traceTimer = setInterval(function () {
                            var oldTrace = trace;
                            trace = findTrace();
                            if (!trace || oldTrace.ts === trace.ts) {
                                // Simulates a close signal
                                listener(jQuery.stringifyJSON({
                                    target: "c",
                                    type: "close",
                                    data: {
                                        reason: "error",
                                        heir: oldTrace.heir
                                    }
                                }));
                            }
                        }, 1000);

                        parentOpened = connector.init();
                        if (parentOpened) {
                            // Firing the open event without delay robs the user of the opportunity to bind connecting event handlers
                            setTimeout(function () {
                                _open("opening", 'local', request);
                            }, 50);
                        }
                        return parentOpened;
                    },
                    send: function (event) {
                        connector.signal("send", event);
                    },
                    localSend: function (event) {
                        connector.signal("localSend", jQuery.stringifyJSON({
                            id: guid,
                            event: event
                        }));
                    },
                    close: function () {
                        // Do not signal the parent if this method is executed by the unload event handler
                        if (!_abordingConnection) {
                            clearInterval(_traceTimer);
                            connector.signal("close");
                            connector.close();
                        }
                    }
                };
            }

            function share() {
                var storageService, name = "atmosphere-" + _request.url, servers = {
                    // Powered by the storage event and the localStorage
                    // http://www.w3.org/TR/webstorage/#event-storage
                    storage: function () {
                        if (!jQuery.atmosphere.supportStorage()) {
                            return;
                        }

                        var storage = window.localStorage;

                        return {
                            init: function () {
                                // Handles the storage event
                                jQuery(window).on("storage.socket", function (event) {
                                    event = event.originalEvent;
                                    // When a deletion, newValue initialized to null
                                    if (event.key === name && event.newValue) {
                                        listener(event.newValue);
                                    }
                                });
                            },
                            signal: function (type, data) {
                                storage.setItem(name, jQuery.stringifyJSON({
                                    target: "c",
                                    type: type,
                                    data: data
                                }));
                            },
                            get: function (key) {
                                return jQuery.parseJSON(storage.getItem(name + "-" + key));
                            },
                            set: function (key, value) {
                                storage.setItem(name + "-" + key, jQuery.stringifyJSON(value));
                            },
                            close: function () {
                                jQuery(window).off("storage.socket");
                                storage.removeItem(name);
                                storage.removeItem(name + "-opened");
                                storage.removeItem(name + "-children");
                            }

                        };
                    },
                    // Powered by the window.open method
                    // https://developer.mozilla.org/en/DOM/window.open
                    windowref: function () {
                        // Internet Explorer raises an invalid argument error
                        // when calling the window.open method with the name containing non-word characters
                        var neim = name.replace(/\W/g, ""), win = (jQuery('iframe[name="' + neim + '"]')[0] || jQuery(
                            '<iframe name="' + neim + '" />').hide().appendTo("body")[0]).contentWindow;

                        return {
                            init: function () {
                                // Callbacks from different windows
                                win.callbacks = [listener];
                                // In IE 8 and less, only string argument can be safely passed to the function in other window
                                win.fire = function (string) {
                                    var i;

                                    for (i = 0; i < win.callbacks.length; i++) {
                                        win.callbacks[i](string);
                                    }
                                };
                            },
                            signal: function (type, data) {
                                if (!win.closed && win.fire) {
                                    win.fire(jQuery.stringifyJSON({
                                        target: "c",
                                        type: type,
                                        data: data
                                    }));
                                }
                            },
                            get: function (key) {
                                return !win.closed ? win[key] : null;
                            },
                            set: function (key, value) {
                                if (!win.closed) {
                                    win[key] = value;
                                }
                            },
                            close: function () {
                            }
                        };
                    }
                };

                // Receives send and close command from the children
                function listener(string) {
                    var command = jQuery.parseJSON(string), data = command.data;

                    if (command.target === "p") {
                        switch (command.type) {
                            case "send":
                                _push(data);
                                break;
                            case "localSend":
                                _localMessage(data);
                                break;
                            case "close":
                                _close();
                                break;
                        }
                    }
                }

                _localSocketF = function propagateMessageEvent(context) {
                    storageService.signal("message", context);
                };

                function leaveTrace() {
                    document.cookie = _sharingKey + "=" +
                        // Opera's JSON implementation ignores a number whose a last digit of 0 strangely
                        // but has no problem with a number whose a last digit of 9 + 1
                        encodeURIComponent(jQuery.stringifyJSON({
                            ts: jQuery.now() + 1,
                            heir: (storageService.get("children") || [])[0]
                        })) + "; path=/";
                }

                // Chooses a storageService
                storageService = servers.storage() || servers.windowref();
                storageService.init();

                if (_request.logLevel === 'debug') {
                    jQuery.atmosphere.debug("Installed StorageService " + storageService);
                }

                // List of children sockets
                storageService.set("children", []);

                if (storageService.get("opened") != null && !storageService.get("opened")) {
                    // Flag indicating the parent socket is opened
                    storageService.set("opened", false);
                }
                // Leaves traces
                _sharingKey = encodeURIComponent(name);
                leaveTrace();
                _traceTimer = setInterval(leaveTrace, 1000);

                _storageService = storageService;
            }

            /**
             * @private
             */
            function _open(state, transport, request) {
                if (_request.shared && transport !== 'local') {
                    share();
                }

                if (_storageService != null) {
                    _storageService.set("opened", true);
                }

                request.close = function () {
                    _close();
                };

                if (_requestCount > 0 && state === 're-connecting') {
                    request.isReopen = true;
                    _tryingToReconnect(_response);
                } else if (_response.error == null) {
                    _response.request = request;
                    var prevState = _response.state;
                    _response.state = state;
                    var prevTransport = _response.transport;
                    _response.transport = transport;

                    var _body = _response.responseBody;
                    _invokeCallback();
                    _response.responseBody = _body;

                    _response.state = prevState;
                    _response.transport = prevTransport;
                }
            }

            /**
             * Execute request using jsonp transport.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _jsonp(request) {
                // When CORS is enabled, make sure we force the proper transport.
                request.transport = "jsonp";

                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                var url = rq.url;
                if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                }

                var data = rq.data;
                if (rq.attachHeadersAsQueryString) {
                    url = _attachHeaders(rq);
                    if (data !== '') {
                        url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
                    }
                    data = '';
                }

                _jqxhr = jQuery.ajax({
                    url: url,
                    type: rq.method,
                    dataType: "jsonp",
                    error: function (jqXHR, textStatus, errorThrown) {
                        _response.error = true;

                        if (rq.openId) {
                            clearTimeout(rq.openId);
                        }

                        if (rq.heartbeatTimer) {
                            clearTimeout(rq.heartbeatTimer);
                        }

                        if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
                            _open('re-connecting', rq.transport, rq);
                            _reconnect(_jqxhr, rq, rq.reconnectInterval);
                            rq.openId = setTimeout(function() {
                                _triggerOpen(rq);
                            }, rq.reconnectInterval + 1000);
                        } else {
                            _onError(jqXHR.status, errorThrown);
                        }
                    },
                    jsonp: "jsonpTransport",
                    success: function (json) {
                        if (rq.reconnect) {
                            if (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {
                                _readHeaders(_jqxhr, rq);

                                if (!rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }

                                var msg = json.message;
                                if (msg != null && typeof msg !== 'string') {
                                    try {
                                        msg = jQuery.stringifyJSON(msg);
                                    } catch (err) {
                                        // The message was partial
                                    }
                                }

                                var skipCallbackInvocation = _trackMessageSize(msg, rq, _response);
                                if (!skipCallbackInvocation) {
                                    _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                }

                                if (rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }
                            } else {
                                jQuery.atmosphere.log(_request.logLevel, ["JSONP reconnect maximum try reached " + _request.requestCount]);
                                _onError(0, "maxRequest reached");
                            }
                        }
                    },
                    data: rq.data,
                    beforeSend: function (jqXHR) {
                        _doRequest(jqXHR, rq, false);
                    }
                });
            }

            /**
             * Execute request using ajax transport.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _ajax(request) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                var url = rq.url;
                if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                }

                var data = rq.data;
                if (rq.attachHeadersAsQueryString) {
                    url = _attachHeaders(rq);
                    if (data !== '') {
                        url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(data);
                    }
                    data = '';
                }

                var async = typeof (rq.async) !== 'undefined' ? rq.async : true;
                _jqxhr = jQuery.ajax({
                    url: url,
                    type: rq.method,
                    error: function (jqXHR, textStatus, errorThrown) {
                        _response.error = true;
                        if (jqXHR.status < 300) {
                            _reconnect(_jqxhr, rq);
                        } else {
                            _onError(jqXHR.status, errorThrown);
                        }
                    },
                    success: function (data, textStatus, jqXHR) {

                        if (rq.reconnect) {
                            if (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest) {
                                if (!rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }
                                var skipCallbackInvocation = _trackMessageSize(data, rq, _response);
                                if (!skipCallbackInvocation) {
                                    _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                }

                                if (rq.executeCallbackBeforeReconnect) {
                                    _reconnect(_jqxhr, rq, rq.pollingInterval);
                                }
                            } else {
                                jQuery.atmosphere.log(_request.logLevel, ["AJAX reconnect maximum try reached " + _request.requestCount]);
                                _onError(0, "maxRequest reached");
                            }
                        }
                    },
                    beforeSend: function (jqXHR) {
                        _doRequest(jqXHR, rq, false);
                    },
                    crossDomain: rq.enableXDR,
                    async: async
                });
            }

            /**
             * Build websocket object.
             *
             * @param location {string} Web socket url.
             * @returns {websocket} Web socket object.
             * @private
             */
            function _getWebSocket(location) {
                if (_request.webSocketImpl != null) {
                    return _request.webSocketImpl;
                } else {
                    if (window.WebSocket) {
                        return new WebSocket(location);
                    } else {
                        return new MozWebSocket(location);
                    }
                }
            }

            /**
             * Build web socket url from request url.
             *
             * @return {string} Web socket url (start with "ws" or "wss" for secure web socket).
             * @private
             */
            function _buildWebSocketUrl() {
                var url = _attachHeaders(_request);

                return decodeURI(jQuery('<a href="' + url + '"/>')[0].href.replace(/^http/, "ws"));
            }

            /**
             * Build SSE url from request url.
             *
             * @return a url with Atmosphere's headers
             * @private
             */
            function _buildSSEUrl() {
                var url = _attachHeaders(_request);
                return url;
            }

            /**
             * Open SSE. <br>
             * Automatically use fallback transport if SSE can't be opened.
             *
             * @private
             */
            function _executeSSE(sseOpened) {

                _response.transport = "sse";

                var location = _buildSSEUrl(_request.url);

                if (_request.logLevel === 'debug') {
                    jQuery.atmosphere.debug("Invoking executeSSE");
                    jQuery.atmosphere.debug("Using URL: " + location);
                }

                if (_request.enableProtocol && sseOpened) {
                    var time = jQuery.now() - _request.ctime;
                    _request.lastTimestamp = Number(_request.stime) + Number(time);
                }

                if (sseOpened && !_request.reconnect) {
                    if (_sse != null) {
                        _clearState();
                    }
                    return;
                }

                try {
                    _sse = new EventSource(location, {
                        withCredentials: _request.withCredentials
                    });
                } catch (e) {
                    _onError(0, e);
                    _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
                    return;
                }

                if (_request.connectTimeout > 0) {
                    _request.id = setTimeout(function () {
                        if (!sseOpened) {
                            _clearState();
                        }
                    }, _request.connectTimeout);
                }

                _sse.onopen = function (event) {
                    _timeout(_request);
                    if (_request.logLevel === 'debug') {
                        jQuery.atmosphere.debug("SSE successfully opened");
                    }

                    if (!_request.enableProtocol) {
                        if (!sseOpened) {
                            _open('opening', "sse", _request);
                        } else {
                            _open('re-opening', "sse", _request);
                        }
                    } else if (_request.isReopen) {
                        _request.isReopen = false;
                        _open('re-opening', _request.transport, _request);
                    }
                    sseOpened = true;

                    if (_request.method === 'POST') {
                        _response.state = "messageReceived";
                        _sse.send(_request.data);
                    }
                };

                _sse.onmessage = function (message) {
                    _timeout(_request);
                    if (!_request.enableXDR && message.origin !== window.location.protocol + "//" + window.location.host) {
                        jQuery.atmosphere.log(_request.logLevel, ["Origin was not " + window.location.protocol + "//" + window.location.host]);
                        return;
                    }

                    _response.state = 'messageReceived';
                    _response.status = 200;

                    message = message.data;
                    var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
                    if (!skipCallbackInvocation) {
                        _invokeCallback();
                        _response.responseBody = '';
                        _response.messages = [];
                    }
                };

                _sse.onerror = function (message) {
                    clearTimeout(_request.id);

                    if (_request.heartbeatTimer) {
                        clearTimeout(_request.heartbeatTimer);
                    }

                    if (_response.closedByClientTimeout) return;

                    _invokeClose(sseOpened);
                    _clearState();

                    if (_abordingConnection) {
                        jQuery.atmosphere.log(_request.logLevel, ["SSE closed normally"]);
                    } else if (!sseOpened) {
                        _reconnectWithFallbackTransport("SSE failed. Downgrading to fallback transport and resending");
                    } else if (_request.reconnect && (_response.transport === 'sse')) {
                        if (_requestCount++ < _request.maxReconnectOnClose) {
                            _open('re-connecting', _request.transport, _request);
                            if (_request.reconnectInterval > 0) {
                                _request.reconnectId = setTimeout(function () {
                                    _executeSSE(true);
                                }, _request.reconnectInterval);
                            } else {
                                _executeSSE(true);
                            }
                            _response.responseBody = "";
                            _response.messages = [];
                        } else {
                            jQuery.atmosphere.log(_request.logLevel, ["SSE reconnect maximum try reached " + _requestCount]);
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };
            }

            /**
             * Open web socket. <br>
             * Automatically use fallback transport if web socket can't be opened.
             *
             * @private
             */
            function _executeWebSocket(webSocketOpened) {

                _response.transport = "websocket";

                if (_request.enableProtocol && webSocketOpened) {
                    var time = jQuery.now() - _request.ctime;
                    _request.lastTimestamp = Number(_request.stime) + Number(time);
                }

                var location = _buildWebSocketUrl(_request.url);
                if (_request.logLevel === 'debug') {
                    jQuery.atmosphere.debug("Invoking executeWebSocket");
                    jQuery.atmosphere.debug("Using URL: " + location);
                }

                if (webSocketOpened && !_request.reconnect) {
                    if (_websocket != null) {
                        _clearState();
                    }
                    return;
                }

                _websocket = _getWebSocket(location);
                if (_request.webSocketBinaryType != null) {
                    _websocket.binaryType = _request.webSocketBinaryType;
                }

                if (_request.connectTimeout > 0) {
                    _request.id = setTimeout(function () {
                        if (!webSocketOpened) {
                            var _message = {
                                code: 1002,
                                reason: "",
                                wasClean: false
                            };
                            _websocket.onclose(_message);
                            // Close it anyway
                            try {
                                _clearState();
                            } catch (e) {
                            }
                            return;
                        }

                    }, _request.connectTimeout);
                }

                _websocket.onopen = function (message) {
                    _timeout(_request);
                    if (_request.logLevel === 'debug') {
                        jQuery.atmosphere.debug("Websocket successfully opened");
                    }

                    var reopening = webSocketOpened;

                    if(_websocket != null) {
                        _websocket.canSendMessage = true;
                    }

                    if (!_request.enableProtocol) {
                        webSocketOpened = true;
                        if (reopening) {
                            _open('re-opening', "websocket", _request);
                        } else {
                            _open('opening', "websocket", _request);
                        }
                    }

                    if (_websocket != null) {
                        if (_request.method === 'POST') {
                            _response.state = "messageReceived";
                            _websocket.send(_request.data);
                        }
                    }
                };

                _websocket.onmessage = function (message) {
                    _timeout(_request);

                    // We only consider it opened if we get the handshake data
                    // https://github.com/Atmosphere/atmosphere-javascript/issues/74
                    if (_request.enableProtocol) {
                        webSocketOpened = true;
                    }

                    _response.state = 'messageReceived';
                    _response.status = 200;

                    message = message.data;
                    var isString = typeof (message) === 'string';
                    if (isString) {
                        var skipCallbackInvocation = _trackMessageSize(message, _request, _response);
                        if (!skipCallbackInvocation) {
                            _invokeCallback();
                            _response.responseBody = '';
                            _response.messages = [];
                        }
                    } else {
                        message = _handleProtocol(_request, message);
                        if (message === "")
                            return;

                        _response.responseBody = message;
                        _invokeCallback();
                        _response.responseBody = null;
                    }
                };

                _websocket.onerror = function (message) {
                    clearTimeout(_request.id);

                    if (_request.heartbeatTimer) {
                        clearTimeout(_request.heartbeatTimer);
                    }
                };

                _websocket.onclose = function (message) {
                    if (_response.state === 'closed')
                        return;
                    clearTimeout(_request.id);

                    var reason = message.reason;
                    if (reason === "") {
                        switch (message.code) {
                            case 1000:
                                reason = "Normal closure; the connection successfully completed whatever purpose for which " + "it was created.";
                                break;
                            case 1001:
                                reason = "The endpoint is going away, either because of a server failure or because the "
                                    + "browser is navigating away from the page that opened the connection.";
                                break;
                            case 1002:
                                reason = "The endpoint is terminating the connection due to a protocol error.";
                                break;
                            case 1003:
                                reason = "The connection is being terminated because the endpoint received data of a type it "
                                    + "cannot accept (for example, a text-only endpoint received binary data).";
                                break;
                            case 1004:
                                reason = "The endpoint is terminating the connection because a data frame was received that " + "is too large.";
                                break;
                            case 1005:
                                reason = "Unknown: no status code was provided even though one was expected.";
                                break;
                            case 1006:
                                reason = "Connection was closed abnormally (that is, with no close frame being sent).";
                                break;
                        }
                    }

                    if (_request.logLevel === 'warn') {
                        jQuery.atmosphere.warn("Websocket closed, reason: " + reason);
                        jQuery.atmosphere.warn("Websocket closed, wasClean: " + message.wasClean);
                    }

                    if (_response.closedByClientTimeout) {
                        return;
                    }

                    _invokeClose(webSocketOpened);

                    _response.state = 'closed';

                    if (_abordingConnection) {
                        jQuery.atmosphere.log(_request.logLevel, ["Websocket closed normally"]);
                    } else if (!webSocketOpened) {
                        _reconnectWithFallbackTransport("Websocket failed. Downgrading to Comet and resending");

                    } else if (_request.reconnect && _response.transport === 'websocket' && message.code !== 1001) {
                        _clearState();
                        if (_requestCount++ < _request.maxReconnectOnClose) {
                            _open('re-connecting', _request.transport, _request);
                            if (_request.reconnectInterval > 0) {
                                _request.reconnectId = setTimeout(function () {
                                    _response.responseBody = "";
                                    _response.messages = [];
                                    _executeWebSocket(true);
                                }, _request.reconnectInterval);
                            } else {
                                _response.responseBody = "";
                                _response.messages = [];
                                _executeWebSocket(true);
                            }
                        } else {
                            jQuery.atmosphere.log(_request.logLevel, ["Websocket reconnect maximum try reached " + _request.requestCount]);
                            if (_request.logLevel === 'warn') {
                                jQuery.atmosphere.warn("Websocket error, reason: " + message.reason);
                            }
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };

                var ua = navigator.userAgent.toLowerCase();
                var isAndroid = ua.indexOf("android") > -1;
                if (isAndroid && _websocket.url === undefined) {
                    // Android 4.1 does not really support websockets and fails silently
                    _websocket.onclose({
                        reason: "Android 4.1 does not support websockets.",
                        wasClean: false
                    });
                }
            }

            function _handleProtocol(request, message) {
                var nMessage = message;
                if (request.transport === 'polling') return nMessage;

                if (jQuery.trim(message).length !== 0 && request.enableProtocol && request.firstMessage) {
                    var pos = request.trackMessageLength ? 1 : 0;
                    var messages = message.split(request.messageDelimiter);

                    if (messages.length <= pos + 1) {
                        // Something went wrong, normally with IE or when a message is written before the
                        // handshake has been received.
                        return nMessage;
                    }

                    request.firstMessage = false;
                    request.uuid = jQuery.trim(messages[pos]);
                    request.stime = jQuery.trim(messages[pos + 1]);

                    if (messages.length <= pos + 3) {
                        jQuery.atmosphere.log('error', ["Protocol data not sent by the server. " +
                            "If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side." +
                            "Also note that atmosphere-runtime 2.2+ should be used."]);
                    }

                    var interval = parseInt(jQuery.trim(messages[pos + 2]), 10);
                    var paddingData = messages[pos + 3];

                    if (!isNaN(interval) && interval > 0) {
                        var _pushHeartbeat = function () {
                            _push(paddingData);
                            request.heartbeatTimer = setTimeout(_pushHeartbeat, interval);
                        };
                        request.heartbeatTimer = setTimeout(_pushHeartbeat, interval);
                    }

                    b = false;
                    if (request.transport !== 'long-polling') {
                        _triggerOpen(request);
                    }
                    jQuery.atmosphere.uuid = request.uuid;
                    nMessage = "";

                    // We have trailing messages
                    pos = request.trackMessageLength ? 5 : 4;
                    if (messages.length > pos + 1) {
                        for (var i = pos; i < messages.length; i++) {
                            nMessage += messages[i];
                            if (i + 1 !== messages.length) {
                                nMessage += request.messageDelimiter;
                            }
                        }
                    }

                    if (request.ackInterval !== 0) {
                        setTimeout(function () {
                            _push("...ACK...");
                        }, request.ackInterval);
                    }
                } else if (request.enableProtocol && request.firstMessage && jQuery.browser.msie && +jQuery.browser.version.split(".")[0] < 10) {
                    // In case we are getting some junk from IE
                    jQuery.atmosphere.log(_request.logLevel, ["Receiving unexpected data from IE"]);
                } else {
                    _triggerOpen(request);
                }
                return nMessage;
            }

            function _timeout(_request) {
                clearTimeout(_request.id);
                if (_request.timeout > 0 && _request.transport !== 'polling') {
                    _request.id = setTimeout(function () {
                        _onClientTimeout(_request);
                        _disconnect();
                        _clearState();
                    }, _request.timeout);
                }
            }

            function _onClientTimeout(_request) {
                _response.closedByClientTimeout = true;
                _response.state = 'closedByClient';
                _response.responseBody = "";
                _response.status = 408;
                _response.messages = [];
                _invokeCallback();
            }

            function _onError(code, reason) {
                _clearState();
                clearTimeout(_request.id);
                _response.state = 'error';
                _response.reasonPhrase = reason;
                _response.responseBody = "";
                _response.status = code;
                _response.messages = [];
                _invokeCallback();
            }

            /**
             * Track received message and make sure callbacks/functions are only invoked when the complete message has been received.
             *
             * @param message
             * @param request
             * @param response
             */
            function _trackMessageSize(message, request, response) {
                message = _handleProtocol(request, message);
                if (message.length === 0)
                    return true;

                response.responseBody = message;

                if (request.trackMessageLength) {
                    // prepend partialMessage if any
                    message = response.partialMessage + message;

                    var messages = [];
                    var messageStart = message.indexOf(request.messageDelimiter);
                    while (messageStart !== -1) {
                        var str = message.substring(0, messageStart);
                        var messageLength = parseInt(str, 10);
                        if (isNaN(messageLength))
                            throw 'message length "' + str + '" is not a number';
                        messageStart += request.messageDelimiter.length;
                        if (messageStart + messageLength > message.length) {
                            // message not complete, so there is no trailing messageDelimiter
                            messageStart = -1;
                        } else {
                            // message complete, so add it
                            messages.push(message.substring(messageStart, messageStart + messageLength));
                            // remove consumed characters
                            message = message.substring(messageStart + messageLength, message.length);
                            messageStart = message.indexOf(request.messageDelimiter);
                        }
                    }

                    /* keep any remaining data */
                    response.partialMessage = message;

                    if (messages.length !== 0) {
                        response.responseBody = messages.join(request.messageDelimiter);
                        response.messages = messages;
                        return false;
                    } else {
                        response.responseBody = "";
                        response.messages = [];
                        return true;
                    }
                } else {
                    response.responseBody = message;
                }
                return false;
            }

            /**
             * Reconnect request with fallback transport. <br>
             * Used in case websocket can't be opened.
             *
             * @private
             */
            function _reconnectWithFallbackTransport(errorMessage) {
                jQuery.atmosphere.log(_request.logLevel, [errorMessage]);

                if (typeof (_request.onTransportFailure) !== 'undefined') {
                    _request.onTransportFailure(errorMessage, _request);
                } else if (typeof (jQuery.atmosphere.onTransportFailure) !== 'undefined') {
                    jQuery.atmosphere.onTransportFailure(errorMessage, _request);
                }

                _request.transport = _request.fallbackTransport;
                var reconnectInterval = _request.connectTimeout === -1 ? 0 : _request.connectTimeout;
                if (_request.reconnect && _request.transport !== 'none' || _request.transport == null) {
                    _request.method = _request.fallbackMethod;
                    _response.transport = _request.fallbackTransport;
                    _request.fallbackTransport = 'none';
                    if (reconnectInterval > 0) {
                        _request.reconnectId = setTimeout(function () {
                            _execute();
                        }, reconnectInterval);
                    } else {
                        _execute();
                    }
                } else {
                    _onError(500, "Unable to reconnect with fallback transport");
                }
            }

            /**
             * Get url from request and attach headers to it.
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             *
             * @returns {Object} Request object, if undefined, _request object will be used.
             * @private
             */
            function _attachHeaders(request, url) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                if (url == null) {
                    url = rq.url;
                }

                // If not enabled
                if (!rq.attachHeadersAsQueryString)
                    return url;

                // If already added
                if (url.indexOf("X-Atmosphere-Framework") !== -1) {
                    return url;
                }

                url += (url.indexOf('?') !== -1) ? '&' : '?';
                url += "X-Atmosphere-tracking-id=" + rq.uuid;
                url += "&X-Atmosphere-Framework=" + jQuery.atmosphere.version;
                url += "&X-Atmosphere-Transport=" + rq.transport;

                if (rq.trackMessageLength) {
                    url += "&X-Atmosphere-TrackMessageSize=" + "true";
                }

                if (rq.lastTimestamp != null) {
                    url += "&X-Cache-Date=" + rq.lastTimestamp;
                } else {
                    url += "&X-Cache-Date=" + 0;
                }

                if (rq.heartbeat !== null && rq.heartbeat.server !== null) {
                    url += "&X-Heartbeat-Server=" + rq.heartbeat.server;
                }

                if (rq.contentType !== '') {
                    url += "&Content-Type=" + (rq.transport === 'websocket' ? rq.contentType : encodeURIComponent(rq.contentType));
                }

                if (rq.enableProtocol) {
                    url += "&X-atmo-protocol=true";
                }

                jQuery.each(rq.headers, function (name, value) {
                    var h = jQuery.isFunction(value) ? value.call(this, rq, request, _response) : value;
                    if (h != null) {
                        url += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                    }
                });

                return url;
            }

            function _triggerOpen(rq) {
                if (!rq.isOpen) {
                    rq.isOpen = true;
                    _open('opening', rq.transport, rq);
                } else if (rq.isReopen) {
                    rq.isReopen = false;
                    _open('re-opening', rq.transport, rq);
                }
            }

            /**
             * Execute ajax request. <br>
             *
             * @param request {Object} request Request parameters, if undefined _request object will be used.
             * @private
             */
            function _executeRequest(request) {
                var rq = _request;
                if ((request != null) || (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                rq.lastIndex = 0;
                rq.readyState = 0;

                // CORS fake using JSONP
                if ((rq.transport === 'jsonp') || ((rq.enableXDR) && (jQuery.atmosphere.checkCORSSupport()))) {
                    _jsonp(rq);
                    return;
                }

                if (rq.transport === 'ajax') {
                    _ajax(request);
                    return;
                }

                if (jQuery.browser.msie && +jQuery.browser.version.split(".")[0] < 10) {
                    if ((rq.transport === 'streaming')) {
                        if (rq.enableXDR && window.XDomainRequest) {
                            _ieXDR(rq);
                        } else {
                            _ieStreaming(rq);
                        }
                        return;
                    }

                    if ((rq.enableXDR) && (window.XDomainRequest)) {
                        _ieXDR(rq);
                        return;
                    }
                }

                var reconnectF = function () {
                    rq.lastIndex = 0;
                    if (rq.reconnect && _requestCount++ < rq.maxReconnectOnClose) {
                        _open('re-connecting', request.transport, request);
                        _reconnect(ajaxRequest, rq, request.reconnectInterval);
                    } else {
                        _onError(0, "maxReconnectOnClose reached");
                    }
                };

                var disconnected = function () {
                    // Prevent onerror callback to be called
                    _response.errorHandled = true;
                    _clearState();
                    reconnectF();
                };

                if (rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest)) {
                    var ajaxRequest = jQuery.ajaxSettings.xhr();
                    ajaxRequest.hasData = false;

                    _doRequest(ajaxRequest, rq, true);

                    if (rq.suspend) {
                        _activeRequest = ajaxRequest;
                    }

                    if (rq.transport !== 'polling') {
                        _response.transport = rq.transport;

                        ajaxRequest.onabort = function () {
                            _invokeClose(true);
                        };

                        ajaxRequest.onerror = function () {
                            _response.error = true;
                            _response.ffTryingReconnect = true;
                            try {
                                _response.status = XMLHttpRequest.status;
                            } catch (e) {
                                _response.status = 500;
                            }

                            if (!_response.status) {
                                _response.status = 500;
                            }
                            if (!_response.errorHandled) {
                                _clearState();
                                reconnectF();
                            }
                        };
                    }

                    ajaxRequest.onreadystatechange = function () {
                        if (_abordingConnection) {
                            return;
                        }

                        _response.error = null;
                        var skipCallbackInvocation = false;
                        var update = false;

                        if (rq.transport === 'streaming' && rq.readyState > 2 && ajaxRequest.readyState === 4) {
                            _clearState();
                            reconnectF();
                            return;
                        }

                        rq.readyState = ajaxRequest.readyState;

                        if (rq.transport === 'streaming' && ajaxRequest.readyState >= 3) {
                            update = true;
                        } else if (rq.transport === 'long-polling' && ajaxRequest.readyState === 4) {
                            update = true;
                        }
                        _timeout(_request);

                        if (rq.transport !== 'polling') {
                            // MSIE 9 and lower status can be higher than 1000, Chrome can be 0
                            var status = 200;
                            if (ajaxRequest.readyState === 4) {
                                status = ajaxRequest.status > 1000 ? 0 : ajaxRequest.status;
                            }

                            if (status >= 300 || status === 0) {
                                disconnected();
                                return;
                            }
                            
                            // Firefox incorrectly send statechange 0->2 when a reconnect attempt fails. The above checks ensure that onopen is not called for these
                            if ((!rq.enableProtocol || !request.firstMessage) && ajaxRequest.readyState === 2) {
                                // Firefox incorrectly send statechange 0->2 when a reconnect attempt fails. The above checks ensure that onopen is not called for these
                                // In that case, ajaxRequest.onerror will be called just after onreadystatechange is called, so we delay the trigger untill we are
                                // garantee the connection is well established.
                                if (jQuery.browser.mozilla && _response.ffTryingReconnect) {
                                    _response.ffTryingReconnect = false;
                                    setTimeout(function(){
                                       if (!_response.ffTryingReconnect) {
                                           _triggerOpen(rq);
                                       }
                                    }, 500);
                                } else {
                                    _triggerOpen(rq);
                                }                            }
                        } else if (ajaxRequest.readyState === 4) {
                            update = true;
                        }

                        if (update) {
                            var responseText = ajaxRequest.responseText;

                            if (jQuery.trim(responseText).length === 0 && rq.transport === 'long-polling') {
                                // For browser that aren't support onabort
                                if (!ajaxRequest.hasData) {
                                    disconnected();
                                } else {
                                    ajaxRequest.hasData = false;
                                }
                                return;
                            }
                            ajaxRequest.hasData = true;

                            _readHeaders(ajaxRequest, _request);

                            if (rq.transport === 'streaming') {
                                if (!jQuery.browser.opera) {
                                    var message = responseText.substring(rq.lastIndex, responseText.length);
                                    skipCallbackInvocation = _trackMessageSize(message, rq, _response);

                                    rq.lastIndex = responseText.length;
                                    if (skipCallbackInvocation) {
                                        return;
                                    }
                                } else {
                                    jQuery.atmosphere.iterate(function () {
                                        if (_response.status !== 500 && ajaxRequest.responseText.length > rq.lastIndex) {
                                            try {
                                                _response.status = ajaxRequest.status;
                                                _response.headers = parseHeaders(ajaxRequest.getAllResponseHeaders());

                                                _readHeaders(ajaxRequest, _request);

                                            } catch (e) {
                                                _response.status = 404;
                                            }
                                            _timeout(_request);

                                            _response.state = "messageReceived";
                                            var message = ajaxRequest.responseText.substring(rq.lastIndex);
                                            rq.lastIndex = ajaxRequest.responseText.length;

                                            skipCallbackInvocation = _trackMessageSize(message, rq, _response);
                                            if (!skipCallbackInvocation) {
                                                _invokeCallback();
                                            }

                                            if (_verifyStreamingLength(ajaxRequest, rq)){
                                                _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                                                return;
                                            }
                                        } else if (_response.status > 400) {
                                            // Prevent replaying the last message.
                                            rq.lastIndex = ajaxRequest.responseText.length;
                                            return false;
                                        }
                                    }, 0);
                                }
                            } else {
                                skipCallbackInvocation = _trackMessageSize(responseText, rq, _response);
                            }
                            var closeStream = _verifyStreamingLength(ajaxRequest, rq);

                            try {
                                _response.status = ajaxRequest.status;
                                _response.headers = parseHeaders(ajaxRequest.getAllResponseHeaders());

                                _readHeaders(ajaxRequest, rq);
                            } catch (e) {
                                _response.status = 404;
                            }

                            if (rq.suspend) {
                                _response.state = _response.status === 0 ? "closed" : "messageReceived";
                            } else {
                                _response.state = "messagePublished";
                            }

                            var isAllowedToReconnect = !closeStream && request.transport !== 'streaming' && request.transport !== 'polling';;
                            if (isAllowedToReconnect && !rq.executeCallbackBeforeReconnect) {
                                _reconnect(ajaxRequest, rq, rq.pollingInterval);
                            }

                            if (_response.responseBody.length !== 0 && !skipCallbackInvocation)
                                _invokeCallback();

                            if (isAllowedToReconnect && rq.executeCallbackBeforeReconnect) {
                                _reconnect(ajaxRequest, rq, rq.pollingInterval);
                            }

                            if (closeStream) {
                                _reconnectOnMaxStreamingLength(ajaxRequest, rq);
                            }
                        }
                    };

                    ajaxRequest.send(rq.data);
                    _subscribed = true;
                } else {
                    if (rq.logLevel === 'debug') {
                        jQuery.atmosphere.log(rq.logLevel, ["Max re-connection reached."]);
                    }
                    _onError(0, "maxRequest reached");
                }
            }

            function _reconnectOnMaxStreamingLength(ajaxRequest, rq) {
                _close();
                _abordingConnection = false;
                _reconnect(ajaxRequest, rq, 500);
            }

            /**
             * Do ajax request.
             *
             * @param ajaxRequest Ajax request.
             * @param request Request parameters.
             * @param create If ajax request has to be open.
             */
            function _doRequest(ajaxRequest, request, create) {
                // Prevent Android to cache request
                var url = request.url;
                if (request.dispatchUrl != null && request.method === 'POST') {
                    url += request.dispatchUrl;
                }
                url = _attachHeaders(request, url);
                url = jQuery.atmosphere.prepareURL(url);

                if (create) {
                    ajaxRequest.open(request.method, url, true);
                    if (request.connectTimeout > 0) {
                        request.id = setTimeout(function () {
                            if (request.requestCount === 0) {
                                _clearState();
                                _prepareCallback("Connect timeout", "closed", 200, request.transport);
                            }
                        }, request.connectTimeout);
                    }
                }

                if (_request.withCredentials && _request.transport !== 'websocket') {
                    if ("withCredentials" in ajaxRequest) {
                        ajaxRequest.withCredentials = true;
                    }
                }

                if (!_request.dropHeaders) {
                    ajaxRequest.setRequestHeader("X-Atmosphere-Framework", jQuery.atmosphere.version);
                    ajaxRequest.setRequestHeader("X-Atmosphere-Transport", request.transport);
                    if (request.lastTimestamp != null) {
                        ajaxRequest.setRequestHeader("X-Cache-Date", request.lastTimestamp);
                    } else {
                        ajaxRequest.setRequestHeader("X-Cache-Date", 0);
                    }

                    if (ajaxRequest.heartbeat !== null && ajaxRequest.heartbeat.server !== null) {
                        ajaxRequest.setRequestHeader("X-Heartbeat-Server", ajaxRequest.heartbeat.server);
                    }

                    if (request.trackMessageLength) {
                        ajaxRequest.setRequestHeader("X-Atmosphere-TrackMessageSize", "true");
                    }
                    ajaxRequest.setRequestHeader("X-Atmosphere-tracking-id", request.uuid);

                    jQuery.each(request.headers, function (name, value) {
                        var h = jQuery.isFunction(value) ? value.call(this, ajaxRequest, request, create, _response) : value;
                        if (h != null) {
                            ajaxRequest.setRequestHeader(name, h);
                        }
                    });
                }

                if (request.contentType !== '') {
                    ajaxRequest.setRequestHeader("Content-Type", request.contentType);
                }
            }

            function _reconnect(ajaxRequest, request, reconnectInterval) {
                if (request.reconnect || (request.suspend && _subscribed)) {
                    var status = 0;
                    if (ajaxRequest.readyState > 1) {
                        status = ajaxRequest.status > 1000 ? 0 : ajaxRequest.status;
                    }
                    _response.status = status === 0 ? 204 : status;
                    _response.reason = status === 0 ? "Server resumed the connection or down." : "OK";

                    // Reconnect immediately
                    clearTimeout(request.id);
                    if (request.reconnectId) {
                        clearTimeout(request.reconnectId);
                        delete request.reconnectId;
                    }

                    if (reconnectInterval > 0) {
                        setTimeout(function () {
                            _request.reconnectId = _executeRequest(request);
                        }, reconnectInterval);
                    } else {
                        _executeRequest(request);
                    }
                }
            }

            function _tryingToReconnect(response) {
                response.state = 're-connecting';
                _invokeFunction(response);
            }

            // From jquery-stream, which is APL2 licensed as well.
            function _ieXDR(request) {
                if (request.transport !== "polling") {
                    _ieStream = _configureXDR(request);
                    _ieStream.open();
                } else {
                    _configureXDR(request).open();
                }
            }

            function _configureXDR(request) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                var transport = rq.transport;
                var lastIndex = 0;
                var xdr = new window.XDomainRequest();

                var reconnect = function () {
                    if (rq.transport === "long-polling" && (rq.reconnect && (rq.maxRequest === -1 || rq.requestCount++ < rq.maxRequest))) {
                        xdr.status = 200;
                        _ieXDR(rq);
                    }
                };

                var rewriteURL = rq.rewriteURL || function (url) {
                    // Maintaining session by rewriting URL
                    // http://stackoverflow.com/questions/6453779/maintaining-session-by-rewriting-url
                    var match = /(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(document.cookie);

                    switch (match && match[1]) {
                        case "JSESSIONID":
                            return url.replace(/;jsessionid=[^\?]*|(\?)|$/, ";jsessionid=" + match[2] + "$1");
                        case "PHPSESSID":
                            return url.replace(/\?PHPSESSID=[^&]*&?|\?|$/, "?PHPSESSID=" + match[2] + "&").replace(/&$/, "");
                    }
                    return url;
                };

                // Handles open and message event
                xdr.onprogress = function () {
                    handle(xdr);
                };
                // Handles error event
                xdr.onerror = function () {
                    // If the server doesn't send anything back to XDR will fail with polling
                    if (rq.transport !== 'polling') {
                        _clearState();
                        if (_requestCount++ < rq.maxReconnectOnClose) {
                            if (rq.reconnectInterval > 0) {
                                rq.reconnectId = setTimeout(function () {
                                    _open('re-connecting', request.transport, request);
                                    _ieXDR(rq);
                                }, rq.reconnectInterval);
                            } else {
                                _open('re-connecting', request.transport, request);
                                _ieXDR(rq);
                            }
                        } else {
                            _onError(0, "maxReconnectOnClose reached");
                        }
                    }
                };

                // Handles close event
                xdr.onload = function () {
                };

                var handle = function (xdr) {
                    clearTimeout(rq.id);
                    var message = xdr.responseText;

                    message = message.substring(lastIndex);
                    lastIndex += message.length;

                    if (transport !== 'polling') {
                        _timeout(rq);

                        var skipCallbackInvocation = _trackMessageSize(message, rq, _response);

                        if (transport === 'long-polling' && jQuery.trim(message).length === 0)
                            return;

                        if (rq.executeCallbackBeforeReconnect) {
                            reconnect();
                        }

                        if (!skipCallbackInvocation) {
                            _prepareCallback(_response.responseBody, "messageReceived", 200, transport);
                        }

                        if (!rq.executeCallbackBeforeReconnect) {
                            reconnect();
                        }
                    }
                };

                return {
                    open: function () {
                        var url = rq.url;
                        if (rq.dispatchUrl != null) {
                            url += rq.dispatchUrl;
                        }
                        url = _attachHeaders(rq, url);
                        xdr.open(rq.method, rewriteURL(url));
                        if (rq.method === 'GET') {
                            xdr.send();
                        } else {
                            xdr.send(rq.data);
                        }

                        if (rq.connectTimeout > 0) {
                            rq.id = setTimeout(function () {
                                if (rq.requestCount === 0) {
                                    _clearState();
                                    _prepareCallback("Connect timeout", "closed", 200, rq.transport);
                                }
                            }, rq.connectTimeout);
                        }
                    },
                    close: function () {
                        xdr.abort();
                    }
                };
            }

            function _ieStreaming(request) {
                _ieStream = _configureIE(request);
                _ieStream.open();
            }

            function _configureIE(request) {
                var rq = _request;
                if ((request != null) && (typeof (request) !== 'undefined')) {
                    rq = request;
                }

                var stop;
                var doc = new window.ActiveXObject("htmlfile");

                doc.open();
                doc.close();

                var url = rq.url;
                if (rq.dispatchUrl != null) {
                    url += rq.dispatchUrl;
                }

                if (rq.transport !== 'polling') {
                    _response.transport = rq.transport;
                }

                return {
                    open: function () {
                        var iframe = doc.createElement("iframe");

                        url = _attachHeaders(rq);
                        if (rq.data !== '') {
                            url += "&X-Atmosphere-Post-Body=" + encodeURIComponent(rq.data);
                        }

                        // Finally attach a timestamp to prevent Android and IE caching.
                        url = jQuery.atmosphere.prepareURL(url);

                        iframe.src = url;
                        doc.body.appendChild(iframe);

                        // For the server to respond in a consistent format regardless of user agent, we polls response text
                        var cdoc = iframe.contentDocument || iframe.contentWindow.document;

                        stop = jQuery.atmosphere.iterate(function () {
                            try {
                                if (!cdoc.firstChild) {
                                    return;
                                }

                                // Detects connection failure
                                if (cdoc.readyState === "complete") {
                                    try {
                                        jQuery.noop(cdoc.fileSize);
                                    } catch (e) {
                                        _prepareCallback("Connection Failure", "error", 500, rq.transport);
                                        return false;
                                    }
                                }

                                var res = cdoc.body ? cdoc.body.lastChild : cdoc;
                                var readResponse = function () {
                                    // Clones the element not to disturb the original one
                                    var clone = res.cloneNode(true);

                                    // If the last character is a carriage return or a line feed, IE ignores it in the innerText property
                                    // therefore, we add another non-newline character to preserve it
                                    clone.appendChild(cdoc.createTextNode("."));

                                    var text = clone.innerText;

                                    text = text.substring(0, text.length - 1);
                                    return text;

                                };

                                // To support text/html content type
                                if (!jQuery.nodeName(res, "pre")) {
                                    // Injects a plaintext element which renders text without interpreting the HTML and cannot be stopped
                                    // it is deprecated in HTML5, but still works
                                    var head = cdoc.head || cdoc.getElementsByTagName("head")[0] || cdoc.documentElement || cdoc;
                                    var script = cdoc.createElement("script");

                                    script.text = "document.write('<plaintext>')";

                                    head.insertBefore(script, head.firstChild);
                                    head.removeChild(script);

                                    // The plaintext element will be the response container
                                    res = cdoc.body.lastChild;
                                }

                                if (rq.closed) {
                                    rq.isReopen = true;
                                }

                                // Handles message and close event
                                stop = jQuery.atmosphere.iterate(function () {
                                    var text = readResponse();
                                    if (text.length > rq.lastIndex) {
                                        _timeout(_request);

                                        _response.status = 200;
                                        _response.error = null;

                                        // Empties response every time that it is handled
                                        res.innerText = "";
                                        var skipCallbackInvocation = _trackMessageSize(text, rq, _response);
                                        if (skipCallbackInvocation) {
                                            return "";
                                        }

                                        _prepareCallback(_response.responseBody, "messageReceived", 200, rq.transport);
                                    }

                                    rq.lastIndex = 0;

                                    if (cdoc.readyState === "complete") {
                                        _invokeClose(true);
                                        _open('re-connecting', rq.transport, rq);
                                        if (rq.reconnectInterval > 0) {
                                            rq.reconnectId = setTimeout(function () {
                                                _ieStreaming(rq);
                                            }, rq.reconnectInterval);
                                        } else {
                                            _ieStreaming(rq);
                                        }
                                        return false;
                                    }
                                }, null);

                                return false;
                            } catch (err) {
                                _response.error = true;
                                _open('re-connecting', rq.transport, rq);
                                if (_requestCount++ < rq.maxReconnectOnClose) {
                                    if (rq.reconnectInterval > 0) {
                                        rq.reconnectId = setTimeout(function () {
                                            _ieStreaming(rq);
                                        }, rq.reconnectInterval);
                                    } else {
                                        _ieStreaming(rq);
                                    }
                                } else {
                                    _onError(0, "maxReconnectOnClose reached");
                                }
                                doc.execCommand("Stop");
                                doc.close();
                                return false;
                            }
                        });
                    },

                    close: function () {
                        if (stop) {
                            stop();
                        }

                        doc.execCommand("Stop");
                        _invokeClose(true);
                    }
                };
            }

            /**
             * Send message. <br>
             * Will be automatically dispatch to other connected.
             *
             * @param {Object, string} Message to send.
             * @private
             */
            function _push(message) {

                if (_localStorageService != null) {
                    _pushLocal(message);
                } else if (_activeRequest != null || _sse != null) {
                    _pushAjaxMessage(message);
                } else if (_ieStream != null) {
                    _pushIE(message);
                } else if (_jqxhr != null) {
                    _pushJsonp(message);
                } else if (_websocket != null) {
                    _pushWebSocket(message);
                } else {
                    _onError(0, "No suspended connection available");
                    jQuery.atmosphere.error("No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before invoking this method");
                }
            }

            function _pushOnClose(message) {
                var rq = _getPushRequest(message);
                rq.transport = "ajax";
                rq.method = "GET";
                rq.async = false;
                rq.reconnect = false;
                _executeRequest(rq);
            }

            function _pushLocal(message) {
                _localStorageService.send(message);
            }

            function _intraPush(message) {
                // IE 9 will crash if not.
                if (message.length === 0)
                    return;

                try {
                    if (_localStorageService) {
                        _localStorageService.localSend(message);
                    } else if (_storageService) {
                        _storageService.signal("localMessage", jQuery.stringifyJSON({
                            id: guid,
                            event: message
                        }));
                    }
                } catch (err) {
                    jQuery.atmosphere.error(err);
                }
            }

            /**
             * Send a message using currently opened ajax request (using http-streaming or long-polling). <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushAjaxMessage(message) {
                var rq = _getPushRequest(message);
                _executeRequest(rq);
            }

            /**
             * Send a message using currently opened ie streaming (using http-streaming or long-polling). <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushIE(message) {
                if (_request.enableXDR && jQuery.atmosphere.checkCORSSupport()) {
                    var rq = _getPushRequest(message);
                    // Do not reconnect since we are pushing.
                    rq.reconnect = false;
                    _jsonp(rq);
                } else {
                    _pushAjaxMessage(message);
                }
            }

            /**
             * Send a message using jsonp transport. <br>
             *
             * @param {string, Object} Message to send. This is an object, string message is saved in data member.
             * @private
             */
            function _pushJsonp(message) {
                _pushAjaxMessage(message);
            }

            function _getStringMessage(message) {
                var msg = message;
                if (typeof (msg) === 'object') {
                    msg = message.data;
                }
                return msg;
            }

            /**
             * Build request use to push message using method 'POST' <br>. Transport is defined as 'polling' and 'suspend' is set to false.
             *
             * @return {Object} Request object use to push message.
             * @private
             */
            function _getPushRequest(message) {
                var msg = _getStringMessage(message);

                var rq = {
                    connected: false,
                    timeout: 60000,
                    method: 'POST',
                    url: _request.url,
                    contentType: _request.contentType,
                    headers: _request.headers,
                    reconnect: true,
                    callback: null,
                    data: msg,
                    suspend: false,
                    maxRequest: -1,
                    logLevel: 'info',
                    requestCount: 0,
                    withCredentials: _request.withCredentials,
                    transport: 'polling',
                    isOpen: true,
                    attachHeadersAsQueryString: true,
                    enableXDR: _request.enableXDR,
                    uuid: _request.uuid,
                    dispatchUrl: _request.dispatchUrl,
                    enableProtocol: false,
                    messageDelimiter: '|',
                    trackMessageLength: _request.trackMessageLength,
                    maxReconnectOnClose: _request.maxReconnectOnClose,
                    heartbeatTimer: _request.heartbeatTimer,
                    heartbeat: _request.heartbeat
                };

                if (typeof (message) === 'object') {
                    rq = jQuery.extend(rq, message);
                }

                return rq;
            }

            /**
             * Send a message using currently opened websocket. <br>
             *
             */
            function _pushWebSocket(message) {
                var msg = jQuery.atmosphere.isBinary(message) ? message : _getStringMessage(message);
                var data;
                try {
                    if (_request.dispatchUrl != null) {
                        data = _request.webSocketPathDelimiter + _request.dispatchUrl + _request.webSocketPathDelimiter + msg;
                    } else {
                        data = msg;
                    }

                    if (!_websocket.canSendMessage) {
                        jQuery.atmosphere.error("WebSocket not connected.");
                        return;
                    }

                    _websocket.send(data);

                } catch (e) {
                    _websocket.onclose = function (message) {
                    };
                    _clearState();

                    _reconnectWithFallbackTransport("Websocket failed. Downgrading to Comet and resending " + message);
                    _pushAjaxMessage(message);
                }
            }

            function _localMessage(message) {
                var m = jQuery.parseJSON(message);
                if (m.id !== guid) {
                    if (typeof (_request.onLocalMessage) !== 'undefined') {
                        _request.onLocalMessage(m.event);
                    } else if (typeof (jQuery.atmosphere.onLocalMessage) !== 'undefined') {
                        jQuery.atmosphere.onLocalMessage(m.event);
                    }
                }
            }

            function _prepareCallback(messageBody, state, errorCode, transport) {

                _response.responseBody = messageBody;
                _response.transport = transport;
                _response.status = errorCode;
                _response.state = state;

                _invokeCallback();
            }

            function _readHeaders(xdr, request) {
                if (!request.readResponsesHeaders) {
                    if (!request.enableProtocol) {
                        request.lastTimestamp = jQuery.now();
                        request.uuid = jQuery.atmosphere.guid();
                    }
                }
                else {
                    try {
                        var tempDate = xdr.getResponseHeader('X-Cache-Date');
                        if (tempDate && tempDate != null && tempDate.length > 0) {
                            request.lastTimestamp = tempDate.split(" ").pop();
                        }

                        var tempUUID = xdr.getResponseHeader('X-Atmosphere-tracking-id');
                        if (tempUUID && tempUUID != null) {
                            request.uuid = tempUUID.split(" ").pop();
                        }
                    } catch (e) {
                    }
                }
            }

            function _invokeFunction(response) {
                _f(response, _request);
                // Global
                _f(response, jQuery.atmosphere);
            }

            function _f(response, f) {
                switch (response.state) {
                    case "messageReceived":
                        _requestCount = 0;
                        if (typeof (f.onMessage) !== 'undefined')
                            f.onMessage(response);
                        break;
                    case "error":
                        if (typeof (f.onError) !== 'undefined')
                            f.onError(response);
                        break;
                    case "opening":
                        delete _request.closed;
                        if (typeof (f.onOpen) !== 'undefined')
                            f.onOpen(response);
                        break;
                    case "messagePublished":
                        if (typeof (f.onMessagePublished) !== 'undefined')
                            f.onMessagePublished(response);
                        break;
                    case "re-connecting":
                        if (typeof (f.onReconnect) !== 'undefined')
                            f.onReconnect(_request, response);
                        break;
                    case "closedByClient":
                        if (typeof (f.onClientTimeout) !== 'undefined')
                            f.onClientTimeout(_request);
                        break;
                    case "re-opening":
                        delete _request.closed;
                        if (typeof (f.onReopen) !== 'undefined')
                            f.onReopen(_request, response);
                        break;
                    case "fail-to-reconnect":
                        if (typeof (f.onFailureToReconnect) !== 'undefined')
                            f.onFailureToReconnect(_request, response);
                        break;
                    case "unsubscribe":
                    case "closed":
                        var closed = typeof (_request.closed) !== 'undefined' ? _request.closed : false;
                        if (!closed) {
                            if (typeof (f.onClose) !== 'undefined') {
                                f.onClose(response);
                            }
                        }

                        _request.closed = true;
                        break;
                }
            }

            function _invokeClose(wasOpen) {
                if (_response.state !== 'closed') {
                    _response.state = 'closed';
                    _response.responseBody = "";
                    _response.messages = [];
                    _response.status = !wasOpen ? 501 : 200;
                    _invokeCallback();
                }
            }

            /**
             * Invoke request callbacks.
             *
             * @private
             */
            function _invokeCallback() {
                var call = function (index, func) {
                    func(_response);
                };

                if (_localStorageService == null && _localSocketF != null) {
                    _localSocketF(_response.responseBody);
                }

                _request.reconnect = _request.mrequest;

                var isString = typeof (_response.responseBody) === 'string';
                var messages = (isString && _request.trackMessageLength) ? (_response.messages.length > 0 ? _response.messages : ['']) : new Array(
                    _response.responseBody);
                for (var i = 0; i < messages.length; i++) {

                    if (messages.length > 1 && messages[i].length === 0) {
                        continue;
                    }
                    _response.responseBody = (isString) ? jQuery.trim(messages[i]) : messages[i];

                    if (_localStorageService == null && _localSocketF != null) {
                        _localSocketF(_response.responseBody);
                    }

                    if (_response.responseBody.length === 0 && _response.state === "messageReceived") {
                        continue;
                    }

                    _invokeFunction(_response);

                    // Invoke global callbacks
                    if (jQuery.atmosphere.callbacks.length > 0) {
                        if (_request.logLevel === 'debug') {
                            jQuery.atmosphere.debug("Invoking " + jQuery.atmosphere.callbacks.length + " global callbacks: " + _response.state);
                        }
                        try {
                            jQuery.each(jQuery.atmosphere.callbacks, call);
                        } catch (e) {
                            jQuery.atmosphere.log(_request.logLevel, ["Callback exception" + e]);
                        }
                    }

                    // Invoke request callback
                    if (typeof (_request.callback) === 'function') {
                        if (_request.logLevel === 'debug') {
                            jQuery.atmosphere.debug("Invoking request callbacks");
                        }
                        try {
                            _request.callback(_response);
                        } catch (e) {
                            jQuery.atmosphere.log(_request.logLevel, ["Callback exception" + e]);
                        }
                    }
                }

            }

            /**
             *
             * @private
             */
            function _verifyStreamingLength(ajaxRequest, rq) {
                // Wait to be sure we have the full message before closing.
                if (_response.partialMessage === "" && (rq.transport === 'streaming') && (ajaxRequest.responseText.length > rq.maxStreamingLength)) {
                    return true;
                }
                return false;
            }

            /**
             * Disconnect
             *
             * @private
             */
            function _disconnect() {
                if (_request.enableProtocol && !_request.firstMessage) {
                    var query = "X-Atmosphere-Transport=close&X-Atmosphere-tracking-id=" + _request.uuid;

                    jQuery.each(_request.headers, function (name, value) {
                        var h = jQuery.isFunction(value) ? value.call(this, _request, _request, _response) : value;
                        if (h != null) {
                            query += "&" + encodeURIComponent(name) + "=" + encodeURIComponent(h);
                        }
                    });

                    var url = _request.url.replace(/([?&])_=[^&]*/, query);
                    url = url + (url === _request.url ? (/\?/.test(_request.url) ? "&" : "?") + query : "");

                    if (_request.connectTimeout > 0) {
                        jQuery.ajax({
                            url: url,
                            async: false,
                            timeout: _request.connectTimeout,
                            cache: false
                        });
                    } else {
                        jQuery.ajax({
                            url: url,
                            async: false,
                            cache: false
                        });
                    }
                }
            }

            /**
             * Close request.
             *
             * @private
             */
            function _close() {
                if (_request.reconnectId) {
                    clearTimeout(_request.reconnectId);
                    delete _request.reconnectId;
                }

                if (_request.heartbeatTimer) {
                    clearTimeout(_request.heartbeatTimer);
                }

                _request.reconnect = false;
                _abordingConnection = true;
                _response.request = _request;
                _response.state = 'unsubscribe';
                _response.responseBody = "";
                _response.status = 408;
                _invokeCallback();
                _disconnect();
                _clearState();
            }

            function _clearState() {
                _response.partialMessage = "";
                if (_request.id) {
                    clearTimeout(_request.id);
                }

                if (_request.heartbeatTimer) {
                    clearTimeout(_request.heartbeatTimer);
                }

                if (_ieStream != null) {
                    _ieStream.close();
                    _ieStream = null;
                }
                if (_jqxhr != null) {
                    _jqxhr.abort();
                    _jqxhr = null;
                }
                if (_activeRequest != null) {
                    _activeRequest.abort();
                    _activeRequest = null;
                }
                if (_websocket != null) {
                    if (_websocket.canSendMessage) {
                        _websocket.close();
                    }
                    _websocket = null;
                }
                if (_sse != null) {
                    _sse.close();
                    _sse = null;
                }

                _clearStorage();
            }

            function _clearStorage() {
                // Stop sharing a connection
                if (_storageService != null) {
                    // Clears trace timer
                    clearInterval(_traceTimer);
                    // Removes the trace
                    document.cookie = _sharingKey + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
                    // The heir is the parent unless unloading
                    _storageService.signal("close", {
                        reason: "",
                        heir: !_abordingConnection ? guid : (_storageService.get("children") || [])[0]
                    });
                    _storageService.close();
                }
                if (_localStorageService != null) {
                    _localStorageService.close();
                }
            }

            this.subscribe = function (options) {
                _subscribe(options);
                _execute();
            };

            this.execute = function () {
                _execute();
            };

            this.invokeCallback = function () {
                _invokeCallback();
            };

            this.close = function () {
                _close();
            };

            this.disconnect = function () {
                _disconnect();
            };

            this.getUrl = function () {
                return _request.url;
            };

            this.push = function (message, dispatchUrl) {
                if (dispatchUrl != null) {
                    var originalDispatchUrl = _request.dispatchUrl;
                    _request.dispatchUrl = dispatchUrl;
                    _push(message);
                    _request.dispatchUrl = originalDispatchUrl;
                } else {
                    _push(message);
                }
            };

            this.getUUID = function () {
                return _request.uuid;
            };

            this.pushLocal = function (message) {
                _intraPush(message);
            };

            this.enableProtocol = function (message) {
                return _request.enableProtocol;
            };

            this.request = _request;
            this.response = _response;
        },

        subscribe: function (url, callback, request) {
            if (typeof (callback) === 'function') {
                jQuery.atmosphere.addCallback(callback);
            }

            if (typeof (url) !== "string") {
                request = url;
            } else {
                request.url = url;
            }

            // https://github.com/Atmosphere/atmosphere-javascript/issues/58
            jQuery.atmosphere.uuid = ((typeof (request) !== 'undefined') && typeof (request.uuid) !== 'undefined') ? request.uuid : 0;

            var rq = new jQuery.atmosphere.AtmosphereRequest(request);
            rq.execute();

            jQuery.atmosphere.requests[jQuery.atmosphere.requests.length] = rq;
            return rq;
        },

        addCallback: function (func) {
            if (jQuery.inArray(func, jQuery.atmosphere.callbacks) === -1) {
                jQuery.atmosphere.callbacks.push(func);
            }
        },

        removeCallback: function (func) {
            var index = jQuery.inArray(func, jQuery.atmosphere.callbacks);
            if (index !== -1) {
                jQuery.atmosphere.callbacks.splice(index, 1);
            }
        },

        unsubscribe: function () {
            if (jQuery.atmosphere.requests.length > 0) {
                var requestsClone = [].concat(jQuery.atmosphere.requests);
                for (var i = 0; i < requestsClone.length; i++) {
                    var rq = requestsClone[i];
                    rq.close();
                    clearTimeout(rq.response.request.id);

                    if (rq.heartbeatTimer) {
                        clearTimeout(rq.heartbeatTimer);
                    }
                }
            }
            jQuery.atmosphere.requests = [];
            jQuery.atmosphere.callbacks = [];
        },

        unsubscribeUrl: function (url) {
            var idx = -1;
            if (jQuery.atmosphere.requests.length > 0) {
                for (var i = 0; i < jQuery.atmosphere.requests.length; i++) {
                    var rq = jQuery.atmosphere.requests[i];

                    // Suppose you can subscribe once to an url
                    if (rq.getUrl() === url) {
                        rq.close();
                        clearTimeout(rq.response.request.id);

                        if (rq.heartbeatTimer) {
                            clearTimeout(rq.heartbeatTimer);
                        }

                        idx = i;
                        break;
                    }
                }
            }
            if (idx >= 0) {
                jQuery.atmosphere.requests.splice(idx, 1);
            }
        },

        publish: function (request) {
            if (typeof (request.callback) === 'function') {
                jQuery.atmosphere.addCallback(request.callback);
            }
            request.transport = "polling";

            var rq = new jQuery.atmosphere.AtmosphereRequest(request);
            jQuery.atmosphere.requests[jQuery.atmosphere.requests.length] = rq;
            return rq;
        },

        checkCORSSupport: function () {
            if (jQuery.browser.msie && !window.XDomainRequest && +jQuery.browser.version.split(".")[0] < 11) {
                return true;
            } else if (jQuery.browser.opera && +jQuery.browser.version.split(".")[0] < 12.0) {
                return true;
            }

            // KreaTV 4.1 -> 4.4
            else if (jQuery.trim(navigator.userAgent).slice(0, 16) === "KreaTVWebKit/531") {
                return true;
            }
            // KreaTV 3.8
            else if (jQuery.trim(navigator.userAgent).slice(-7).toLowerCase() === "kreatel") {
                return true;
            }

            // Force Android to use CORS as some version like 2.2.3 fail otherwise
            var ua = navigator.userAgent.toLowerCase();
            var isAndroid = ua.indexOf("android") > -1;
            if (isAndroid) {
                return true;
            }
            return false;
        },

        S4: function () {
            return (((1 + Math.random()) * 0x10000) | 0).toString(16).substring(1);
        },

        guid: function () {
            return (jQuery.atmosphere.S4() + jQuery.atmosphere.S4() + "-" + jQuery.atmosphere.S4() + "-" + jQuery.atmosphere.S4() + "-"
                + jQuery.atmosphere.S4() + "-" + jQuery.atmosphere.S4() + jQuery.atmosphere.S4() + jQuery.atmosphere.S4());
        },

        // From jQuery-Stream
        prepareURL: function (url) {
            // Attaches a time stamp to prevent caching
            var ts = jQuery.now();
            var ret = url.replace(/([?&])_=[^&]*/, "$1_=" + ts);

            return ret + (ret === url ? (/\?/.test(url) ? "&" : "?") + "_=" + ts : "");
        },

        // From jQuery-Stream
        param: function (data) {
            return jQuery.param(data, jQuery.ajaxSettings.traditional);
        },

        supportStorage: function () {
            var storage = window.localStorage;
            if (storage) {
                try {
                    storage.setItem("t", "t");
                    storage.removeItem("t");
                    // The storage event of Internet Explorer and Firefox 3 works strangely
                    return window.StorageEvent && !jQuery.browser.msie && !(jQuery.browser.mozilla && jQuery.browser.version.split(".")[0] === "1");
                } catch (e) {
                }
            }

            return false;
        },

        iterate: function (fn, interval) {
            var timeoutId;

            // Though the interval is 0 for real-time application, there is a delay between setTimeout calls
            // For detail, see https://developer.mozilla.org/en/window.setTimeout#Minimum_delay_and_timeout_nesting
            interval = interval || 0;

            (function loop() {
                timeoutId = setTimeout(function () {
                    if (fn() === false) {
                        return;
                    }

                    loop();
                }, interval);
            })();

            return function () {
                clearTimeout(timeoutId);
            };
        },

        log: function (level, args) {
            if (window.console) {
                var logger = window.console[level];
                if (typeof logger === 'function') {
                    logger.apply(window.console, args);
                }
            }
        },

        warn: function () {
            jQuery.atmosphere.log('warn', arguments);
        },

        info: function () {
            jQuery.atmosphere.log('info', arguments);
        },

        debug: function () {
            jQuery.atmosphere.log('debug', arguments);
        },

        error: function () {
            jQuery.atmosphere.log('error', arguments);
        },

        // TODO extract to utils or something
        isBinary: function (data) {
            // True if data is an instance of Blob, ArrayBuffer or ArrayBufferView 
            return /^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(Object.prototype.toString.call(data));
        }
    };


    // http://stackoverflow.com/questions/9645803/whats-the-replacement-for-browser
    // Limit scope pollution from any deprecated API
    (function () {
	
        var matched, browser;
	
        // Use of jQuery.browser is frowned upon.
        // More details: http://api.jquery.com/jQuery.browser
        // jQuery.uaMatch maintained for back-compat
        jQuery.uaMatch = function (ua) {
            ua = ua.toLowerCase();
	
            var match = /(chrome)[ \/]([\w.]+)/.exec(ua) || 
                    /(webkit)[ \/]([\w.]+)/.exec(ua) || 
                    /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) || 
                    /(msie) ([\w.]+)/.exec(ua) || 
                    /(trident)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
                    ua.indexOf("compatible") < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) || 
                    [];
	
            return {
                browser: match[1] || "",
                version: match[2] || "0"
            };
        };
	
        matched = jQuery.uaMatch(navigator.userAgent);
        browser = {};
	
        if (matched.browser) {
            browser[matched.browser] = true;
            browser.version = matched.version;
        }
	
        // Chrome is Webkit, but Webkit is also Safari.
        if (browser.chrome) {
            browser.webkit = true;
        } else if (browser.webkit) {
            browser.safari = true;
        }
        
        // Trident is the layout engine of the Internet Explorer
        // IE 11 has no "MSIE: 11.0" token
        if (browser.trident) {
            browser.msie = true;
        }
	
        jQuery.browser = browser;
	
        jQuery.sub = function () {
            function jQuerySub(selector, context) {
                return new jQuerySub.fn.init(selector, context);
            }
	
            jQuery.extend(true, jQuerySub, this);
            jQuerySub.superclass = this;
            jQuerySub.fn = jQuerySub.prototype = this();
            jQuerySub.fn.constructor = jQuerySub;
            jQuerySub.sub = this.sub;
            jQuerySub.fn.init = function init(selector, context) {
                if (context && context instanceof jQuery && !(context instanceof jQuerySub)) {
                    context = jQuerySub(context);
                }
	
                return jQuery.fn.init.call(this, selector, context, rootjQuerySub);
            };
            jQuerySub.fn.init.prototype = jQuerySub.fn;
            var rootjQuerySub = jQuerySub(document);
            return jQuerySub;
        };
	
    })();
	
    /*
     * jQuery stringifyJSON
     * http://github.com/flowersinthesand/jquery-stringifyJSON
     *
     * Copyright 2011, Donghwan Kim
     * Licensed under the Apache License, Version 2.0
     * http://www.apache.org/licenses/LICENSE-2.0
     */
    // This plugin is heavily based on Douglas Crockford's reference implementation
    (function (jQuery) {
	
        var escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, meta = {
            '\b': '\\b',
            '\t': '\\t',
            '\n': '\\n',
            '\f': '\\f',
            '\r': '\\r',
            '"': '\\"',
            '\\': '\\\\'
        };
	
        function quote(string) {
            return '"' + string.replace(escapable, function (a) {
                var c = meta[a];
                return typeof c === "string" ? c : "\\u" + ("0000" + a.charCodeAt(0).toString(16)).slice(-4);
            }) + '"';
        }
	
        function f(n) {
            return n < 10 ? "0" + n : n;
        }
	
        function str(key, holder) {
            var i, v, len, partial, value = holder[key], type = typeof value;
	
            if (value && typeof value === "object" && typeof value.toJSON === "function") {
                value = value.toJSON(key);
                type = typeof value;
            }
	
            switch (type) {
                case "string":
                    return quote(value);
                case "number":
                    return isFinite(value) ? String(value) : "null";
                case "boolean":
                    return String(value);
                case "object":
                    if (!value) {
                        return "null";
                    }
	
                    switch (Object.prototype.toString.call(value)) {
                        case "[object Date]":
                            return isFinite(value.valueOf()) ? '"' + value.getUTCFullYear() + "-" + f(value.getUTCMonth() + 1) + "-" + f(value.getUTCDate())
                                + "T" + f(value.getUTCHours()) + ":" + f(value.getUTCMinutes()) + ":" + f(value.getUTCSeconds()) + "Z" + '"' : "null";
                        case "[object Array]":
                            len = value.length;
                            partial = [];
                            for (i = 0; i < len; i++) {
                                partial.push(str(i, value) || "null");
                            }
	
                            return "[" + partial.join(",") + "]";
                        default:
                            partial = [];
                            for (i in value) {
                                if (Object.prototype.hasOwnProperty.call(value, i)) {
                                    v = str(i, value);
                                    if (v) {
                                        partial.push(quote(i) + ":" + v);
                                    }
                                }
                            }
	
                            return "{" + partial.join(",") + "}";
                    }
            }
        }
	
        jQuery.stringifyJSON = function (value) {
            if (window.JSON && window.JSON.stringify) {
                return window.JSON.stringify(value);
            }
	
            return str("", {
                "": value
            });
        };
	
    }(jQuery));
}));
/* jshint noarg:true, noempty:true, eqeqeq:true, evil:true, laxbreak:true, undef:true, browser:true, jquery:true, indent:false, maxerr:50, eqnull:true */

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/canvasLayer/leaflet_canvas_layer.js":[function(require,module,exports){
if (typeof(L) !== 'undefined') {
    /**
     * full canvas layer implementation for Leaflet
     */

    L.CanvasLayer = L.Class.extend({

        includes: [L.Mixin.Events, L.Mixin.TileLoader],

        options: {
            minZoom: 0,
            maxZoom: 28,
            tileSize: 256,
            subdomains: 'abc',
            errorTileUrl: '',
            attribution: '',
            zoomOffset: 0,
            opacity: 1,
            unloadInvisibleTiles: L.Browser.mobile,
            updateWhenIdle: L.Browser.mobile,
            tileLoader: false // installs tile loading events
        },

        initialize: function(options) {
            var self = this;
            options = options || {};
            //this.project = this._project.bind(this);
            this.render = this.render.bind(this);
            L.Util.setOptions(this, options);
            this._canvas = this._createCanvas();
            // backCanvas for zoom animation
            this._backCanvas = this._createCanvas();
            this._ctx = this._canvas.getContext('2d');
            this.currentAnimationFrame = -1;
            this.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || function(callback) {
                    return window.setTimeout(callback, 1000 / 60);
                };
            this.cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame ||
                window.webkitCancelAnimationFrame || window.msCancelAnimationFrame || function(id) {
                    clearTimeout(id);
                };
        },

        _createCanvas: function() {
            var canvas;
            canvas = document.createElement('canvas');
            canvas.style.position = 'absolute';
            canvas.style.top = 0;
            canvas.style.left = 0;
            canvas.style.pointerEvents = "none";
            canvas.style.zIndex = this.options.zIndex || 0;
            var className = 'leaflet-tile-container leaflet-zoom-animated';
            canvas.setAttribute('class', className);
            return canvas;
        },

        onAdd: function(map) {
            this._map = map;

            // add container with the canvas to the tile pane
            // the container is moved in the oposite direction of the 
            // map pane to keep the canvas always in (0, 0)
            var tilePane = this._map._panes.tilePane;
            var _container = L.DomUtil.create('div', 'leaflet-layer');
            _container.appendChild(this._canvas);
            _container.appendChild(this._backCanvas);
            this._backCanvas.style.display = 'none';
            tilePane.appendChild(_container);

            this._container = _container;

            // hack: listen to predrag event launched by dragging to
            // set container in position (0, 0) in screen coordinates
            map.dragging._draggable.on('predrag', function() {
                var d = map.dragging._draggable;
                L.DomUtil.setPosition(this._canvas, {
                    x: -d._newPos.x,
                    y: -d._newPos.y
                });
            }, this);

            map.on({
                'viewreset': this._reset
            }, this);
            map.on('move', this.render, this);
            map.on('resize', this._reset, this);
            map.on({
                'zoomanim': this._animateZoom,
                'zoomend': this._endZoomAnim
            }, this);

            if (this.options.tileLoader) {
                this._initTileLoader();
            }

            this._reset();
        },

        _animateZoom: function(e) {
            if (!this._animating) {
                this._animating = true;
            }
            var back = this._backCanvas;

            back.width = this._canvas.width;
            back.height = this._canvas.height;

            // paint current canvas in back canvas with trasnformation
            var pos = this._canvas._leaflet_pos || {
                x: 0,
                y: 0
            };
            back.getContext('2d').drawImage(this._canvas, 0, 0);

            // hide original
            this._canvas.style.display = 'none';
            back.style.display = 'block';
            var map = this._map;
            var scale = map.getZoomScale(e.zoom);
            var newCenter = map._latLngToNewLayerPoint(map.getCenter(), e.zoom, e.center);
            var oldCenter = map._latLngToNewLayerPoint(e.center, e.zoom, e.center);

            var origin = {
                x: newCenter.x - oldCenter.x,
                y: newCenter.y - oldCenter.y
            };

            var bg = back;
            var transform = L.DomUtil.TRANSFORM;
            bg.style[transform] = L.DomUtil.getTranslateString(origin) + ' scale(' + e.scale + ') ';
        },

        _endZoomAnim: function() {
            this._animating = false;
            this._canvas.style.display = 'block';
            this._backCanvas.style.display = 'none';
        },

        getCanvas: function() {
            return this._canvas;
        },

        getAttribution: function() {
            return this.options.attribution;
        },

        draw: function() {
            return this._reset();
        },

        onRemove: function(map) {
            if (this._container.parentNode) {
                this._container.parentNode.removeChild(this._container);
            }

            map.off({
                'viewreset': this._reset,
                'move': this._render,
                'resize': this._reset,
                'zoomanim': this._animateZoom,
                'zoomend': this._endZoomAnim
            }, this);
        },

        addTo: function(map) {
            map.addLayer(this);
            return this;
        },

        setOpacity: function(opacity) {
            this.options.opacity = opacity;
            this._updateOpacity();
            return this;
        },

        setZIndex: function(zIndex) {
            this._canvas.style.zIndex = zIndex;
        },

        bringToFront: function() {
            return this;
        },

        bringToBack: function() {
            return this;
        },

        _reset: function() {
            var size = this._map.getSize();
            this._canvas.width = size.x;
            this._canvas.height = size.y;
            this.onResize();
            this._render();
        },

        /*
        _project: function(x) {
          var point = this._map.latLngToLayerPoint(new L.LatLng(x[1], x[0]));
          return [point.x, point.y];
        },
        */

        _updateOpacity: function() {},

        _render: function() {
            if (this.currentAnimationFrame >= 0) {
                this.cancelAnimationFrame.call(window, this.currentAnimationFrame);
            }
            this.currentAnimationFrame = this.requestAnimationFrame.call(window, this.render);
        },

        // use direct: true if you are inside an animation frame call
        redraw: function(direct) {
            if (direct) {
                this.render();
            } else {
                this._render();
            }
        },

        onResize: function() {},

        render: function() {
            throw new Error('render function should be implemented');
        }

    });

} //L defined
},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet.draw/dist/leaflet.draw-src.js":[function(require,module,exports){
/*
	Leaflet.draw, a plugin that adds drawing and editing tools to Leaflet powered maps.
	(c) 2012-2013, Jacob Toye, Smartrak

	https://github.com/Leaflet/Leaflet.draw
	http://leafletjs.com
	https://github.com/jacobtoye
*/
(function (window, document, undefined) {/*
 * Leaflet.draw assumes that you have already included the Leaflet library.
 */

L.drawVersion = '0.2.3';

L.drawLocal = {
	draw: {
		toolbar: {
			actions: {
				title: 'Cancel drawing',
				text: 'Cancel'
			},
			actionsIso: {
					option: {
						title: 'Set options.',
						text: 'Options'
					},
					cancel: {
						title: 'Cancel.',
						text: 'Cancel'
					}
				},
			undo: {
				title: 'Delete last point drawn',
				text: 'Delete last point'
			},
			buttons: {
				polyline: 'Draw a polyline',
				polygon: 'Draw a polygon',
				rectangle: 'Draw a rectangle',
				circle: 'Draw a circle',
				marker: 'Draw a marker',
				isochrone: 'Draw a isochrone',
				isochroneDisabled: ''
			}
		},
		handlers: {
			circle: {
				tooltip: {
					start: 'Click and drag to draw circle.'
				}
			},
			marker: {
				tooltip: {
					start: 'Click map to place marker.'
				}
			},
			polygon: {
				tooltip: {
					start: 'Click to start drawing shape.',
					cont: 'Click to continue drawing shape.',
					end: 'Click first point to close this shape.'
				}
			},
			polyline: {
				error: '<strong>Error:</strong> shape edges cannot cross!',
				tooltip: {
					start: 'Click to start drawing line.',
					cont: 'Click to continue drawing line.',
					end: 'Click last point to finish line.'
				}
			},
			rectangle: {
				tooltip: {
					start: 'Click and drag to draw rectangle.'
				}
			},
			simpleshape: {
				tooltip: {
					end: 'Release mouse to finish drawing.'
				}
			},
			isochrone: {
				tooltip: {
					start: 'Click map to place start point.'
				}
			}
		}
	},
	edit: {
		toolbar: {
			actions: {
				save: {
					title: 'Save changes.',
					text: 'Save'
				},
				cancel: {
					title: 'Cancel editing, discards all changes.',
					text: 'Cancel'
				}
			},
			buttons: {
				edit: 'Edit geometry layers.',
				editDisabled: 'No layers to edit.',
				editData: 'Edit attributes layers.',
				editDataDisabled: 'No layers to edit attributes.',
				remove: 'Delete layers.',
				removeDisabled: 'No layers to delete.'
			}
		},
		handlers: {
			edit: {
				tooltip: {
					text: 'Drag handles, or marker to edit feature.',
					subtext: 'Click cancel to undo changes.'
				}
			},
			editData: {
				tooltip: {
					text: 'Click on a feature to edit attributes.',
					subtext: 'Click cancel to undo changes.'
				}
			},
			remove: {
				tooltip: {
					text: 'Click on a feature to remove'
				}
			}
		}
	}
	
};


L.Draw = {};

L.Draw.Feature = L.Handler.extend({
	includes: L.Mixin.Events,

	initialize: function (map, options) {
		this._map = map;
		this._container = map._container;
		this._overlayPane = map._panes.overlayPane;
		this._popupPane = map._panes.popupPane;

		// Merge default shapeOptions options with custom shapeOptions
		if (options && options.shapeOptions) {
			options.shapeOptions = L.Util.extend({}, this.options.shapeOptions, options.shapeOptions);
		}
		L.setOptions(this, options);
	},

	enable: function () {
		if (this._enabled) { return; }

		this.fire('enabled', { handler: this.type });

		this._map.fire('draw:drawstart', { layerType: this.type });

		L.Handler.prototype.enable.call(this);
	},

	disable: function () {
		if (!this._enabled) { return; }

		L.Handler.prototype.disable.call(this);

		this._map.fire('draw:drawstop', { layerType: this.type });

		this.fire('disabled', { handler: this.type });
	},

	addHooks: function () {
		var map = this._map;

		if (map) {
			L.DomUtil.disableTextSelection();

			map.getContainer().focus();

			this._tooltip = new L.Tooltip(this._map);

			L.DomEvent.on(this._container, 'keyup', this._cancelDrawing, this);
		}
	},

	removeHooks: function () {
		if (this._map) {
			L.DomUtil.enableTextSelection();

			this._tooltip.dispose();
			this._tooltip = null;

			L.DomEvent.off(this._container, 'keyup', this._cancelDrawing, this);
		}
	},

	setOptions: function (options) {
		L.setOptions(this, options);
	},

	_fireCreatedEvent: function (layer) {
		this._map.fire('draw:created', { layer: layer, layerType: this.type });
	},

	// Cancel drawing when the escape key is pressed
	_cancelDrawing: function (e) {
		if (e.keyCode === 27) {
			this.disable();
		}
	}
});

L.Draw.Polyline = L.Draw.Feature.extend({
	statics: {
		TYPE: 'polyline'
	},

	Poly: L.Polyline,

	options: {
		allowIntersection: true,
		repeatMode: false,
		drawError: {
			color: '#b00b00',
			timeout: 2500
		},
		icon: new L.DivIcon({
			iconSize: new L.Point(8, 8),
			className: 'leaflet-div-icon leaflet-editing-icon'
		}),
		guidelineDistance: 20,
		maxGuideLineLength: 4000,
		shapeOptions: {
			stroke: true,
			color: '#f06eaa',
			weight: 4,
			opacity: 0.5,
			fill: false,
			clickable: true
		},
		metric: true, // Whether to use the metric meaurement system or imperial
		showLength: true, // Whether to display distance in the tooltip
		zIndexOffset: 2000 // This should be > than the highest z-index any map layers
	},

	initialize: function (map, options) {
		// Need to set this here to ensure the correct message is used.
		this.options.drawError.message = L.drawLocal.draw.handlers.polyline.error;

		// Merge default drawError options with custom options
		if (options && options.drawError) {
			options.drawError = L.Util.extend({}, this.options.drawError, options.drawError);
		}

		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.Draw.Polyline.TYPE;

		L.Draw.Feature.prototype.initialize.call(this, map, options);
	},

	addHooks: function () {
		L.Draw.Feature.prototype.addHooks.call(this);
		if (this._map) {
			this._markers = [];

			this._markerGroup = new L.LayerGroup();
			this._map.addLayer(this._markerGroup);

			this._poly = new L.Polyline([], this.options.shapeOptions);

			this._tooltip.updateContent(this._getTooltipText());

			// Make a transparent marker that will used to catch click events. These click
			// events will create the vertices. We need to do this so we can ensure that
			// we can create vertices over other map layers (markers, vector layers). We
			// also do not want to trigger any click handlers of objects we are clicking on
			// while drawing.
			if (!this._mouseMarker) {
				this._mouseMarker = L.marker(this._map.getCenter(), {
					icon: L.divIcon({
						className: 'leaflet-mouse-marker',
						iconAnchor: [20, 20],
						iconSize: [40, 40]
					}),
					opacity: 0,
					zIndexOffset: this.options.zIndexOffset
				});
			}

			this._mouseMarker
				.on('mousedown', this._onMouseDown, this)
				.addTo(this._map);

			this._map
				.on('mousemove', this._onMouseMove, this)
				.on('mouseup', this._onMouseUp, this)
				.on('zoomend', this._onZoomEnd, this);
		}
	},

	removeHooks: function () {
		L.Draw.Feature.prototype.removeHooks.call(this);

		this._clearHideErrorTimeout();

		this._cleanUpShape();

		// remove markers from map
		this._map.removeLayer(this._markerGroup);
		delete this._markerGroup;
		delete this._markers;

		this._map.removeLayer(this._poly);
		delete this._poly;

		this._mouseMarker
			.off('mousedown', this._onMouseDown, this)
			.off('mouseup', this._onMouseUp, this);
		this._map.removeLayer(this._mouseMarker);
		delete this._mouseMarker;

		// clean up DOM
		this._clearGuides();

		this._map
			.off('mousemove', this._onMouseMove, this)
			.off('zoomend', this._onZoomEnd, this);
	},

	deleteLastVertex: function () {
		if (this._markers.length <= 1) {
			return;
		}

		var lastMarker = this._markers.pop(),
			poly = this._poly,
			latlng = this._poly.spliceLatLngs(poly.getLatLngs().length - 1, 1)[0];

		this._markerGroup.removeLayer(lastMarker);

		if (poly.getLatLngs().length < 2) {
			this._map.removeLayer(poly);
		}

		this._vertexChanged(latlng, false);
	},

	addVertex: function (latlng) {
		var markersLength = this._markers.length;

		if (markersLength > 0 && !this.options.allowIntersection && this._poly.newLatLngIntersects(latlng)) {
			this._showErrorTooltip();
			return;
		}
		else if (this._errorShown) {
			this._hideErrorTooltip();
		}

		this._markers.push(this._createMarker(latlng));

		this._poly.addLatLng(latlng);

		if (this._poly.getLatLngs().length === 2) {
			this._map.addLayer(this._poly);
		}

		this._vertexChanged(latlng, true);
	},

	_finishShape: function () {
		var intersects = this._poly.newLatLngIntersects(this._poly.getLatLngs()[0], true);

		if ((!this.options.allowIntersection && intersects) || !this._shapeIsValid()) {
			this._showErrorTooltip();
			return;
		}

		this._fireCreatedEvent();
		this.disable();
		if (this.options.repeatMode) {
			this.enable();
		}
	},

	//Called to verify the shape is valid when the user tries to finish it
	//Return false if the shape is not valid
	_shapeIsValid: function () {
		return true;
	},

	_onZoomEnd: function () {
		this._updateGuide();
	},

	_onMouseMove: function (e) {
		var newPos = e.layerPoint,
			latlng = e.latlng;

		// Save latlng
		// should this be moved to _updateGuide() ?
		this._currentLatLng = latlng;

		this._updateTooltip(latlng);

		// Update the guide line
		this._updateGuide(newPos);

		// Update the mouse marker position
		this._mouseMarker.setLatLng(latlng);

		L.DomEvent.preventDefault(e.originalEvent);
	},

	_vertexChanged: function (latlng, added) {
		this._updateFinishHandler();

		this._updateRunningMeasure(latlng, added);

		this._clearGuides();

		this._updateTooltip();
	},

	_onMouseDown: function (e) {
		var originalEvent = e.originalEvent;
		this._mouseDownOrigin = L.point(originalEvent.clientX, originalEvent.clientY);
	},

	_onMouseUp: function (e) {
		if (this._mouseDownOrigin) {
			// We detect clicks within a certain tolerance, otherwise let it
			// be interpreted as a drag by the map
			var distance = L.point(e.originalEvent.clientX, e.originalEvent.clientY)
				.distanceTo(this._mouseDownOrigin);
			if (Math.abs(distance) < 9 * (window.devicePixelRatio || 1)) {
				this.addVertex(e.latlng);
			}
		}
		this._mouseDownOrigin = null;
	},

	_updateFinishHandler: function () {
		var markerCount = this._markers.length;
		// The last marker should have a click handler to close the polyline
		if (markerCount > 1) {
			this._markers[markerCount - 1].on('click', this._finishShape, this);
		}

		// Remove the old marker click handler (as only the last point should close the polyline)
		if (markerCount > 2) {
			this._markers[markerCount - 2].off('click', this._finishShape, this);
		}
	},

	_createMarker: function (latlng) {
		var marker = new L.Marker(latlng, {
			icon: this.options.icon,
			zIndexOffset: this.options.zIndexOffset * 2
		});

		this._markerGroup.addLayer(marker);

		return marker;
	},

	_updateGuide: function (newPos) {
		var markerCount = this._markers.length;

		if (markerCount > 0) {
			newPos = newPos || this._map.latLngToLayerPoint(this._currentLatLng);

			// draw the guide line
			this._clearGuides();
			this._drawGuide(
				this._map.latLngToLayerPoint(this._markers[markerCount - 1].getLatLng()),
				newPos
			);
		}
	},

	_updateTooltip: function (latLng) {
		var text = this._getTooltipText();

		if (latLng) {
			this._tooltip.updatePosition(latLng);
		}

		if (!this._errorShown) {
			this._tooltip.updateContent(text);
		}
	},

	_drawGuide: function (pointA, pointB) {
		var length = Math.floor(Math.sqrt(Math.pow((pointB.x - pointA.x), 2) + Math.pow((pointB.y - pointA.y), 2))),
			guidelineDistance = this.options.guidelineDistance,
			maxGuideLineLength = this.options.maxGuideLineLength,
			// Only draw a guideline with a max length
			i = length > maxGuideLineLength ? length - maxGuideLineLength : guidelineDistance,
			fraction,
			dashPoint,
			dash;

		//create the guides container if we haven't yet
		if (!this._guidesContainer) {
			this._guidesContainer = L.DomUtil.create('div', 'leaflet-draw-guides', this._overlayPane);
		}

		//draw a dash every GuildeLineDistance
		for (; i < length; i += this.options.guidelineDistance) {
			//work out fraction along line we are
			fraction = i / length;

			//calculate new x,y point
			dashPoint = {
				x: Math.floor((pointA.x * (1 - fraction)) + (fraction * pointB.x)),
				y: Math.floor((pointA.y * (1 - fraction)) + (fraction * pointB.y))
			};

			//add guide dash to guide container
			dash = L.DomUtil.create('div', 'leaflet-draw-guide-dash', this._guidesContainer);
			dash.style.backgroundColor =
				!this._errorShown ? this.options.shapeOptions.color : this.options.drawError.color;

			L.DomUtil.setPosition(dash, dashPoint);
		}
	},

	_updateGuideColor: function (color) {
		if (this._guidesContainer) {
			for (var i = 0, l = this._guidesContainer.childNodes.length; i < l; i++) {
				this._guidesContainer.childNodes[i].style.backgroundColor = color;
			}
		}
	},

	// removes all child elements (guide dashes) from the guides container
	_clearGuides: function () {
		if (this._guidesContainer) {
			while (this._guidesContainer.firstChild) {
				this._guidesContainer.removeChild(this._guidesContainer.firstChild);
			}
		}
	},

	_getTooltipText: function () {
		var showLength = this.options.showLength,
			labelText, distanceStr;

		if (this._markers.length === 0) {
			labelText = {
				text: L.drawLocal.draw.handlers.polyline.tooltip.start
			};
		} else {
			distanceStr = showLength ? this._getMeasurementString() : '';

			if (this._markers.length === 1) {
				labelText = {
					text: L.drawLocal.draw.handlers.polyline.tooltip.cont,
					subtext: distanceStr
				};
			} else {
				labelText = {
					text: L.drawLocal.draw.handlers.polyline.tooltip.end,
					subtext: distanceStr
				};
			}
		}
		return labelText;
	},

	_updateRunningMeasure: function (latlng, added) {
		var markersLength = this._markers.length,
			previousMarkerIndex, distance;

		if (this._markers.length === 1) {
			this._measurementRunningTotal = 0;
		} else {
			previousMarkerIndex = markersLength - (added ? 2 : 1);
			distance = latlng.distanceTo(this._markers[previousMarkerIndex].getLatLng());

			this._measurementRunningTotal += distance * (added ? 1 : -1);
		}
	},

	_getMeasurementString: function () {
		var currentLatLng = this._currentLatLng,
			previousLatLng = this._markers[this._markers.length - 1].getLatLng(),
			distance;

		// calculate the distance from the last fixed point to the mouse position
		distance = this._measurementRunningTotal + currentLatLng.distanceTo(previousLatLng);

		return L.GeometryUtil.readableDistance(distance, this.options.metric);
	},

	_showErrorTooltip: function () {
		this._errorShown = true;

		// Update tooltip
		this._tooltip
			.showAsError()
			.updateContent({ text: this.options.drawError.message });

		// Update shape
		this._updateGuideColor(this.options.drawError.color);
		this._poly.setStyle({ color: this.options.drawError.color });

		// Hide the error after 2 seconds
		this._clearHideErrorTimeout();
		this._hideErrorTimeout = setTimeout(L.Util.bind(this._hideErrorTooltip, this), this.options.drawError.timeout);
	},

	_hideErrorTooltip: function () {
		this._errorShown = false;

		this._clearHideErrorTimeout();

		// Revert tooltip
		this._tooltip
			.removeError()
			.updateContent(this._getTooltipText());

		// Revert shape
		this._updateGuideColor(this.options.shapeOptions.color);
		this._poly.setStyle({ color: this.options.shapeOptions.color });
	},

	_clearHideErrorTimeout: function () {
		if (this._hideErrorTimeout) {
			clearTimeout(this._hideErrorTimeout);
			this._hideErrorTimeout = null;
		}
	},

	_cleanUpShape: function () {
		if (this._markers.length > 1) {
			this._markers[this._markers.length - 1].off('click', this._finishShape, this);
		}
	},

	_fireCreatedEvent: function () {
		var poly = new this.Poly(this._poly.getLatLngs(), this.options.shapeOptions);
		L.Draw.Feature.prototype._fireCreatedEvent.call(this, poly);
	}
});


L.Draw.Polygon = L.Draw.Polyline.extend({
	statics: {
		TYPE: 'polygon'
	},

	Poly: L.Polygon,

	options: {
		showArea: false,
		shapeOptions: {
			stroke: true,
			color: '#f06eaa',
			weight: 4,
			opacity: 0.5,
			fill: true,
			fillColor: null, //same as color by default
			fillOpacity: 0.2,
			clickable: true
		}
	},

	initialize: function (map, options) {
		L.Draw.Polyline.prototype.initialize.call(this, map, options);

		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.Draw.Polygon.TYPE;
	},

	_updateFinishHandler: function () {
		var markerCount = this._markers.length;

		// The first marker should have a click handler to close the polygon
		if (markerCount === 1) {
			this._markers[0].on('click', this._finishShape, this);
		}

		// Add and update the double click handler
		if (markerCount > 2) {
			this._markers[markerCount - 1].on('dblclick', this._finishShape, this);
			// Only need to remove handler if has been added before
			if (markerCount > 3) {
				this._markers[markerCount - 2].off('dblclick', this._finishShape, this);
			}
		}
	},

	_getTooltipText: function () {
		var text, subtext;

		if (this._markers.length === 0) {
			text = L.drawLocal.draw.handlers.polygon.tooltip.start;
		} else if (this._markers.length < 3) {
			text = L.drawLocal.draw.handlers.polygon.tooltip.cont;
		} else {
			text = L.drawLocal.draw.handlers.polygon.tooltip.end;
			subtext = this._getMeasurementString();
		}

		return {
			text: text,
			subtext: subtext
		};
	},

	_getMeasurementString: function () {
		var area = this._area;

		if (!area) {
			return null;
		}

		return L.GeometryUtil.readableArea(area, this.options.metric);
	},

	_shapeIsValid: function () {
		return this._markers.length >= 3;
	},

	_vertexAdded: function () {
		// Check to see if we should show the area
		if (this.options.allowIntersection || !this.options.showArea) {
			return;
		}

		var latLngs = this._poly.getLatLngs();

		this._area = L.GeometryUtil.geodesicArea(latLngs);
	},

	_cleanUpShape: function () {
		var markerCount = this._markers.length;

		if (markerCount > 0) {
			this._markers[0].off('click', this._finishShape, this);

			if (markerCount > 2) {
				this._markers[markerCount - 1].off('dblclick', this._finishShape, this);
			}
		}
	}
});


L.SimpleShape = {};

L.Draw.SimpleShape = L.Draw.Feature.extend({
	options: {
		repeatMode: false
	},

	initialize: function (map, options) {
		this._endLabelText = L.drawLocal.draw.handlers.simpleshape.tooltip.end;

		L.Draw.Feature.prototype.initialize.call(this, map, options);
	},

	addHooks: function () {
		L.Draw.Feature.prototype.addHooks.call(this);
		if (this._map) {
			this._mapDraggable = this._map.dragging.enabled();

			if (this._mapDraggable) {
				this._map.dragging.disable();
			}

			//TODO refactor: move cursor to styles
			this._container.style.cursor = 'crosshair';

			this._tooltip.updateContent({ text: this._initialLabelText });

			this._map
				.on('mousedown', this._onMouseDown, this)
				.on('mousemove', this._onMouseMove, this);
		}
	},

	removeHooks: function () {
		L.Draw.Feature.prototype.removeHooks.call(this);
		if (this._map) {
			if (this._mapDraggable) {
				this._map.dragging.enable();
			}

			//TODO refactor: move cursor to styles
			this._container.style.cursor = '';

			this._map
				.off('mousedown', this._onMouseDown, this)
				.off('mousemove', this._onMouseMove, this);

			L.DomEvent.off(document, 'mouseup', this._onMouseUp, this);

			// If the box element doesn't exist they must not have moved the mouse, so don't need to destroy/return
			if (this._shape) {
				this._map.removeLayer(this._shape);
				delete this._shape;
			}
		}
		this._isDrawing = false;
	},

	_onMouseDown: function (e) {
		this._isDrawing = true;
		this._startLatLng = e.latlng;

		L.DomEvent
			.on(document, 'mouseup', this._onMouseUp, this)
			.preventDefault(e.originalEvent);
	},

	_onMouseMove: function (e) {
		var latlng = e.latlng;

		this._tooltip.updatePosition(latlng);
		if (this._isDrawing) {
			this._tooltip.updateContent({ text: this._endLabelText });
			this._drawShape(latlng);
		}
	},

	_onMouseUp: function () {
		if (this._shape) {
			this._fireCreatedEvent();
		}

		this.disable();
		if (this.options.repeatMode) {
			this.enable();
		}
	}
});

L.Draw.Rectangle = L.Draw.SimpleShape.extend({
	statics: {
		TYPE: 'rectangle'
	},

	options: {
		shapeOptions: {
			stroke: true,
			color: '#f06eaa',
			weight: 4,
			opacity: 0.5,
			fill: true,
			fillColor: null, //same as color by default
			fillOpacity: 0.2,
			clickable: true
		}
	},

	initialize: function (map, options) {
		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.Draw.Rectangle.TYPE;

		this._initialLabelText = L.drawLocal.draw.handlers.rectangle.tooltip.start;

		L.Draw.SimpleShape.prototype.initialize.call(this, map, options);
	},

	_drawShape: function (latlng) {
		if (!this._shape) {
			this._shape = new L.Rectangle(new L.LatLngBounds(this._startLatLng, latlng), this.options.shapeOptions);
			this._map.addLayer(this._shape);
		} else {
			this._shape.setBounds(new L.LatLngBounds(this._startLatLng, latlng));
		}
	},

	_fireCreatedEvent: function () {
		var rectangle = new L.Rectangle(this._shape.getBounds(), this.options.shapeOptions);
		L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, rectangle);
	}
});


L.Draw.Circle = L.Draw.SimpleShape.extend({
	statics: {
		TYPE: 'circle'
	},

	options: {
		shapeOptions: {
			stroke: true,
			color: '#f06eaa',
			weight: 4,
			opacity: 0.5,
			fill: true,
			fillColor: null, //same as color by default
			fillOpacity: 0.2,
			clickable: true
		},
		showRadius: true,
		metric: true // Whether to use the metric meaurement system or imperial
	},

	initialize: function (map, options) {
		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.Draw.Circle.TYPE;

		this._initialLabelText = L.drawLocal.draw.handlers.circle.tooltip.start;

		L.Draw.SimpleShape.prototype.initialize.call(this, map, options);
	},

	_drawShape: function (latlng) {
		if (!this._shape) {
			this._shape = new L.Circle(this._startLatLng, this._startLatLng.distanceTo(latlng), this.options.shapeOptions);
			this._map.addLayer(this._shape);
		} else {
			this._shape.setRadius(this._startLatLng.distanceTo(latlng));
		}
	},

	_fireCreatedEvent: function () {
		var circle = new L.Circle(this._startLatLng, this._shape.getRadius(), this.options.shapeOptions);
		L.Draw.SimpleShape.prototype._fireCreatedEvent.call(this, circle);
	},

	_onMouseMove: function (e) {
		var latlng = e.latlng,
			showRadius = this.options.showRadius,
			useMetric = this.options.metric,
			radius;

		this._tooltip.updatePosition(latlng);
		if (this._isDrawing) {
			this._drawShape(latlng);

			// Get the new radius (rounded to 1 dp)
			radius = this._shape.getRadius().toFixed(1);

			this._tooltip.updateContent({
				text: this._endLabelText,
				subtext: showRadius ? 'Radius: ' + L.GeometryUtil.readableDistance(radius, useMetric) : ''
			});
		}
	}
});


L.Draw.Marker = L.Draw.Feature.extend({
	statics: {
		TYPE: 'marker'
	},

	options: {
		icon: new L.Icon.Default(),
		repeatMode: false,
		zIndexOffset: 2000 // This should be > than the highest z-index any markers
	},

	initialize: function (map, options) {
		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.Draw.Marker.TYPE;

		L.Draw.Feature.prototype.initialize.call(this, map, options);
	},

	addHooks: function () {
		L.Draw.Feature.prototype.addHooks.call(this);

		if (this._map) {
			this._tooltip.updateContent({ text: L.drawLocal.draw.handlers.marker.tooltip.start });

			// Same mouseMarker as in Draw.Polyline
			if (!this._mouseMarker) {
				this._mouseMarker = L.marker(this._map.getCenter(), {
					icon: L.divIcon({
						className: 'leaflet-mouse-marker',
						iconAnchor: [20, 20],
						iconSize: [40, 40]
					}),
					opacity: 0,
					zIndexOffset: this.options.zIndexOffset
				});
			}

			this._mouseMarker
				.on('click', this._onClick, this)
				.addTo(this._map);

			this._map.on('mousemove', this._onMouseMove, this);
		}
	},

	removeHooks: function () {
		L.Draw.Feature.prototype.removeHooks.call(this);

		if (this._map) {
			if (this._marker) {
				this._marker.off('click', this._onClick, this);
				this._map
					.off('click', this._onClick, this)
					.removeLayer(this._marker);
				delete this._marker;
			}

			this._mouseMarker.off('click', this._onClick, this);
			this._map.removeLayer(this._mouseMarker);
			delete this._mouseMarker;

			this._map.off('mousemove', this._onMouseMove, this);
		}
	},

	_onMouseMove: function (e) {
		var latlng = e.latlng;

		this._tooltip.updatePosition(latlng);
		this._mouseMarker.setLatLng(latlng);

		if (!this._marker) {
			this._marker = new L.Marker(latlng, {
				icon: this.options.icon,
				zIndexOffset: this.options.zIndexOffset
			});
			// Bind to both marker and map to make sure we get the click event.
			this._marker.on('click', this._onClick, this);
			this._map
				.on('click', this._onClick, this)
				//.addLayer(this._marker); //marker mouse 
		}
		else {
			latlng = this._mouseMarker.getLatLng();
			this._marker.setLatLng(latlng);
		}
	},

	_onClick: function () {
		this._fireCreatedEvent();
		this._map.fire('addIso');
		this.disable();
		if (this.options.repeatMode) {
			this.enable();
		}
	},

	_fireCreatedEvent: function () {
		var marker = new L.Marker(this._marker.getLatLng(), { icon: this.options.icon });
		L.Draw.Feature.prototype._fireCreatedEvent.call(this, marker);
	}
});

L.Draw.Isochrone = L.Draw.Marker.extend({
	statics: {
		TYPE: 'isochrone'
	},
	initialize: function(map, options){
		this.type = L.Draw.Isochrone.TYPE;

		L.Draw.Feature.prototype.initialize.call(this, map, options);
	},
	addHooks: function () {
		
		L.Draw.Feature.prototype.addHooks.call(this);
		
		if (this._map) {
			this._tooltip.updateContent({ text: L.drawLocal.draw.handlers.isochrone.tooltip.start });

			// Same mouseMarker as in Draw.Polyline
			if (!this._mouseMarker) {
				this._mouseMarker = L.marker(this._map.getCenter(), {
					icon: L.divIcon({
						className: 'leaflet-mouse-marker',
						iconAnchor: [20, 20],
						iconSize: [40, 40]
					}),
					opacity: 0,
					zIndexOffset: this.options.zIndexOffset
				});
			}

			this._mouseMarker
				.on('click', this._onClick, this)
				.addTo(this._map);

			this._map.on('mousemove', this._onMouseMove, this);
		}
	},

	_onMouseMove: function (e) {
		var latlng = e.latlng;

		this._tooltip.updatePosition(latlng);
		this._mouseMarker.setLatLng(latlng);

		if (!this._marker) {
			this._marker = new L.Marker(latlng, {
				icon: this.options.icon,
				zIndexOffset: this.options.zIndexOffset
			});
			// Bind to both marker and map to make sure we get the click event.
			this._marker.on('click', this._onClick, this);
			this._map
				.on('click', this._onClick, this)
				.addLayer(this._marker);
		}
		else {
			latlng = this._mouseMarker.getLatLng();
			this._marker.setLatLng(latlng);
		}
	},

	formOptions: function(toolbar){
		this._map.fire('draw:startIso',{toolbar: toolbar});
	}
}),

L.Edit = L.Edit || {};

/*
 * L.Edit.Poly is an editing handler for polylines and polygons.
 */

L.Edit.Poly = L.Handler.extend({
	options: {
		icon: new L.DivIcon({
			iconSize: new L.Point(8, 8),
			className: 'leaflet-div-icon leaflet-editing-icon'
		})
	},

	initialize: function (poly, options) {
		this._poly = poly;
		L.setOptions(this, options);
	},

	addHooks: function () {
		if (this._poly._map) {
			if (!this._markerGroup) {
				this._initMarkers();
			}
			this._poly._map.addLayer(this._markerGroup);
		}
	},

	removeHooks: function () {
		if (this._poly._map) {
			this._poly._map.removeLayer(this._markerGroup);
			delete this._markerGroup;
			delete this._markers;
		}
	},

	updateMarkers: function () {
		this._markerGroup.clearLayers();
		this._initMarkers();
	},

	_initMarkers: function () {
		if (!this._markerGroup) {
			this._markerGroup = new L.LayerGroup();
		}
		this._markers = [];

		var latlngs = this._poly._latlngs,
			i, j, len, marker;

		// TODO refactor holes implementation in Polygon to support it here

		for (i = 0, len = latlngs.length; i < len; i++) {

			marker = this._createMarker(latlngs[i], i);
			marker.on('click', this._onMarkerClick, this);
			this._markers.push(marker);
		}

		var markerLeft, markerRight;

		for (i = 0, j = len - 1; i < len; j = i++) {
			if (i === 0 && !(L.Polygon && (this._poly instanceof L.Polygon))) {
				continue;
			}

			markerLeft = this._markers[j];
			markerRight = this._markers[i];

			this._createMiddleMarker(markerLeft, markerRight);
			this._updatePrevNext(markerLeft, markerRight);
		}
	},

	_createMarker: function (latlng, index) {
		var marker = new L.Marker(latlng, {
			draggable: true,
			icon: this.options.icon
		});

		marker._origLatLng = latlng;
		marker._index = index;

		marker.on('drag', this._onMarkerDrag, this);
		marker.on('dragend', this._fireEdit, this);

		this._markerGroup.addLayer(marker);

		return marker;
	},

	_removeMarker: function (marker) {
		var i = marker._index;

		this._markerGroup.removeLayer(marker);
		this._markers.splice(i, 1);
		this._poly.spliceLatLngs(i, 1);
		this._updateIndexes(i, -1);

		marker
			.off('drag', this._onMarkerDrag, this)
			.off('dragend', this._fireEdit, this)
			.off('click', this._onMarkerClick, this);
	},

	_fireEdit: function () {
		this._poly.edited = true;
		this._poly.fire('edit');
	},

	_onMarkerDrag: function (e) {
		var marker = e.target;

		L.extend(marker._origLatLng, marker._latlng);

		if (marker._middleLeft) {
			marker._middleLeft.setLatLng(this._getMiddleLatLng(marker._prev, marker));
		}
		if (marker._middleRight) {
			marker._middleRight.setLatLng(this._getMiddleLatLng(marker, marker._next));
		}

		this._poly.redraw();
	},

	_onMarkerClick: function (e) {
		var minPoints = L.Polygon && (this._poly instanceof L.Polygon) ? 4 : 3,
			marker = e.target;

		// If removing this point would create an invalid polyline/polygon don't remove
		if (this._poly._latlngs.length < minPoints) {
			return;
		}

		// remove the marker
		this._removeMarker(marker);

		// update prev/next links of adjacent markers
		this._updatePrevNext(marker._prev, marker._next);

		// remove ghost markers near the removed marker
		if (marker._middleLeft) {
			this._markerGroup.removeLayer(marker._middleLeft);
		}
		if (marker._middleRight) {
			this._markerGroup.removeLayer(marker._middleRight);
		}

		// create a ghost marker in place of the removed one
		if (marker._prev && marker._next) {
			this._createMiddleMarker(marker._prev, marker._next);

		} else if (!marker._prev) {
			marker._next._middleLeft = null;

		} else if (!marker._next) {
			marker._prev._middleRight = null;
		}

		this._fireEdit();
	},

	_updateIndexes: function (index, delta) {
		this._markerGroup.eachLayer(function (marker) {
			if (marker._index > index) {
				marker._index += delta;
			}
		});
	},

	_createMiddleMarker: function (marker1, marker2) {
		var latlng = this._getMiddleLatLng(marker1, marker2),
		    marker = this._createMarker(latlng),
		    onClick,
		    onDragStart,
		    onDragEnd;

		marker.setOpacity(0.6);

		marker1._middleRight = marker2._middleLeft = marker;

		onDragStart = function () {
			var i = marker2._index;

			marker._index = i;

			marker
			    .off('click', onClick, this)
			    .on('click', this._onMarkerClick, this);

			latlng.lat = marker.getLatLng().lat;
			latlng.lng = marker.getLatLng().lng;
			this._poly.spliceLatLngs(i, 0, latlng);
			this._markers.splice(i, 0, marker);

			marker.setOpacity(1);

			this._updateIndexes(i, 1);
			marker2._index++;
			this._updatePrevNext(marker1, marker);
			this._updatePrevNext(marker, marker2);

			this._poly.fire('editstart');
		};

		onDragEnd = function () {
			marker.off('dragstart', onDragStart, this);
			marker.off('dragend', onDragEnd, this);

			this._createMiddleMarker(marker1, marker);
			this._createMiddleMarker(marker, marker2);
		};

		onClick = function () {
			onDragStart.call(this);
			onDragEnd.call(this);
			this._fireEdit();
		};

		marker
		    .on('click', onClick, this)
		    .on('dragstart', onDragStart, this)
		    .on('dragend', onDragEnd, this);

		this._markerGroup.addLayer(marker);
	},

	_updatePrevNext: function (marker1, marker2) {
		if (marker1) {
			marker1._next = marker2;
		}
		if (marker2) {
			marker2._prev = marker1;
		}
	},

	_getMiddleLatLng: function (marker1, marker2) {
		var map = this._poly._map,
		    p1 = map.project(marker1.getLatLng()),
		    p2 = map.project(marker2.getLatLng());

		return map.unproject(p1._add(p2)._divideBy(2));
	}
});

L.Polyline.addInitHook(function () {

	// Check to see if handler has already been initialized. This is to support versions of Leaflet that still have L.Handler.PolyEdit
	if (this.editing) {
		return;
	}

	if (L.Edit.Poly) {
		this.editing = new L.Edit.Poly(this);

		if (this.options.editable) {
			this.editing.enable();
		}
	}

	this.on('add', function () {
		if (this.editing && this.editing.enabled()) {
			this.editing.addHooks();
		}
	});

	this.on('remove', function () {
		if (this.editing && this.editing.enabled()) {
			this.editing.removeHooks();
		}
	});
});


L.Edit = L.Edit || {};

L.Edit.SimpleShape = L.Handler.extend({
	options: {
		moveIcon: new L.DivIcon({
			iconSize: new L.Point(8, 8),
			className: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-move'
		}),
		resizeIcon: new L.DivIcon({
			iconSize: new L.Point(8, 8),
			className: 'leaflet-div-icon leaflet-editing-icon leaflet-edit-resize'
		})
	},

	initialize: function (shape, options) {
		this._shape = shape;
		L.Util.setOptions(this, options);
	},

	addHooks: function () {
		if (this._shape._map) {
			this._map = this._shape._map;

			if (!this._markerGroup) {
				this._initMarkers();
			}
			this._map.addLayer(this._markerGroup);
		}
	},

	removeHooks: function () {
		if (this._shape._map) {
			this._unbindMarker(this._moveMarker);

			for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
				this._unbindMarker(this._resizeMarkers[i]);
			}
			this._resizeMarkers = null;

			this._map.removeLayer(this._markerGroup);
			delete this._markerGroup;
		}

		this._map = null;
	},

	updateMarkers: function () {
		this._markerGroup.clearLayers();
		this._initMarkers();
	},

	_initMarkers: function () {
		if (!this._markerGroup) {
			this._markerGroup = new L.LayerGroup();
		}

		// Create center marker
		this._createMoveMarker();

		// Create edge marker
		this._createResizeMarker();
	},

	_createMoveMarker: function () {
		// Children override
	},

	_createResizeMarker: function () {
		// Children override
	},

	_createMarker: function (latlng, icon) {
		var marker = new L.Marker(latlng, {
			draggable: true,
			icon: icon,
			zIndexOffset: 10
		});

		this._bindMarker(marker);

		this._markerGroup.addLayer(marker);

		return marker;
	},

	_bindMarker: function (marker) {
		marker
			.on('dragstart', this._onMarkerDragStart, this)
			.on('drag', this._onMarkerDrag, this)
			.on('dragend', this._onMarkerDragEnd, this);
	},

	_unbindMarker: function (marker) {
		marker
			.off('dragstart', this._onMarkerDragStart, this)
			.off('drag', this._onMarkerDrag, this)
			.off('dragend', this._onMarkerDragEnd, this);
	},

	_onMarkerDragStart: function (e) {
		var marker = e.target;
		marker.setOpacity(0);

		this._shape.fire('editstart');
	},

	_fireEdit: function () {
		this._shape.edited = true;
		this._shape.fire('edit');
	},

	_onMarkerDrag: function (e) {
		var marker = e.target,
			latlng = marker.getLatLng();

		if (marker === this._moveMarker) {
			this._move(latlng);
		} else {
			this._resize(latlng);
		}

		this._shape.redraw();
	},

	_onMarkerDragEnd: function (e) {
		var marker = e.target;
		marker.setOpacity(1);

		this._fireEdit();
	},

	_move: function () {
		// Children override
	},

	_resize: function () {
		// Children override
	}
});


L.Edit = L.Edit || {};

L.Edit.Rectangle = L.Edit.SimpleShape.extend({
	_createMoveMarker: function () {
		var bounds = this._shape.getBounds(),
			center = bounds.getCenter();

		this._moveMarker = this._createMarker(center, this.options.moveIcon);
	},

	_createResizeMarker: function () {
		var corners = this._getCorners();

		this._resizeMarkers = [];

		for (var i = 0, l = corners.length; i < l; i++) {
			this._resizeMarkers.push(this._createMarker(corners[i], this.options.resizeIcon));
			// Monkey in the corner index as we will need to know this for dragging
			this._resizeMarkers[i]._cornerIndex = i;
		}
	},

	_onMarkerDragStart: function (e) {
		L.Edit.SimpleShape.prototype._onMarkerDragStart.call(this, e);

		// Save a reference to the opposite point
		var corners = this._getCorners(),
			marker = e.target,
			currentCornerIndex = marker._cornerIndex;

		this._oppositeCorner = corners[(currentCornerIndex + 2) % 4];

		this._toggleCornerMarkers(0, currentCornerIndex);
	},

	_onMarkerDragEnd: function (e) {
		var marker = e.target,
			bounds, center;

		// Reset move marker position to the center
		if (marker === this._moveMarker) {
			bounds = this._shape.getBounds();
			center = bounds.getCenter();

			marker.setLatLng(center);
		}

		this._toggleCornerMarkers(1);

		this._repositionCornerMarkers();

		L.Edit.SimpleShape.prototype._onMarkerDragEnd.call(this, e);
	},

	_move: function (newCenter) {
		var latlngs = this._shape.getLatLngs(),
			bounds = this._shape.getBounds(),
			center = bounds.getCenter(),
			offset, newLatLngs = [];

		// Offset the latlngs to the new center
		for (var i = 0, l = latlngs.length; i < l; i++) {
			offset = [latlngs[i].lat - center.lat, latlngs[i].lng - center.lng];
			newLatLngs.push([newCenter.lat + offset[0], newCenter.lng + offset[1]]);
		}

		this._shape.setLatLngs(newLatLngs);

		// Reposition the resize markers
		this._repositionCornerMarkers();
	},

	_resize: function (latlng) {
		var bounds;

		// Update the shape based on the current position of this corner and the opposite point
		this._shape.setBounds(L.latLngBounds(latlng, this._oppositeCorner));

		// Reposition the move marker
		bounds = this._shape.getBounds();
		this._moveMarker.setLatLng(bounds.getCenter());
	},

	_getCorners: function () {
		var bounds = this._shape.getBounds(),
			nw = bounds.getNorthWest(),
			ne = bounds.getNorthEast(),
			se = bounds.getSouthEast(),
			sw = bounds.getSouthWest();

		return [nw, ne, se, sw];
	},

	_toggleCornerMarkers: function (opacity) {
		for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
			this._resizeMarkers[i].setOpacity(opacity);
		}
	},

	_repositionCornerMarkers: function () {
		var corners = this._getCorners();

		for (var i = 0, l = this._resizeMarkers.length; i < l; i++) {
			this._resizeMarkers[i].setLatLng(corners[i]);
		}
	}
});

L.Rectangle.addInitHook(function () {
	if (L.Edit.Rectangle) {
		this.editing = new L.Edit.Rectangle(this);

		if (this.options.editable) {
			this.editing.enable();
		}
	}
});


L.Edit = L.Edit || {};

L.Edit.Circle = L.Edit.SimpleShape.extend({
	_createMoveMarker: function () {
		var center = this._shape.getLatLng();

		this._moveMarker = this._createMarker(center, this.options.moveIcon);
	},

	_createResizeMarker: function () {
		var center = this._shape.getLatLng(),
			resizemarkerPoint = this._getResizeMarkerPoint(center);

		this._resizeMarkers = [];
		this._resizeMarkers.push(this._createMarker(resizemarkerPoint, this.options.resizeIcon));
	},

	_getResizeMarkerPoint: function (latlng) {
		// From L.shape.getBounds()
		var delta = this._shape._radius * Math.cos(Math.PI / 4),
			point = this._map.project(latlng);
		return this._map.unproject([point.x + delta, point.y - delta]);
	},

	_move: function (latlng) {
		var resizemarkerPoint = this._getResizeMarkerPoint(latlng);

		// Move the resize marker
		this._resizeMarkers[0].setLatLng(resizemarkerPoint);

		// Move the circle
		this._shape.setLatLng(latlng);
	},

	_resize: function (latlng) {
		var moveLatLng = this._moveMarker.getLatLng(),
			radius = moveLatLng.distanceTo(latlng);

		this._shape.setRadius(radius);
	}
});

L.Circle.addInitHook(function () {
	if (L.Edit.Circle) {
		this.editing = new L.Edit.Circle(this);

		if (this.options.editable) {
			this.editing.enable();
		}
	}

	this.on('add', function () {
		if (this.editing && this.editing.enabled()) {
			this.editing.addHooks();
		}
	});

	this.on('remove', function () {
		if (this.editing && this.editing.enabled()) {
			this.editing.removeHooks();
		}
	});
});

/*
 * L.LatLngUtil contains different utility functions for LatLngs.
 */

L.LatLngUtil = {
	// Clones a LatLngs[], returns [][]
	cloneLatLngs: function (latlngs) {
		var clone = [];
		for (var i = 0, l = latlngs.length; i < l; i++) {
			clone.push(this.cloneLatLng(latlngs[i]));
		}
		return clone;
	},

	cloneLatLng: function (latlng) {
		return L.latLng(latlng.lat, latlng.lng);
	}
};

L.GeometryUtil = L.extend(L.GeometryUtil || {}, {
	// Ported from the OpenLayers implementation. See https://github.com/openlayers/openlayers/blob/master/lib/OpenLayers/Geometry/LinearRing.js#L270
	geodesicArea: function (latLngs) {
		var pointsCount = latLngs.length,
			area = 0.0,
			d2r = L.LatLng.DEG_TO_RAD,
			p1, p2;

		if (pointsCount > 2) {
			for (var i = 0; i < pointsCount; i++) {
				p1 = latLngs[i];
				p2 = latLngs[(i + 1) % pointsCount];
				area += ((p2.lng - p1.lng) * d2r) *
						(2 + Math.sin(p1.lat * d2r) + Math.sin(p2.lat * d2r));
			}
			area = area * 6378137.0 * 6378137.0 / 2.0;
		}

		return Math.abs(area);
	},

	readableArea: function (area, isMetric) {
		var areaStr;

		if (isMetric) {
			if (area >= 10000) {
				areaStr = (area * 0.0001).toFixed(2) + ' ha';
			} else {
				areaStr = area.toFixed(2) + ' m&sup2;';
			}
		} else {
			area *= 0.836127; // Square yards in 1 meter

			if (area >= 3097600) { //3097600 square yards in 1 square mile
				areaStr = (area / 3097600).toFixed(2) + ' mi&sup2;';
			} else if (area >= 4840) {//48040 square yards in 1 acre
				areaStr = (area / 4840).toFixed(2) + ' acres';
			} else {
				areaStr = Math.ceil(area) + ' yd&sup2;';
			}
		}

		return areaStr;
	},

	readableDistance: function (distance, isMetric) {
		var distanceStr;

		if (isMetric) {
			// show metres when distance is < 1km, then show km
			if (distance > 1000) {
				distanceStr = (distance  / 1000).toFixed(2) + ' km';
			} else {
				distanceStr = Math.ceil(distance) + ' m';
			}
		} else {
			distance *= 1.09361;

			if (distance > 1760) {
				distanceStr = (distance / 1760).toFixed(2) + ' miles';
			} else {
				distanceStr = Math.ceil(distance) + ' yd';
			}
		}

		return distanceStr;
	}
});

L.Util.extend(L.LineUtil, {
	// Checks to see if two line segments intersect. Does not handle degenerate cases.
	// http://compgeom.cs.uiuc.edu/~jeffe/teaching/373/notes/x06-sweepline.pdf
	segmentsIntersect: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2, /*Point*/ p3) {
		return	this._checkCounterclockwise(p, p2, p3) !==
				this._checkCounterclockwise(p1, p2, p3) &&
				this._checkCounterclockwise(p, p1, p2) !==
				this._checkCounterclockwise(p, p1, p3);
	},

	// check to see if points are in counterclockwise order
	_checkCounterclockwise: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return (p2.y - p.y) * (p1.x - p.x) > (p1.y - p.y) * (p2.x - p.x);
	}
});

L.Polyline.include({
	// Check to see if this polyline has any linesegments that intersect.
	// NOTE: does not support detecting intersection for degenerate cases.
	intersects: function () {
		var points = this._originalPoints,
			len = points ? points.length : 0,
			i, p, p1;

		if (this._tooFewPointsForIntersection()) {
			return false;
		}

		for (i = len - 1; i >= 3; i--) {
			p = points[i - 1];
			p1 = points[i];


			if (this._lineSegmentsIntersectsRange(p, p1, i - 2)) {
				return true;
			}
		}

		return false;
	},

	// Check for intersection if new latlng was added to this polyline.
	// NOTE: does not support detecting intersection for degenerate cases.
	newLatLngIntersects: function (latlng, skipFirst) {
		// Cannot check a polyline for intersecting lats/lngs when not added to the map
		if (!this._map) {
			return false;
		}

		return this.newPointIntersects(this._map.latLngToLayerPoint(latlng), skipFirst);
	},

	// Check for intersection if new point was added to this polyline.
	// newPoint must be a layer point.
	// NOTE: does not support detecting intersection for degenerate cases.
	newPointIntersects: function (newPoint, skipFirst) {
		var points = this._originalPoints,
			len = points ? points.length : 0,
			lastPoint = points ? points[len - 1] : null,
			// The previous previous line segment. Previous line segment doesn't need testing.
			maxIndex = len - 2;

		if (this._tooFewPointsForIntersection(1)) {
			return false;
		}

		return this._lineSegmentsIntersectsRange(lastPoint, newPoint, maxIndex, skipFirst ? 1 : 0);
	},

	// Polylines with 2 sides can only intersect in cases where points are collinear (we don't support detecting these).
	// Cannot have intersection when < 3 line segments (< 4 points)
	_tooFewPointsForIntersection: function (extraPoints) {
		var points = this._originalPoints,
			len = points ? points.length : 0;
		// Increment length by extraPoints if present
		len += extraPoints || 0;

		return !this._originalPoints || len <= 3;
	},

	// Checks a line segment intersections with any line segments before its predecessor.
	// Don't need to check the predecessor as will never intersect.
	_lineSegmentsIntersectsRange: function (p, p1, maxIndex, minIndex) {
		var points = this._originalPoints,
			p2, p3;

		minIndex = minIndex || 0;

		// Check all previous line segments (beside the immediately previous) for intersections
		for (var j = maxIndex; j > minIndex; j--) {
			p2 = points[j - 1];
			p3 = points[j];

			if (L.LineUtil.segmentsIntersect(p, p1, p2, p3)) {
				return true;
			}
		}

		return false;
	}
});


L.Polygon.include({
	// Checks a polygon for any intersecting line segments. Ignores holes.
	intersects: function () {
		var polylineIntersects,
			points = this._originalPoints,
			len, firstPoint, lastPoint, maxIndex;

		if (this._tooFewPointsForIntersection()) {
			return false;
		}

		polylineIntersects = L.Polyline.prototype.intersects.call(this);

		// If already found an intersection don't need to check for any more.
		if (polylineIntersects) {
			return true;
		}

		len = points.length;
		firstPoint = points[0];
		lastPoint = points[len - 1];
		maxIndex = len - 2;

		// Check the line segment between last and first point. Don't need to check the first line segment (minIndex = 1)
		return this._lineSegmentsIntersectsRange(lastPoint, firstPoint, maxIndex, 1);
	}
});

L.Control.Draw = L.Control.extend({

	options: {
		position: 'topleft',
		draw: {},
		edit: false
	},

	initialize: function (options) {
		if (L.version < '0.7') {
			throw new Error('Leaflet.draw 0.2.3+ requires Leaflet 0.7.0+. Download latest from https://github.com/Leaflet/Leaflet/');
		}

		L.Control.prototype.initialize.call(this, options);

		var id, toolbar;

		this._toolbars = {};

		// Initialize toolbars
		if (L.DrawToolbar && this.options.draw) {
			toolbar = new L.DrawToolbar(this.options.draw);
			id = L.stamp(toolbar);
			this._toolbars[id] = toolbar;

			// Listen for when toolbar is enabled
			this._toolbars[id].on('enable', this._toolbarEnabled, this);
		}

		if (L.EditToolbar && this.options.edit) {
			toolbar = new L.EditToolbar(this.options.edit);
			id = L.stamp(toolbar);
			this._toolbars[id] = toolbar;

			// Listen for when toolbar is enabled
			this._toolbars[id].on('enable', this._toolbarEnabled, this);
		}
	},

	onAdd: function (map) {
		var container = L.DomUtil.create('div', 'leaflet-draw'),
			addedTopClass = false,
			topClassName = 'leaflet-draw-toolbar-top',
			toolbarContainer;

		for (var toolbarId in this._toolbars) {
			if (this._toolbars.hasOwnProperty(toolbarId)) {
				toolbarContainer = this._toolbars[toolbarId].addToolbar(map);

				if (toolbarContainer) {
					// Add class to the first toolbar to remove the margin
					if (!addedTopClass) {
						if (!L.DomUtil.hasClass(toolbarContainer, topClassName)) {
							L.DomUtil.addClass(toolbarContainer.childNodes[0], topClassName);
						}
						addedTopClass = true;
					}

					container.appendChild(toolbarContainer);
				}
			}
		}

		return container;
	},

	onRemove: function () {
		for (var toolbarId in this._toolbars) {
			if (this._toolbars.hasOwnProperty(toolbarId)) {
				this._toolbars[toolbarId].removeToolbar();
			}
		}
	},

	setDrawingOptions: function (options) {
		for (var toolbarId in this._toolbars) {
			if (this._toolbars[toolbarId] instanceof L.DrawToolbar) {
				this._toolbars[toolbarId].setOptions(options);
			}
		}
	},

	_toolbarEnabled: function (e) {
		var id = '' + L.stamp(e.target);

		for (var toolbarId in this._toolbars) {
			if (this._toolbars.hasOwnProperty(toolbarId) && toolbarId !== id) {
				this._toolbars[toolbarId].disable();
			}
		}
	}
});

L.Map.mergeOptions({
	drawControlTooltips: true,
	drawControl: false
});

L.Map.addInitHook(function () {
	if (this.options.drawControl) {
		this.drawControl = new L.Control.Draw();
		this.addControl(this.drawControl);
	}
});


L.Toolbar = L.Class.extend({
	includes: [L.Mixin.Events],

	initialize: function (options) {
		L.setOptions(this, options);

		this._modes = {};
		this._actionButtons = [];
		this._activeMode = null;
	},

	enabled: function () {
		return this._activeMode !== null;
	},

	disable: function () {
		if (!this.enabled()) { return; }

		this._activeMode.handler.disable();
	},

	addToolbar: function (map) {
		var container = L.DomUtil.create('div', 'leaflet-draw-section'),
			buttonIndex = 0,
			buttonClassPrefix = this._toolbarClass || '',
			modeHandlers = this.getModeHandlers(map),
			i;

		this._toolbarContainer = L.DomUtil.create('div', 'leaflet-draw-toolbar leaflet-bar');
		this._map = map;

		for (i = 0; i < modeHandlers.length; i++) {
			if (modeHandlers[i].enabled) {
				this._initModeHandler(
					modeHandlers[i].handler,
					this._toolbarContainer,
					buttonIndex++,
					buttonClassPrefix,
					modeHandlers[i].title
				);
			}
		}

		// if no buttons were added, do not add the toolbar
		if (!buttonIndex) {
			return;
		}

		// Save button index of the last button, -1 as we would have ++ after the last button
		this._lastButtonIndex = --buttonIndex;

		// Create empty actions part of the toolbar
		this._actionsContainer = L.DomUtil.create('ul', 'leaflet-draw-actions');

		// Add draw and cancel containers to the control container
		container.appendChild(this._toolbarContainer);
		container.appendChild(this._actionsContainer);

		return container;
	},

	removeToolbar: function () {
		// Dispose each handler
		for (var handlerId in this._modes) {
			if (this._modes.hasOwnProperty(handlerId)) {
				// Unbind handler button
				this._disposeButton(
					this._modes[handlerId].button,
					this._modes[handlerId].handler.enable,
					this._modes[handlerId].handler
				);

				// Make sure is disabled
				this._modes[handlerId].handler.disable();

				// Unbind handler
				this._modes[handlerId].handler
					.off('enabled', this._handlerActivated, this)
					.off('disabled', this._handlerDeactivated, this);
			}
		}
		this._modes = {};

		// Dispose the actions toolbar
		for (var i = 0, l = this._actionButtons.length; i < l; i++) {
			this._disposeButton(
				this._actionButtons[i].button,
				this._actionButtons[i].callback,
				this
			);
		}
		this._actionButtons = [];
		this._actionsContainer = null;
	},

	_initModeHandler: function (handler, container, buttonIndex, classNamePredix, buttonTitle) {
		var type = handler.type;

		this._modes[type] = {};

		this._modes[type].handler = handler;

		this._modes[type].button = this._createButton({
			title: buttonTitle,
			className: classNamePredix + '-' + type,
			container: container,
			callback: this._modes[type].handler.enable,
			context: this._modes[type].handler
		});
		if(type == 'editData'){
			this._modes[type].button.className = 'fa fa-bars';
		}

		if(type == 'isochrone'){
			this._modes[type].button.className = 'fa fa-dot-circle-o';
		}

		this._modes[type].buttonIndex = buttonIndex;

		this._modes[type].handler
			.on('enabled', this._handlerActivated, this)
			.on('disabled', this._handlerDeactivated, this);
	},

	_createButton: function (options) {
		var link = L.DomUtil.create('a', options.className || '', options.container);
		link.href = '#';

		if (options.text) {
			link.innerHTML = options.text;
		}

		if (options.title) {
			link.title = options.title;
		}

		L.DomEvent
			.on(link, 'click', L.DomEvent.stopPropagation)
			.on(link, 'mousedown', L.DomEvent.stopPropagation)
			.on(link, 'dblclick', L.DomEvent.stopPropagation)
			.on(link, 'click', L.DomEvent.preventDefault)
			.on(link, 'click', options.callback, options.context);

		return link;
	},

	_disposeButton: function (button, callback) {
		L.DomEvent
			.off(button, 'click', L.DomEvent.stopPropagation)
			.off(button, 'mousedown', L.DomEvent.stopPropagation)
			.off(button, 'dblclick', L.DomEvent.stopPropagation)
			.off(button, 'click', L.DomEvent.preventDefault)
			.off(button, 'click', callback);
	},

	_handlerActivated: function (e) {
		// Disable active mode (if present)
		this.disable();

		// Cache new active feature
		this._activeMode = this._modes[e.handler];

		L.DomUtil.addClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');

		this._showActionsToolbar();

		this.fire('enable');
	},

	_handlerDeactivated: function () {
		this._hideActionsToolbar();

		L.DomUtil.removeClass(this._activeMode.button, 'leaflet-draw-toolbar-button-enabled');

		this._activeMode = null;

		this.fire('disable');
	},

	_createActions: function (handler) {
		var container = this._actionsContainer,
			buttons = this.getActions(handler),
			l = buttons.length,
			li, di, dl, button;

		// Dispose the actions toolbar (todo: dispose only not used buttons)
		for (di = 0, dl = this._actionButtons.length; di < dl; di++) {
			this._disposeButton(this._actionButtons[di].button, this._actionButtons[di].callback);
		}
		this._actionButtons = [];

		// Remove all old buttons
		while (container.firstChild) {
			container.removeChild(container.firstChild);
		}

		for (var i = 0; i < l; i++) {
			if ('enabled' in buttons[i] && !buttons[i].enabled) {
				continue;
			}

			li = L.DomUtil.create('li', '', container);

			button = this._createButton({
				title: buttons[i].title,
				text: buttons[i].text,
				container: li,
				callback: buttons[i].callback,
				context: buttons[i].context
			});

			this._actionButtons.push({
				button: button,
				callback: buttons[i].callback
			});
		}
	},

	_showActionsToolbar: function () {
		var buttonIndex = this._activeMode.buttonIndex,
			lastButtonIndex = this._lastButtonIndex,
			toolbarPosition = this._activeMode.button.offsetTop - 1;

		// Recreate action buttons on every click
		this._createActions(this._activeMode.handler);

		// Correctly position the cancel button
		this._actionsContainer.style.top = toolbarPosition + 'px';

		if (buttonIndex === 0) {
			L.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');
			L.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-top');
		}

		if (buttonIndex === lastButtonIndex) {
			L.DomUtil.addClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');
			L.DomUtil.addClass(this._actionsContainer, 'leaflet-draw-actions-bottom');
		}

		this._actionsContainer.style.display = 'block';
	},

	_hideActionsToolbar: function () {
		this._actionsContainer.style.display = 'none';

		L.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-notop');
		L.DomUtil.removeClass(this._toolbarContainer, 'leaflet-draw-toolbar-nobottom');
		L.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-top');
		L.DomUtil.removeClass(this._actionsContainer, 'leaflet-draw-actions-bottom');
	}
});


L.Tooltip = L.Class.extend({
	initialize: function (map) {
		this._map = map;
		this._popupPane = map._panes.popupPane;

		this._container = map.options.drawControlTooltips ? L.DomUtil.create('div', 'leaflet-draw-tooltip', this._popupPane) : null;
		this._singleLineLabel = false;
	},

	dispose: function () {
		if (this._container) {
			this._popupPane.removeChild(this._container);
			this._container = null;
		}
	},

	updateContent: function (labelText) {
		if (!this._container) {
			return this;
		}
		labelText.subtext = labelText.subtext || '';

		// update the vertical position (only if changed)
		if (labelText.subtext.length === 0 && !this._singleLineLabel) {
			L.DomUtil.addClass(this._container, 'leaflet-draw-tooltip-single');
			this._singleLineLabel = true;
		}
		else if (labelText.subtext.length > 0 && this._singleLineLabel) {
			L.DomUtil.removeClass(this._container, 'leaflet-draw-tooltip-single');
			this._singleLineLabel = false;
		}

		this._container.innerHTML =
			(labelText.subtext.length > 0 ? '<span class="leaflet-draw-tooltip-subtext">' + labelText.subtext + '</span>' + '<br />' : '') +
			'<span>' + labelText.text + '</span>';

		return this;
	},

	updatePosition: function (latlng) {
		var pos = this._map.latLngToLayerPoint(latlng),
			tooltipContainer = this._container;

		if (this._container) {
			tooltipContainer.style.visibility = 'inherit';
			L.DomUtil.setPosition(tooltipContainer, pos);
		}

		return this;
	},

	showAsError: function () {
		if (this._container) {
			L.DomUtil.addClass(this._container, 'leaflet-error-draw-tooltip');
		}
		return this;
	},

	removeError: function () {
		if (this._container) {
			L.DomUtil.removeClass(this._container, 'leaflet-error-draw-tooltip');
		}
		return this;
	}
});

L.DrawToolbar = L.Toolbar.extend({

	options: {
		polyline: {},
		polygon: {},
		rectangle: {},
		circle: {},
		marker: {},
		isochrone:{}
	},

	initialize: function (options) {
		// Ensure that the options are merged correctly since L.extend is only shallow
		for (var type in this.options) {
			if (this.options.hasOwnProperty(type)) {
				if (options[type]) {
					options[type] = L.extend({}, this.options[type], options[type]);
				}
			}
		}

		this._toolbarClass = 'leaflet-draw-draw';
		L.Toolbar.prototype.initialize.call(this, options);
	},

	_formOptions: function () {
		this._activeMode.handler.formOptions(this);
		//this._activeMode.handler.disable();
	},

	getModeHandlers: function (map) {
		return [
			{
				enabled: this.options.polyline,
				handler: new L.Draw.Polyline(map, this.options.polyline),
				title: L.drawLocal.draw.toolbar.buttons.polyline
			},
			{
				enabled: this.options.polygon,
				handler: new L.Draw.Polygon(map, this.options.polygon),
				title: L.drawLocal.draw.toolbar.buttons.polygon
			},
			{
				enabled: this.options.rectangle,
				handler: new L.Draw.Rectangle(map, this.options.rectangle),
				title: L.drawLocal.draw.toolbar.buttons.rectangle
			},
			{
				enabled: this.options.circle,
				handler: new L.Draw.Circle(map, this.options.circle),
				title: L.drawLocal.draw.toolbar.buttons.circle
			},
			{
				enabled: this.options.marker,
				handler: new L.Draw.Marker(map, this.options.marker),
				title: L.drawLocal.draw.toolbar.buttons.marker
			},
			{
				enabled: this.options.isochrone,
				handler: new L.Draw.Isochrone(map, this.options.isochrone),
				title: L.drawLocal.draw.toolbar.buttons.isochrone
			}
		];
	},

	// Get the actions part of the toolbar
	getActions: function (handler) {
		if(this.options.isochrone){
			return [
				{
					title: L.drawLocal.draw.toolbar.actionsIso.option.title,
					text: L.drawLocal.draw.toolbar.actionsIso.option.text,
					callback: this._formOptions,
					context: this
				},
				{
					title: L.drawLocal.draw.toolbar.actionsIso.cancel.title,
					text: L.drawLocal.draw.toolbar.actionsIso.cancel.text,
					callback: this.disable,
					context: this
				}
			];
		};

		return [
			{
				enabled: handler.deleteLastVertex,
				title: L.drawLocal.draw.toolbar.undo.title,
				text: L.drawLocal.draw.toolbar.undo.text,
				callback: handler.deleteLastVertex,
				context: handler
			},
			{
				title: L.drawLocal.draw.toolbar.actions.title,
				text: L.drawLocal.draw.toolbar.actions.text,
				callback: this.disable,
				context: this
			}
		];
	
	},

	setOptions: function (options) {
		L.setOptions(this, options);

		for (var type in this._modes) {
			if (this._modes.hasOwnProperty(type) && options.hasOwnProperty(type)) {
				this._modes[type].handler.setOptions(options[type]);
			}
		}
	},

	_disabled: function () {
		if (this.options.isochrone) {
			button = this._modes.isochrone.button;
			L.DomUtil.addClass(button, 'leaflet-disabled');
			L.DomUtil.removeClass(button, 'leaflet-draw-toolbar-button-enabled');
			L.DomUtil.addClass(button, 'leaflet-draw-toolbar-button-disabled');
			this._activeMode.handler.disable(); //quita el marker del raton
			this._modes.isochrone.handler._enabled = true;
		}
	},

	_enabled: function(){
		if (this.options.isochrone) {
			button = this._modes.isochrone.button;
			L.DomUtil.removeClass(button, 'leaflet-disabled');
			L.DomUtil.addClass(button, 'leaflet-draw-toolbar-button-enabled');
			this._modes.isochrone.handler._enabled = false;
			this._modes.isochrone.handler.enable();

						
		}
	}
});


/*L.Map.mergeOptions({
	editControl: true
});*/

L.EditToolbar = L.Toolbar.extend({
	options: {
		edit: {
			selectedPathOptions: {
				color: '#fe57a1', /* Hot pink all the things! */
				opacity: 0.6,
				dashArray: '10, 10',

				fill: true,
				fillColor: '#fe57a1',
				fillOpacity: 0.1
			}
		},
		editData:{},
		remove: {},
		featureGroup: null /* REQUIRED! TODO: perhaps if not set then all layers on the map are selectable? */
	},

	initialize: function (options) {
		// Need to set this manually since null is an acceptable value here
		if (options.edit) {
			if (typeof options.edit.selectedPathOptions === 'undefined') {
				options.edit.selectedPathOptions = this.options.edit.selectedPathOptions;
			}
			options.edit = L.extend({}, this.options.edit, options.edit);
		}

		if (options.editData) {
			options.editData = L.extend({}, this.options.editData, options.editData);
		}
		if (options.remove) {
			options.remove = L.extend({}, this.options.remove, options.remove);
		}

		this._toolbarClass = 'leaflet-draw-edit';
		L.Toolbar.prototype.initialize.call(this, options);

		this._selectedFeatureCount = 0;
	},

	getModeHandlers: function (map) {
		var featureGroup = this.options.featureGroup;
		return [
			{
				enabled: this.options.edit,
				handler: new L.EditToolbar.Edit(map, {
					featureGroup: featureGroup,
					selectedPathOptions: this.options.edit.selectedPathOptions
				}),
				title: L.drawLocal.edit.toolbar.buttons.edit
			},
			{
				enabled: this.options.editData,
				handler: new L.EditToolbar.EditData(map, {
					featureGroup: featureGroup
				}),
				title: L.drawLocal.edit.toolbar.buttons.editData
			},
			{
				enabled: this.options.remove,
				handler: new L.EditToolbar.Delete(map, {
					featureGroup: featureGroup
				}),
				title: L.drawLocal.edit.toolbar.buttons.remove
			}
		];
	},

	getActions: function () {
		return [
			{
				title: L.drawLocal.edit.toolbar.actions.save.title,
				text: L.drawLocal.edit.toolbar.actions.save.text,
				callback: this._save,
				context: this
			},
			{
				title: L.drawLocal.edit.toolbar.actions.cancel.title,
				text: L.drawLocal.edit.toolbar.actions.cancel.text,
				callback: this.disable,
				context: this
			}
		];
	},

	addToolbar: function (map) {
		var container = L.Toolbar.prototype.addToolbar.call(this, map);

		this._checkDisabled();

		this.options.featureGroup.on('layeradd layerremove', this._checkDisabled, this);

		return container;
	},

	removeToolbar: function () {
		this.options.featureGroup.off('layeradd layerremove', this._checkDisabled, this);

		L.Toolbar.prototype.removeToolbar.call(this);
	},

	disable: function () {
		if (!this.enabled()) { return; }

		this._activeMode.handler.revertLayers();

		L.Toolbar.prototype.disable.call(this);
	},

	_save: function () {
		this._activeMode.handler.save();
		this._activeMode.handler.disable();
	},

	_checkDisabled: function () {
		var featureGroup = this.options.featureGroup,
			hasLayers = featureGroup.getLayers().length !== 0,
			button;

		if (this.options.edit) {
			button = this._modes[L.EditToolbar.Edit.TYPE].button;

			if (hasLayers) {
				L.DomUtil.removeClass(button, 'leaflet-disabled');
			} else {
				L.DomUtil.addClass(button, 'leaflet-disabled');
			}

			button.setAttribute(
				'title',
				hasLayers ?
				L.drawLocal.edit.toolbar.buttons.edit
				: L.drawLocal.edit.toolbar.buttons.editDisabled
			);
		}

		if (this.options.editData) {
			button = this._modes[L.EditToolbar.EditData.TYPE].button;

			if (hasLayers) {
				L.DomUtil.removeClass(button, 'leaflet-disabled');
			} else {
				L.DomUtil.addClass(button, 'leaflet-disabled');
			}

			button.setAttribute(
				'title',
				hasLayers ?
				L.drawLocal.edit.toolbar.buttons.editData
				: L.drawLocal.edit.toolbar.buttons.editDataDisabled
			);
		}

		if (this.options.remove) {
			button = this._modes[L.EditToolbar.Delete.TYPE].button;

			if (hasLayers) {
				L.DomUtil.removeClass(button, 'leaflet-disabled');
			} else {
				L.DomUtil.addClass(button, 'leaflet-disabled');
			}

			button.setAttribute(
				'title',
				hasLayers ?
				L.drawLocal.edit.toolbar.buttons.remove
				: L.drawLocal.edit.toolbar.buttons.removeDisabled
			);
		}
	}
});


L.EditToolbar.Edit = L.Handler.extend({
	statics: {
		TYPE: 'edit'
	},

	includes: L.Mixin.Events,

	initialize: function (map, options) {
		L.Handler.prototype.initialize.call(this, map);

		// Set options to the default unless already set
		this._selectedPathOptions = options.selectedPathOptions;

		// Store the selectable layer group for ease of access
		this._featureGroup = options.featureGroup;

		if (!(this._featureGroup instanceof L.FeatureGroup)) {
			throw new Error('options.featureGroup must be a L.FeatureGroup');
		}

		this._uneditedLayerProps = {};

		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.EditToolbar.Edit.TYPE;
	},

	enable: function () {
		if (this._enabled || !this._hasAvailableLayers()) {
			return;
		}
		this.fire('enabled', {handler: this.type});
			//this disable other handlers

		this._map.fire('draw:editstart', { handler: this.type });
			//allow drawLayer to be updated before beginning edition.

		L.Handler.prototype.enable.call(this);
		this._featureGroup
			.on('layeradd', this._enableLayerEdit, this)
			.on('layerremove', this._disableLayerEdit, this);
	},

	disable: function () {
		if (!this._enabled) { return; }
		this._featureGroup
			.off('layeradd', this._enableLayerEdit, this)
			.off('layerremove', this._disableLayerEdit, this);
		L.Handler.prototype.disable.call(this);
		this._map.fire('draw:editstop', { handler: this.type });
		this.fire('disabled', {handler: this.type});
	},

	addHooks: function () {
		var map = this._map;

		if (map) {
			map.getContainer().focus();

			this._featureGroup.eachLayer(this._enableLayerEdit, this);

			this._tooltip = new L.Tooltip(this._map);
			this._tooltip.updateContent({
				text: L.drawLocal.edit.handlers.edit.tooltip.text,
				subtext: L.drawLocal.edit.handlers.edit.tooltip.subtext
			});

			this._map.on('mousemove', this._onMouseMove, this);
		}
	},

	removeHooks: function () {
		if (this._map) {
			// Clean up selected layers.
			this._featureGroup.eachLayer(this._disableLayerEdit, this);

			// Clear the backups of the original layers
			this._uneditedLayerProps = {};

			this._tooltip.dispose();
			this._tooltip = null;

			this._map.off('mousemove', this._onMouseMove, this);
		}
	},

	revertLayers: function () {
		this._featureGroup.eachLayer(function (layer) {
			this._revertLayer(layer);
		}, this);
	},

	save: function () {
		var editedLayers = new L.LayerGroup();
		this._featureGroup.eachLayer(function (layer) {
			if (layer.edited) {
				editedLayers.addLayer(layer);
				layer.edited = false;
			}
		});
		this._map.fire('draw:edited', {layers: editedLayers});
	},

	_backupLayer: function (layer) {
		var id = L.Util.stamp(layer);

		if (!this._uneditedLayerProps[id]) {
			// Polyline, Polygon or Rectangle
			if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {
				this._uneditedLayerProps[id] = {
					latlngs: L.LatLngUtil.cloneLatLngs(layer.getLatLngs())
				};
			} else if (layer instanceof L.Circle) {
				this._uneditedLayerProps[id] = {
					latlng: L.LatLngUtil.cloneLatLng(layer.getLatLng()),
					radius: layer.getRadius()
				};
			} else if (layer instanceof L.Marker) { // Marker
				this._uneditedLayerProps[id] = {
					latlng: L.LatLngUtil.cloneLatLng(layer.getLatLng())
				};
			}
		}
	},

	_revertLayer: function (layer) {
		var id = L.Util.stamp(layer);
		layer.edited = false;
		if (this._uneditedLayerProps.hasOwnProperty(id)) {
			// Polyline, Polygon or Rectangle
			if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {
				layer.setLatLngs(this._uneditedLayerProps[id].latlngs);
			} else if (layer instanceof L.Circle) {
				layer.setLatLng(this._uneditedLayerProps[id].latlng);
				layer.setRadius(this._uneditedLayerProps[id].radius);
			} else if (layer instanceof L.Marker) { // Marker
				layer.setLatLng(this._uneditedLayerProps[id].latlng);
			}
		}
	},

	_toggleMarkerHighlight: function (marker) {
		if (!marker._icon) {
			return;
		}
		// This is quite naughty, but I don't see another way of doing it. (short of setting a new icon)
		var icon = marker._icon;

		icon.style.display = 'none';

		if (L.DomUtil.hasClass(icon, 'leaflet-edit-marker-selected')) {
			L.DomUtil.removeClass(icon, 'leaflet-edit-marker-selected');
			// Offset as the border will make the icon move.
			this._offsetMarker(icon, -4);

		} else {
			L.DomUtil.addClass(icon, 'leaflet-edit-marker-selected');
			// Offset as the border will make the icon move.
			this._offsetMarker(icon, 4);
		}

		icon.style.display = '';
	},

	_offsetMarker: function (icon, offset) {
		var iconMarginTop = parseInt(icon.style.marginTop, 10) - offset,
			iconMarginLeft = parseInt(icon.style.marginLeft, 10) - offset;

		icon.style.marginTop = iconMarginTop + 'px';
		icon.style.marginLeft = iconMarginLeft + 'px';
	},

	_enableLayerEdit: function (e) {
		var layer = e.layer || e.target || e,
			isMarker = layer instanceof L.Marker,
			pathOptions;

		// Don't do anything if this layer is a marker but doesn't have an icon. Markers
		// should usually have icons. If using Leaflet.draw with Leafler.markercluster there
		// is a chance that a marker doesn't.
		if (isMarker && !layer._icon) {
			return;
		}

		// Back up this layer (if haven't before)
		this._backupLayer(layer);

		// Update layer style so appears editable
		if (this._selectedPathOptions) {
			pathOptions = L.Util.extend({}, this._selectedPathOptions);

			if (isMarker) {
				this._toggleMarkerHighlight(layer);
			} else {
				layer.options.previousOptions = L.Util.extend({ dashArray: null }, layer.options);

				// Make sure that Polylines are not filled
				if (!(layer instanceof L.Circle) && !(layer instanceof L.Polygon) && !(layer instanceof L.Rectangle)) {
					pathOptions.fill = false;
				}

				layer.setStyle(pathOptions);
			}
		}

		if (isMarker) {
			layer.dragging.enable();
			layer.on('dragend', this._onMarkerDragEnd);
		} else {
			layer.editing.enable();
		}
	},

	_disableLayerEdit: function (e) {
		var layer = e.layer || e.target || e;
		layer.edited = false;

		// Reset layer styles to that of before select
		if (this._selectedPathOptions) {
			if (layer instanceof L.Marker) {
				this._toggleMarkerHighlight(layer);
			} else {
				// reset the layer style to what is was before being selected
				layer.setStyle(layer.options.previousOptions);
				// remove the cached options for the layer object
				delete layer.options.previousOptions;
			}
		}

		if (layer instanceof L.Marker) {
			layer.dragging.disable();
			layer.off('dragend', this._onMarkerDragEnd, this);
		} else {
			layer.editing.disable();
		}
	},

	_onMarkerDragEnd: function (e) {
		var layer = e.target;
		layer.edited = true;
	},

	_onMouseMove: function (e) {
		this._tooltip.updatePosition(e.latlng);
	},

	_hasAvailableLayers: function () {
		return this._featureGroup.getLayers().length !== 0;
	}
});

L.EditToolbar.EditData = L.Handler.extend({
	statics: {
		TYPE: 'editData' // not delete as delete is reserved in js
	},

	includes: L.Mixin.Events,

	initialize: function (map, options) {
		L.Handler.prototype.initialize.call(this, map);


		// Store the selectable layer group for ease of access
		this._featureGroup = options.featureGroup;

		if (!(this._featureGroup instanceof L.FeatureGroup)) {
			throw new Error('options.featureGroup must be a L.FeatureGroup');
		}

		this._uneditedLayerProps = {};

		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.EditToolbar.EditData.TYPE;
	},

	enable: function () {
		if (this._enabled || !this._hasAvailableLayers()) {
			return;
		}
		this.fire('enabled', { handler: this.type});

		this._map.fire('draw:editDatastart', { handler: this.type });

		L.Handler.prototype.enable.call(this);

		this._featureGroup
			.on('layeradd', this._enableLayerEditData, this)
			.on('layerremove', this._disableLayerEditData, this);
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._featureGroup
			.off('layeradd', this._enableLayerEditData, this)
			.off('layerremove', this._disableLayerEditData, this);

		L.Handler.prototype.disable.call(this);

		this._map.fire('draw:editDatastop', { handler: this.type });

		this.fire('disabled', { handler: this.type});
	},

	addHooks: function () {
		var map = this._map;

		if (map) {
			map.getContainer().focus();

			this._featureGroup.eachLayer(this._enableLayerEditData, this);

			this._tooltip = new L.Tooltip(this._map);
			this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.editData.tooltip.text });

			this._map.on('mousemove', this._onMouseMove, this);
		}
	},

	removeHooks: function () {
		if (this._map) {
			this._featureGroup.eachLayer(this._disableLayerEditData, this);


			// Clear the backups of the original layers
			this._uneditedLayerProps = {};

			this._tooltip.dispose();
			this._tooltip = null;

			this._map.off('mousemove', this._onMouseMove, this);
		}
	},

	revertLayers: function () {
		this._featureGroup.eachLayer(function (layer) {
			this._revertLayer(layer);
		}, this);
	},

	_revertLayer: function (layer) {
		var id = L.Util.stamp(layer);
		layer.edited = false;
		if (this._uneditedLayerProps.hasOwnProperty(id)) {
			// Polyline, Polygon or Rectangle
			if (layer instanceof L.Polyline || layer instanceof L.Polygon || layer instanceof L.Rectangle) {
				layer.setLatLngs(this._uneditedLayerProps[id].latlngs);
			} else if (layer instanceof L.Circle) {
				layer.setLatLng(this._uneditedLayerProps[id].latlng);
				layer.setRadius(this._uneditedLayerProps[id].radius);
			} else if (layer instanceof L.Marker) { // Marker
				layer.setLatLng(this._uneditedLayerProps[id].latlng);
			}
		}
	},

	save: function () {
		var editedLayers = new L.LayerGroup();
		this._featureGroup.eachLayer(function (layer) {
			if (layer.edited) {
				editedLayers.addLayer(layer);
				layer.edited = false;
			}
		});
		this._map.fire('draw:editedData', {layers: editedLayers});

	},

	_enableLayerEditData: function (e) {
		var layer = e.layer || e.target || e;
		if (layer instanceof L.Marker) {
			layer.dragging.disable();
			layer.on('click', this._editDataLayer, this);
		} else {
			layer.editing.disable();
		}

		
	},

	_disableLayerEditData: function (e) {

		var layer = e.layer || e.target || e;

		if (layer instanceof L.Marker) {
			layer.dragging.disable();
			layer.off('click', this._editDataLayer, this);
		} else {
			layer.editing.disable();
		}

	},

	_editDataLayer: function (e) {
		var layer = e.target;
		layer.edited = true;
		this._map.fire('editAttributes', {layer: layer});
	},

	_onMouseMove: function (e) {
		this._tooltip.updatePosition(e.latlng);
	},

	_hasAvailableLayers: function () {
		return this._featureGroup.getLayers().length !== 0;
	}
});


L.EditToolbar.Delete = L.Handler.extend({
	statics: {
		TYPE: 'remove' // not delete as delete is reserved in js
	},

	includes: L.Mixin.Events,

	initialize: function (map, options) {
		L.Handler.prototype.initialize.call(this, map);

		L.Util.setOptions(this, options);

		// Store the selectable layer group for ease of access
		this._deletableLayers = this.options.featureGroup;

		if (!(this._deletableLayers instanceof L.FeatureGroup)) {
			throw new Error('options.featureGroup must be a L.FeatureGroup');
		}

		// Save the type so super can fire, need to do this as cannot do this.TYPE :(
		this.type = L.EditToolbar.Delete.TYPE;
	},

	enable: function () {
		if (this._enabled || !this._hasAvailableLayers()) {
			return;
		}
		this.fire('enabled', { handler: this.type});

		this._map.fire('draw:deletestart', { handler: this.type });

		L.Handler.prototype.enable.call(this);

		this._deletableLayers
			.on('layeradd', this._enableLayerDelete, this)
			.on('layerremove', this._disableLayerDelete, this);
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._deletableLayers
			.off('layeradd', this._enableLayerDelete, this)
			.off('layerremove', this._disableLayerDelete, this);

		L.Handler.prototype.disable.call(this);

		this._map.fire('draw:deletestop', { handler: this.type });

		this.fire('disabled', { handler: this.type});
	},

	addHooks: function () {
		var map = this._map;

		if (map) {
			map.getContainer().focus();

			this._deletableLayers.eachLayer(this._enableLayerDelete, this);
			this._deletedLayers = new L.layerGroup();

			this._tooltip = new L.Tooltip(this._map);
			this._tooltip.updateContent({ text: L.drawLocal.edit.handlers.remove.tooltip.text });

			this._map.on('mousemove', this._onMouseMove, this);
		}
	},

	removeHooks: function () {
		if (this._map) {
			this._deletableLayers.eachLayer(this._disableLayerDelete, this);
			this._deletedLayers = null;

			this._tooltip.dispose();
			this._tooltip = null;

			this._map.off('mousemove', this._onMouseMove, this);
		}
	},

	revertLayers: function () {
		// Iterate of the deleted layers and add them back into the featureGroup
		this._deletedLayers.eachLayer(function (layer) {
			this._deletableLayers.addLayer(layer);
		}, this);
	},

	save: function () {
		this._map.fire('draw:deleted', { layers: this._deletedLayers });
	},

	_enableLayerDelete: function (e) {
		var layer = e.layer || e.target || e;

		layer.on('click', this._removeLayer, this);
	},

	_disableLayerDelete: function (e) {
		var layer = e.layer || e.target || e;

		layer.off('click', this._removeLayer, this);

		// Remove from the deleted layers so we can't accidently revert if the user presses cancel
		this._deletedLayers.removeLayer(layer);
	},

	_removeLayer: function (e) {
		var layer = e.layer || e.target || e;

		this._deletableLayers.removeLayer(layer);

		this._deletedLayers.addLayer(layer);
	},

	_onMouseMove: function (e) {
		this._tooltip.updatePosition(e.latlng);
	},

	_hasAvailableLayers: function () {
		return this._deletableLayers.getLayers().length !== 0;
	}
});


}(window, document));
},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet.markercluster/dist/leaflet.markercluster-src.js":[function(require,module,exports){
/*
 Leaflet.markercluster, Provides Beautiful Animated Marker Clustering functionality for Leaflet, a JS library for interactive maps.
 https://github.com/Leaflet/Leaflet.markercluster
 (c) 2012-2013, Dave Leaver, smartrak
*/
(function (window, document, undefined) {
/*
 * L.MarkerClusterGroup extends L.FeatureGroup by clustering the markers contained within
 */

L.MarkerClusterGroup = L.FeatureGroup.extend({

	options: {
		maxClusterRadius: 80, //A cluster will cover at most this many pixels from its center
		iconCreateFunction: null,

		spiderfyOnMaxZoom: true,
		showCoverageOnHover: true,
		zoomToBoundsOnClick: true,
		singleMarkerMode: false,

		disableClusteringAtZoom: null,

		// Setting this to false prevents the removal of any clusters outside of the viewpoint, which
		// is the default behaviour for performance reasons.
		removeOutsideVisibleBounds: true,

		//Whether to animate adding markers after adding the MarkerClusterGroup to the map
		// If you are adding individual markers set to true, if adding bulk markers leave false for massive performance gains.
		animateAddingMarkers: false,

		//Increase to increase the distance away that spiderfied markers appear from the center
		spiderfyDistanceMultiplier: 1,

		//Options to pass to the L.Polygon constructor
		polygonOptions: {}
	},

	initialize: function (options) {
		L.Util.setOptions(this, options);
		if (!this.options.iconCreateFunction) {
			this.options.iconCreateFunction = this._defaultIconCreateFunction;
		}

		this._featureGroup = L.featureGroup();
		this._featureGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		this._nonPointGroup = L.featureGroup();
		this._nonPointGroup.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		this._inZoomAnimation = 0;
		this._needsClustering = [];
		this._needsRemoving = []; //Markers removed while we aren't on the map need to be kept track of
		//The bounds of the currently shown area (from _getExpandedVisibleBounds) Updated on zoom/move
		this._currentShownBounds = null;

		this._queue = [];
	},

	addLayer: function (layer) {

		if (layer instanceof L.LayerGroup) {
			var array = [];
			for (var i in layer._layers) {
				array.push(layer._layers[i]);
			}
			return this.addLayers(array);
		}

		//Don't cluster non point data
		if (!layer.getLatLng) {
			this._nonPointGroup.addLayer(layer);
			return this;
		}

		if (!this._map) {
			this._needsClustering.push(layer);
			return this;
		}

		if (this.hasLayer(layer)) {
			return this;
		}


		//If we have already clustered we'll need to add this one to a cluster

		if (this._unspiderfy) {
			this._unspiderfy();
		}

		this._addLayer(layer, this._maxZoom);

		//Work out what is visible
		var visibleLayer = layer,
			currentZoom = this._map.getZoom();
		if (layer.__parent) {
			while (visibleLayer.__parent._zoom >= currentZoom) {
				visibleLayer = visibleLayer.__parent;
			}
		}

		if (this._currentShownBounds.contains(visibleLayer.getLatLng())) {
			if (this.options.animateAddingMarkers) {
				this._animationAddLayer(layer, visibleLayer);
			} else {
				this._animationAddLayerNonAnimated(layer, visibleLayer);
			}
		}
		return this;
	},

	removeLayer: function (layer) {

		if (layer instanceof L.LayerGroup)
		{
			var array = [];
			for (var i in layer._layers) {
				array.push(layer._layers[i]);
			}
			return this.removeLayers(array);
		}

		//Non point layers
		if (!layer.getLatLng) {
			this._nonPointGroup.removeLayer(layer);
			return this;
		}

		if (!this._map) {
			if (!this._arraySplice(this._needsClustering, layer) && this.hasLayer(layer)) {
				this._needsRemoving.push(layer);
			}
			return this;
		}

		if (!layer.__parent) {
			return this;
		}

		if (this._unspiderfy) {
			this._unspiderfy();
			this._unspiderfyLayer(layer);
		}

		//Remove the marker from clusters
		this._removeLayer(layer, true);

		if (this._featureGroup.hasLayer(layer)) {
			this._featureGroup.removeLayer(layer);
			if (layer.setOpacity) {
				layer.setOpacity(1);
			}
		}

		return this;
	},

	//Takes an array of markers and adds them in bulk
	addLayers: function (layersArray) {
		var i, l, m,
			onMap = this._map,
			fg = this._featureGroup,
			npg = this._nonPointGroup;

		for (i = 0, l = layersArray.length; i < l; i++) {
			m = layersArray[i];

			//Not point data, can't be clustered
			if (!m.getLatLng) {
				npg.addLayer(m);
				continue;
			}

			if (this.hasLayer(m)) {
				continue;
			}

			if (!onMap) {
				this._needsClustering.push(m);
				continue;
			}

			this._addLayer(m, this._maxZoom);

			//If we just made a cluster of size 2 then we need to remove the other marker from the map (if it is) or we never will
			if (m.__parent) {
				if (m.__parent.getChildCount() === 2) {
					var markers = m.__parent.getAllChildMarkers(),
						otherMarker = markers[0] === m ? markers[1] : markers[0];
					fg.removeLayer(otherMarker);
				}
			}
		}

		if (onMap) {
			//Update the icons of all those visible clusters that were affected
			fg.eachLayer(function (c) {
				if (c instanceof L.MarkerCluster && c._iconNeedsUpdate) {
					c._updateIcon();
				}
			});

			this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
		}

		return this;
	},

	//Takes an array of markers and removes them in bulk
	removeLayers: function (layersArray) {
		var i, l, m,
			fg = this._featureGroup,
			npg = this._nonPointGroup;

		if (!this._map) {
			for (i = 0, l = layersArray.length; i < l; i++) {
				m = layersArray[i];
				this._arraySplice(this._needsClustering, m);
				npg.removeLayer(m);
			}
			return this;
		}

		for (i = 0, l = layersArray.length; i < l; i++) {
			m = layersArray[i];

			if (!m.__parent) {
				npg.removeLayer(m);
				continue;
			}

			this._removeLayer(m, true, true);

			if (fg.hasLayer(m)) {
				fg.removeLayer(m);
				if (m.setOpacity) {
					m.setOpacity(1);
				}
			}
		}

		//Fix up the clusters and markers on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);

		fg.eachLayer(function (c) {
			if (c instanceof L.MarkerCluster) {
				c._updateIcon();
			}
		});

		return this;
	},

	//Removes all layers from the MarkerClusterGroup
	clearLayers: function () {
		//Need our own special implementation as the LayerGroup one doesn't work for us

		//If we aren't on the map (yet), blow away the markers we know of
		if (!this._map) {
			this._needsClustering = [];
			delete this._gridClusters;
			delete this._gridUnclustered;
		}

		if (this._noanimationUnspiderfy) {
			this._noanimationUnspiderfy();
		}

		//Remove all the visible layers
		this._featureGroup.clearLayers();
		this._nonPointGroup.clearLayers();

		this.eachLayer(function (marker) {
			delete marker.__parent;
		});

		if (this._map) {
			//Reset _topClusterLevel and the DistanceGrids
			this._generateInitialClusters();
		}

		return this;
	},

	//Override FeatureGroup.getBounds as it doesn't work
	getBounds: function () {
		var bounds = new L.LatLngBounds();
		if (this._topClusterLevel) {
			bounds.extend(this._topClusterLevel._bounds);
		} else {
			for (var i = this._needsClustering.length - 1; i >= 0; i--) {
				bounds.extend(this._needsClustering[i].getLatLng());
			}
		}

		bounds.extend(this._nonPointGroup.getBounds());

		return bounds;
	},

	//Overrides LayerGroup.eachLayer
	eachLayer: function (method, context) {
		var markers = this._needsClustering.slice(),
		    i;

		if (this._topClusterLevel) {
			this._topClusterLevel.getAllChildMarkers(markers);
		}

		for (i = markers.length - 1; i >= 0; i--) {
			method.call(context, markers[i]);
		}

		this._nonPointGroup.eachLayer(method, context);
	},

	//Overrides LayerGroup.getLayers
	getLayers: function () {
		var layers = [];
		this.eachLayer(function (l) {
			layers.push(l);
		});
		return layers;
	},

	//Overrides LayerGroup.getLayer, WARNING: Really bad performance
	getLayer: function (id) {
		var result = null;

		this.eachLayer(function (l) {
			if (L.stamp(l) === id) {
				result = l;
			}
		});

		return result;
	},

	//Returns true if the given layer is in this MarkerClusterGroup
	hasLayer: function (layer) {
		if (!layer) {
			return false;
		}

		var i, anArray = this._needsClustering;

		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return true;
			}
		}

		anArray = this._needsRemoving;
		for (i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === layer) {
				return false;
			}
		}

		return !!(layer.__parent && layer.__parent._group === this) || this._nonPointGroup.hasLayer(layer);
	},

	//Zoom down to show the given layer (spiderfying if necessary) then calls the callback
	zoomToShowLayer: function (layer, callback) {

		var showMarker = function () {
			if ((layer._icon || layer.__parent._icon) && !this._inZoomAnimation) {
				this._map.off('moveend', showMarker, this);
				this.off('animationend', showMarker, this);

				if (layer._icon) {
					callback();
				} else if (layer.__parent._icon) {
					var afterSpiderfy = function () {
						this.off('spiderfied', afterSpiderfy, this);
						callback();
					};

					this.on('spiderfied', afterSpiderfy, this);
					layer.__parent.spiderfy();
				}
			}
		};

		if (layer._icon && this._map.getBounds().contains(layer.getLatLng())) {
			callback();
		} else if (layer.__parent._zoom < this._map.getZoom()) {
			//Layer should be visible now but isn't on screen, just pan over to it
			this._map.on('moveend', showMarker, this);
			this._map.panTo(layer.getLatLng());
		} else {
			this._map.on('moveend', showMarker, this);
			this.on('animationend', showMarker, this);
			this._map.setView(layer.getLatLng(), layer.__parent._zoom + 1);
			layer.__parent.zoomToBounds();
		}
	},

	//Overrides FeatureGroup.onAdd
	onAdd: function (map) {
		this._map = map;
		var i, l, layer;

		if (!isFinite(this._map.getMaxZoom())) {
			throw "Map has no maxZoom specified";
		}

		this._featureGroup.onAdd(map);
		this._nonPointGroup.onAdd(map);

		if (!this._gridClusters) {
			this._generateInitialClusters();
		}

		for (i = 0, l = this._needsRemoving.length; i < l; i++) {
			layer = this._needsRemoving[i];
			this._removeLayer(layer, true);
		}
		this._needsRemoving = [];

		for (i = 0, l = this._needsClustering.length; i < l; i++) {
			layer = this._needsClustering[i];

			//If the layer doesn't have a getLatLng then we can't cluster it, so add it to our child featureGroup
			if (!layer.getLatLng) {
				this._featureGroup.addLayer(layer);
				continue;
			}


			if (layer.__parent) {
				continue;
			}
			this._addLayer(layer, this._maxZoom);
		}
		this._needsClustering = [];


		this._map.on('zoomend', this._zoomEnd, this);
		this._map.on('moveend', this._moveEnd, this);

		if (this._spiderfierOnAdd) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnAdd();
		}

		this._bindEvents();


		//Actually add our markers to the map:

		//Remember the current zoom level and bounds
		this._zoom = this._map.getZoom();
		this._currentShownBounds = this._getExpandedVisibleBounds();

		//Make things appear on the map
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._zoom, this._currentShownBounds);
	},

	//Overrides FeatureGroup.onRemove
	onRemove: function (map) {
		map.off('zoomend', this._zoomEnd, this);
		map.off('moveend', this._moveEnd, this);

		this._unbindEvents();

		//In case we are in a cluster animation
		this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');

		if (this._spiderfierOnRemove) { //TODO FIXME: Not sure how to have spiderfier add something on here nicely
			this._spiderfierOnRemove();
		}



		//Clean up all the layers we added to the map
		this._hideCoverage();
		this._featureGroup.onRemove(map);
		this._nonPointGroup.onRemove(map);

		this._featureGroup.clearLayers();

		this._map = null;
	},

	getVisibleParent: function (marker) {
		var vMarker = marker;
		while (vMarker && !vMarker._icon) {
			vMarker = vMarker.__parent;
		}
		return vMarker || null;
	},

	//Remove the given object from the given array
	_arraySplice: function (anArray, obj) {
		for (var i = anArray.length - 1; i >= 0; i--) {
			if (anArray[i] === obj) {
				anArray.splice(i, 1);
				return true;
			}
		}
	},

	//Internal function for removing a marker from everything.
	//dontUpdateMap: set to true if you will handle updating the map manually (for bulk functions)
	_removeLayer: function (marker, removeFromDistanceGrid, dontUpdateMap) {
		var gridClusters = this._gridClusters,
			gridUnclustered = this._gridUnclustered,
			fg = this._featureGroup,
			map = this._map;

		//Remove the marker from distance clusters it might be in
		if (removeFromDistanceGrid) {
			for (var z = this._maxZoom; z >= 0; z--) {
				if (!gridUnclustered[z].removeObject(marker, map.project(marker.getLatLng(), z))) {
					break;
				}
			}
		}

		//Work our way up the clusters removing them as we go if required
		var cluster = marker.__parent,
			markers = cluster._markers,
			otherMarker;

		//Remove the marker from the immediate parents marker list
		this._arraySplice(markers, marker);

		while (cluster) {
			cluster._childCount--;

			if (cluster._zoom < 0) {
				//Top level, do nothing
				break;
			} else if (removeFromDistanceGrid && cluster._childCount <= 1) { //Cluster no longer required
				//We need to push the other marker up to the parent
				otherMarker = cluster._markers[0] === marker ? cluster._markers[1] : cluster._markers[0];

				//Update distance grid
				gridClusters[cluster._zoom].removeObject(cluster, map.project(cluster._cLatLng, cluster._zoom));
				gridUnclustered[cluster._zoom].addObject(otherMarker, map.project(otherMarker.getLatLng(), cluster._zoom));

				//Move otherMarker up to parent
				this._arraySplice(cluster.__parent._childClusters, cluster);
				cluster.__parent._markers.push(otherMarker);
				otherMarker.__parent = cluster.__parent;

				if (cluster._icon) {
					//Cluster is currently on the map, need to put the marker on the map instead
					fg.removeLayer(cluster);
					if (!dontUpdateMap) {
						fg.addLayer(otherMarker);
					}
				}
			} else {
				cluster._recalculateBounds();
				if (!dontUpdateMap || !cluster._icon) {
					cluster._updateIcon();
				}
			}

			cluster = cluster.__parent;
		}

		delete marker.__parent;
	},

	_isOrIsParent: function (el, oel) {
		while (oel) {
			if (el === oel) {
				return true;
			}
			oel = oel.parentNode;
		}
		return false;
	},

	_propagateEvent: function (e) {
		if (e.layer instanceof L.MarkerCluster) {
			//Prevent multiple clustermouseover/off events if the icon is made up of stacked divs (Doesn't work in ie <= 8, no relatedTarget)
			if (e.originalEvent && this._isOrIsParent(e.layer._icon, e.originalEvent.relatedTarget)) {
				return;
			}
			e.type = 'cluster' + e.type;
		}

		this.fire(e.type, e);
	},

	//Default functionality
	_defaultIconCreateFunction: function (cluster) {
		var childCount = cluster.getChildCount();

		var c = ' marker-cluster-';
		if (childCount < 10) {
			c += 'small';
		} else if (childCount < 100) {
			c += 'medium';
		} else {
			c += 'large';
		}

		return new L.DivIcon({ html: '<div><span>' + childCount + '</span></div>', className: 'marker-cluster' + c, iconSize: new L.Point(40, 40) });
	},

	_bindEvents: function () {
		var map = this._map,
		    spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
		    showCoverageOnHover = this.options.showCoverageOnHover,
		    zoomToBoundsOnClick = this.options.zoomToBoundsOnClick;

		//Zoom on cluster click or spiderfy if we are at the lowest level
		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.on('clusterclick', this._zoomOrSpiderfy, this);
		}

		//Show convex hull (boundary) polygon on mouse over
		if (showCoverageOnHover) {
			this.on('clustermouseover', this._showCoverage, this);
			this.on('clustermouseout', this._hideCoverage, this);
			map.on('zoomend', this._hideCoverage, this);
		}
	},

	_zoomOrSpiderfy: function (e) {
		var map = this._map;
		if (map.getMaxZoom() === map.getZoom()) {
			if (this.options.spiderfyOnMaxZoom) {
				e.layer.spiderfy();
			}
		} else if (this.options.zoomToBoundsOnClick) {
			e.layer.zoomToBounds();
		}

    // Focus the map again for keyboard users.
		if (e.originalEvent && e.originalEvent.keyCode === 13) {
			map._container.focus();
		}
	},

	_showCoverage: function (e) {
		var map = this._map;
		if (this._inZoomAnimation) {
			return;
		}
		if (this._shownPolygon) {
			map.removeLayer(this._shownPolygon);
		}
		if (e.layer.getChildCount() > 2 && e.layer !== this._spiderfied) {
			this._shownPolygon = new L.Polygon(e.layer.getConvexHull(), this.options.polygonOptions);
			map.addLayer(this._shownPolygon);
		}
	},

	_hideCoverage: function () {
		if (this._shownPolygon) {
			this._map.removeLayer(this._shownPolygon);
			this._shownPolygon = null;
		}
	},

	_unbindEvents: function () {
		var spiderfyOnMaxZoom = this.options.spiderfyOnMaxZoom,
			showCoverageOnHover = this.options.showCoverageOnHover,
			zoomToBoundsOnClick = this.options.zoomToBoundsOnClick,
			map = this._map;

		if (spiderfyOnMaxZoom || zoomToBoundsOnClick) {
			this.off('clusterclick', this._zoomOrSpiderfy, this);
		}
		if (showCoverageOnHover) {
			this.off('clustermouseover', this._showCoverage, this);
			this.off('clustermouseout', this._hideCoverage, this);
			map.off('zoomend', this._hideCoverage, this);
		}
	},

	_zoomEnd: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}
		this._mergeSplitClusters();

		this._zoom = this._map._zoom;
		this._currentShownBounds = this._getExpandedVisibleBounds();
	},

	_moveEnd: function () {
		if (this._inZoomAnimation) {
			return;
		}

		var newBounds = this._getExpandedVisibleBounds();

		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, newBounds);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, this._map._zoom, newBounds);

		this._currentShownBounds = newBounds;
		return;
	},

	_generateInitialClusters: function () {
		var maxZoom = this._map.getMaxZoom(),
			radius = this.options.maxClusterRadius;

		if (this.options.disableClusteringAtZoom) {
			maxZoom = this.options.disableClusteringAtZoom - 1;
		}
		this._maxZoom = maxZoom;
		this._gridClusters = {};
		this._gridUnclustered = {};

		//Set up DistanceGrids for each zoom
		for (var zoom = maxZoom; zoom >= 0; zoom--) {
			this._gridClusters[zoom] = new L.DistanceGrid(radius);
			this._gridUnclustered[zoom] = new L.DistanceGrid(radius);
		}

		this._topClusterLevel = new L.MarkerCluster(this, -1);
	},

	//Zoom: Zoom to start adding at (Pass this._maxZoom to start at the bottom)
	_addLayer: function (layer, zoom) {
		var gridClusters = this._gridClusters,
		    gridUnclustered = this._gridUnclustered,
		    markerPoint, z;

		if (this.options.singleMarkerMode) {
			layer.options.icon = this.options.iconCreateFunction({
				getChildCount: function () {
					return 1;
				},
				getAllChildMarkers: function () {
					return [layer];
				}
			});
		}

		//Find the lowest zoom level to slot this one in
		for (; zoom >= 0; zoom--) {
			markerPoint = this._map.project(layer.getLatLng(), zoom); // calculate pixel position

			//Try find a cluster close by
			var closest = gridClusters[zoom].getNearObject(markerPoint);
			if (closest) {
				closest._addChild(layer);
				layer.__parent = closest;
				return;
			}

			//Try find a marker close by to form a new cluster with
			closest = gridUnclustered[zoom].getNearObject(markerPoint);
			if (closest) {
				var parent = closest.__parent;
				if (parent) {
					this._removeLayer(closest, false);
				}

				//Create new cluster with these 2 in it

				var newCluster = new L.MarkerCluster(this, zoom, closest, layer);
				gridClusters[zoom].addObject(newCluster, this._map.project(newCluster._cLatLng, zoom));
				closest.__parent = newCluster;
				layer.__parent = newCluster;

				//First create any new intermediate parent clusters that don't exist
				var lastParent = newCluster;
				for (z = zoom - 1; z > parent._zoom; z--) {
					lastParent = new L.MarkerCluster(this, z, lastParent);
					gridClusters[z].addObject(lastParent, this._map.project(closest.getLatLng(), z));
				}
				parent._addChild(lastParent);

				//Remove closest from this zoom level and any above that it is in, replace with newCluster
				for (z = zoom; z >= 0; z--) {
					if (!gridUnclustered[z].removeObject(closest, this._map.project(closest.getLatLng(), z))) {
						break;
					}
				}

				return;
			}

			//Didn't manage to cluster in at this zoom, record us as a marker here and continue upwards
			gridUnclustered[zoom].addObject(layer, markerPoint);
		}

		//Didn't get in anything, add us to the top
		this._topClusterLevel._addChild(layer);
		layer.__parent = this._topClusterLevel;
		return;
	},

	//Enqueue code to fire after the marker expand/contract has happened
	_enqueue: function (fn) {
		this._queue.push(fn);
		if (!this._queueTimeout) {
			this._queueTimeout = setTimeout(L.bind(this._processQueue, this), 300);
		}
	},
	_processQueue: function () {
		for (var i = 0; i < this._queue.length; i++) {
			this._queue[i].call(this);
		}
		this._queue.length = 0;
		clearTimeout(this._queueTimeout);
		this._queueTimeout = null;
	},

	//Merge and split any existing clusters that are too big or small
	_mergeSplitClusters: function () {

		//Incase we are starting to split before the animation finished
		this._processQueue();

		if (this._zoom < this._map._zoom && this._currentShownBounds.contains(this._getExpandedVisibleBounds())) { //Zoom in, split
			this._animationStart();
			//Remove clusters now off screen
			this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, this._zoom, this._getExpandedVisibleBounds());

			this._animationZoomIn(this._zoom, this._map._zoom);

		} else if (this._zoom > this._map._zoom) { //Zoom out, merge
			this._animationStart();

			this._animationZoomOut(this._zoom, this._map._zoom);
		} else {
			this._moveEnd();
		}
	},

	//Gets the maps visible bounds expanded in each direction by the size of the screen (so the user cannot see an area we do not cover in one pan)
	_getExpandedVisibleBounds: function () {
		if (!this.options.removeOutsideVisibleBounds) {
			return this.getBounds();
		}

		var map = this._map,
			bounds = map.getBounds(),
			sw = bounds._southWest,
			ne = bounds._northEast,
			latDiff = L.Browser.mobile ? 0 : Math.abs(sw.lat - ne.lat),
			lngDiff = L.Browser.mobile ? 0 : Math.abs(sw.lng - ne.lng);

		return new L.LatLngBounds(
			new L.LatLng(sw.lat - latDiff, sw.lng - lngDiff, true),
			new L.LatLng(ne.lat + latDiff, ne.lng + lngDiff, true));
	},

	//Shared animation code
	_animationAddLayerNonAnimated: function (layer, newCluster) {
		if (newCluster === layer) {
			this._featureGroup.addLayer(layer);
		} else if (newCluster._childCount === 2) {
			newCluster._addToMap();

			var markers = newCluster.getAllChildMarkers();
			this._featureGroup.removeLayer(markers[0]);
			this._featureGroup.removeLayer(markers[1]);
		} else {
			newCluster._updateIcon();
		}
	}
});

L.MarkerClusterGroup.include(!L.DomUtil.TRANSITION ? {

	//Non Animated versions of everything
	_animationStart: function () {
		//Do nothing...
	},
	_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
	},
	_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel);
		this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
	},
	_animationAddLayer: function (layer, newCluster) {
		this._animationAddLayerNonAnimated(layer, newCluster);
	}
} : {

	//Animated versions here
	_animationStart: function () {
		this._map._mapPane.className += ' leaflet-cluster-anim';
		this._inZoomAnimation++;
	},
	_animationEnd: function () {
		if (this._map) {
			this._map._mapPane.className = this._map._mapPane.className.replace(' leaflet-cluster-anim', '');
		}
		this._inZoomAnimation--;
		this.fire('animationend');
	},
	_animationZoomIn: function (previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds(),
		    fg = this._featureGroup,
		    i;

		//Add all children of current clusters to map and remove those clusters from map
		this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
			var startPos = c._latlng,
				markers = c._markers,
				m;

			if (!bounds.contains(startPos)) {
				startPos = null;
			}

			if (c._isSingleParent() && previousZoomLevel + 1 === newZoomLevel) { //Immediately add the new child and remove us
				fg.removeLayer(c);
				c._recursivelyAddChildrenToMap(null, newZoomLevel, bounds);
			} else {
				//Fade out old cluster
				c.setOpacity(0);
				c._recursivelyAddChildrenToMap(startPos, newZoomLevel, bounds);
			}

			//Remove all markers that aren't visible any more
			//TODO: Do we actually need to do this on the higher levels too?
			for (i = markers.length - 1; i >= 0; i--) {
				m = markers[i];
				if (!bounds.contains(m._latlng)) {
					fg.removeLayer(m);
				}
			}

		});

		this._forceLayout();

		//Update opacities
		this._topClusterLevel._recursivelyBecomeVisible(bounds, newZoomLevel);
		//TODO Maybe? Update markers in _recursivelyBecomeVisible
		fg.eachLayer(function (n) {
			if (!(n instanceof L.MarkerCluster) && n._icon) {
				n.setOpacity(1);
			}
		});

		//update the positions of the just added clusters/markers
		this._topClusterLevel._recursively(bounds, previousZoomLevel, newZoomLevel, function (c) {
			c._recursivelyRestoreChildPositions(newZoomLevel);
		});

		//Remove the old clusters and close the zoom animation
		this._enqueue(function () {
			//update the positions of the just added clusters/markers
			this._topClusterLevel._recursively(bounds, previousZoomLevel, 0, function (c) {
				fg.removeLayer(c);
				c.setOpacity(1);
			});

			this._animationEnd();
		});
	},

	_animationZoomOut: function (previousZoomLevel, newZoomLevel) {
		this._animationZoomOutSingle(this._topClusterLevel, previousZoomLevel - 1, newZoomLevel);

		//Need to add markers for those that weren't on the map before but are now
		this._topClusterLevel._recursivelyAddChildrenToMap(null, newZoomLevel, this._getExpandedVisibleBounds());
		//Remove markers that were on the map before but won't be now
		this._topClusterLevel._recursivelyRemoveChildrenFromMap(this._currentShownBounds, previousZoomLevel, this._getExpandedVisibleBounds());
	},
	_animationZoomOutSingle: function (cluster, previousZoomLevel, newZoomLevel) {
		var bounds = this._getExpandedVisibleBounds();

		//Animate all of the markers in the clusters to move to their cluster center point
		cluster._recursivelyAnimateChildrenInAndAddSelfToMap(bounds, previousZoomLevel + 1, newZoomLevel);

		var me = this;

		//Update the opacity (If we immediately set it they won't animate)
		this._forceLayout();
		cluster._recursivelyBecomeVisible(bounds, newZoomLevel);

		//TODO: Maybe use the transition timing stuff to make this more reliable
		//When the animations are done, tidy up
		this._enqueue(function () {

			//This cluster stopped being a cluster before the timeout fired
			if (cluster._childCount === 1) {
				var m = cluster._markers[0];
				//If we were in a cluster animation at the time then the opacity and position of our child could be wrong now, so fix it
				m.setLatLng(m.getLatLng());
				m.setOpacity(1);
			} else {
				cluster._recursively(bounds, newZoomLevel, 0, function (c) {
					c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel + 1);
				});
			}
			me._animationEnd();
		});
	},
	_animationAddLayer: function (layer, newCluster) {
		var me = this,
			fg = this._featureGroup;

		fg.addLayer(layer);
		if (newCluster !== layer) {
			if (newCluster._childCount > 2) { //Was already a cluster

				newCluster._updateIcon();
				this._forceLayout();
				this._animationStart();

				layer._setPos(this._map.latLngToLayerPoint(newCluster.getLatLng()));
				layer.setOpacity(0);

				this._enqueue(function () {
					fg.removeLayer(layer);
					layer.setOpacity(1);

					me._animationEnd();
				});

			} else { //Just became a cluster
				this._forceLayout();

				me._animationStart();
				me._animationZoomOutSingle(newCluster, this._map.getMaxZoom(), this._map.getZoom());
			}
		}
	},

	//Force a browser layout of stuff in the map
	// Should apply the current opacity and location to all elements so we can update them again for an animation
	_forceLayout: function () {
		//In my testing this works, infact offsetWidth of any element seems to work.
		//Could loop all this._layers and do this for each _icon if it stops working

		L.Util.falseFn(document.body.offsetWidth);
	}
});

L.markerClusterGroup = function (options) {
	return new L.MarkerClusterGroup(options);
};


L.MarkerCluster = L.Marker.extend({
	initialize: function (group, zoom, a, b) {

		L.Marker.prototype.initialize.call(this, a ? (a._cLatLng || a.getLatLng()) : new L.LatLng(0, 0), { icon: this });


		this._group = group;
		this._zoom = zoom;

		this._markers = [];
		this._childClusters = [];
		this._childCount = 0;
		this._iconNeedsUpdate = true;

		this._bounds = new L.LatLngBounds();

		if (a) {
			this._addChild(a);
		}
		if (b) {
			this._addChild(b);
		}
	},

	//Recursively retrieve all child markers of this cluster
	getAllChildMarkers: function (storageArray) {
		storageArray = storageArray || [];

		for (var i = this._childClusters.length - 1; i >= 0; i--) {
			this._childClusters[i].getAllChildMarkers(storageArray);
		}

		for (var j = this._markers.length - 1; j >= 0; j--) {
			storageArray.push(this._markers[j]);
		}

		return storageArray;
	},

	//Returns the count of how many child markers we have
	getChildCount: function () {
		return this._childCount;
	},

	//Zoom to the minimum of showing all of the child markers, or the extents of this cluster
	zoomToBounds: function () {
		var childClusters = this._childClusters.slice(),
			map = this._group._map,
			boundsZoom = map.getBoundsZoom(this._bounds),
			zoom = this._zoom + 1,
			mapZoom = map.getZoom(),
			i;

		//calculate how fare we need to zoom down to see all of the markers
		while (childClusters.length > 0 && boundsZoom > zoom) {
			zoom++;
			var newClusters = [];
			for (i = 0; i < childClusters.length; i++) {
				newClusters = newClusters.concat(childClusters[i]._childClusters);
			}
			childClusters = newClusters;
		}

		if (boundsZoom > zoom) {
			this._group._map.setView(this._latlng, zoom);
		} else if (boundsZoom <= mapZoom) { //If fitBounds wouldn't zoom us down, zoom us down instead
			this._group._map.setView(this._latlng, mapZoom + 1);
		} else {
			this._group._map.fitBounds(this._bounds);
		}
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();
		bounds.extend(this._bounds);
		return bounds;
	},

	_updateIcon: function () {
		this._iconNeedsUpdate = true;
		if (this._icon) {
			this.setIcon(this);
		}
	},

	//Cludge for Icon, we pretend to be an icon for performance
	createIcon: function () {
		if (this._iconNeedsUpdate) {
			this._iconObj = this._group.options.iconCreateFunction(this);
			this._iconNeedsUpdate = false;
		}
		return this._iconObj.createIcon();
	},
	createShadow: function () {
		return this._iconObj.createShadow();
	},


	_addChild: function (new1, isNotificationFromChild) {

		this._iconNeedsUpdate = true;
		this._expandBounds(new1);

		if (new1 instanceof L.MarkerCluster) {
			if (!isNotificationFromChild) {
				this._childClusters.push(new1);
				new1.__parent = this;
			}
			this._childCount += new1._childCount;
		} else {
			if (!isNotificationFromChild) {
				this._markers.push(new1);
			}
			this._childCount++;
		}

		if (this.__parent) {
			this.__parent._addChild(new1, true);
		}
	},

	//Expand our bounds and tell our parent to
	_expandBounds: function (marker) {
		var addedCount,
		    addedLatLng = marker._wLatLng || marker._latlng;

		if (marker instanceof L.MarkerCluster) {
			this._bounds.extend(marker._bounds);
			addedCount = marker._childCount;
		} else {
			this._bounds.extend(addedLatLng);
			addedCount = 1;
		}

		if (!this._cLatLng) {
			// when clustering, take position of the first point as the cluster center
			this._cLatLng = marker._cLatLng || addedLatLng;
		}

		// when showing clusters, take weighted average of all points as cluster center
		var totalCount = this._childCount + addedCount;

		//Calculate weighted latlng for display
		if (!this._wLatLng) {
			this._latlng = this._wLatLng = new L.LatLng(addedLatLng.lat, addedLatLng.lng);
		} else {
			this._wLatLng.lat = (addedLatLng.lat * addedCount + this._wLatLng.lat * this._childCount) / totalCount;
			this._wLatLng.lng = (addedLatLng.lng * addedCount + this._wLatLng.lng * this._childCount) / totalCount;
		}
	},

	//Set our markers position as given and add it to the map
	_addToMap: function (startPos) {
		if (startPos) {
			this._backupLatlng = this._latlng;
			this.setLatLng(startPos);
		}
		this._group._featureGroup.addLayer(this);
	},

	_recursivelyAnimateChildrenIn: function (bounds, center, maxZoom) {
		this._recursively(bounds, 0, maxZoom - 1,
			function (c) {
				var markers = c._markers,
					i, m;
				for (i = markers.length - 1; i >= 0; i--) {
					m = markers[i];

					//Only do it if the icon is still on the map
					if (m._icon) {
						m._setPos(center);
						m.setOpacity(0);
					}
				}
			},
			function (c) {
				var childClusters = c._childClusters,
					j, cm;
				for (j = childClusters.length - 1; j >= 0; j--) {
					cm = childClusters[j];
					if (cm._icon) {
						cm._setPos(center);
						cm.setOpacity(0);
					}
				}
			}
		);
	},

	_recursivelyAnimateChildrenInAndAddSelfToMap: function (bounds, previousZoomLevel, newZoomLevel) {
		this._recursively(bounds, newZoomLevel, 0,
			function (c) {
				c._recursivelyAnimateChildrenIn(bounds, c._group._map.latLngToLayerPoint(c.getLatLng()).round(), previousZoomLevel);

				//TODO: depthToAnimateIn affects _isSingleParent, if there is a multizoom we may/may not be.
				//As a hack we only do a animation free zoom on a single level zoom, if someone does multiple levels then we always animate
				if (c._isSingleParent() && previousZoomLevel - 1 === newZoomLevel) {
					c.setOpacity(1);
					c._recursivelyRemoveChildrenFromMap(bounds, previousZoomLevel); //Immediately remove our children as we are replacing them. TODO previousBounds not bounds
				} else {
					c.setOpacity(0);
				}

				c._addToMap();
			}
		);
	},

	_recursivelyBecomeVisible: function (bounds, zoomLevel) {
		this._recursively(bounds, 0, zoomLevel, null, function (c) {
			c.setOpacity(1);
		});
	},

	_recursivelyAddChildrenToMap: function (startPos, zoomLevel, bounds) {
		this._recursively(bounds, -1, zoomLevel,
			function (c) {
				if (zoomLevel === c._zoom) {
					return;
				}

				//Add our child markers at startPos (so they can be animated out)
				for (var i = c._markers.length - 1; i >= 0; i--) {
					var nm = c._markers[i];

					if (!bounds.contains(nm._latlng)) {
						continue;
					}

					if (startPos) {
						nm._backupLatlng = nm.getLatLng();

						nm.setLatLng(startPos);
						if (nm.setOpacity) {
							nm.setOpacity(0);
						}
					}

					c._group._featureGroup.addLayer(nm);
				}
			},
			function (c) {
				c._addToMap(startPos);
			}
		);
	},

	_recursivelyRestoreChildPositions: function (zoomLevel) {
		//Fix positions of child markers
		for (var i = this._markers.length - 1; i >= 0; i--) {
			var nm = this._markers[i];
			if (nm._backupLatlng) {
				nm.setLatLng(nm._backupLatlng);
				delete nm._backupLatlng;
			}
		}

		if (zoomLevel - 1 === this._zoom) {
			//Reposition child clusters
			for (var j = this._childClusters.length - 1; j >= 0; j--) {
				this._childClusters[j]._restorePosition();
			}
		} else {
			for (var k = this._childClusters.length - 1; k >= 0; k--) {
				this._childClusters[k]._recursivelyRestoreChildPositions(zoomLevel);
			}
		}
	},

	_restorePosition: function () {
		if (this._backupLatlng) {
			this.setLatLng(this._backupLatlng);
			delete this._backupLatlng;
		}
	},

	//exceptBounds: If set, don't remove any markers/clusters in it
	_recursivelyRemoveChildrenFromMap: function (previousBounds, zoomLevel, exceptBounds) {
		var m, i;
		this._recursively(previousBounds, -1, zoomLevel - 1,
			function (c) {
				//Remove markers at every level
				for (i = c._markers.length - 1; i >= 0; i--) {
					m = c._markers[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.setOpacity) {
							m.setOpacity(1);
						}
					}
				}
			},
			function (c) {
				//Remove child clusters at just the bottom level
				for (i = c._childClusters.length - 1; i >= 0; i--) {
					m = c._childClusters[i];
					if (!exceptBounds || !exceptBounds.contains(m._latlng)) {
						c._group._featureGroup.removeLayer(m);
						if (m.setOpacity) {
							m.setOpacity(1);
						}
					}
				}
			}
		);
	},

	//Run the given functions recursively to this and child clusters
	// boundsToApplyTo: a L.LatLngBounds representing the bounds of what clusters to recurse in to
	// zoomLevelToStart: zoom level to start running functions (inclusive)
	// zoomLevelToStop: zoom level to stop running functions (inclusive)
	// runAtEveryLevel: function that takes an L.MarkerCluster as an argument that should be applied on every level
	// runAtBottomLevel: function that takes an L.MarkerCluster as an argument that should be applied at only the bottom level
	_recursively: function (boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel) {
		var childClusters = this._childClusters,
		    zoom = this._zoom,
			i, c;

		if (zoomLevelToStart > zoom) { //Still going down to required depth, just recurse to child clusters
			for (i = childClusters.length - 1; i >= 0; i--) {
				c = childClusters[i];
				if (boundsToApplyTo.intersects(c._bounds)) {
					c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
				}
			}
		} else { //In required depth

			if (runAtEveryLevel) {
				runAtEveryLevel(this);
			}
			if (runAtBottomLevel && this._zoom === zoomLevelToStop) {
				runAtBottomLevel(this);
			}

			//TODO: This loop is almost the same as above
			if (zoomLevelToStop > zoom) {
				for (i = childClusters.length - 1; i >= 0; i--) {
					c = childClusters[i];
					if (boundsToApplyTo.intersects(c._bounds)) {
						c._recursively(boundsToApplyTo, zoomLevelToStart, zoomLevelToStop, runAtEveryLevel, runAtBottomLevel);
					}
				}
			}
		}
	},

	_recalculateBounds: function () {
		var markers = this._markers,
			childClusters = this._childClusters,
			i;

		this._bounds = new L.LatLngBounds();
		delete this._wLatLng;

		for (i = markers.length - 1; i >= 0; i--) {
			this._expandBounds(markers[i]);
		}
		for (i = childClusters.length - 1; i >= 0; i--) {
			this._expandBounds(childClusters[i]);
		}
	},


	//Returns true if we are the parent of only one cluster and that cluster is the same as us
	_isSingleParent: function () {
		//Don't need to check this._markers as the rest won't work if there are any
		return this._childClusters.length > 0 && this._childClusters[0]._childCount === this._childCount;
	}
});



L.DistanceGrid = function (cellSize) {
	this._cellSize = cellSize;
	this._sqCellSize = cellSize * cellSize;
	this._grid = {};
	this._objectPoint = { };
};

L.DistanceGrid.prototype = {

	addObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    stamp = L.Util.stamp(obj);

		this._objectPoint[stamp] = point;

		cell.push(obj);
	},

	updateObject: function (obj, point) {
		this.removeObject(obj);
		this.addObject(obj, point);
	},

	//Returns true if the object was found
	removeObject: function (obj, point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    grid = this._grid,
		    row = grid[y] = grid[y] || {},
		    cell = row[x] = row[x] || [],
		    i, len;

		delete this._objectPoint[L.Util.stamp(obj)];

		for (i = 0, len = cell.length; i < len; i++) {
			if (cell[i] === obj) {

				cell.splice(i, 1);

				if (len === 1) {
					delete row[x];
				}

				return true;
			}
		}

	},

	eachObject: function (fn, context) {
		var i, j, k, len, row, cell, removed,
		    grid = this._grid;

		for (i in grid) {
			row = grid[i];

			for (j in row) {
				cell = row[j];

				for (k = 0, len = cell.length; k < len; k++) {
					removed = fn.call(context, cell[k]);
					if (removed) {
						k--;
						len--;
					}
				}
			}
		}
	},

	getNearObject: function (point) {
		var x = this._getCoord(point.x),
		    y = this._getCoord(point.y),
		    i, j, k, row, cell, len, obj, dist,
		    objectPoint = this._objectPoint,
		    closestDistSq = this._sqCellSize,
		    closest = null;

		for (i = y - 1; i <= y + 1; i++) {
			row = this._grid[i];
			if (row) {

				for (j = x - 1; j <= x + 1; j++) {
					cell = row[j];
					if (cell) {

						for (k = 0, len = cell.length; k < len; k++) {
							obj = cell[k];
							dist = this._sqDist(objectPoint[L.Util.stamp(obj)], point);
							if (dist < closestDistSq) {
								closestDistSq = dist;
								closest = obj;
							}
						}
					}
				}
			}
		}
		return closest;
	},

	_getCoord: function (x) {
		return Math.floor(x / this._cellSize);
	},

	_sqDist: function (p, p2) {
		var dx = p2.x - p.x,
		    dy = p2.y - p.y;
		return dx * dx + dy * dy;
	}
};


/* Copyright (c) 2012 the authors listed at the following URL, and/or
the authors of referenced articles or incorporated external code:
http://en.literateprograms.org/Quickhull_(Javascript)?action=history&offset=20120410175256

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

Retrieved from: http://en.literateprograms.org/Quickhull_(Javascript)?oldid=18434
*/

(function () {
	L.QuickHull = {

		/*
		 * @param {Object} cpt a point to be measured from the baseline
		 * @param {Array} bl the baseline, as represented by a two-element
		 *   array of latlng objects.
		 * @returns {Number} an approximate distance measure
		 */
		getDistant: function (cpt, bl) {
			var vY = bl[1].lat - bl[0].lat,
				vX = bl[0].lng - bl[1].lng;
			return (vX * (cpt.lat - bl[0].lat) + vY * (cpt.lng - bl[0].lng));
		},

		/*
		 * @param {Array} baseLine a two-element array of latlng objects
		 *   representing the baseline to project from
		 * @param {Array} latLngs an array of latlng objects
		 * @returns {Object} the maximum point and all new points to stay
		 *   in consideration for the hull.
		 */
		findMostDistantPointFromBaseLine: function (baseLine, latLngs) {
			var maxD = 0,
				maxPt = null,
				newPoints = [],
				i, pt, d;

			for (i = latLngs.length - 1; i >= 0; i--) {
				pt = latLngs[i];
				d = this.getDistant(pt, baseLine);

				if (d > 0) {
					newPoints.push(pt);
				} else {
					continue;
				}

				if (d > maxD) {
					maxD = d;
					maxPt = pt;
				}
			}

			return { maxPoint: maxPt, newPoints: newPoints };
		},


		/*
		 * Given a baseline, compute the convex hull of latLngs as an array
		 * of latLngs.
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		buildConvexHull: function (baseLine, latLngs) {
			var convexHullBaseLines = [],
				t = this.findMostDistantPointFromBaseLine(baseLine, latLngs);

			if (t.maxPoint) { // if there is still a point "outside" the base line
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([baseLine[0], t.maxPoint], t.newPoints)
					);
				convexHullBaseLines =
					convexHullBaseLines.concat(
						this.buildConvexHull([t.maxPoint, baseLine[1]], t.newPoints)
					);
				return convexHullBaseLines;
			} else {  // if there is no more point "outside" the base line, the current base line is part of the convex hull
				return [baseLine[0]];
			}
		},

		/*
		 * Given an array of latlngs, compute a convex hull as an array
		 * of latlngs
		 *
		 * @param {Array} latLngs
		 * @returns {Array}
		 */
		getConvexHull: function (latLngs) {
			// find first baseline
			var maxLat = false, minLat = false,
				maxPt = null, minPt = null,
				i;

			for (i = latLngs.length - 1; i >= 0; i--) {
				var pt = latLngs[i];
				if (maxLat === false || pt.lat > maxLat) {
					maxPt = pt;
					maxLat = pt.lat;
				}
				if (minLat === false || pt.lat < minLat) {
					minPt = pt;
					minLat = pt.lat;
				}
			}
			var ch = [].concat(this.buildConvexHull([minPt, maxPt], latLngs),
								this.buildConvexHull([maxPt, minPt], latLngs));
			return ch;
		}
	};
}());

L.MarkerCluster.include({
	getConvexHull: function () {
		var childMarkers = this.getAllChildMarkers(),
			points = [],
			p, i;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			p = childMarkers[i].getLatLng();
			points.push(p);
		}

		return L.QuickHull.getConvexHull(points);
	}
});


//This code is 100% based on https://github.com/jawj/OverlappingMarkerSpiderfier-Leaflet
//Huge thanks to jawj for implementing it first to make my job easy :-)

L.MarkerCluster.include({

	_2PI: Math.PI * 2,
	_circleFootSeparation: 25, //related to circumference of circle
	_circleStartAngle: Math.PI / 6,

	_spiralFootSeparation:  28, //related to size of spiral (experiment!)
	_spiralLengthStart: 11,
	_spiralLengthFactor: 5,

	_circleSpiralSwitchover: 9, //show spiral instead of circle from this marker count upwards.
								// 0 -> always spiral; Infinity -> always circle

	spiderfy: function () {
		if (this._group._spiderfied === this || this._group._inZoomAnimation) {
			return;
		}

		var childMarkers = this.getAllChildMarkers(),
			group = this._group,
			map = group._map,
			center = map.latLngToLayerPoint(this._latlng),
			positions;

		this._group._unspiderfy();
		this._group._spiderfied = this;

		//TODO Maybe: childMarkers order by distance to center

		if (childMarkers.length >= this._circleSpiralSwitchover) {
			positions = this._generatePointsSpiral(childMarkers.length, center);
		} else {
			center.y += 10; //Otherwise circles look wrong
			positions = this._generatePointsCircle(childMarkers.length, center);
		}

		this._animationSpiderfy(childMarkers, positions);
	},

	unspiderfy: function (zoomDetails) {
		/// <param Name="zoomDetails">Argument from zoomanim if being called in a zoom animation or null otherwise</param>
		if (this._group._inZoomAnimation) {
			return;
		}
		this._animationUnspiderfy(zoomDetails);

		this._group._spiderfied = null;
	},

	_generatePointsCircle: function (count, centerPt) {
		var circumference = this._group.options.spiderfyDistanceMultiplier * this._circleFootSeparation * (2 + count),
			legLength = circumference / this._2PI,  //radius from circumference
			angleStep = this._2PI / count,
			res = [],
			i, angle;

		res.length = count;

		for (i = count - 1; i >= 0; i--) {
			angle = this._circleStartAngle + i * angleStep;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
		}

		return res;
	},

	_generatePointsSpiral: function (count, centerPt) {
		var legLength = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthStart,
			separation = this._group.options.spiderfyDistanceMultiplier * this._spiralFootSeparation,
			lengthFactor = this._group.options.spiderfyDistanceMultiplier * this._spiralLengthFactor,
			angle = 0,
			res = [],
			i;

		res.length = count;

		for (i = count - 1; i >= 0; i--) {
			angle += separation / legLength + i * 0.0005;
			res[i] = new L.Point(centerPt.x + legLength * Math.cos(angle), centerPt.y + legLength * Math.sin(angle))._round();
			legLength += this._2PI * lengthFactor / angle;
		}
		return res;
	},

	_noanimationUnspiderfy: function () {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			childMarkers = this.getAllChildMarkers(),
			m, i;

		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			fg.removeLayer(m);

			if (m._preSpiderfyLatlng) {
				m.setLatLng(m._preSpiderfyLatlng);
				delete m._preSpiderfyLatlng;
			}
			if (m.setZIndexOffset) {
				m.setZIndexOffset(0);
			}

			if (m._spiderLeg) {
				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
		}

		group._spiderfied = null;
	}
});

L.MarkerCluster.include(!L.DomUtil.TRANSITION ? {
	//Non Animated versions of everything
	_animationSpiderfy: function (childMarkers, positions) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			i, m, leg, newPos;

		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			if (m.setZIndexOffset) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
			}

			fg.addLayer(m);


			leg = new L.Polyline([this._latlng, newPos], { weight: 1.5, color: '#222' });
			map.addLayer(leg);
			m._spiderLeg = leg;
		}
		this.setOpacity(0.3);
		group.fire('spiderfied');
	},

	_animationUnspiderfy: function () {
		this._noanimationUnspiderfy();
	}
} : {
	//Animated versions here
	SVG_ANIMATION: (function () {
		return document.createElementNS('http://www.w3.org/2000/svg', 'animate').toString().indexOf('SVGAnimate') > -1;
	}()),

	_animationSpiderfy: function (childMarkers, positions) {
		var me = this,
			group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerPos = map.latLngToLayerPoint(this._latlng),
			i, m, leg, newPos;

		//Add markers to map hidden at our center point
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//If it is a marker, add it now and we'll animate it out
			if (m.setOpacity) {
				m.setZIndexOffset(1000000); //Make these appear on top of EVERYTHING
				m.setOpacity(0);
			
				fg.addLayer(m);

				m._setPos(thisLayerPos);
			} else {
				//Vectors just get immediately added
				fg.addLayer(m);
			}
		}

		group._forceLayout();
		group._animationStart();

		var initialLegOpacity = L.Path.SVG ? 0 : 0.3,
			xmlns = L.Path.SVG_NS;


		for (i = childMarkers.length - 1; i >= 0; i--) {
			newPos = map.layerPointToLatLng(positions[i]);
			m = childMarkers[i];

			//Move marker to new position
			m._preSpiderfyLatlng = m._latlng;
			m.setLatLng(newPos);
			
			if (m.setOpacity) {
				m.setOpacity(1);
			}


			//Add Legs.
			leg = new L.Polyline([me._latlng, newPos], { weight: 1.5, color: '#222', opacity: initialLegOpacity });
			map.addLayer(leg);
			m._spiderLeg = leg;

			//Following animations don't work for canvas
			if (!L.Path.SVG || !this.SVG_ANIMATION) {
				continue;
			}

			//How this works:
			//http://stackoverflow.com/questions/5924238/how-do-you-animate-an-svg-path-in-ios
			//http://dev.opera.com/articles/view/advanced-svg-animation-techniques/

			//Animate length
			var length = leg._path.getTotalLength();
			leg._path.setAttribute("stroke-dasharray", length + "," + length);

			var anim = document.createElementNS(xmlns, "animate");
			anim.setAttribute("attributeName", "stroke-dashoffset");
			anim.setAttribute("begin", "indefinite");
			anim.setAttribute("from", length);
			anim.setAttribute("to", 0);
			anim.setAttribute("dur", 0.25);
			leg._path.appendChild(anim);
			anim.beginElement();

			//Animate opacity
			anim = document.createElementNS(xmlns, "animate");
			anim.setAttribute("attributeName", "stroke-opacity");
			anim.setAttribute("attributeName", "stroke-opacity");
			anim.setAttribute("begin", "indefinite");
			anim.setAttribute("from", 0);
			anim.setAttribute("to", 0.5);
			anim.setAttribute("dur", 0.25);
			leg._path.appendChild(anim);
			anim.beginElement();
		}
		me.setOpacity(0.3);

		//Set the opacity of the spiderLegs back to their correct value
		// The animations above override this until they complete.
		// If the initial opacity of the spiderlegs isn't 0 then they appear before the animation starts.
		if (L.Path.SVG) {
			this._group._forceLayout();

			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i]._spiderLeg;

				m.options.opacity = 0.5;
				m._path.setAttribute('stroke-opacity', 0.5);
			}
		}

		setTimeout(function () {
			group._animationEnd();
			group.fire('spiderfied');
		}, 200);
	},

	_animationUnspiderfy: function (zoomDetails) {
		var group = this._group,
			map = group._map,
			fg = group._featureGroup,
			thisLayerPos = zoomDetails ? map._latLngToNewLayerPoint(this._latlng, zoomDetails.zoom, zoomDetails.center) : map.latLngToLayerPoint(this._latlng),
			childMarkers = this.getAllChildMarkers(),
			svg = L.Path.SVG && this.SVG_ANIMATION,
			m, i, a;

		group._animationStart();

		//Make us visible and bring the child markers back in
		this.setOpacity(1);
		for (i = childMarkers.length - 1; i >= 0; i--) {
			m = childMarkers[i];

			//Marker was added to us after we were spidified
			if (!m._preSpiderfyLatlng) {
				continue;
			}

			//Fix up the location to the real one
			m.setLatLng(m._preSpiderfyLatlng);
			delete m._preSpiderfyLatlng;
			//Hack override the location to be our center
			if (m.setOpacity) {
				m._setPos(thisLayerPos);
				m.setOpacity(0);
			} else {
				fg.removeLayer(m);
			}

			//Animate the spider legs back in
			if (svg) {
				a = m._spiderLeg._path.childNodes[0];
				a.setAttribute('to', a.getAttribute('from'));
				a.setAttribute('from', 0);
				a.beginElement();

				a = m._spiderLeg._path.childNodes[1];
				a.setAttribute('from', 0.5);
				a.setAttribute('to', 0);
				a.setAttribute('stroke-opacity', 0);
				a.beginElement();

				m._spiderLeg._path.setAttribute('stroke-opacity', 0);
			}
		}

		setTimeout(function () {
			//If we have only <= one child left then that marker will be shown on the map so don't remove it!
			var stillThereChildCount = 0;
			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];
				if (m._spiderLeg) {
					stillThereChildCount++;
				}
			}


			for (i = childMarkers.length - 1; i >= 0; i--) {
				m = childMarkers[i];

				if (!m._spiderLeg) { //Has already been unspiderfied
					continue;
				}


				if (m.setOpacity) {
					m.setOpacity(1);
					m.setZIndexOffset(0);
				}

				if (stillThereChildCount > 1) {
					fg.removeLayer(m);
				}

				map.removeLayer(m._spiderLeg);
				delete m._spiderLeg;
			}
			group._animationEnd();
		}, 200);
	}
});


L.MarkerClusterGroup.include({
	//The MarkerCluster currently spiderfied (if any)
	_spiderfied: null,

	_spiderfierOnAdd: function () {
		this._map.on('click', this._unspiderfyWrapper, this);

		if (this._map.options.zoomAnimation) {
			this._map.on('zoomstart', this._unspiderfyZoomStart, this);
		}
		//Browsers without zoomAnimation or a big zoom don't fire zoomstart
		this._map.on('zoomend', this._noanimationUnspiderfy, this);

		if (L.Path.SVG && !L.Browser.touch) {
			this._map._initPathRoot();
			//Needs to happen in the pageload, not after, or animations don't work in webkit
			//  http://stackoverflow.com/questions/8455200/svg-animate-with-dynamically-added-elements
			//Disable on touch browsers as the animation messes up on a touch zoom and isn't very noticable
		}
	},

	_spiderfierOnRemove: function () {
		this._map.off('click', this._unspiderfyWrapper, this);
		this._map.off('zoomstart', this._unspiderfyZoomStart, this);
		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);

		this._unspiderfy(); //Ensure that markers are back where they should be
	},


	//On zoom start we add a zoomanim handler so that we are guaranteed to be last (after markers are animated)
	//This means we can define the animation they do rather than Markers doing an animation to their actual location
	_unspiderfyZoomStart: function () {
		if (!this._map) { //May have been removed from the map by a zoomEnd handler
			return;
		}

		this._map.on('zoomanim', this._unspiderfyZoomAnim, this);
	},
	_unspiderfyZoomAnim: function (zoomDetails) {
		//Wait until the first zoomanim after the user has finished touch-zooming before running the animation
		if (L.DomUtil.hasClass(this._map._mapPane, 'leaflet-touching')) {
			return;
		}

		this._map.off('zoomanim', this._unspiderfyZoomAnim, this);
		this._unspiderfy(zoomDetails);
	},


	_unspiderfyWrapper: function () {
		/// <summary>_unspiderfy but passes no arguments</summary>
		this._unspiderfy();
	},

	_unspiderfy: function (zoomDetails) {
		if (this._spiderfied) {
			this._spiderfied.unspiderfy(zoomDetails);
		}
	},

	_noanimationUnspiderfy: function () {
		if (this._spiderfied) {
			this._spiderfied._noanimationUnspiderfy();
		}
	},

	//If the given layer is currently being spiderfied then we unspiderfy it so it isn't on the map anymore etc
	_unspiderfyLayer: function (layer) {
		if (layer._spiderLeg) {
			this._featureGroup.removeLayer(layer);

			layer.setOpacity(1);
			//Position will be fixed up immediately in _animationUnspiderfy
			layer.setZIndexOffset(0);

			this._map.removeLayer(layer._spiderLeg);
			delete layer._spiderLeg;
		}
	}
});


}(window, document));
},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet/leaflet-src.js":[function(require,module,exports){
/*
 Leaflet, a JavaScript library for mobile-friendly interactive maps. http://leafletjs.com
 (c) 2010-2013, Vladimir Agafonkin
 (c) 2010-2011, CloudMade
*/
(function (window, document, undefined) {
var oldL = window.L,
    L = {};

L.version = '0.7.2';

// define Leaflet for Node module pattern loaders, including Browserify
if (typeof module === 'object' && typeof module.exports === 'object') {
	module.exports = L;

// define Leaflet as an AMD module
} else if (typeof define === 'function' && define.amd) {
	define(L);
}

// define Leaflet as a global L variable, saving the original L to restore later if needed

L.noConflict = function () {
	window.L = oldL;
	return this;
};

window.L = L;


/*
 * L.Util contains various utility functions used throughout Leaflet code.
 */

L.Util = {
	extend: function (dest) { // (Object[, Object, ...]) ->
		var sources = Array.prototype.slice.call(arguments, 1),
		    i, j, len, src;

		for (j = 0, len = sources.length; j < len; j++) {
			src = sources[j] || {};
			for (i in src) {
				if (src.hasOwnProperty(i)) {
					dest[i] = src[i];
				}
			}
		}
		return dest;
	},

	bind: function (fn, obj) { // (Function, Object) -> Function
		var args = arguments.length > 2 ? Array.prototype.slice.call(arguments, 2) : null;
		return function () {
			return fn.apply(obj, args || arguments);
		};
	},

	stamp: (function () {
		var lastId = 0,
		    key = '_leaflet_id';
		return function (obj) {
			obj[key] = obj[key] || ++lastId;
			return obj[key];
		};
	}()),

	invokeEach: function (obj, method, context) {
		var i, args;

		if (typeof obj === 'object') {
			args = Array.prototype.slice.call(arguments, 3);

			for (i in obj) {
				method.apply(context, [i, obj[i]].concat(args));
			}
			return true;
		}

		return false;
	},

	limitExecByInterval: function (fn, time, context) {
		var lock, execOnUnlock;

		return function wrapperFn() {
			var args = arguments;

			if (lock) {
				execOnUnlock = true;
				return;
			}

			lock = true;

			setTimeout(function () {
				lock = false;

				if (execOnUnlock) {
					wrapperFn.apply(context, args);
					execOnUnlock = false;
				}
			}, time);

			fn.apply(context, args);
		};
	},

	falseFn: function () {
		return false;
	},

	formatNum: function (num, digits) {
		var pow = Math.pow(10, digits || 5);
		return Math.round(num * pow) / pow;
	},

	trim: function (str) {
		return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
	},

	splitWords: function (str) {
		return L.Util.trim(str).split(/\s+/);
	},

	setOptions: function (obj, options) {
		obj.options = L.extend({}, obj.options, options);
		return obj.options;
	},

	getParamString: function (obj, existingUrl, uppercase) {
		var params = [];
		for (var i in obj) {
			params.push(encodeURIComponent(uppercase ? i.toUpperCase() : i) + '=' + encodeURIComponent(obj[i]));
		}
		return ((!existingUrl || existingUrl.indexOf('?') === -1) ? '?' : '&') + params.join('&');
	},
	template: function (str, data) {
		return str.replace(/\{ *([\w_]+) *\}/g, function (str, key) {
			var value = data[key];
			if (value === undefined) {
				throw new Error('No value provided for variable ' + str);
			} else if (typeof value === 'function') {
				value = value(data);
			}
			return value;
		});
	},

	isArray: Array.isArray || function (obj) {
		return (Object.prototype.toString.call(obj) === '[object Array]');
	},

	emptyImageUrl: 'data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs='
};

(function () {

	// inspired by http://paulirish.com/2011/requestanimationframe-for-smart-animating/

	function getPrefixed(name) {
		var i, fn,
		    prefixes = ['webkit', 'moz', 'o', 'ms'];

		for (i = 0; i < prefixes.length && !fn; i++) {
			fn = window[prefixes[i] + name];
		}

		return fn;
	}

	var lastTime = 0;

	function timeoutDefer(fn) {
		var time = +new Date(),
		    timeToCall = Math.max(0, 16 - (time - lastTime));

		lastTime = time + timeToCall;
		return window.setTimeout(fn, timeToCall);
	}

	var requestFn = window.requestAnimationFrame ||
	        getPrefixed('RequestAnimationFrame') || timeoutDefer;

	var cancelFn = window.cancelAnimationFrame ||
	        getPrefixed('CancelAnimationFrame') ||
	        getPrefixed('CancelRequestAnimationFrame') ||
	        function (id) { window.clearTimeout(id); };


	L.Util.requestAnimFrame = function (fn, context, immediate, element) {
		fn = L.bind(fn, context);

		if (immediate && requestFn === timeoutDefer) {
			fn();
		} else {
			return requestFn.call(window, fn, element);
		}
	};

	L.Util.cancelAnimFrame = function (id) {
		if (id) {
			cancelFn.call(window, id);
		}
	};

}());

// shortcuts for most used utility functions
L.extend = L.Util.extend;
L.bind = L.Util.bind;
L.stamp = L.Util.stamp;
L.setOptions = L.Util.setOptions;


/*
 * L.Class powers the OOP facilities of the library.
 * Thanks to John Resig and Dean Edwards for inspiration!
 */

L.Class = function () {};

L.Class.extend = function(props, classIncludes) {

    // extended class with the new prototype
    var NewClass = function() {

        // call the constructor
        if (this.initialize) {
            this.initialize.apply(this, arguments);
        }

        // call all constructor hooks
        if (this._initHooks) {
            this.callInitHooks();
        }
    };

    // instantiate class without calling constructor
    var F = function() {};
    F.prototype = this.prototype;

    var proto = new F();
    proto.constructor = NewClass;

    NewClass.prototype = proto;

    //inherit parent's statics
    var i;
    for (i in this) {
        if (this.hasOwnProperty(i) && i !== 'prototype') {
            NewClass[i] = this[i];
        }
    }

    // Inherit included classes' statics.
    if (classIncludes && classIncludes.length > 0) {
        for (i = 0; i < classIncludes.length; i++) {
            var includedClass = classIncludes[i];
            for (i in includedClass) {
                if (includedClass.hasOwnProperty(i) && i !== 'prototype') {
                    NewClass[i] = includedClass[i];
                }
            }
        }
    }


    // mix static properties into the class
    if (props.statics) {
        L.extend(NewClass, props.statics);
        delete props.statics;
    }


    // mix included classes into the prototype
    if (classIncludes && classIncludes.length) {
    	if(! proto.options) {
    		proto.options = {};
    	}

        for (i = 0; i < classIncludes.length; i++) {
            var includedClassProto = classIncludes[i].prototype;
            var includedClassProtoOpts = includedClassProto.options;
            proto.options = L.extend({}, proto.options, includedClassProtoOpts);

            for (var j in includedClassProto) {
                if (j !== "options") {
                    proto[j] = includedClassProto[j];
                }
            }
        }
        L.Util.extend.apply(null, [proto].concat(props.includes));
    }

    // mix includes into the prototype
    if (props.includes) {
        L.Util.extend.apply(null, [proto].concat(props.includes));
        delete props.includes;
    }

    // merge options
    if (props.options && proto.options) {
        props.options = L.extend({}, proto.options, props.options);
    }

    // mix given properties into the prototype
    L.extend(proto, props);

    proto._initHooks = [];

    var parent = this;
    // jshint camelcase: false
    NewClass.__super__ = parent.prototype;
    NewClass.prototype.__super__ = parent.prototype;

    // add method for calling all hooks
    proto.callInitHooks = function() {

        if (this._initHooksCalled) {
            return;
        }

        if (parent.prototype.callInitHooks) {
            parent.prototype.callInitHooks.call(this);
        }

        this._initHooksCalled = true;

        for (var i = 0, len = proto._initHooks.length; i < len; i++) {
            proto._initHooks[i].call(this);
        }
    };

    return NewClass;
};


// method for adding properties to prototype
L.Class.include = function (props) {
	L.extend(this.prototype, props);
};

// merge new default options to the Class
L.Class.mergeOptions = function (options) {
	L.extend(this.prototype.options, options);
};

// add a constructor hook
L.Class.addInitHook = function (fn) { // (Function) || (String, args...)
	var args = Array.prototype.slice.call(arguments, 1);

	var init = typeof fn === 'function' ? fn : function () {
		this[fn].apply(this, args);
	};

	this.prototype._initHooks = this.prototype._initHooks || [];
	this.prototype._initHooks.push(init);
};


/*
 * L.Mixin.Events is used to add custom events functionality to Leaflet classes.
 */

var eventsKey = '_leaflet_events';

L.Mixin = {};

L.Mixin.Events = {

	addEventListener: function (types, fn, context) { // (String, Function[, Object]) or (Object[, Object])

		// types can be a map of types/handlers
		if (L.Util.invokeEach(types, this.addEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey] = this[eventsKey] || {},
		    contextId = context && context !== this && L.stamp(context),
		    i, len, event, type, indexKey, indexLenKey, typeIndex;

		// types can be a string of space-separated words
		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			event = {
				action: fn,
				context: context || this
			};
			type = types[i];

			if (contextId) {
				// store listeners of a particular context in a separate hash (if it has an id)
				// gives a major performance boost when removing thousands of map layers

				indexKey = type + '_idx';
				indexLenKey = indexKey + '_len';

				typeIndex = events[indexKey] = events[indexKey] || {};

				if (!typeIndex[contextId]) {
					typeIndex[contextId] = [];

					// keep track of the number of keys in the index to quickly check if it's empty
					events[indexLenKey] = (events[indexLenKey] || 0) + 1;
				}

				typeIndex[contextId].push(event);


			} else {
				events[type] = events[type] || [];
				events[type].push(event);
			}
		}

		return this;
	},

	hasEventListeners: function (type) { // (String) -> Boolean
		var events = this[eventsKey];
		return !!events && ((type in events && events[type].length > 0) ||
		                    (type + '_idx' in events && events[type + '_idx_len'] > 0));
	},

	removeEventListener: function (types, fn, context) { // ([String, Function, Object]) or (Object[, Object])

		if (!this[eventsKey]) {
			return this;
		}

		if (!types) {
			return this.clearAllEventListeners();
		}

		if (L.Util.invokeEach(types, this.removeEventListener, this, fn, context)) { return this; }

		var events = this[eventsKey],
		    contextId = context && context !== this && L.stamp(context),
		    i, len, type, listeners, j, indexKey, indexLenKey, typeIndex, removed;

		types = L.Util.splitWords(types);

		for (i = 0, len = types.length; i < len; i++) {
			type = types[i];
			indexKey = type + '_idx';
			indexLenKey = indexKey + '_len';

			typeIndex = events[indexKey];

			if (!fn) {
				// clear all listeners for a type if function isn't specified
				delete events[type];
				delete events[indexKey];
				delete events[indexLenKey];

			} else {
				listeners = contextId && typeIndex ? typeIndex[contextId] : events[type];

				if (listeners) {
					for (j = listeners.length - 1; j >= 0; j--) {
						if ((listeners[j].action === fn) && (!context || (listeners[j].context === context))) {
							removed = listeners.splice(j, 1);
							// set the old action to a no-op, because it is possible
							// that the listener is being iterated over as part of a dispatch
							removed[0].action = L.Util.falseFn;
						}
					}

					if (context && typeIndex && (listeners.length === 0)) {
						delete typeIndex[contextId];
						events[indexLenKey]--;
					}
				}
			}
		}

		return this;
	},

	clearAllEventListeners: function () {
		delete this[eventsKey];
		return this;
	},

	fireEvent: function (type, data) { // (String[, Object])
		if (!this.hasEventListeners(type)) {
			return this;
		}

		var event = L.Util.extend({}, data, { type: type, target: this });

		var events = this[eventsKey],
		    listeners, i, len, typeIndex, contextId;

		if (events[type]) {
			// make sure adding/removing listeners inside other listeners won't cause infinite loop
			listeners = events[type].slice();

			for (i = 0, len = listeners.length; i < len; i++) {
				listeners[i].action.call(listeners[i].context, event);
			}
		}

		// fire event for the context-indexed listeners as well
		typeIndex = events[type + '_idx'];

		for (contextId in typeIndex) {
			listeners = typeIndex[contextId].slice();

			if (listeners) {
				for (i = 0, len = listeners.length; i < len; i++) {
					listeners[i].action.call(listeners[i].context, event);
				}
			}
		}

		return this;
	},

	addOneTimeEventListener: function (types, fn, context) {

		if (L.Util.invokeEach(types, this.addOneTimeEventListener, this, fn, context)) { return this; }

		var handler = L.bind(function () {
			this
			    .removeEventListener(types, fn, context)
			    .removeEventListener(types, handler, context);
		}, this);

		return this
		    .addEventListener(types, fn, context)
		    .addEventListener(types, handler, context);
	}
};

L.Mixin.Events.on = L.Mixin.Events.addEventListener;
L.Mixin.Events.off = L.Mixin.Events.removeEventListener;
L.Mixin.Events.once = L.Mixin.Events.addOneTimeEventListener;
L.Mixin.Events.fire = L.Mixin.Events.fireEvent;


/*
 * L.Browser handles different browser and feature detections for internal Leaflet use.
 */

(function () {

	var ie = 'ActiveXObject' in window,
		ielt9 = ie && !document.addEventListener,

	    // terrible browser detection to work around Safari / iOS / Android browser bugs
	    ua = navigator.userAgent.toLowerCase(),
	    webkit = ua.indexOf('webkit') !== -1,
	    chrome = ua.indexOf('chrome') !== -1,
	    phantomjs = ua.indexOf('phantom') !== -1,
	    android = ua.indexOf('android') !== -1,
	    android23 = ua.search('android [23]') !== -1,
		gecko = ua.indexOf('gecko') !== -1,

	    mobile = typeof orientation !== undefined + '',
	    msPointer = window.navigator && window.navigator.msPointerEnabled &&
	              window.navigator.msMaxTouchPoints && !window.PointerEvent,
		pointer = (window.PointerEvent && window.navigator.pointerEnabled && window.navigator.maxTouchPoints) ||
				  msPointer,
	    retina = ('devicePixelRatio' in window && window.devicePixelRatio > 1) ||
	             ('matchMedia' in window && window.matchMedia('(min-resolution:144dpi)') &&
	              window.matchMedia('(min-resolution:144dpi)').matches),

	    doc = document.documentElement,
	    ie3d = ie && ('transition' in doc.style),
	    webkit3d = ('WebKitCSSMatrix' in window) && ('m11' in new window.WebKitCSSMatrix()) && !android23,
	    gecko3d = 'MozPerspective' in doc.style,
	    opera3d = 'OTransition' in doc.style,
	    any3d = !window.L_DISABLE_3D && (ie3d || webkit3d || gecko3d || opera3d) && !phantomjs;


	// PhantomJS has 'ontouchstart' in document.documentElement, but doesn't actually support touch.
	// https://github.com/Leaflet/Leaflet/pull/1434#issuecomment-13843151

	var touch = !window.L_NO_TOUCH && !phantomjs && (function () {

		var startName = 'ontouchstart';

		// IE10+ (We simulate these into touch* events in L.DomEvent and L.DomEvent.Pointer) or WebKit, etc.
		if (pointer || (startName in doc)) {
			return true;
		}

		// Firefox/Gecko
		var div = document.createElement('div'),
		    supported = false;

		if (!div.setAttribute) {
			return false;
		}
		div.setAttribute(startName, 'return;');

		if (typeof div[startName] === 'function') {
			supported = true;
		}

		div.removeAttribute(startName);
		div = null;

		return supported;
	}());


	L.Browser = {
		ie: ie,
		ielt9: ielt9,
		webkit: webkit,
		gecko: gecko && !webkit && !window.opera && !ie,

		android: android,
		android23: android23,

		chrome: chrome,

		ie3d: ie3d,
		webkit3d: webkit3d,
		gecko3d: gecko3d,
		opera3d: opera3d,
		any3d: any3d,

		mobile: mobile,
		mobileWebkit: mobile && webkit,
		mobileWebkit3d: mobile && webkit3d,
		mobileOpera: mobile && window.opera,

		touch: touch,
		msPointer: msPointer,
		pointer: pointer,

		retina: retina
	};

}());


/*
 * L.Point represents a point with x and y coordinates.
 */

L.Point = function (/*Number*/ x, /*Number*/ y, /*Boolean*/ round) {
	this.x = (round ? Math.round(x) : x);
	this.y = (round ? Math.round(y) : y);
};

L.Point.prototype = {

	clone: function () {
		return new L.Point(this.x, this.y);
	},

	// non-destructive, returns a new point
	add: function (point) {
		return this.clone()._add(L.point(point));
	},

	// destructive, used directly for performance in situations where it's safe to modify existing point
	_add: function (point) {
		this.x += point.x;
		this.y += point.y;
		return this;
	},

	subtract: function (point) {
		return this.clone()._subtract(L.point(point));
	},

	_subtract: function (point) {
		this.x -= point.x;
		this.y -= point.y;
		return this;
	},

	divideBy: function (num) {
		return this.clone()._divideBy(num);
	},

	_divideBy: function (num) {
		this.x /= num;
		this.y /= num;
		return this;
	},

	multiplyBy: function (num) {
		return this.clone()._multiplyBy(num);
	},

	_multiplyBy: function (num) {
		this.x *= num;
		this.y *= num;
		return this;
	},

	round: function () {
		return this.clone()._round();
	},

	_round: function () {
		this.x = Math.round(this.x);
		this.y = Math.round(this.y);
		return this;
	},

	floor: function () {
		return this.clone()._floor();
	},

	_floor: function () {
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	},

	distanceTo: function (point) {
		point = L.point(point);

		var x = point.x - this.x,
		    y = point.y - this.y;

		return Math.sqrt(x * x + y * y);
	},

	equals: function (point) {
		point = L.point(point);

		return point.x === this.x &&
		       point.y === this.y;
	},

	contains: function (point) {
		point = L.point(point);

		return Math.abs(point.x) <= Math.abs(this.x) &&
		       Math.abs(point.y) <= Math.abs(this.y);
	},

	toString: function () {
		return 'Point(' +
		        L.Util.formatNum(this.x) + ', ' +
		        L.Util.formatNum(this.y) + ')';
	}
};

L.point = function (x, y, round) {
	if (x instanceof L.Point) {
		return x;
	}
	if (L.Util.isArray(x)) {
		return new L.Point(x[0], x[1]);
	}
	if (x === undefined || x === null) {
		return x;
	}
	return new L.Point(x, y, round);
};


/*
 * L.Bounds represents a rectangular area on the screen in pixel coordinates.
 */

L.Bounds = function (a, b) { //(Point, Point) or Point[]
	if (!a) { return; }

	var points = b ? [a, b] : a;

	for (var i = 0, len = points.length; i < len; i++) {
		this.extend(points[i]);
	}
};

L.Bounds.prototype = {
	// extend the bounds to contain the given point
	extend: function (point) { // (Point)
		point = L.point(point);

		if (!this.min && !this.max) {
			this.min = point.clone();
			this.max = point.clone();
		} else {
			this.min.x = Math.min(point.x, this.min.x);
			this.max.x = Math.max(point.x, this.max.x);
			this.min.y = Math.min(point.y, this.min.y);
			this.max.y = Math.max(point.y, this.max.y);
		}
		return this;
	},

	getCenter: function (round) { // (Boolean) -> Point
		return new L.Point(
		        (this.min.x + this.max.x) / 2,
		        (this.min.y + this.max.y) / 2, round);
	},

	getBottomLeft: function () { // -> Point
		return new L.Point(this.min.x, this.max.y);
	},

	getTopRight: function () { // -> Point
		return new L.Point(this.max.x, this.min.y);
	},

	getSize: function () {
		return this.max.subtract(this.min);
	},

	contains: function (obj) { // (Bounds) or (Point) -> Boolean
		var min, max;

		if (typeof obj[0] === 'number' || obj instanceof L.Point) {
			obj = L.point(obj);
		} else {
			obj = L.bounds(obj);
		}

		if (obj instanceof L.Bounds) {
			min = obj.min;
			max = obj.max;
		} else {
			min = max = obj;
		}

		return (min.x >= this.min.x) &&
		       (max.x <= this.max.x) &&
		       (min.y >= this.min.y) &&
		       (max.y <= this.max.y);
	},

	intersects: function (bounds) { // (Bounds) -> Boolean
		bounds = L.bounds(bounds);

		var min = this.min,
		    max = this.max,
		    min2 = bounds.min,
		    max2 = bounds.max,
		    xIntersects = (max2.x >= min.x) && (min2.x <= max.x),
		    yIntersects = (max2.y >= min.y) && (min2.y <= max.y);

		return xIntersects && yIntersects;
	},

	isValid: function () {
		return !!(this.min && this.max);
	}
};

L.bounds = function (a, b) { // (Bounds) or (Point, Point) or (Point[])
	if (!a || a instanceof L.Bounds) {
		return a;
	}
	return new L.Bounds(a, b);
};


/*
 * L.Transformation is an utility class to perform simple point transformations through a 2d-matrix.
 */

L.Transformation = function (a, b, c, d) {
	this._a = a;
	this._b = b;
	this._c = c;
	this._d = d;
};

L.Transformation.prototype = {
	transform: function (point, scale) { // (Point, Number) -> Point
		return this._transform(point.clone(), scale);
	},

	// destructive transform (faster)
	_transform: function (point, scale) {
		scale = scale || 1;
		point.x = scale * (this._a * point.x + this._b);
		point.y = scale * (this._c * point.y + this._d);
		return point;
	},

	untransform: function (point, scale) {
		scale = scale || 1;
		return new L.Point(
		        (point.x / scale - this._b) / this._a,
		        (point.y / scale - this._d) / this._c);
	}
};


/*
 * L.DomUtil contains various utility functions for working with DOM.
 */

L.DomUtil = {
	get: function (id) {
		return (typeof id === 'string' ? document.getElementById(id) : id);
	},

	getStyle: function (el, style) {

		var value = el.style[style];

		if (!value && el.currentStyle) {
			value = el.currentStyle[style];
		}

		if ((!value || value === 'auto') && document.defaultView) {
			var css = document.defaultView.getComputedStyle(el, null);
			value = css ? css[style] : null;
		}

		return value === 'auto' ? null : value;
	},

	getViewportOffset: function (element) {

		var top = 0,
		    left = 0,
		    el = element,
		    docBody = document.body,
		    docEl = document.documentElement,
		    pos;

		do {
			top  += el.offsetTop  || 0;
			left += el.offsetLeft || 0;

			//add borders
			top += parseInt(L.DomUtil.getStyle(el, 'borderTopWidth'), 10) || 0;
			left += parseInt(L.DomUtil.getStyle(el, 'borderLeftWidth'), 10) || 0;

			pos = L.DomUtil.getStyle(el, 'position');

			if (el.offsetParent === docBody && pos === 'absolute') { break; }

			if (pos === 'fixed') {
				top  += docBody.scrollTop  || docEl.scrollTop  || 0;
				left += docBody.scrollLeft || docEl.scrollLeft || 0;
				break;
			}

			if (pos === 'relative' && !el.offsetLeft) {
				var width = L.DomUtil.getStyle(el, 'width'),
				    maxWidth = L.DomUtil.getStyle(el, 'max-width'),
				    r = el.getBoundingClientRect();

				if (width !== 'none' || maxWidth !== 'none') {
					left += r.left + el.clientLeft;
				}

				//calculate full y offset since we're breaking out of the loop
				top += r.top + (docBody.scrollTop  || docEl.scrollTop  || 0);

				break;
			}

			el = el.offsetParent;

		} while (el);

		el = element;

		do {
			if (el === docBody) { break; }

			top  -= el.scrollTop  || 0;
			left -= el.scrollLeft || 0;

			el = el.parentNode;
		} while (el);

		return new L.Point(left, top);
	},

	documentIsLtr: function () {
		if (!L.DomUtil._docIsLtrCached) {
			L.DomUtil._docIsLtrCached = true;
			L.DomUtil._docIsLtr = L.DomUtil.getStyle(document.body, 'direction') === 'ltr';
		}
		return L.DomUtil._docIsLtr;
	},

	create: function (tagName, className, container) {

		var el = document.createElement(tagName);
		el.className = className;

		if (container) {
			container.appendChild(el);
		}

		return el;
	},

	hasClass: function (el, name) {
		if (el.classList !== undefined) {
			return el.classList.contains(name);
		}
		var className = L.DomUtil._getClass(el);
		return className.length > 0 && new RegExp('(^|\\s)' + name + '(\\s|$)').test(className);
	},

	addClass: function (el, name) {
		if (el.classList !== undefined) {
			var classes = L.Util.splitWords(name);
			for (var i = 0, len = classes.length; i < len; i++) {
				el.classList.add(classes[i]);
			}
		} else if (!L.DomUtil.hasClass(el, name)) {
			var className = L.DomUtil._getClass(el);
			L.DomUtil._setClass(el, (className ? className + ' ' : '') + name);
		}
	},

	removeClass: function (el, name) {
		if (el.classList !== undefined) {
			el.classList.remove(name);
		} else {
			L.DomUtil._setClass(el, L.Util.trim((' ' + L.DomUtil._getClass(el) + ' ').replace(' ' + name + ' ', ' ')));
		}
	},

	_setClass: function (el, name) {
		if (el.className.baseVal === undefined) {
			el.className = name;
		} else {
			// in case of SVG element
			el.className.baseVal = name;
		}
	},

	_getClass: function (el) {
		return el.className.baseVal === undefined ? el.className : el.className.baseVal;
	},

	setOpacity: function (el, value) {

		if ('opacity' in el.style) {
			el.style.opacity = value;

		} else if ('filter' in el.style) {

			var filter = false,
			    filterName = 'DXImageTransform.Microsoft.Alpha';

			// filters collection throws an error if we try to retrieve a filter that doesn't exist
			try {
				filter = el.filters.item(filterName);
			} catch (e) {
				// don't set opacity to 1 if we haven't already set an opacity,
				// it isn't needed and breaks transparent pngs.
				if (value === 1) { return; }
			}

			value = Math.round(value * 100);

			if (filter) {
				filter.Enabled = (value !== 100);
				filter.Opacity = value;
			} else {
				el.style.filter += ' progid:' + filterName + '(opacity=' + value + ')';
			}
		}
	},

	testProp: function (props) {

		var style = document.documentElement.style;

		for (var i = 0; i < props.length; i++) {
			if (props[i] in style) {
				return props[i];
			}
		}
		return false;
	},

	getTranslateString: function (point) {
		// on WebKit browsers (Chrome/Safari/iOS Safari/Android) using translate3d instead of translate
		// makes animation smoother as it ensures HW accel is used. Firefox 13 doesn't care
		// (same speed either way), Opera 12 doesn't support translate3d

		var is3d = L.Browser.webkit3d,
		    open = 'translate' + (is3d ? '3d' : '') + '(',
		    close = (is3d ? ',0' : '') + ')';

		return open + point.x + 'px,' + point.y + 'px' + close;
	},

	getScaleString: function (scale, origin) {

		var preTranslateStr = L.DomUtil.getTranslateString(origin.add(origin.multiplyBy(-1 * scale))),
		    scaleStr = ' scale(' + scale + ') ';

		return preTranslateStr + scaleStr;
	},

	setPosition: function (el, point, disable3D) { // (HTMLElement, Point[, Boolean])

		// jshint camelcase: false
		el._leaflet_pos = point;

		if (!disable3D && L.Browser.any3d) {
			el.style[L.DomUtil.TRANSFORM] =  L.DomUtil.getTranslateString(point);
		} else {
			el.style.left = point.x + 'px';
			el.style.top = point.y + 'px';
		}
	},

	getPosition: function (el) {
		// this method is only used for elements previously positioned using setPosition,
		// so it's safe to cache the position for performance

		// jshint camelcase: false
		return el._leaflet_pos;
	}
};


// prefix style property names

L.DomUtil.TRANSFORM = L.DomUtil.testProp(
        ['transform', 'WebkitTransform', 'OTransform', 'MozTransform', 'msTransform']);

// webkitTransition comes first because some browser versions that drop vendor prefix don't do
// the same for the transitionend event, in particular the Android 4.1 stock browser

L.DomUtil.TRANSITION = L.DomUtil.testProp(
        ['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition']);

L.DomUtil.TRANSITION_END =
        L.DomUtil.TRANSITION === 'webkitTransition' || L.DomUtil.TRANSITION === 'OTransition' ?
        L.DomUtil.TRANSITION + 'End' : 'transitionend';

(function () {
    if ('onselectstart' in document) {
        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                L.DomEvent.on(window, 'selectstart', L.DomEvent.preventDefault);
            },

            enableTextSelection: function () {
                L.DomEvent.off(window, 'selectstart', L.DomEvent.preventDefault);
            }
        });
    } else {
        var userSelectProperty = L.DomUtil.testProp(
            ['userSelect', 'WebkitUserSelect', 'OUserSelect', 'MozUserSelect', 'msUserSelect']);

        L.extend(L.DomUtil, {
            disableTextSelection: function () {
                if (userSelectProperty) {
                    var style = document.documentElement.style;
                    this._userSelect = style[userSelectProperty];
                    style[userSelectProperty] = 'none';
                }
            },

            enableTextSelection: function () {
                if (userSelectProperty) {
                    document.documentElement.style[userSelectProperty] = this._userSelect;
                    delete this._userSelect;
                }
            }
        });
    }

	L.extend(L.DomUtil, {
		disableImageDrag: function () {
			L.DomEvent.on(window, 'dragstart', L.DomEvent.preventDefault);
		},

		enableImageDrag: function () {
			L.DomEvent.off(window, 'dragstart', L.DomEvent.preventDefault);
		}
	});
})();


/*
 * L.LatLng represents a geographical point with latitude and longitude coordinates.
 */

L.LatLng = function (lat, lng, alt) { // (Number, Number, Number)
	lat = parseFloat(lat);
	lng = parseFloat(lng);

	if (isNaN(lat) || isNaN(lng)) {
		throw new Error('Invalid LatLng object: (' + lat + ', ' + lng + ')');
	}

	this.lat = lat;
	this.lng = lng;

	if (alt !== undefined) {
		this.alt = parseFloat(alt);
	}
};

L.extend(L.LatLng, {
	DEG_TO_RAD: Math.PI / 180,
	RAD_TO_DEG: 180 / Math.PI,
	MAX_MARGIN: 1.0E-9 // max margin of error for the "equals" check
});

L.LatLng.prototype = {
	equals: function (obj) { // (LatLng) -> Boolean
		if (!obj) { return false; }

		obj = L.latLng(obj);

		var margin = Math.max(
		        Math.abs(this.lat - obj.lat),
		        Math.abs(this.lng - obj.lng));

		return margin <= L.LatLng.MAX_MARGIN;
	},

	toString: function (precision) { // (Number) -> String
		return 'LatLng(' +
		        L.Util.formatNum(this.lat, precision) + ', ' +
		        L.Util.formatNum(this.lng, precision) + ')';
	},

	// Haversine distance formula, see http://en.wikipedia.org/wiki/Haversine_formula
	// TODO move to projection code, LatLng shouldn't know about Earth
	distanceTo: function (other) { // (LatLng) -> Number
		other = L.latLng(other);

		var R = 6378137, // earth radius in meters
		    d2r = L.LatLng.DEG_TO_RAD,
		    dLat = (other.lat - this.lat) * d2r,
		    dLon = (other.lng - this.lng) * d2r,
		    lat1 = this.lat * d2r,
		    lat2 = other.lat * d2r,
		    sin1 = Math.sin(dLat / 2),
		    sin2 = Math.sin(dLon / 2);

		var a = sin1 * sin1 + sin2 * sin2 * Math.cos(lat1) * Math.cos(lat2);

		return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
	},

	wrap: function (a, b) { // (Number, Number) -> LatLng
		var lng = this.lng;

		a = a || -180;
		b = b ||  180;

		lng = (lng + b) % (b - a) + (lng < a || lng === b ? b : a);

		return new L.LatLng(this.lat, lng);
	}
};

L.latLng = function (a, b) { // (LatLng) or ([Number, Number]) or (Number, Number)
	if (a instanceof L.LatLng) {
		return a;
	}
	if (L.Util.isArray(a)) {
		if (typeof a[0] === 'number' || typeof a[0] === 'string') {
			return new L.LatLng(a[0], a[1], a[2]);
		} else {
			return null;
		}
	}
	if (a === undefined || a === null) {
		return a;
	}
	if (typeof a === 'object' && 'lat' in a) {
		return new L.LatLng(a.lat, 'lng' in a ? a.lng : a.lon);
	}
	if (b === undefined) {
		return null;
	}
	return new L.LatLng(a, b);
};



/*
 * L.LatLngBounds represents a rectangular area on the map in geographical coordinates.
 */

L.LatLngBounds = function (southWest, northEast) { // (LatLng, LatLng) or (LatLng[])
	if (!southWest) { return; }

	var latlngs = northEast ? [southWest, northEast] : southWest;

	for (var i = 0, len = latlngs.length; i < len; i++) {
		this.extend(latlngs[i]);
	}
};

L.LatLngBounds.prototype = {
	// extend the bounds to contain the given point or bounds
	extend: function (obj) { // (LatLng) or (LatLngBounds)
		if (!obj) { return this; }

		var latLng = L.latLng(obj);
		if (latLng !== null) {
			obj = latLng;
		} else {
			obj = L.latLngBounds(obj);
		}

		if (obj instanceof L.LatLng) {
			if (!this._southWest && !this._northEast) {
				this._southWest = new L.LatLng(obj.lat, obj.lng);
				this._northEast = new L.LatLng(obj.lat, obj.lng);
			} else {
				this._southWest.lat = Math.min(obj.lat, this._southWest.lat);
				this._southWest.lng = Math.min(obj.lng, this._southWest.lng);

				this._northEast.lat = Math.max(obj.lat, this._northEast.lat);
				this._northEast.lng = Math.max(obj.lng, this._northEast.lng);
			}
		} else if (obj instanceof L.LatLngBounds) {
			this.extend(obj._southWest);
			this.extend(obj._northEast);
		}
		return this;
	},

	// extend the bounds by a percentage
	pad: function (bufferRatio) { // (Number) -> LatLngBounds
		var sw = this._southWest,
		    ne = this._northEast,
		    heightBuffer = Math.abs(sw.lat - ne.lat) * bufferRatio,
		    widthBuffer = Math.abs(sw.lng - ne.lng) * bufferRatio;

		return new L.LatLngBounds(
		        new L.LatLng(sw.lat - heightBuffer, sw.lng - widthBuffer),
		        new L.LatLng(ne.lat + heightBuffer, ne.lng + widthBuffer));
	},

	getCenter: function () { // -> LatLng
		return new L.LatLng(
		        (this._southWest.lat + this._northEast.lat) / 2,
		        (this._southWest.lng + this._northEast.lng) / 2);
	},

	getSouthWest: function () {
		return this._southWest;
	},

	getNorthEast: function () {
		return this._northEast;
	},

	getNorthWest: function () {
		return new L.LatLng(this.getNorth(), this.getWest());
	},

	getSouthEast: function () {
		return new L.LatLng(this.getSouth(), this.getEast());
	},

	getWest: function () {
		return this._southWest.lng;
	},

	getSouth: function () {
		return this._southWest.lat;
	},

	getEast: function () {
		return this._northEast.lng;
	},

	getNorth: function () {
		return this._northEast.lat;
	},

	contains: function (obj) { // (LatLngBounds) or (LatLng) -> Boolean
		if (typeof obj[0] === 'number' || obj instanceof L.LatLng) {
			obj = L.latLng(obj);
		} else {
			obj = L.latLngBounds(obj);
		}

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2, ne2;

		if (obj instanceof L.LatLngBounds) {
			sw2 = obj.getSouthWest();
			ne2 = obj.getNorthEast();
		} else {
			sw2 = ne2 = obj;
		}

		return (sw2.lat >= sw.lat) && (ne2.lat <= ne.lat) &&
		       (sw2.lng >= sw.lng) && (ne2.lng <= ne.lng);
	},

	intersects: function (bounds) { // (LatLngBounds)
		bounds = L.latLngBounds(bounds);

		var sw = this._southWest,
		    ne = this._northEast,
		    sw2 = bounds.getSouthWest(),
		    ne2 = bounds.getNorthEast(),

		    latIntersects = (ne2.lat >= sw.lat) && (sw2.lat <= ne.lat),
		    lngIntersects = (ne2.lng >= sw.lng) && (sw2.lng <= ne.lng);

		return latIntersects && lngIntersects;
	},

	toBBoxString: function () {
		return [this.getWest(), this.getSouth(), this.getEast(), this.getNorth()].join(',');
	},

	equals: function (bounds) { // (LatLngBounds)
		if (!bounds) { return false; }

		bounds = L.latLngBounds(bounds);

		return this._southWest.equals(bounds.getSouthWest()) &&
		       this._northEast.equals(bounds.getNorthEast());
	},

	isValid: function () {
		return !!(this._southWest && this._northEast);
	}
};

//TODO International date line?

L.latLngBounds = function (a, b) { // (LatLngBounds) or (LatLng, LatLng)
	if (!a || a instanceof L.LatLngBounds) {
		return a;
	}
	return new L.LatLngBounds(a, b);
};


/*
 * L.Projection contains various geographical projections used by CRS classes.
 */

L.Projection = {};


/*
 * Spherical Mercator is the most popular map projection, used by EPSG:3857 CRS used by default.
 */

L.Projection.SphericalMercator = {
	MAX_LATITUDE: 85.0511287798,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    x = latlng.lng * d,
		    y = lat * d;

		y = Math.log(Math.tan((Math.PI / 4) + (y / 2)));

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    lng = point.x * d,
		    lat = (2 * Math.atan(Math.exp(point.y)) - (Math.PI / 2)) * d;

		return new L.LatLng(lat, lng);
	}
};


/*
 * Simple equirectangular (Plate Carree) projection, used by CRS like EPSG:4326 and Simple.
 */

L.Projection.LonLat = {
	project: function (latlng) {
		return new L.Point(latlng.lng, latlng.lat);
	},

	unproject: function (point) {
		return new L.LatLng(point.y, point.x);
	}
};


/*
 * L.CRS is a base object for all defined CRS (Coordinate Reference Systems) in Leaflet.
 */

L.CRS = {
	latLngToPoint: function (latlng, zoom) { // (LatLng, Number) -> Point
		var projectedPoint = this.projection.project(latlng),
		    scale = this.scale(zoom);

		return this.transformation._transform(projectedPoint, scale);
	},

	pointToLatLng: function (point, zoom) { // (Point, Number[, Boolean]) -> LatLng
		var scale = this.scale(zoom),
		    untransformedPoint = this.transformation.untransform(point, scale);

		return this.projection.unproject(untransformedPoint);
	},

	project: function (latlng) {
		return this.projection.project(latlng);
	},

	scale: function (zoom) {
		return 256 * Math.pow(2, zoom);
	},

	getSize: function (zoom) {
		var s = this.scale(zoom);
		return L.point(s, s);
	}
};


/*
 * A simple CRS that can be used for flat non-Earth maps like panoramas or game maps.
 */

L.CRS.Simple = L.extend({}, L.CRS, {
	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1, 0, -1, 0),

	scale: function (zoom) {
		return Math.pow(2, zoom);
	}
});


/*
 * L.CRS.EPSG3857 (Spherical Mercator) is the most common CRS for web mapping
 * and is used by Leaflet by default.
 */

L.CRS.EPSG3857 = L.extend({}, L.CRS, {
	code: 'EPSG:3857',

	projection: L.Projection.SphericalMercator,
	transformation: new L.Transformation(0.5 / Math.PI, 0.5, -0.5 / Math.PI, 0.5),

	project: function (latlng) { // (LatLng) -> Point
		var projectedPoint = this.projection.project(latlng),
		    earthRadius = 6378137;
		return projectedPoint.multiplyBy(earthRadius);
	}
});

L.CRS.EPSG900913 = L.extend({}, L.CRS.EPSG3857, {
	code: 'EPSG:900913'
});


/*
 * L.CRS.EPSG4326 is a CRS popular among advanced GIS specialists.
 */

L.CRS.EPSG4326 = L.extend({}, L.CRS, {
	code: 'EPSG:4326',

	projection: L.Projection.LonLat,
	transformation: new L.Transformation(1 / 360, 0.5, -1 / 360, 0.5)
});


/*
 * L.Map is the central class of the API - it is used to create a map.
 */

L.Map = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		crs: L.CRS.EPSG3857,

		/*
		center: LatLng,
		zoom: Number,
		layers: Array,
		*/

		fadeAnimation: L.DomUtil.TRANSITION && !L.Browser.android23,
		trackResize: true,
		markerZoomAnimation: L.DomUtil.TRANSITION && L.Browser.any3d
	},

	initialize: function (id, options) { // (HTMLElement or String, Object)
		options = L.setOptions(this, options);


		this._initContainer(id);
		this._initLayout();

		// hack for https://github.com/Leaflet/Leaflet/issues/1980
		this._onResize = L.bind(this._onResize, this);

		this._initEvents();

		if (options.maxBounds) {
			this.setMaxBounds(options.maxBounds);
		}

		if (options.center && options.zoom !== undefined) {
			this.setView(L.latLng(options.center), options.zoom, {reset: true});
		}

		this._handlers = [];

		this._layers = {};
		this._zoomBoundLayers = {};
		this._tileLayersNum = 0;

		this.callInitHooks();

		this._addLayers(options.layers);
	},


	// public methods that modify map state

	// replaced by animation-powered implementation in Map.PanAnimation.js
	setView: function (center, zoom) {
		zoom = zoom === undefined ? this.getZoom() : zoom;
		this._resetView(L.latLng(center), this._limitZoom(zoom));
		return this;
	},

	setZoom: function (zoom, options) {
		if (!this._loaded) {
			this._zoom = this._limitZoom(zoom);
			return this;
		}
		return this.setView(this.getCenter(), zoom, {zoom: options});
	},

	zoomIn: function (delta, options) {
		return this.setZoom(this._zoom + (delta || 1), options);
	},

	zoomOut: function (delta, options) {
		return this.setZoom(this._zoom - (delta || 1), options);
	},

	setZoomAround: function (latlng, zoom, options) {
		var scale = this.getZoomScale(zoom),
		    viewHalf = this.getSize().divideBy(2),
		    containerPoint = latlng instanceof L.Point ? latlng : this.latLngToContainerPoint(latlng),

		    centerOffset = containerPoint.subtract(viewHalf).multiplyBy(1 - 1 / scale),
		    newCenter = this.containerPointToLatLng(viewHalf.add(centerOffset));

		return this.setView(newCenter, zoom, {zoom: options});
	},

	fitBounds: function (bounds, options) {

		options = options || {};
		bounds = bounds.getBounds ? bounds.getBounds() : L.latLngBounds(bounds);

		var paddingTL = L.point(options.paddingTopLeft || options.padding || [0, 0]),
		    paddingBR = L.point(options.paddingBottomRight || options.padding || [0, 0]),

		    zoom = this.getBoundsZoom(bounds, false, paddingTL.add(paddingBR)),
		    paddingOffset = paddingBR.subtract(paddingTL).divideBy(2),

		    swPoint = this.project(bounds.getSouthWest(), zoom),
		    nePoint = this.project(bounds.getNorthEast(), zoom),
		    center = this.unproject(swPoint.add(nePoint).divideBy(2).add(paddingOffset), zoom);

		zoom = options && options.maxZoom ? Math.min(options.maxZoom, zoom) : zoom;

		return this.setView(center, zoom, options);
	},

	fitWorld: function (options) {
		return this.fitBounds([[-90, -180], [90, 180]], options);
	},

	panTo: function (center, options) { // (LatLng)
		return this.setView(center, this._zoom, {pan: options});
	},

	panBy: function (offset) { // (Point)
		// replaced with animated panBy in Map.PanAnimation.js
		this.fire('movestart');

		this._rawPanBy(L.point(offset));

		this.fire('move');
		return this.fire('moveend');
	},

	setMaxBounds: function (bounds) {
		bounds = L.latLngBounds(bounds);

		this.options.maxBounds = bounds;

		if (!bounds) {
			return this.off('moveend', this._panInsideMaxBounds, this);
		}

		if (this._loaded) {
			this._panInsideMaxBounds();
		}

		return this.on('moveend', this._panInsideMaxBounds, this);
	},

	panInsideBounds: function (bounds, options) {
		var center = this.getCenter(),
			newCenter = this._limitCenter(center, this._zoom, bounds);

		if (center.equals(newCenter)) { return this; }

		return this.panTo(newCenter, options);
	},

	addLayer: function (layer) {
		// TODO method is too big, refactor

		var id = L.stamp(layer);

		if (this._layers[id]) { return this; }

		this._layers[id] = layer;

		// TODO getMaxZoom, getMinZoom in ILayer (instead of options)
		if (layer.options && (!isNaN(layer.options.maxZoom) || !isNaN(layer.options.minZoom))) {
			this._zoomBoundLayers[id] = layer;
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor!!!
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum++;
			this._tileLayersToLoad++;
			layer.on('load', this._onTileLayerLoad, this);
		}

		if (this._loaded) {
			this._layerAdd(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);

		if (!this._layers[id]) { return this; }

		if (this._loaded) {
			layer.onRemove(this);
		}

		delete this._layers[id];

		if (this._loaded) {
			this.fire('layerremove', {layer: layer});
		}

		if (this._zoomBoundLayers[id]) {
			delete this._zoomBoundLayers[id];
			this._updateZoomLevels();
		}

		// TODO looks ugly, refactor
		if (this.options.zoomAnimation && L.TileLayer && (layer instanceof L.TileLayer)) {
			this._tileLayersNum--;
			this._tileLayersToLoad--;
			layer.off('load', this._onTileLayerLoad, this);
		}

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (L.stamp(layer) in this._layers);
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	invalidateSize: function (options) {
		if (!this._loaded) { return this; }

		options = L.extend({
			animate: false,
			pan: true
		}, options === true ? {animate: true} : options);

		var oldSize = this.getSize();
		this._sizeChanged = true;
		this._initialCenter = null;

		var newSize = this.getSize(),
		    oldCenter = oldSize.divideBy(2).round(),
		    newCenter = newSize.divideBy(2).round(),
		    offset = oldCenter.subtract(newCenter);

		if (!offset.x && !offset.y) { return this; }

		if (options.animate && options.pan) {
			this.panBy(offset);

		} else {
			if (options.pan) {
				this._rawPanBy(offset);
			}

			this.fire('move');

			if (options.debounceMoveend) {
				clearTimeout(this._sizeTimer);
				this._sizeTimer = setTimeout(L.bind(this.fire, this, 'moveend'), 200);
			} else {
				this.fire('moveend');
			}
		}

		return this.fire('resize', {
			oldSize: oldSize,
			newSize: newSize
		});
	},

	// TODO handler.addTo
	addHandler: function (name, HandlerClass) {
		if (!HandlerClass) { return this; }

		var handler = this[name] = new HandlerClass(this);

		this._handlers.push(handler);

		if (this.options[name]) {
			handler.enable();
		}

		return this;
	},

	remove: function () {
		if (this._loaded) {
			this.fire('unload');
		}

		this._initEvents('off');

		try {
			// throws error in IE6-8
			delete this._container._leaflet;
		} catch (e) {
			this._container._leaflet = undefined;
		}

		this._clearPanes();
		if (this._clearControlPos) {
			this._clearControlPos();
		}

		this._clearHandlers();

		return this;
	},


	// public methods for getting map state

	getCenter: function () { // (Boolean) -> LatLng
		this._checkIfLoaded();

		if (this._initialCenter && !this._moved()) {
			return this._initialCenter;
		}
		return this.layerPointToLatLng(this._getCenterLayerPoint());
	},

	getZoom: function () {
		return this._zoom;
	},

	getBounds: function () {
		var bounds = this.getPixelBounds(),
		    sw = this.unproject(bounds.getBottomLeft()),
		    ne = this.unproject(bounds.getTopRight());

		return new L.LatLngBounds(sw, ne);
	},

	getMinZoom: function () {
		return this.options.minZoom === undefined ?
			(this._layersMinZoom === undefined ? 0 : this._layersMinZoom) :
			this.options.minZoom;
	},

	getMaxZoom: function () {
		return this.options.maxZoom === undefined ?
			(this._layersMaxZoom === undefined ? Infinity : this._layersMaxZoom) :
			this.options.maxZoom;
	},

	getBoundsZoom: function (bounds, inside, padding) { // (LatLngBounds[, Boolean, Point]) -> Number
		bounds = L.latLngBounds(bounds);

		var zoom = this.getMinZoom() - (inside ? 1 : 0),
		    maxZoom = this.getMaxZoom(),
		    size = this.getSize(),

		    nw = bounds.getNorthWest(),
		    se = bounds.getSouthEast(),

		    zoomNotFound = true,
		    boundsSize;

		padding = L.point(padding || [0, 0]);

		do {
			zoom++;
			boundsSize = this.project(se, zoom).subtract(this.project(nw, zoom)).add(padding);
			zoomNotFound = !inside ? size.contains(boundsSize) : boundsSize.x < size.x || boundsSize.y < size.y;

		} while (zoomNotFound && zoom <= maxZoom);

		if (zoomNotFound && inside) {
			return null;
		}

		return inside ? zoom : zoom - 1;
	},

	getSize: function () {
		if (!this._size || this._sizeChanged) {
			this._size = new L.Point(
				this._container.clientWidth,
				this._container.clientHeight);

			this._sizeChanged = false;
		}
		return this._size.clone();
	},

	getPixelBounds: function () {
		var topLeftPoint = this._getTopLeftPoint();
		return new L.Bounds(topLeftPoint, topLeftPoint.add(this.getSize()));
	},

	getPixelOrigin: function () {
		this._checkIfLoaded();
		return this._initialTopLeftPoint;
	},

	getPanes: function () {
		return this._panes;
	},

	getContainer: function () {
		return this._container;
	},


	// TODO replace with universal implementation after refactoring projections

	getZoomScale: function (toZoom) {
		var crs = this.options.crs;
		return crs.scale(toZoom) / crs.scale(this._zoom);
	},

	getScaleZoom: function (scale) {
		return this._zoom + (Math.log(scale) / Math.LN2);
	},


	// conversion methods

	project: function (latlng, zoom) { // (LatLng[, Number]) -> Point
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.latLngToPoint(L.latLng(latlng), zoom);
	},

	unproject: function (point, zoom) { // (Point[, Number]) -> LatLng
		zoom = zoom === undefined ? this._zoom : zoom;
		return this.options.crs.pointToLatLng(L.point(point), zoom);
	},

	layerPointToLatLng: function (point) { // (Point)
		var projectedPoint = L.point(point).add(this.getPixelOrigin());
		return this.unproject(projectedPoint);
	},

	latLngToLayerPoint: function (latlng) { // (LatLng)
		var projectedPoint = this.project(L.latLng(latlng))._round();
		return projectedPoint._subtract(this.getPixelOrigin());
	},

	containerPointToLayerPoint: function (point) { // (Point)
		return L.point(point).subtract(this._getMapPanePos());
	},

	layerPointToContainerPoint: function (point) { // (Point)
		return L.point(point).add(this._getMapPanePos());
	},

	containerPointToLatLng: function (point) {
		var layerPoint = this.containerPointToLayerPoint(L.point(point));
		return this.layerPointToLatLng(layerPoint);
	},

	latLngToContainerPoint: function (latlng) {
		return this.layerPointToContainerPoint(this.latLngToLayerPoint(L.latLng(latlng)));
	},

	mouseEventToContainerPoint: function (e) { // (MouseEvent)
		return L.DomEvent.getMousePosition(e, this._container);
	},

	mouseEventToLayerPoint: function (e) { // (MouseEvent)
		return this.containerPointToLayerPoint(this.mouseEventToContainerPoint(e));
	},

	mouseEventToLatLng: function (e) { // (MouseEvent)
		return this.layerPointToLatLng(this.mouseEventToLayerPoint(e));
	},


	// map initialization methods

	_initContainer: function (id) {
		var container = this._container = L.DomUtil.get(id);

		if (!container) {
			throw new Error('Map container not found.');
		} else if (container._leaflet) {
			throw new Error('Map container is already initialized.');
		}

		container._leaflet = true;
	},

	_initLayout: function () {
		var container = this._container;

		L.DomUtil.addClass(container, 'leaflet-container' +
			(L.Browser.touch ? ' leaflet-touch' : '') +
			(L.Browser.retina ? ' leaflet-retina' : '') +
			(L.Browser.ielt9 ? ' leaflet-oldie' : '') +
			(this.options.fadeAnimation ? ' leaflet-fade-anim' : ''));

		var position = L.DomUtil.getStyle(container, 'position');

		if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
			container.style.position = 'relative';
		}

		this._initPanes();

		if (this._initControlPos) {
			this._initControlPos();
		}
	},

	_initPanes: function () {
		var panes = this._panes = {};

		this._mapPane = panes.mapPane = this._createPane('leaflet-map-pane', this._container);

		this._tilePane = panes.tilePane = this._createPane('leaflet-tile-pane', this._mapPane);
		panes.objectsPane = this._createPane('leaflet-objects-pane', this._mapPane);
		panes.shadowPane = this._createPane('leaflet-shadow-pane');
		panes.overlayPane = this._createPane('leaflet-overlay-pane');
		panes.markerPane = this._createPane('leaflet-marker-pane');
		panes.popupPane = this._createPane('leaflet-popup-pane');

		var zoomHide = ' leaflet-zoom-hide';

		if (!this.options.markerZoomAnimation) {
			L.DomUtil.addClass(panes.markerPane, zoomHide);
			L.DomUtil.addClass(panes.shadowPane, zoomHide);
			L.DomUtil.addClass(panes.popupPane, zoomHide);
		}
	},

	_createPane: function (className, container) {
		return L.DomUtil.create('div', className, container || this._panes.objectsPane);
	},

	_clearPanes: function () {
		this._container.removeChild(this._mapPane);
	},

	_addLayers: function (layers) {
		layers = layers ? (L.Util.isArray(layers) ? layers : [layers]) : [];

		for (var i = 0, len = layers.length; i < len; i++) {
			this.addLayer(layers[i]);
		}
	},


	// private methods that modify map state

	_resetView: function (center, zoom, preserveMapOffset, afterZoomAnim) {

		var zoomChanged = (this._zoom !== zoom);

		if (!afterZoomAnim) {
			this.fire('movestart');

			if (zoomChanged) {
				this.fire('zoomstart');
			}
		}

		this._zoom = zoom;
		this._initialCenter = center;

		this._initialTopLeftPoint = this._getNewTopLeftPoint(center);

		if (!preserveMapOffset) {
			L.DomUtil.setPosition(this._mapPane, new L.Point(0, 0));
		} else {
			this._initialTopLeftPoint._add(this._getMapPanePos());
		}

		this._tileLayersToLoad = this._tileLayersNum;

		var loading = !this._loaded;
		this._loaded = true;

		if (loading) {
			this.fire('load');
			this.eachLayer(this._layerAdd, this);
		}

		this.fire('viewreset', {hard: !preserveMapOffset});

		this.fire('move');

		if (zoomChanged || afterZoomAnim) {
			this.fire('zoomend');
		}

		this.fire('moveend', {hard: !preserveMapOffset});
	},

	_rawPanBy: function (offset) {
		L.DomUtil.setPosition(this._mapPane, this._getMapPanePos().subtract(offset));
	},

	_getZoomSpan: function () {
		return this.getMaxZoom() - this.getMinZoom();
	},

	_updateZoomLevels: function () {
		var i,
			minZoom = Infinity,
			maxZoom = -Infinity,
			oldZoomSpan = this._getZoomSpan();

		for (i in this._zoomBoundLayers) {
			var layer = this._zoomBoundLayers[i];
			if (!isNaN(layer.options.minZoom)) {
				minZoom = Math.min(minZoom, layer.options.minZoom);
			}
			if (!isNaN(layer.options.maxZoom)) {
				maxZoom = Math.max(maxZoom, layer.options.maxZoom);
			}
		}

		if (i === undefined) { // we have no tilelayers
			this._layersMaxZoom = this._layersMinZoom = undefined;
		} else {
			this._layersMaxZoom = maxZoom;
			this._layersMinZoom = minZoom;
		}

		if (oldZoomSpan !== this._getZoomSpan()) {
			this.fire('zoomlevelschange');
		}
	},

	_panInsideMaxBounds: function () {
		this.panInsideBounds(this.options.maxBounds);
	},

	_checkIfLoaded: function () {
		if (!this._loaded) {
			throw new Error('Set map center and zoom first.');
		}
	},

	// map events

	_initEvents: function (onOff) {
		if (!L.DomEvent) { return; }

		onOff = onOff || 'on';

		L.DomEvent[onOff](this._container, 'click', this._onMouseClick, this);

		var events = ['dblclick', 'mousedown', 'mouseup', 'mouseenter',
		              'mouseleave', 'mousemove', 'contextmenu'],
		    i, len;

		for (i = 0, len = events.length; i < len; i++) {
			L.DomEvent[onOff](this._container, events[i], this._fireMouseEvent, this);
		}

		if (this.options.trackResize) {
			L.DomEvent[onOff](window, 'resize', this._onResize, this);
		}
	},

	_onResize: function () {
		L.Util.cancelAnimFrame(this._resizeRequest);
		this._resizeRequest = L.Util.requestAnimFrame(
		        function () { this.invalidateSize({debounceMoveend: true}); }, this, false, this._container);
	},

	_onMouseClick: function (e) {
		if (!this._loaded || (!e._simulated &&
		        ((this.dragging && this.dragging.moved()) ||
		         (this.boxZoom  && this.boxZoom.moved()))) ||
		            L.DomEvent._skipped(e)) { return; }

		this.fire('preclick');
		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this._loaded || L.DomEvent._skipped(e)) { return; }

		var type = e.type;

		type = (type === 'mouseenter' ? 'mouseover' : (type === 'mouseleave' ? 'mouseout' : type));

		if (!this.hasEventListeners(type)) { return; }

		if (type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}

		var containerPoint = this.mouseEventToContainerPoint(e),
		    layerPoint = this.containerPointToLayerPoint(containerPoint),
		    latlng = this.layerPointToLatLng(layerPoint);

		this.fire(type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});
	},

	_onTileLayerLoad: function () {
		this._tileLayersToLoad--;
		if (this._tileLayersNum && !this._tileLayersToLoad) {
			this.fire('tilelayersload');
		}
	},

	_clearHandlers: function () {
		for (var i = 0, len = this._handlers.length; i < len; i++) {
			this._handlers[i].disable();
		}
	},

	whenReady: function (callback, context) {
		if (this._loaded) {
			callback.call(context || this, this);
		} else {
			this.on('load', callback, context);
		}
		return this;
	},

	_layerAdd: function (layer) {
		layer.onAdd(this);
		this.fire('layeradd', {layer: layer});
	},


	// private methods for getting map state

	_getMapPanePos: function () {
		return L.DomUtil.getPosition(this._mapPane);
	},

	_moved: function () {
		var pos = this._getMapPanePos();
		return pos && !pos.equals([0, 0]);
	},

	_getTopLeftPoint: function () {
		return this.getPixelOrigin().subtract(this._getMapPanePos());
	},

	_getNewTopLeftPoint: function (center, zoom) {
		var viewHalf = this.getSize()._divideBy(2);
		// TODO round on display, not calculation to increase precision?
		return this.project(center, zoom)._subtract(viewHalf)._round();
	},

	_latLngToNewLayerPoint: function (latlng, newZoom, newCenter) {
		var topLeft = this._getNewTopLeftPoint(newCenter, newZoom).add(this._getMapPanePos());
		return this.project(latlng, newZoom)._subtract(topLeft);
	},

	// layer point of the current center
	_getCenterLayerPoint: function () {
		return this.containerPointToLayerPoint(this.getSize()._divideBy(2));
	},

	// offset of the specified place to the current center in pixels
	_getCenterOffset: function (latlng) {
		return this.latLngToLayerPoint(latlng).subtract(this._getCenterLayerPoint());
	},

	// adjust center for view to get inside bounds
	_limitCenter: function (center, zoom, bounds) {

		if (!bounds) { return center; }

		var centerPoint = this.project(center, zoom),
		    viewHalf = this.getSize().divideBy(2),
		    viewBounds = new L.Bounds(centerPoint.subtract(viewHalf), centerPoint.add(viewHalf)),
		    offset = this._getBoundsOffset(viewBounds, bounds, zoom);

		return this.unproject(centerPoint.add(offset), zoom);
	},

	// adjust offset for view to get inside bounds
	_limitOffset: function (offset, bounds) {
		if (!bounds) { return offset; }

		var viewBounds = this.getPixelBounds(),
		    newBounds = new L.Bounds(viewBounds.min.add(offset), viewBounds.max.add(offset));

		return offset.add(this._getBoundsOffset(newBounds, bounds));
	},

	// returns offset needed for pxBounds to get inside maxBounds at a specified zoom
	_getBoundsOffset: function (pxBounds, maxBounds, zoom) {
		var nwOffset = this.project(maxBounds.getNorthWest(), zoom).subtract(pxBounds.min),
		    seOffset = this.project(maxBounds.getSouthEast(), zoom).subtract(pxBounds.max),

		    dx = this._rebound(nwOffset.x, -seOffset.x),
		    dy = this._rebound(nwOffset.y, -seOffset.y);

		return new L.Point(dx, dy);
	},

	_rebound: function (left, right) {
		return left + right > 0 ?
			Math.round(left - right) / 2 :
			Math.max(0, Math.ceil(left)) - Math.max(0, Math.floor(right));
	},

	_limitZoom: function (zoom) {
		var min = this.getMinZoom(),
		    max = this.getMaxZoom();

		return Math.max(min, Math.min(max, zoom));
	}
});

L.map = function (id, options) {
	return new L.Map(id, options);
};


/*
 * Mercator projection that takes into account that the Earth is not a perfect sphere.
 * Less popular than spherical mercator; used by projections like EPSG:3395.
 */

L.Projection.Mercator = {
	MAX_LATITUDE: 85.0840591556,

	R_MINOR: 6356752.314245179,
	R_MAJOR: 6378137,

	project: function (latlng) { // (LatLng) -> Point
		var d = L.LatLng.DEG_TO_RAD,
		    max = this.MAX_LATITUDE,
		    lat = Math.max(Math.min(max, latlng.lat), -max),
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    x = latlng.lng * d * r,
		    y = lat * d,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1.0 - tmp * tmp),
		    con = eccent * Math.sin(y);

		con = Math.pow((1 - con) / (1 + con), eccent * 0.5);

		var ts = Math.tan(0.5 * ((Math.PI * 0.5) - y)) / con;
		y = -r * Math.log(ts);

		return new L.Point(x, y);
	},

	unproject: function (point) { // (Point, Boolean) -> LatLng
		var d = L.LatLng.RAD_TO_DEG,
		    r = this.R_MAJOR,
		    r2 = this.R_MINOR,
		    lng = point.x * d / r,
		    tmp = r2 / r,
		    eccent = Math.sqrt(1 - (tmp * tmp)),
		    ts = Math.exp(- point.y / r),
		    phi = (Math.PI / 2) - 2 * Math.atan(ts),
		    numIter = 15,
		    tol = 1e-7,
		    i = numIter,
		    dphi = 0.1,
		    con;

		while ((Math.abs(dphi) > tol) && (--i > 0)) {
			con = eccent * Math.sin(phi);
			dphi = (Math.PI / 2) - 2 * Math.atan(ts *
			            Math.pow((1.0 - con) / (1.0 + con), 0.5 * eccent)) - phi;
			phi += dphi;
		}

		return new L.LatLng(phi * d, lng);
	}
};



L.CRS.EPSG3395 = L.extend({}, L.CRS, {
	code: 'EPSG:3395',

	projection: L.Projection.Mercator,

	transformation: (function () {
		var m = L.Projection.Mercator,
		    r = m.R_MAJOR,
		    scale = 0.5 / (Math.PI * r);

		return new L.Transformation(scale, 0.5, -scale, 0.5);
	}())
});


/*
 * L.TileLayer is used for standard xyz-numbered tile layers.
 */

L.TileLayer = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minZoom: 0,
		maxZoom: 18,
		tileSize: 256,
		subdomains: 'abc',
		errorTileUrl: '',
		attribution: '',
		zoomOffset: 0,
		opacity: 1,
		/*
		maxNativeZoom: null,
		zIndex: null,
		tms: false,
		continuousWorld: false,
		noWrap: false,
		zoomReverse: false,
		detectRetina: false,
		reuseTiles: false,
		bounds: false,
		*/
		unloadInvisibleTiles: L.Browser.mobile,
		updateWhenIdle: L.Browser.mobile
	},

	initialize: function (url, options) {
		options = L.setOptions(this, options);

		// detecting retina displays, adjusting tileSize and zoom levels
		if (options.detectRetina && L.Browser.retina && options.maxZoom > 0) {

			options.tileSize = Math.floor(options.tileSize / 2);
			options.zoomOffset++;

			if (options.minZoom > 0) {
				options.minZoom--;
			}
			this.options.maxZoom--;
		}

		if (options.bounds) {
			options.bounds = L.latLngBounds(options.bounds);
		}

		this._url = url;

		var subdomains = this.options.subdomains;

		if (typeof subdomains === 'string') {
			this.options.subdomains = subdomains.split('');
		}
	},

	onAdd: function (map) {
		this._map = map;
		this._animated = map._zoomAnimated;

		// create a container div for tiles
		this._initContainer();

		// set up events
		map.on({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.on({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			this._limitedUpdate = L.Util.limitExecByInterval(this._update, 150, this);
			map.on('move', this._limitedUpdate, this);
		}

		this._reset();
		this._update();
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		this._container.parentNode.removeChild(this._container);

		map.off({
			'viewreset': this._reset,
			'moveend': this._update
		}, this);

		if (this._animated) {
			map.off({
				'zoomanim': this._animateZoom,
				'zoomend': this._endZoomAnim
			}, this);
		}

		if (!this.options.updateWhenIdle) {
			map.off('move', this._limitedUpdate, this);
		}

		this._container = null;
		this._map = null;
	},

	bringToFront: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.appendChild(this._container);
			this._setAutoZIndex(pane, Math.max);
		}

		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.tilePane;

		if (this._container) {
			pane.insertBefore(this._container, pane.firstChild);
			this._setAutoZIndex(pane, Math.min);
		}

		return this;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	getContainer: function () {
		return this._container;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;

		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	setZIndex: function (zIndex) {
		this.options.zIndex = zIndex;
		this._updateZIndex();

		return this;
	},

	setUrl: function (url, noRedraw) {
		this._url = url;

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}
		return this;
	},

	_updateZIndex: function () {
		if (this._container && this.options.zIndex !== undefined) {
			this._container.style.zIndex = this.options.zIndex;
		}
	},

	_setAutoZIndex: function (pane, compare) {

		var layers = pane.children,
		    edgeZIndex = -compare(Infinity, -Infinity), // -Infinity for max, Infinity for min
		    zIndex, i, len;

		for (i = 0, len = layers.length; i < len; i++) {

			if (layers[i] !== this._container) {
				zIndex = parseInt(layers[i].style.zIndex, 10);

				if (!isNaN(zIndex)) {
					edgeZIndex = compare(edgeZIndex, zIndex);
				}
			}
		}

		this.options.zIndex = this._container.style.zIndex =
		        (isFinite(edgeZIndex) ? edgeZIndex : 0) + compare(1, -1);
	},

	_updateOpacity: function () {
		var i,
		    tiles = this._tiles;

		if (L.Browser.ielt9) {
			for (i in tiles) {
				L.DomUtil.setOpacity(tiles[i], this.options.opacity);
			}
		} else {
			L.DomUtil.setOpacity(this._container, this.options.opacity);
		}
	},

	_initContainer: function () {
		var tilePane = this._map._panes.tilePane;

		if (!this._container) {
			this._container = L.DomUtil.create('div', 'leaflet-layer');

			this._updateZIndex();

			if (this._animated) {
				var className = 'leaflet-tile-container';

				this._bgBuffer = L.DomUtil.create('div', className, this._container);
				this._tileContainer = L.DomUtil.create('div', className, this._container);

			} else {
				this._tileContainer = this._container;
			}

			tilePane.appendChild(this._container);

			if (this.options.opacity < 1) {
				this._updateOpacity();
			}
		}
	},

	_reset: function (e) {
		for (var key in this._tiles) {
			this.fire('tileunload', {tile: this._tiles[key]});
		}

		this._tiles = {};
		this._tilesToLoad = 0;

		if (this.options.reuseTiles) {
			this._unusedTiles = [];
		}

		this._tileContainer.innerHTML = '';

		if (this._animated && e && e.hard) {
			this._clearBgBuffer();
		}

		this._initContainer();
	},

	_getTileSize: function () {
		var map = this._map,
		    zoom = map.getZoom() + this.options.zoomOffset,
		    zoomN = this.options.maxNativeZoom,
		    tileSize = this.options.tileSize;

		if (zoomN && zoom > zoomN) {
			tileSize = Math.round(map.getZoomScale(zoom) / map.getZoomScale(zoomN) * tileSize);
		}

		return tileSize;
	},

	_update: function () {

		if (!this._map) { return; }

		var map = this._map,
		    bounds = map.getPixelBounds(),
		    zoom = map.getZoom(),
		    tileSize = this._getTileSize();

		if (zoom > this.options.maxZoom || zoom < this.options.minZoom) {
			return;
		}

		var tileBounds = L.bounds(
		        bounds.min.divideBy(tileSize)._floor(),
		        bounds.max.divideBy(tileSize)._floor());

		this._addTilesFromCenterOut(tileBounds);

		if (this.options.unloadInvisibleTiles || this.options.reuseTiles) {
			this._removeOtherTiles(tileBounds);
		}
	},

	_addTilesFromCenterOut: function (bounds) {
		var queue = [],
		    center = bounds.getCenter();

		var j, i, point;

		for (j = bounds.min.y; j <= bounds.max.y; j++) {
			for (i = bounds.min.x; i <= bounds.max.x; i++) {
				point = new L.Point(i, j);

				if (this._tileShouldBeLoaded(point)) {
					queue.push(point);
				}
			}
		}

		var tilesToLoad = queue.length;

		if (tilesToLoad === 0) { return; }

		// load tiles in order of their distance to center
		queue.sort(function (a, b) {
			return a.distanceTo(center) - b.distanceTo(center);
		});

		var fragment = document.createDocumentFragment();

		// if its the first batch of tiles to load
		if (!this._tilesToLoad) {
			this.fire('loading');
		}

		this._tilesToLoad += tilesToLoad;

		for (i = 0; i < tilesToLoad; i++) {
			this._addTile(queue[i], fragment);
		}

		this._tileContainer.appendChild(fragment);
	},

	_tileShouldBeLoaded: function (tilePoint) {
		if ((tilePoint.x + ':' + tilePoint.y) in this._tiles) {
			return false; // already loaded
		}

		var options = this.options;

		if (!options.continuousWorld) {
			var limit = this._getWrapTileNum();

			// don't load if exceeds world bounds
			if ((options.noWrap && (tilePoint.x < 0 || tilePoint.x >= limit.x)) ||
				tilePoint.y < 0 || tilePoint.y >= limit.y) { return false; }
		}

		if (options.bounds) {
			var tileSize = options.tileSize,
			    nwPoint = tilePoint.multiplyBy(tileSize),
			    sePoint = nwPoint.add([tileSize, tileSize]),
			    nw = this._map.unproject(nwPoint),
			    se = this._map.unproject(sePoint);

			// TODO temporary hack, will be removed after refactoring projections
			// https://github.com/Leaflet/Leaflet/issues/1618
			if (!options.continuousWorld && !options.noWrap) {
				nw = nw.wrap();
				se = se.wrap();
			}

			if (!options.bounds.intersects([nw, se])) { return false; }
		}

		return true;
	},

	_removeOtherTiles: function (bounds) {
		var kArr, x, y, key;

		for (key in this._tiles) {
			kArr = key.split(':');
			x = parseInt(kArr[0], 10);
			y = parseInt(kArr[1], 10);

			// remove tile if it's out of bounds
			if (x < bounds.min.x || x > bounds.max.x || y < bounds.min.y || y > bounds.max.y) {
				this._removeTile(key);
			}
		}
	},

	_removeTile: function (key) {
		var tile = this._tiles[key];

		this.fire('tileunload', {tile: tile, url: tile.src});

		if (this.options.reuseTiles) {
			L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');
			this._unusedTiles.push(tile);

		} else if (tile.parentNode === this._tileContainer) {
			this._tileContainer.removeChild(tile);
		}

		// for https://github.com/CloudMade/Leaflet/issues/137
		if (!L.Browser.android) {
			tile.onload = null;
			tile.src = L.Util.emptyImageUrl;
		}

		delete this._tiles[key];
	},

	_addTile: function (tilePoint, container) {
		var tilePos = this._getTilePos(tilePoint);

		// get unused tile - or create a new tile
		var tile = this._getTile();

		/*
		Chrome 20 layouts much faster with top/left (verify with timeline, frames)
		Android 4 browser has display issues with top/left and requires transform instead
		(other browsers don't currently care) - see debug/hacks/jitter.html for an example
		*/
		L.DomUtil.setPosition(tile, tilePos, L.Browser.chrome);

		this._tiles[tilePoint.x + ':' + tilePoint.y] = tile;

		this._loadTile(tile, tilePoint);

		if (tile.parentNode !== this._tileContainer) {
			container.appendChild(tile);
		}
	},

	_getZoomForUrl: function () {

		var options = this.options,
		    zoom = this._map.getZoom();

		if (options.zoomReverse) {
			zoom = options.maxZoom - zoom;
		}

		zoom += options.zoomOffset;

		return options.maxNativeZoom ? Math.min(zoom, options.maxNativeZoom) : zoom;
	},

	_getTilePos: function (tilePoint) {
		var origin = this._map.getPixelOrigin(),
		    tileSize = this._getTileSize();

		return tilePoint.multiplyBy(tileSize).subtract(origin);
	},

	// image-specific code (override to implement e.g. Canvas or SVG tile layer)

	getTileUrl: function (tilePoint) {
		return L.Util.template(this._url, L.extend({
			s: this._getSubdomain(tilePoint),
			z: tilePoint.z,
			x: tilePoint.x,
			y: tilePoint.y
		}, this.options));
	},

	_getWrapTileNum: function () {
		var crs = this._map.options.crs,
		    size = crs.getSize(this._map.getZoom());
		return size.divideBy(this._getTileSize())._floor();
	},

	_adjustTilePoint: function (tilePoint) {

		var limit = this._getWrapTileNum();

		// wrap tile coordinates
		if (!this.options.continuousWorld && !this.options.noWrap) {
			tilePoint.x = ((tilePoint.x % limit.x) + limit.x) % limit.x;
		}

		if (this.options.tms) {
			tilePoint.y = limit.y - tilePoint.y - 1;
		}

		tilePoint.z = this._getZoomForUrl();
	},

	_getSubdomain: function (tilePoint) {
		var index = Math.abs(tilePoint.x + tilePoint.y) % this.options.subdomains.length;
		return this.options.subdomains[index];
	},

	_getTile: function () {
		if (this.options.reuseTiles && this._unusedTiles.length > 0) {
			var tile = this._unusedTiles.pop();
			this._resetTile(tile);
			return tile;
		}
		return this._createTile();
	},

	// Override if data stored on a tile needs to be cleaned up before reuse
	_resetTile: function (/*tile*/) {},

	_createTile: function () {
		var tile = L.DomUtil.create('img', 'leaflet-tile');
		tile.style.width = tile.style.height = this._getTileSize() + 'px';
		tile.galleryimg = 'no';

		tile.onselectstart = tile.onmousemove = L.Util.falseFn;

		if (L.Browser.ielt9 && this.options.opacity !== undefined) {
			L.DomUtil.setOpacity(tile, this.options.opacity);
		}
		// without this hack, tiles disappear after zoom on Chrome for Android
		// https://github.com/Leaflet/Leaflet/issues/2078
		if (L.Browser.mobileWebkit3d) {
			tile.style.WebkitBackfaceVisibility = 'hidden';
		}
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer  = this;
		tile.onload  = this._tileOnLoad;
		tile.onerror = this._tileOnError;

		this._adjustTilePoint(tilePoint);
		tile.src     = this.getTileUrl(tilePoint);

		this.fire('tileloadstart', {
			tile: tile,
			url: tile.src
		});
	},

	_tileLoaded: function () {
		this._tilesToLoad--;

		if (this._animated) {
			L.DomUtil.addClass(this._tileContainer, 'leaflet-zoom-animated');
		}

		if (!this._tilesToLoad) {
			this.fire('load');

			if (this._animated) {
				// clear scaled tiles after all new tiles are loaded (for performance)
				clearTimeout(this._clearBgBufferTimer);
				this._clearBgBufferTimer = setTimeout(L.bind(this._clearBgBuffer, this), 500);
			}
		}
	},

	_tileOnLoad: function () {
		var layer = this._layer;

		//Only if we are loading an actual image
		if (this.src !== L.Util.emptyImageUrl) {
			L.DomUtil.addClass(this, 'leaflet-tile-loaded');

			layer.fire('tileload', {
				tile: this,
				url: this.src
			});
		}

		layer._tileLoaded();
	},

	_tileOnError: function () {
		var layer = this._layer;

		layer.fire('tileerror', {
			tile: this,
			url: this.src
		});

		var newUrl = layer.options.errorTileUrl;
		if (newUrl) {
			this.src = newUrl;
		}

		layer._tileLoaded();
	}
});

L.tileLayer = function (url, options) {
	return new L.TileLayer(url, options);
};


/*
 * L.TileLayer.WMS is used for putting WMS tile layers on the map.
 */

L.TileLayer.WMS = L.TileLayer.extend({

	defaultWmsParams: {
		service: 'WMS',
		request: 'GetMap',
		version: '1.1.1',
		layers: '',
		styles: '',
		format: 'image/jpeg',
		transparent: false
	},

	initialize: function (url, options) { // (String, Object)

		this._url = url;

		var wmsParams = L.extend({}, this.defaultWmsParams),
		    tileSize = options.tileSize || this.options.tileSize;

		if (options.detectRetina && L.Browser.retina) {
			wmsParams.width = wmsParams.height = tileSize * 2;
		} else {
			wmsParams.width = wmsParams.height = tileSize;
		}

		for (var i in options) {
			// all keys that are not TileLayer options go to WMS params
			if (!this.options.hasOwnProperty(i) && i !== 'crs') {
				wmsParams[i] = options[i];
			}
		}

		this.wmsParams = wmsParams;

		L.setOptions(this, options);
	},

	onAdd: function (map) {

		this._crs = this.options.crs || map.options.crs;

		this._wmsVersion = parseFloat(this.wmsParams.version);

		var projectionKey = this._wmsVersion >= 1.3 ? 'crs' : 'srs';
		this.wmsParams[projectionKey] = this._crs.code;

		L.TileLayer.prototype.onAdd.call(this, map);
	},

	getTileUrl: function (tilePoint) { // (Point, Number) -> String

		var map = this._map,
		    tileSize = this.options.tileSize,

		    nwPoint = tilePoint.multiplyBy(tileSize),
		    sePoint = nwPoint.add([tileSize, tileSize]),

		    nw = this._crs.project(map.unproject(nwPoint, tilePoint.z)),
		    se = this._crs.project(map.unproject(sePoint, tilePoint.z)),
		    bbox = this._wmsVersion >= 1.3 && this._crs === L.CRS.EPSG4326 ?
		        [se.y, nw.x, nw.y, se.x].join(',') :
		        [nw.x, se.y, se.x, nw.y].join(','),

		    url = L.Util.template(this._url, {s: this._getSubdomain(tilePoint)});

		return url + L.Util.getParamString(this.wmsParams, url, true) + '&BBOX=' + bbox;
	},

	setParams: function (params, noRedraw) {

		L.extend(this.wmsParams, params);

		if (!noRedraw) {
			this.redraw();
		}

		return this;
	}
});

L.tileLayer.wms = function (url, options) {
	return new L.TileLayer.WMS(url, options);
};


/*
 * L.TileLayer.Canvas is a class that you can use as a base for creating
 * dynamically drawn Canvas-based tile layers.
 */

L.TileLayer.Canvas = L.TileLayer.extend({
	options: {
		async: false
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	redraw: function () {
		if (this._map) {
			this._reset({hard: true});
			this._update();
		}

		for (var i in this._tiles) {
			this._redrawTile(this._tiles[i]);
		}
		return this;
	},

	_redrawTile: function (tile) {
		this.drawTile(tile, tile._tilePoint, this._map._zoom);
	},

	_createTile: function () {
		var tile = L.DomUtil.create('canvas', 'leaflet-tile');
		tile.width = tile.height = this.options.tileSize;
		tile.onselectstart = tile.onmousemove = L.Util.falseFn;
		return tile;
	},

	_loadTile: function (tile, tilePoint) {
		tile._layer = this;
		tile._tilePoint = tilePoint;

		this._redrawTile(tile);

		if (!this.options.async) {
			this.tileDrawn(tile);
		}
	},

	drawTile: function (/*tile, tilePoint*/) {
		// override with rendering code
	},

	tileDrawn: function (tile) {
		this._tileOnLoad.call(tile);
	}
});


L.tileLayer.canvas = function (options) {
	return new L.TileLayer.Canvas(options);
};


/*
 * L.ImageOverlay is used to overlay images over the map (to specific geographical bounds).
 */

L.ImageOverlay = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		opacity: 1
	},

	initialize: function (url, bounds, options) { // (String, LatLngBounds, Object)
		this._url = url;
		this._bounds = L.latLngBounds(bounds);

		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._image) {
			this._initImage();
		}

		map._panes.overlayPane.appendChild(this._image);

		map.on('viewreset', this._reset, this);

		if (map.options.zoomAnimation && L.Browser.any3d) {
			map.on('zoomanim', this._animateZoom, this);
		}

		this._reset();
	},

	onRemove: function (map) {
		map.getPanes().overlayPane.removeChild(this._image);

		map.off('viewreset', this._reset, this);

		if (map.options.zoomAnimation) {
			map.off('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		this._updateOpacity();
		return this;
	},

	// TODO remove bringToFront/bringToBack duplication from TileLayer/Path
	bringToFront: function () {
		if (this._image) {
			this._map._panes.overlayPane.appendChild(this._image);
		}
		return this;
	},

	bringToBack: function () {
		var pane = this._map._panes.overlayPane;
		if (this._image) {
			pane.insertBefore(this._image, pane.firstChild);
		}
		return this;
	},

	setUrl: function (url) {
		this._url = url;
		this._image.src = this._url;
	},

	getAttribution: function () {
		return this.options.attribution;
	},

	_initImage: function () {
		this._image = L.DomUtil.create('img', 'leaflet-image-layer');

		if (this._map.options.zoomAnimation && L.Browser.any3d) {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-animated');
		} else {
			L.DomUtil.addClass(this._image, 'leaflet-zoom-hide');
		}

		this._updateOpacity();

		//TODO createImage util method to remove duplication
		L.extend(this._image, {
			galleryimg: 'no',
			onselectstart: L.Util.falseFn,
			onmousemove: L.Util.falseFn,
			onload: L.bind(this._onImageLoad, this),
			src: this._url
		});
	},

	_animateZoom: function (e) {
		var map = this._map,
		    image = this._image,
		    scale = map.getZoomScale(e.zoom),
		    nw = this._bounds.getNorthWest(),
		    se = this._bounds.getSouthEast(),

		    topLeft = map._latLngToNewLayerPoint(nw, e.zoom, e.center),
		    size = map._latLngToNewLayerPoint(se, e.zoom, e.center)._subtract(topLeft),
		    origin = topLeft._add(size._multiplyBy((1 / 2) * (1 - 1 / scale)));

		image.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(origin) + ' scale(' + scale + ') ';
	},

	_reset: function () {
		var image   = this._image,
		    topLeft = this._map.latLngToLayerPoint(this._bounds.getNorthWest()),
		    size = this._map.latLngToLayerPoint(this._bounds.getSouthEast())._subtract(topLeft);

		L.DomUtil.setPosition(image, topLeft);

		image.style.width  = size.x + 'px';
		image.style.height = size.y + 'px';
	},

	_onImageLoad: function () {
		this.fire('load');
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._image, this.options.opacity);
	}
});

L.imageOverlay = function (url, bounds, options) {
	return new L.ImageOverlay(url, bounds, options);
};


/*
 * L.Icon is an image-based icon class that you can use with L.Marker for custom markers.
 */

L.Icon = L.Class.extend({
	options: {
		/*
		iconUrl: (String) (required)
		iconRetinaUrl: (String) (optional, used for retina devices if detected)
		iconSize: (Point) (can be set through CSS)
		iconAnchor: (Point) (centered by default, can be set in CSS with negative margins)
		popupAnchor: (Point) (if not specified, popup opens in the anchor point)
		shadowUrl: (String) (no shadow by default)
		shadowRetinaUrl: (String) (optional, used for retina devices if detected)
		shadowSize: (Point)
		shadowAnchor: (Point)
		*/
		className: ''
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	createIcon: function (oldIcon) {
		return this._createIcon('icon', oldIcon);
	},

	createShadow: function (oldIcon) {
		return this._createIcon('shadow', oldIcon);
	},

	_createIcon: function (name, oldIcon) {
		var src = this._getIconUrl(name);

		if (!src) {
			if (name === 'icon') {
				throw new Error('iconUrl not set in Icon options (see the docs).');
			}
			return null;
		}

		var img;
		if (!oldIcon || oldIcon.tagName !== 'IMG') {
			img = this._createImg(src);
		} else {
			img = this._createImg(src, oldIcon);
		}
		this._setIconStyles(img, name);

		return img;
	},

	_setIconStyles: function (img, name) {
		var options = this.options,
		    size = L.point(options[name + 'Size']),
		    anchor;

		if (name === 'shadow') {
			anchor = L.point(options.shadowAnchor || options.iconAnchor);
		} else {
			anchor = L.point(options.iconAnchor);
		}

		if (!anchor && size) {
			anchor = size.divideBy(2, true);
		}

		img.className = 'leaflet-marker-' + name + ' ' + options.className;

		if (anchor) {
			img.style.marginLeft = (-anchor.x) + 'px';
			img.style.marginTop  = (-anchor.y) + 'px';
		}

		if (size) {
			img.style.width  = size.x + 'px';
			img.style.height = size.y + 'px';
		}
	},

	_createImg: function (src, el) {
		el = el || document.createElement('img');
		el.src = src;
		return el;
	},

	_getIconUrl: function (name) {
		if (L.Browser.retina && this.options[name + 'RetinaUrl']) {
			return this.options[name + 'RetinaUrl'];
		}
		return this.options[name + 'Url'];
	}
});

L.icon = function (options) {
	return new L.Icon(options);
};


/*
 * L.Icon.Default is the blue marker icon used by default in Leaflet.
 */

L.Icon.Default = L.Icon.extend({

	options: {
		iconSize: [25, 41],
		iconAnchor: [12, 41],
		popupAnchor: [1, -34],

		shadowSize: [41, 41]
	},

	_getIconUrl: function (name) {
		var key = name + 'Url';

		if (this.options[key]) {
			return this.options[key];
		}

		if (L.Browser.retina && name === 'icon') {
			name += '-2x';
		}

		var path = L.Icon.Default.imagePath;

		if (!path) {
			throw new Error('Couldn\'t autodetect L.Icon.Default.imagePath, set it manually.');
		}

		return path + '/marker-' + name + '.png';
	}
});

L.Icon.Default.imagePath = (function () {
	var scripts = document.getElementsByTagName('script'),
	    leafletRe = /[\/^]leaflet[\-\._]?([\w\-\._]*)\.js\??/;

	var i, len, src, matches, path;

	for (i = 0, len = scripts.length; i < len; i++) {
		src = scripts[i].src;
		matches = src.match(leafletRe);

		if (matches) {
			path = src.split(leafletRe)[0];
			return (path ? path + '/' : '') + 'images';
		}
	}
}());


/*
 * L.Marker is used to display clickable/draggable icons on the map.
 */

L.Marker = L.Class.extend({

	includes: L.Mixin.Events,

	options: {
		icon: new L.Icon.Default(),
		title: '',
		alt: '',
		clickable: true,
		draggable: false,
		keyboard: true,
		zIndexOffset: 0,
		opacity: 1,
		riseOnHover: false,
		riseOffset: 250
	},

	initialize: function (latlng, options) {
		L.setOptions(this, options);
		this._latlng = L.latLng(latlng);
	},

	onAdd: function (map) {
		this._map = map;

		map.on('viewreset', this.update, this);

		this._initIcon();
		this.update();
		this.fire('add');

		if (map.options.zoomAnimation && map.options.markerZoomAnimation) {
			map.on('zoomanim', this._animateZoom, this);
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		if (this.dragging) {
			this.dragging.disable();
		}

		this._removeIcon();
		this._removeShadow();

		this.fire('remove');

		map.off({
			'viewreset': this.update,
			'zoomanim': this._animateZoom
		}, this);

		this._map = null;
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);

		this.update();

		return this.fire('move', { latlng: this._latlng });
	},

	setZIndexOffset: function (offset) {
		this.options.zIndexOffset = offset;
		this.update();

		return this;
	},

	setIcon: function (icon) {

		this.options.icon = icon;

		if (this._map) {
			this._initIcon();
			this.update();
		}

		if (this._popup) {
			this.bindPopup(this._popup);
		}

		return this;
	},

	update: function () {
		if (this._icon) {
			var pos = this._map.latLngToLayerPoint(this._latlng).round();
			this._setPos(pos);
		}

		return this;
	},

	_initIcon: function () {
		var options = this.options,
		    map = this._map,
		    animation = (map.options.zoomAnimation && map.options.markerZoomAnimation),
		    classToAdd = animation ? 'leaflet-zoom-animated' : 'leaflet-zoom-hide';

		var icon = options.icon.createIcon(this._icon),
			addIcon = false;

		// if we're not reusing the icon, remove the old one and init new one
		if (icon !== this._icon) {
			if (this._icon) {
				this._removeIcon();
			}
			addIcon = true;

			if (options.title) {
				icon.title = options.title;
			}
			
			if (options.alt) {
				icon.alt = options.alt;
			}
		}

		L.DomUtil.addClass(icon, classToAdd);

		if (options.keyboard) {
			icon.tabIndex = '0';
		}

		this._icon = icon;

		this._initInteraction();

		if (options.riseOnHover) {
			L.DomEvent
				.on(icon, 'mouseover', this._bringToFront, this)
				.on(icon, 'mouseout', this._resetZIndex, this);
		}

		var newShadow = options.icon.createShadow(this._shadow),
			addShadow = false;

		if (newShadow !== this._shadow) {
			this._removeShadow();
			addShadow = true;
		}

		if (newShadow) {
			L.DomUtil.addClass(newShadow, classToAdd);
		}
		this._shadow = newShadow;


		if (options.opacity < 1) {
			this._updateOpacity();
		}


		var panes = this._map._panes;

		if (addIcon) {
			panes.markerPane.appendChild(this._icon);
		}

		if (newShadow && addShadow) {
			panes.shadowPane.appendChild(this._shadow);
		}
	},

	_removeIcon: function () {
		if (this.options.riseOnHover) {
			L.DomEvent
			    .off(this._icon, 'mouseover', this._bringToFront)
			    .off(this._icon, 'mouseout', this._resetZIndex);
		}

		this._map._panes.markerPane.removeChild(this._icon);

		this._icon = null;
	},

	_removeShadow: function () {
		if (this._shadow) {
			this._map._panes.shadowPane.removeChild(this._shadow);
		}
		this._shadow = null;
	},

	_setPos: function (pos) {
		L.DomUtil.setPosition(this._icon, pos);

		if (this._shadow) {
			L.DomUtil.setPosition(this._shadow, pos);
		}

		this._zIndex = pos.y + this.options.zIndexOffset;

		this._resetZIndex();
	},

	_updateZIndex: function (offset) {
		this._icon.style.zIndex = this._zIndex + offset;
	},

	_animateZoom: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center).round();

		this._setPos(pos);
	},

	_initInteraction: function () {

		if (!this.options.clickable) { return; }

		// TODO refactor into something shared with Map/Path/etc. to DRY it up

		var icon = this._icon,
		    events = ['dblclick', 'mousedown', 'mouseover', 'mouseout', 'contextmenu'];

		L.DomUtil.addClass(icon, 'leaflet-clickable');
		L.DomEvent.on(icon, 'click', this._onMouseClick, this);
		L.DomEvent.on(icon, 'keypress', this._onKeyPress, this);

		for (var i = 0; i < events.length; i++) {
			L.DomEvent.on(icon, events[i], this._fireMouseEvent, this);
		}

		if (L.Handler.MarkerDrag) {
			this.dragging = new L.Handler.MarkerDrag(this);

			if (this.options.draggable) {
				this.dragging.enable();
			}
		}
	},

	_onMouseClick: function (e) {
		var wasDragged = this.dragging && this.dragging.moved();

		if (this.hasEventListeners(e.type) || wasDragged) {
			L.DomEvent.stopPropagation(e);
		}

		if (wasDragged) { return; }

		if ((!this.dragging || !this.dragging._enabled) && this._map.dragging && this._map.dragging.moved()) { return; }

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});
	},

	_onKeyPress: function (e) {
		if (e.keyCode === 13) {
			this.fire('click', {
				originalEvent: e,
				latlng: this._latlng
			});
		}
	},

	_fireMouseEvent: function (e) {

		this.fire(e.type, {
			originalEvent: e,
			latlng: this._latlng
		});

		// TODO proper custom event propagation
		// this line will always be called if marker is in a FeatureGroup
		if (e.type === 'contextmenu' && this.hasEventListeners(e.type)) {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousedown') {
			L.DomEvent.stopPropagation(e);
		} else {
			L.DomEvent.preventDefault(e);
		}
	},

	setOpacity: function (opacity) {
		this.options.opacity = opacity;
		if (this._map) {
			this._updateOpacity();
		}

		return this;
	},

	_updateOpacity: function () {
		L.DomUtil.setOpacity(this._icon, this.options.opacity);
		if (this._shadow) {
			L.DomUtil.setOpacity(this._shadow, this.options.opacity);
		}
	},

	_bringToFront: function () {
		this._updateZIndex(this.options.riseOffset);
	},

	_resetZIndex: function () {
		this._updateZIndex(0);
	}
});

L.marker = function (latlng, options) {
	return new L.Marker(latlng, options);
};


/*
 * L.DivIcon is a lightweight HTML-based icon class (as opposed to the image-based L.Icon)
 * to use with L.Marker.
 */

L.DivIcon = L.Icon.extend({
	options: {
		iconSize: [12, 12], // also can be set through CSS
		/*
		iconAnchor: (Point)
		popupAnchor: (Point)
		html: (String)
		bgPos: (Point)
		*/
		className: 'leaflet-div-icon',
		html: false
	},

	createIcon: function (oldIcon) {
		var div = (oldIcon && oldIcon.tagName === 'DIV') ? oldIcon : document.createElement('div'),
		    options = this.options;

		if (options.html !== false) {
			div.innerHTML = options.html;
		} else {
			div.innerHTML = '';
		}

		if (options.bgPos) {
			div.style.backgroundPosition =
			        (-options.bgPos.x) + 'px ' + (-options.bgPos.y) + 'px';
		}

		this._setIconStyles(div, 'icon');
		return div;
	},

	createShadow: function () {
		return null;
	}
});

L.divIcon = function (options) {
	return new L.DivIcon(options);
};


/*
 * L.Popup is used for displaying popups on the map.
 */

L.Map.mergeOptions({
	closePopupOnClick: true
});

L.Popup = L.Class.extend({
	includes: L.Mixin.Events,

	options: {
		minWidth: 50,
		maxWidth: 300,
		// maxHeight: null,
		autoPan: true,
		closeButton: true,
		offset: [0, 7],
		autoPanPadding: [5, 5],
		// autoPanPaddingTopLeft: null,
		// autoPanPaddingBottomRight: null,
		keepInView: false,
		className: '',
		zoomAnimation: true
	},

	initialize: function (options, source) {
		L.setOptions(this, options);

		this._source = source;
		this._animated = L.Browser.any3d && this.options.zoomAnimation;
		this._isOpen = false;
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initLayout();
		}

		var animFade = map.options.fadeAnimation;

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 0);
		}
		map._panes.popupPane.appendChild(this._container);

		map.on(this._getEvents(), this);

		this.update();

		if (animFade) {
			L.DomUtil.setOpacity(this._container, 1);
		}

		this.fire('open');

		map.fire('popupopen', {popup: this});

		if (this._source) {
			this._source.fire('popupopen', {popup: this});
		}
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	openOn: function (map) {
		map.openPopup(this);
		return this;
	},

	onRemove: function (map) {
		map._panes.popupPane.removeChild(this._container);

		L.Util.falseFn(this._container.offsetWidth); // force reflow

		map.off(this._getEvents(), this);

		if (map.options.fadeAnimation) {
			L.DomUtil.setOpacity(this._container, 0);
		}

		this._map = null;

		this.fire('close');

		map.fire('popupclose', {popup: this});

		if (this._source) {
			this._source.fire('popupclose', {popup: this});
		}
	},

	getLatLng: function () {
		return this._latlng;
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		if (this._map) {
			this._updatePosition();
			this._adjustPan();
		}
		return this;
	},

	getContent: function () {
		return this._content;
	},

	setContent: function (content) {
		this._content = content;
		this.update();
		return this;
	},

	update: function () {
		if (!this._map) { return; }

		this._container.style.visibility = 'hidden';

		this._updateContent();
		this._updateLayout();
		this._updatePosition();

		this._container.style.visibility = '';

		this._adjustPan();
	},

	_getEvents: function () {
		var events = {
			viewreset: this._updatePosition
		};

		if (this._animated) {
			events.zoomanim = this._zoomAnimation;
		}
		if ('closeOnClick' in this.options ? this.options.closeOnClick : this._map.options.closePopupOnClick) {
			events.preclick = this._close;
		}
		if (this.options.keepInView) {
			events.moveend = this._adjustPan;
		}

		return events;
	},

	_close: function () {
		if (this._map) {
			this._map.closePopup(this);
		}
	},

	_initLayout: function () {
		var prefix = 'leaflet-popup',
			containerClass = prefix + ' ' + this.options.className + ' leaflet-zoom-' +
			        (this._animated ? 'animated' : 'hide'),
			container = this._container = L.DomUtil.create('div', containerClass),
			closeButton;

		if (this.options.closeButton) {
			closeButton = this._closeButton =
			        L.DomUtil.create('a', prefix + '-close-button', container);
			closeButton.href = '#close';
			closeButton.innerHTML = '&#215;';
			L.DomEvent.disableClickPropagation(closeButton);

			L.DomEvent.on(closeButton, 'click', this._onCloseButtonClick, this);
		}

		var wrapper = this._wrapper =
		        L.DomUtil.create('div', prefix + '-content-wrapper', container);
		L.DomEvent.disableClickPropagation(wrapper);

		this._contentNode = L.DomUtil.create('div', prefix + '-content', wrapper);

		L.DomEvent.disableScrollPropagation(this._contentNode);
		L.DomEvent.on(wrapper, 'contextmenu', L.DomEvent.stopPropagation);

		this._tipContainer = L.DomUtil.create('div', prefix + '-tip-container', container);
		this._tip = L.DomUtil.create('div', prefix + '-tip', this._tipContainer);
	},

	_updateContent: function () {
		if (!this._content) { return; }

		if (typeof this._content === 'string') {
			this._contentNode.innerHTML = this._content;
		} else {
			while (this._contentNode.hasChildNodes()) {
				this._contentNode.removeChild(this._contentNode.firstChild);
			}
			this._contentNode.appendChild(this._content);
		}
		this.fire('contentupdate');
	},

	_updateLayout: function () {
		var container = this._contentNode,
		    style = container.style;

		style.width = '';
		style.whiteSpace = 'nowrap';

		var width = container.offsetWidth;
		width = Math.min(width, this.options.maxWidth);
		width = Math.max(width, this.options.minWidth);

		style.width = (width + 1) + 'px';
		style.whiteSpace = '';

		style.height = '';

		var height = container.offsetHeight,
		    maxHeight = this.options.maxHeight,
		    scrolledClass = 'leaflet-popup-scrolled';

		if (maxHeight && height > maxHeight) {
			style.height = maxHeight + 'px';
			L.DomUtil.addClass(container, scrolledClass);
		} else {
			L.DomUtil.removeClass(container, scrolledClass);
		}

		this._containerWidth = this._container.offsetWidth;
	},

	_updatePosition: function () {
		if (!this._map) { return; }

		var pos = this._map.latLngToLayerPoint(this._latlng),
		    animated = this._animated,
		    offset = L.point(this.options.offset);

		if (animated) {
			L.DomUtil.setPosition(this._container, pos);
		}

		this._containerBottom = -offset.y - (animated ? 0 : pos.y);
		this._containerLeft = -Math.round(this._containerWidth / 2) + offset.x + (animated ? 0 : pos.x);

		// bottom position the popup in case the height of the popup changes (images loading etc)
		this._container.style.bottom = this._containerBottom + 'px';
		this._container.style.left = this._containerLeft + 'px';
	},

	_zoomAnimation: function (opt) {
		var pos = this._map._latLngToNewLayerPoint(this._latlng, opt.zoom, opt.center);

		L.DomUtil.setPosition(this._container, pos);
	},

	_adjustPan: function () {
		if (!this.options.autoPan) { return; }

		var map = this._map,
		    containerHeight = this._container.offsetHeight,
		    containerWidth = this._containerWidth,

		    layerPos = new L.Point(this._containerLeft, -containerHeight - this._containerBottom);

		if (this._animated) {
			layerPos._add(L.DomUtil.getPosition(this._container));
		}

		var containerPos = map.layerPointToContainerPoint(layerPos),
		    padding = L.point(this.options.autoPanPadding),
		    paddingTL = L.point(this.options.autoPanPaddingTopLeft || padding),
		    paddingBR = L.point(this.options.autoPanPaddingBottomRight || padding),
		    size = map.getSize(),
		    dx = 0,
		    dy = 0;

		if (containerPos.x + containerWidth + paddingBR.x > size.x) { // right
			dx = containerPos.x + containerWidth - size.x + paddingBR.x;
		}
		if (containerPos.x - dx - paddingTL.x < 0) { // left
			dx = containerPos.x - paddingTL.x;
		}
		if (containerPos.y + containerHeight + paddingBR.y > size.y) { // bottom
			dy = containerPos.y + containerHeight - size.y + paddingBR.y;
		}
		if (containerPos.y - dy - paddingTL.y < 0) { // top
			dy = containerPos.y - paddingTL.y;
		}

		if (dx || dy) {
			map
			    .fire('autopanstart')
			    .panBy([dx, dy]);
		}
	},

	_onCloseButtonClick: function (e) {
		this._close();
		L.DomEvent.stop(e);
	}
});

L.popup = function (options, source) {
	return new L.Popup(options, source);
};


L.Map.include({
	openPopup: function (popup, latlng, options) { // (Popup) or (String || HTMLElement, LatLng[, Object])
		this.closePopup();

		if (!(popup instanceof L.Popup)) {
			var content = popup;

			popup = new L.Popup(options)
			    .setLatLng(latlng)
			    .setContent(content);
		}
		popup._isOpen = true;

		this._popup = popup;
		return this.addLayer(popup);
	},

	closePopup: function (popup) {
		if (!popup || popup === this._popup) {
			popup = this._popup;
			this._popup = null;
		}
		if (popup) {
			this.removeLayer(popup);
			popup._isOpen = false;
		}
		return this;
	}
});


/*
 * Popup extension to L.Marker, adding popup-related methods.
 */

L.Marker.include({
	openPopup: function () {
		if (this._popup && this._map && !this._map.hasLayer(this._popup)) {
			this._popup.setLatLng(this._latlng);
			this._map.openPopup(this._popup);
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	togglePopup: function () {
		if (this._popup) {
			if (this._popup._isOpen) {
				this.closePopup();
			} else {
				this.openPopup();
			}
		}
		return this;
	},

	bindPopup: function (content, options) {
		var anchor = L.point(this.options.icon.options.popupAnchor || [0, 0]);

		anchor = anchor.add(L.Popup.prototype.options.offset);

		if (options && options.offset) {
			anchor = anchor.add(options.offset);
		}

		options = L.extend({offset: anchor}, options);

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this.togglePopup, this)
			    .on('remove', this.closePopup, this)
			    .on('move', this._movePopup, this);
			this._popupHandlersAdded = true;
		}

		if (content instanceof L.Popup) {
			L.setOptions(content, options);
			this._popup = content;
		} else {
			this._popup = new L.Popup(options, this)
				.setContent(content);
		}

		return this;
	},

	setPopupContent: function (content) {
		if (this._popup) {
			this._popup.setContent(content);
		}
		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this.togglePopup, this)
			    .off('remove', this.closePopup, this)
			    .off('move', this._movePopup, this);
			this._popupHandlersAdded = false;
		}
		return this;
	},

	getPopup: function () {
		return this._popup;
	},

	_movePopup: function (e) {
		this._popup.setLatLng(e.latlng);
	}
});


/*
 * L.LayerGroup is a class to combine several layers into one so that
 * you can manipulate the group (e.g. add/remove it) as one layer.
 */

L.LayerGroup = L.Class.extend({
	initialize: function (layers) {
		this._layers = {};

		var i, len;

		if (layers) {
			for (i = 0, len = layers.length; i < len; i++) {
				this.addLayer(layers[i]);
			}
		}
	},

	addLayer: function (layer) {
		var id = this.getLayerId(layer);

		this._layers[id] = layer;

		if (this._map) {
			this._map.addLayer(layer);
		}

		return this;
	},

	removeLayer: function (layer) {
		var id = layer in this._layers ? layer : this.getLayerId(layer);

		if (this._map && this._layers[id]) {
			this._map.removeLayer(this._layers[id]);
		}

		delete this._layers[id];

		return this;
	},

	hasLayer: function (layer) {
		if (!layer) { return false; }

		return (layer in this._layers || this.getLayerId(layer) in this._layers);
	},

	clearLayers: function () {
		this.eachLayer(this.removeLayer, this);
		return this;
	},

	invoke: function (methodName) {
		var args = Array.prototype.slice.call(arguments, 1),
		    i, layer;

		for (i in this._layers) {
			layer = this._layers[i];

			if (layer[methodName]) {
				layer[methodName].apply(layer, args);
			}
		}

		return this;
	},

	onAdd: function (map) {
		this._map = map;
		this.eachLayer(map.addLayer, map);
	},

	onRemove: function (map) {
		this.eachLayer(map.removeLayer, map);
		this._map = null;
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	eachLayer: function (method, context) {
		for (var i in this._layers) {
			method.call(context, this._layers[i]);
		}
		return this;
	},

	getLayer: function (id) {
		return this._layers[id];
	},

	getLayers: function () {
		var layers = [];

		for (var i in this._layers) {
			layers.push(this._layers[i]);
		}
		return layers;
	},

	setZIndex: function (zIndex) {
		return this.invoke('setZIndex', zIndex);
	},

	getLayerId: function (layer) {
		return L.stamp(layer);
	}
});

L.layerGroup = function (layers) {
	return new L.LayerGroup(layers);
};


/*
 * L.FeatureGroup extends L.LayerGroup by introducing mouse events and additional methods
 * shared between a group of interactive layers (like vectors or markers).
 */

L.FeatureGroup = L.LayerGroup.extend({
	includes: L.Mixin.Events,

	statics: {
		EVENTS: 'click dblclick mouseover mouseout mousemove contextmenu popupopen popupclose'
	},

	addLayer: function (layer) {
		if (this.hasLayer(layer)) {
			return this;
		}

		if ('on' in layer) {
			layer.on(L.FeatureGroup.EVENTS, this._propagateEvent, this);
		}

		L.LayerGroup.prototype.addLayer.call(this, layer);

		if (this._popupContent && layer.bindPopup) {
			layer.bindPopup(this._popupContent, this._popupOptions);
		}

		return this.fire('layeradd', {layer: layer});
	},

	removeLayer: function (layer) {
		if (!this.hasLayer(layer)) {
			return this;
		}
		if (layer in this._layers) {
			layer = this._layers[layer];
		}

		layer.off(L.FeatureGroup.EVENTS, this._propagateEvent, this);

		L.LayerGroup.prototype.removeLayer.call(this, layer);

		if (this._popupContent) {
			this.invoke('unbindPopup');
		}

		return this.fire('layerremove', {layer: layer});
	},

	bindPopup: function (content, options) {
		this._popupContent = content;
		this._popupOptions = options;
		return this.invoke('bindPopup', content, options);
	},

	openPopup: function (latlng) {
		// open popup on the first layer
		for (var id in this._layers) {
			this._layers[id].openPopup(latlng);
			break;
		}
		return this;
	},

	setStyle: function (style) {
		return this.invoke('setStyle', style);
	},

	bringToFront: function () {
		return this.invoke('bringToFront');
	},

	bringToBack: function () {
		return this.invoke('bringToBack');
	},

	getBounds: function () {
		var bounds = new L.LatLngBounds();

		this.eachLayer(function (layer) {
			bounds.extend(layer instanceof L.Marker ? layer.getLatLng() : layer.getBounds());
		});

		return bounds;
	},

	_propagateEvent: function (e) {
		e = L.extend({
			layer: e.target,
			target: this
		}, e);
		this.fire(e.type, e);
	}
});

L.featureGroup = function (layers) {
	return new L.FeatureGroup(layers);
};


/*
 * L.Path is a base class for rendering vector paths on a map. Inherited by Polyline, Circle, etc.
 */

L.Path = L.Class.extend({
	includes: [L.Mixin.Events],

	statics: {
		// how much to extend the clip area around the map view
		// (relative to its size, e.g. 0.5 is half the screen in each direction)
		// set it so that SVG element doesn't exceed 1280px (vectors flicker on dragend if it is)
		CLIP_PADDING: (function () {
			var max = L.Browser.mobile ? 1280 : 2000,
			    target = (max / Math.max(window.outerWidth, window.outerHeight) - 1) / 2;
			return Math.max(0, Math.min(0.5, target));
		})()
	},

	options: {
		stroke: true,
		color: '#0033ff',
		dashArray: null,
		lineCap: null,
		lineJoin: null,
		weight: 5,
		opacity: 0.5,

		fill: false,
		fillColor: null, //same as color by default
		fillOpacity: 0.2,

		clickable: true
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	onAdd: function (map) {
		this._map = map;

		if (!this._container) {
			this._initElements();
			this._initEvents();
		}

		this.projectLatlngs();
		this._updatePath();

		if (this._container) {
			this._map._pathRoot.appendChild(this._container);
		}

		this.fire('add');

		map.on({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	addTo: function (map) {
		map.addLayer(this);
		return this;
	},

	onRemove: function (map) {
		map._pathRoot.removeChild(this._container);

		// Need to fire remove event before we set _map to null as the event hooks might need the object
		this.fire('remove');
		this._map = null;

		if (L.Browser.vml) {
			this._container = null;
			this._stroke = null;
			this._fill = null;
		}

		map.off({
			'viewreset': this.projectLatlngs,
			'moveend': this._updatePath
		}, this);
	},

	projectLatlngs: function () {
		// do all projection stuff here
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._container) {
			this._updateStyle();
		}

		return this;
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._updatePath();
		}
		return this;
	}
});

L.Map.include({
	_updatePathViewport: function () {
		var p = L.Path.CLIP_PADDING,
		    size = this.getSize(),
		    panePos = L.DomUtil.getPosition(this._mapPane),
		    min = panePos.multiplyBy(-1)._subtract(size.multiplyBy(p)._round()),
		    max = min.add(size.multiplyBy(1 + p * 2)._round());

		this._pathViewport = new L.Bounds(min, max);
	}
});


/*
 * Extends L.Path with SVG-specific rendering code.
 */

L.Path.SVG_NS = 'http://www.w3.org/2000/svg';

L.Browser.svg = !!(document.createElementNS && document.createElementNS(L.Path.SVG_NS, 'svg').createSVGRect);

L.Path = L.Path.extend({
	statics: {
		SVG: L.Browser.svg
	},

	bringToFront: function () {
		var root = this._map._pathRoot,
		    path = this._container;

		if (path && root.lastChild !== path) {
			root.appendChild(path);
		}
		return this;
	},

	bringToBack: function () {
		var root = this._map._pathRoot,
		    path = this._container,
		    first = root.firstChild;

		if (path && first !== path) {
			root.insertBefore(path, first);
		}
		return this;
	},

	getPathString: function () {
		// form path string here
	},

	_createElement: function (name) {
		return document.createElementNS(L.Path.SVG_NS, name);
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._initPath();
		this._initStyle();
	},

	_initPath: function () {
		this._container = this._createElement('g');

		this._path = this._createElement('path');

		if (this.options.className) {
			L.DomUtil.addClass(this._path, this.options.className);
		}

		this._container.appendChild(this._path);
	},

	_initStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke-linejoin', 'round');
			this._path.setAttribute('stroke-linecap', 'round');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill-rule', 'evenodd');
		}
		if (this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', this.options.pointerEvents);
		}
		if (!this.options.clickable && !this.options.pointerEvents) {
			this._path.setAttribute('pointer-events', 'none');
		}
		this._updateStyle();
	},

	_updateStyle: function () {
		if (this.options.stroke) {
			this._path.setAttribute('stroke', this.options.color);
			this._path.setAttribute('stroke-opacity', this.options.opacity);
			this._path.setAttribute('stroke-width', this.options.weight);
			if (this.options.dashArray) {
				this._path.setAttribute('stroke-dasharray', this.options.dashArray);
			} else {
				this._path.removeAttribute('stroke-dasharray');
			}
			if (this.options.lineCap) {
				this._path.setAttribute('stroke-linecap', this.options.lineCap);
			}
			if (this.options.lineJoin) {
				this._path.setAttribute('stroke-linejoin', this.options.lineJoin);
			}
		} else {
			this._path.setAttribute('stroke', 'none');
		}
		if (this.options.fill) {
			this._path.setAttribute('fill', this.options.fillColor || this.options.color);
			this._path.setAttribute('fill-opacity', this.options.fillOpacity);
		} else {
			this._path.setAttribute('fill', 'none');
		}
	},

	_updatePath: function () {
		var str = this.getPathString();
		if (!str) {
			// fix webkit empty string parsing bug
			str = 'M0 0';
		}
		this._path.setAttribute('d', str);
	},

	// TODO remove duplication with L.Map
	_initEvents: function () {
		if (this.options.clickable) {
			if (L.Browser.svg || !L.Browser.vml) {
				L.DomUtil.addClass(this._path, 'leaflet-clickable');
			}

			L.DomEvent.on(this._container, 'click', this._onMouseClick, this);

			var events = ['dblclick', 'mousedown', 'mouseover',
			              'mouseout', 'mousemove', 'contextmenu'];
			for (var i = 0; i < events.length; i++) {
				L.DomEvent.on(this._container, events[i], this._fireMouseEvent, this);
			}
		}
	},

	_onMouseClick: function (e) {
		if (this._map.dragging && this._map.dragging.moved()) { return; }

		this._fireMouseEvent(e);
	},

	_fireMouseEvent: function (e) {
		if (!this.hasEventListeners(e.type)) { return; }

		var map = this._map,
		    containerPoint = map.mouseEventToContainerPoint(e),
		    layerPoint = map.containerPointToLayerPoint(containerPoint),
		    latlng = map.layerPointToLatLng(layerPoint);

		this.fire(e.type, {
			latlng: latlng,
			layerPoint: layerPoint,
			containerPoint: containerPoint,
			originalEvent: e
		});

		if (e.type === 'contextmenu') {
			L.DomEvent.preventDefault(e);
		}
		if (e.type !== 'mousemove') {
			L.DomEvent.stopPropagation(e);
		}
	}
});

L.Map.include({
	_initPathRoot: function () {
		if (!this._pathRoot) {
			this._pathRoot = L.Path.prototype._createElement('svg');
			this._panes.overlayPane.appendChild(this._pathRoot);

			if (this.options.zoomAnimation && L.Browser.any3d) {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-animated');

				this.on({
					'zoomanim': this._animatePathZoom,
					'zoomend': this._endPathZoom
				});
			} else {
				L.DomUtil.addClass(this._pathRoot, 'leaflet-zoom-hide');
			}

			this.on('moveend', this._updateSvgViewport);
			this._updateSvgViewport();
		}
	},

	_animatePathZoom: function (e) {
		var scale = this.getZoomScale(e.zoom),
		    offset = this._getCenterOffset(e.center)._multiplyBy(-scale)._add(this._pathViewport.min);

		this._pathRoot.style[L.DomUtil.TRANSFORM] =
		        L.DomUtil.getTranslateString(offset) + ' scale(' + scale + ') ';

		this._pathZooming = true;
	},

	_endPathZoom: function () {
		this._pathZooming = false;
	},

	_updateSvgViewport: function () {

		if (this._pathZooming) {
			// Do not update SVGs while a zoom animation is going on otherwise the animation will break.
			// When the zoom animation ends we will be updated again anyway
			// This fixes the case where you do a momentum move and zoom while the move is still ongoing.
			return;
		}

		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    max = vp.max,
		    width = max.x - min.x,
		    height = max.y - min.y,
		    root = this._pathRoot,
		    pane = this._panes.overlayPane;

		// Hack to make flicker on drag end on mobile webkit less irritating
		if (L.Browser.mobileWebkit) {
			pane.removeChild(root);
		}

		L.DomUtil.setPosition(root, min);
		root.setAttribute('width', width);
		root.setAttribute('height', height);
		root.setAttribute('viewBox', [min.x, min.y, width, height].join(' '));

		if (L.Browser.mobileWebkit) {
			pane.appendChild(root);
		}
	}
});


/*
 * Popup extension to L.Path (polylines, polygons, circles), adding popup-related methods.
 */

L.Path.include({

	bindPopup: function (content, options) {

		if (content instanceof L.Popup) {
			this._popup = content;
		} else {
			if (!this._popup || options) {
				this._popup = new L.Popup(options, this);
			}
			this._popup.setContent(content);
		}

		if (!this._popupHandlersAdded) {
			this
			    .on('click', this._openPopup, this)
			    .on('remove', this.closePopup, this);

			this._popupHandlersAdded = true;
		}

		return this;
	},

	unbindPopup: function () {
		if (this._popup) {
			this._popup = null;
			this
			    .off('click', this._openPopup)
			    .off('remove', this.closePopup);

			this._popupHandlersAdded = false;
		}
		return this;
	},

	openPopup: function (latlng) {

		if (this._popup) {
			// open the popup from one of the path's points if not specified
			latlng = latlng || this._latlng ||
			         this._latlngs[Math.floor(this._latlngs.length / 2)];

			this._openPopup({latlng: latlng});
		}

		return this;
	},

	closePopup: function () {
		if (this._popup) {
			this._popup._close();
		}
		return this;
	},

	_openPopup: function (e) {
		this._popup.setLatLng(e.latlng);
		this._map.openPopup(this._popup);
	}
});


/*
 * Vector rendering for IE6-8 through VML.
 * Thanks to Dmitry Baranovsky and his Raphael library for inspiration!
 */

L.Browser.vml = !L.Browser.svg && (function () {
	try {
		var div = document.createElement('div');
		div.innerHTML = '<v:shape adj="1"/>';

		var shape = div.firstChild;
		shape.style.behavior = 'url(#default#VML)';

		return shape && (typeof shape.adj === 'object');

	} catch (e) {
		return false;
	}
}());

L.Path = L.Browser.svg || !L.Browser.vml ? L.Path : L.Path.extend({
	statics: {
		VML: true,
		CLIP_PADDING: 0.02
	},

	_createElement: (function () {
		try {
			document.namespaces.add('lvml', 'urn:schemas-microsoft-com:vml');
			return function (name) {
				return document.createElement('<lvml:' + name + ' class="lvml">');
			};
		} catch (e) {
			return function (name) {
				return document.createElement(
				        '<' + name + ' xmlns="urn:schemas-microsoft.com:vml" class="lvml">');
			};
		}
	}()),

	_initPath: function () {
		var container = this._container = this._createElement('shape');

		L.DomUtil.addClass(container, 'leaflet-vml-shape' +
			(this.options.className ? ' ' + this.options.className : ''));

		if (this.options.clickable) {
			L.DomUtil.addClass(container, 'leaflet-clickable');
		}

		container.coordsize = '1 1';

		this._path = this._createElement('path');
		container.appendChild(this._path);

		this._map._pathRoot.appendChild(container);
	},

	_initStyle: function () {
		this._updateStyle();
	},

	_updateStyle: function () {
		var stroke = this._stroke,
		    fill = this._fill,
		    options = this.options,
		    container = this._container;

		container.stroked = options.stroke;
		container.filled = options.fill;

		if (options.stroke) {
			if (!stroke) {
				stroke = this._stroke = this._createElement('stroke');
				stroke.endcap = 'round';
				container.appendChild(stroke);
			}
			stroke.weight = options.weight + 'px';
			stroke.color = options.color;
			stroke.opacity = options.opacity;

			if (options.dashArray) {
				stroke.dashStyle = L.Util.isArray(options.dashArray) ?
				    options.dashArray.join(' ') :
				    options.dashArray.replace(/( *, *)/g, ' ');
			} else {
				stroke.dashStyle = '';
			}
			if (options.lineCap) {
				stroke.endcap = options.lineCap.replace('butt', 'flat');
			}
			if (options.lineJoin) {
				stroke.joinstyle = options.lineJoin;
			}

		} else if (stroke) {
			container.removeChild(stroke);
			this._stroke = null;
		}

		if (options.fill) {
			if (!fill) {
				fill = this._fill = this._createElement('fill');
				container.appendChild(fill);
			}
			fill.color = options.fillColor || options.color;
			fill.opacity = options.fillOpacity;

		} else if (fill) {
			container.removeChild(fill);
			this._fill = null;
		}
	},

	_updatePath: function () {
		var style = this._container.style;

		style.display = 'none';
		this._path.v = this.getPathString() + ' '; // the space fixes IE empty path string bug
		style.display = '';
	}
});

L.Map.include(L.Browser.svg || !L.Browser.vml ? {} : {
	_initPathRoot: function () {
		if (this._pathRoot) { return; }

		var root = this._pathRoot = document.createElement('div');
		root.className = 'leaflet-vml-container';
		this._panes.overlayPane.appendChild(root);

		this.on('moveend', this._updatePathViewport);
		this._updatePathViewport();
	}
});


/*
 * Vector rendering for all browsers that support canvas.
 */

L.Browser.canvas = (function () {
	return !!document.createElement('canvas').getContext;
}());

L.Path = (L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? L.Path : L.Path.extend({
	statics: {
		//CLIP_PADDING: 0.02, // not sure if there's a need to set it to a small value
		CANVAS: true,
		SVG: false
	},

	redraw: function () {
		if (this._map) {
			this.projectLatlngs();
			this._requestUpdate();
		}
		return this;
	},

	setStyle: function (style) {
		L.setOptions(this, style);

		if (this._map) {
			this._updateStyle();
			this._requestUpdate();
		}
		return this;
	},

	onRemove: function (map) {
		map
		    .off('viewreset', this.projectLatlngs, this)
		    .off('moveend', this._updatePath, this);

		if (this.options.clickable) {
			this._map.off('click', this._onClick, this);
			this._map.off('mousemove', this._onMouseMove, this);
		}

		this._requestUpdate();

		this._map = null;
	},

	_requestUpdate: function () {
		if (this._map && !L.Path._updateRequest) {
			L.Path._updateRequest = L.Util.requestAnimFrame(this._fireMapMoveEnd, this._map);
		}
	},

	_fireMapMoveEnd: function () {
		L.Path._updateRequest = null;
		this.fire('moveend');
	},

	_initElements: function () {
		this._map._initPathRoot();
		this._ctx = this._map._canvasCtx;
	},

	_updateStyle: function () {
		var options = this.options;

		if (options.stroke) {
			this._ctx.lineWidth = options.weight;
			this._ctx.strokeStyle = options.color;
		}
		if (options.fill) {
			this._ctx.fillStyle = options.fillColor || options.color;
		}
	},

	_drawPath: function () {
		var i, j, len, len2, point, drawMethod;

		this._ctx.beginPath();

		for (i = 0, len = this._parts.length; i < len; i++) {
			for (j = 0, len2 = this._parts[i].length; j < len2; j++) {
				point = this._parts[i][j];
				drawMethod = (j === 0 ? 'move' : 'line') + 'To';

				this._ctx[drawMethod](point.x, point.y);
			}
			// TODO refactor ugly hack
			if (this instanceof L.Polygon) {
				this._ctx.closePath();
			}
		}
	},

	_checkIfEmpty: function () {
		return !this._parts.length;
	},

	_updatePath: function () {
		if (this._checkIfEmpty()) { return; }

		var ctx = this._ctx,
		    options = this.options;

		this._drawPath();
		ctx.save();
		this._updateStyle();

		if (options.fill) {
			ctx.globalAlpha = options.fillOpacity;
			ctx.fill();
		}

		if (options.stroke) {
			ctx.globalAlpha = options.opacity;
			ctx.stroke();
		}

		ctx.restore();

		// TODO optimization: 1 fill/stroke for all features with equal style instead of 1 for each feature
	},

	_initEvents: function () {
		if (this.options.clickable) {
			// TODO dblclick
			this._map.on('mousemove', this._onMouseMove, this);
			this._map.on('click', this._onClick, this);
		}
	},

	_onClick: function (e) {
		if (this._containsPoint(e.layerPoint)) {
			this.fire('click', e);
		}
	},

	_onMouseMove: function (e) {
		if (!this._map || this._map._animatingZoom) { return; }

		// TODO don't do on each move
		if (this._containsPoint(e.layerPoint)) {
			this._ctx.canvas.style.cursor = 'pointer';
			this._mouseInside = true;
			this.fire('mouseover', e);

		} else if (this._mouseInside) {
			this._ctx.canvas.style.cursor = '';
			this._mouseInside = false;
			this.fire('mouseout', e);
		}
	}
});

L.Map.include((L.Path.SVG && !window.L_PREFER_CANVAS) || !L.Browser.canvas ? {} : {
	_initPathRoot: function () {
		var root = this._pathRoot,
		    ctx;

		if (!root) {
			root = this._pathRoot = document.createElement('canvas');
			root.style.position = 'absolute';
			ctx = this._canvasCtx = root.getContext('2d');

			ctx.lineCap = 'round';
			ctx.lineJoin = 'round';

			this._panes.overlayPane.appendChild(root);

			if (this.options.zoomAnimation) {
				this._pathRoot.className = 'leaflet-zoom-animated';
				this.on('zoomanim', this._animatePathZoom);
				this.on('zoomend', this._endPathZoom);
			}
			this.on('moveend', this._updateCanvasViewport);
			this._updateCanvasViewport();
		}
	},

	_updateCanvasViewport: function () {
		// don't redraw while zooming. See _updateSvgViewport for more details
		if (this._pathZooming) { return; }
		this._updatePathViewport();

		var vp = this._pathViewport,
		    min = vp.min,
		    size = vp.max.subtract(min),
		    root = this._pathRoot;

		//TODO check if this works properly on mobile webkit
		L.DomUtil.setPosition(root, min);
		root.width = size.x;
		root.height = size.y;
		root.getContext('2d').translate(-min.x, -min.y);
	}
});


/*
 * L.LineUtil contains different utility functions for line segments
 * and polylines (clipping, simplification, distances, etc.)
 */

/*jshint bitwise:false */ // allow bitwise operations for this file

L.LineUtil = {

	// Simplify polyline with vertex reduction and Douglas-Peucker simplification.
	// Improves rendering performance dramatically by lessening the number of points to draw.

	simplify: function (/*Point[]*/ points, /*Number*/ tolerance) {
		if (!tolerance || !points.length) {
			return points.slice();
		}

		var sqTolerance = tolerance * tolerance;

		// stage 1: vertex reduction
		points = this._reducePoints(points, sqTolerance);

		// stage 2: Douglas-Peucker simplification
		points = this._simplifyDP(points, sqTolerance);

		return points;
	},

	// distance from a point to a segment between two points
	pointToSegmentDistance:  function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return Math.sqrt(this._sqClosestPointOnSegment(p, p1, p2, true));
	},

	closestPointOnSegment: function (/*Point*/ p, /*Point*/ p1, /*Point*/ p2) {
		return this._sqClosestPointOnSegment(p, p1, p2);
	},

	// Douglas-Peucker simplification, see http://en.wikipedia.org/wiki/Douglas-Peucker_algorithm
	_simplifyDP: function (points, sqTolerance) {

		var len = points.length,
		    ArrayConstructor = typeof Uint8Array !== undefined + '' ? Uint8Array : Array,
		    markers = new ArrayConstructor(len);

		markers[0] = markers[len - 1] = 1;

		this._simplifyDPStep(points, markers, sqTolerance, 0, len - 1);

		var i,
		    newPoints = [];

		for (i = 0; i < len; i++) {
			if (markers[i]) {
				newPoints.push(points[i]);
			}
		}

		return newPoints;
	},

	_simplifyDPStep: function (points, markers, sqTolerance, first, last) {

		var maxSqDist = 0,
		    index, i, sqDist;

		for (i = first + 1; i <= last - 1; i++) {
			sqDist = this._sqClosestPointOnSegment(points[i], points[first], points[last], true);

			if (sqDist > maxSqDist) {
				index = i;
				maxSqDist = sqDist;
			}
		}

		if (maxSqDist > sqTolerance) {
			markers[index] = 1;

			this._simplifyDPStep(points, markers, sqTolerance, first, index);
			this._simplifyDPStep(points, markers, sqTolerance, index, last);
		}
	},

	// reduce points that are too close to each other to a single point
	_reducePoints: function (points, sqTolerance) {
		var reducedPoints = [points[0]];

		for (var i = 1, prev = 0, len = points.length; i < len; i++) {
			if (this._sqDist(points[i], points[prev]) > sqTolerance) {
				reducedPoints.push(points[i]);
				prev = i;
			}
		}
		if (prev < len - 1) {
			reducedPoints.push(points[len - 1]);
		}
		return reducedPoints;
	},

	// Cohen-Sutherland line clipping algorithm.
	// Used to avoid rendering parts of a polyline that are not currently visible.

	clipSegment: function (a, b, bounds, useLastCode) {
		var codeA = useLastCode ? this._lastCode : this._getBitCode(a, bounds),
		    codeB = this._getBitCode(b, bounds),

		    codeOut, p, newCode;

		// save 2nd code to avoid calculating it on the next segment
		this._lastCode = codeB;

		while (true) {
			// if a,b is inside the clip window (trivial accept)
			if (!(codeA | codeB)) {
				return [a, b];
			// if a,b is outside the clip window (trivial reject)
			} else if (codeA & codeB) {
				return false;
			// other cases
			} else {
				codeOut = codeA || codeB;
				p = this._getEdgeIntersection(a, b, codeOut, bounds);
				newCode = this._getBitCode(p, bounds);

				if (codeOut === codeA) {
					a = p;
					codeA = newCode;
				} else {
					b = p;
					codeB = newCode;
				}
			}
		}
	},

	_getEdgeIntersection: function (a, b, code, bounds) {
		var dx = b.x - a.x,
		    dy = b.y - a.y,
		    min = bounds.min,
		    max = bounds.max;

		if (code & 8) { // top
			return new L.Point(a.x + dx * (max.y - a.y) / dy, max.y);
		} else if (code & 4) { // bottom
			return new L.Point(a.x + dx * (min.y - a.y) / dy, min.y);
		} else if (code & 2) { // right
			return new L.Point(max.x, a.y + dy * (max.x - a.x) / dx);
		} else if (code & 1) { // left
			return new L.Point(min.x, a.y + dy * (min.x - a.x) / dx);
		}
	},

	_getBitCode: function (/*Point*/ p, bounds) {
		var code = 0;

		if (p.x < bounds.min.x) { // left
			code |= 1;
		} else if (p.x > bounds.max.x) { // right
			code |= 2;
		}
		if (p.y < bounds.min.y) { // bottom
			code |= 4;
		} else if (p.y > bounds.max.y) { // top
			code |= 8;
		}

		return code;
	},

	// square distance (to avoid unnecessary Math.sqrt calls)
	_sqDist: function (p1, p2) {
		var dx = p2.x - p1.x,
		    dy = p2.y - p1.y;
		return dx * dx + dy * dy;
	},

	// return closest point on segment or distance to that point
	_sqClosestPointOnSegment: function (p, p1, p2, sqDist) {
		var x = p1.x,
		    y = p1.y,
		    dx = p2.x - x,
		    dy = p2.y - y,
		    dot = dx * dx + dy * dy,
		    t;

		if (dot > 0) {
			t = ((p.x - x) * dx + (p.y - y) * dy) / dot;

			if (t > 1) {
				x = p2.x;
				y = p2.y;
			} else if (t > 0) {
				x += dx * t;
				y += dy * t;
			}
		}

		dx = p.x - x;
		dy = p.y - y;

		return sqDist ? dx * dx + dy * dy : new L.Point(x, y);
	}
};


/*
 * L.Polyline is used to display polylines on a map.
 */

L.Polyline = L.Path.extend({
	initialize: function (latlngs, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlngs = this._convertLatLngs(latlngs);
	},

	options: {
		// how much to simplify the polyline on each zoom level
		// more = better performance and smoother look, less = more accurate
		smoothFactor: 1.0,
		noClip: false
	},

	projectLatlngs: function () {
		this._originalPoints = [];

		for (var i = 0, len = this._latlngs.length; i < len; i++) {
			this._originalPoints[i] = this._map.latLngToLayerPoint(this._latlngs[i]);
		}
	},

	getPathString: function () {
		for (var i = 0, len = this._parts.length, str = ''; i < len; i++) {
			str += this._getPathPartStr(this._parts[i]);
		}
		return str;
	},

	getLatLngs: function () {
		return this._latlngs;
	},

	setLatLngs: function (latlngs) {
		this._latlngs = this._convertLatLngs(latlngs);
		return this.redraw();
	},

	addLatLng: function (latlng) {
		this._latlngs.push(L.latLng(latlng));
		return this.redraw();
	},

	spliceLatLngs: function () { // (Number index, Number howMany)
		var removed = [].splice.apply(this._latlngs, arguments);
		this._convertLatLngs(this._latlngs, true);
		this.redraw();
		return removed;
	},

	closestLayerPoint: function (p) {
		var minDistance = Infinity, parts = this._parts, p1, p2, minPoint = null;

		for (var j = 0, jLen = parts.length; j < jLen; j++) {
			var points = parts[j];
			for (var i = 1, len = points.length; i < len; i++) {
				p1 = points[i - 1];
				p2 = points[i];
				var sqDist = L.LineUtil._sqClosestPointOnSegment(p, p1, p2, true);
				if (sqDist < minDistance) {
					minDistance = sqDist;
					minPoint = L.LineUtil._sqClosestPointOnSegment(p, p1, p2);
				}
			}
		}
		if (minPoint) {
			minPoint.distance = Math.sqrt(minDistance);
		}
		return minPoint;
	},

	getBounds: function () {
		return new L.LatLngBounds(this.getLatLngs());
	},

	_convertLatLngs: function (latlngs, overwrite) {
		var i, len, target = overwrite ? latlngs : [];

		for (i = 0, len = latlngs.length; i < len; i++) {
			if (L.Util.isArray(latlngs[i]) && typeof latlngs[i][0] !== 'number') {
				return;
			}
			target[i] = L.latLng(latlngs[i]);
		}
		return target;
	},

	_initEvents: function () {
		L.Path.prototype._initEvents.call(this);
	},

	_getPathPartStr: function (points) {
		var round = L.Path.VML;

		for (var j = 0, len2 = points.length, str = '', p; j < len2; j++) {
			p = points[j];
			if (round) {
				p._round();
			}
			str += (j ? 'L' : 'M') + p.x + ' ' + p.y;
		}
		return str;
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    len = points.length,
		    i, k, segment;

		if (this.options.noClip) {
			this._parts = [points];
			return;
		}

		this._parts = [];

		var parts = this._parts,
		    vp = this._map._pathViewport,
		    lu = L.LineUtil;

		for (i = 0, k = 0; i < len - 1; i++) {
			segment = lu.clipSegment(points[i], points[i + 1], vp, i);
			if (!segment) {
				continue;
			}

			parts[k] = parts[k] || [];
			parts[k].push(segment[0]);

			// if segment goes out of screen, or it's the last one, it's the end of the line part
			if ((segment[1] !== points[i + 1]) || (i === len - 2)) {
				parts[k].push(segment[1]);
				k++;
			}
		}
	},

	// simplify each clipped part of the polyline
	_simplifyPoints: function () {
		var parts = this._parts,
		    lu = L.LineUtil;

		for (var i = 0, len = parts.length; i < len; i++) {
			parts[i] = lu.simplify(parts[i], this.options.smoothFactor);
		}
	},

	_updatePath: function () {
		if (!this._map) { return; }

		this._clipPoints();
		this._simplifyPoints();

		L.Path.prototype._updatePath.call(this);
	}
});

L.polyline = function (latlngs, options) {
	return new L.Polyline(latlngs, options);
};


/*
 * L.PolyUtil contains utility functions for polygons (clipping, etc.).
 */

/*jshint bitwise:false */ // allow bitwise operations here

L.PolyUtil = {};

/*
 * Sutherland-Hodgeman polygon clipping algorithm.
 * Used to avoid rendering parts of a polygon that are not currently visible.
 */
L.PolyUtil.clipPolygon = function (points, bounds) {
	var clippedPoints,
	    edges = [1, 4, 2, 8],
	    i, j, k,
	    a, b,
	    len, edge, p,
	    lu = L.LineUtil;

	for (i = 0, len = points.length; i < len; i++) {
		points[i]._code = lu._getBitCode(points[i], bounds);
	}

	// for each edge (left, bottom, right, top)
	for (k = 0; k < 4; k++) {
		edge = edges[k];
		clippedPoints = [];

		for (i = 0, len = points.length, j = len - 1; i < len; j = i++) {
			a = points[i];
			b = points[j];

			// if a is inside the clip window
			if (!(a._code & edge)) {
				// if b is outside the clip window (a->b goes out of screen)
				if (b._code & edge) {
					p = lu._getEdgeIntersection(b, a, edge, bounds);
					p._code = lu._getBitCode(p, bounds);
					clippedPoints.push(p);
				}
				clippedPoints.push(a);

			// else if b is inside the clip window (a->b enters the screen)
			} else if (!(b._code & edge)) {
				p = lu._getEdgeIntersection(b, a, edge, bounds);
				p._code = lu._getBitCode(p, bounds);
				clippedPoints.push(p);
			}
		}
		points = clippedPoints;
	}

	return points;
};


/*
 * L.Polygon is used to display polygons on a map.
 */

L.Polygon = L.Polyline.extend({
	options: {
		fill: true
	},

	initialize: function (latlngs, options) {
		L.Polyline.prototype.initialize.call(this, latlngs, options);
		this._initWithHoles(latlngs);
	},

	_initWithHoles: function (latlngs) {
		var i, len, hole;
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._latlngs = this._convertLatLngs(latlngs[0]);
			this._holes = latlngs.slice(1);

			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = this._holes[i] = this._convertLatLngs(this._holes[i]);
				if (hole[0].equals(hole[hole.length - 1])) {
					hole.pop();
				}
			}
		}

		// filter out last point if its equal to the first one
		latlngs = this._latlngs;

		if (latlngs.length >= 2 && latlngs[0].equals(latlngs[latlngs.length - 1])) {
			latlngs.pop();
		}
	},

	projectLatlngs: function () {
		L.Polyline.prototype.projectLatlngs.call(this);

		// project polygon holes points
		// TODO move this logic to Polyline to get rid of duplication
		this._holePoints = [];

		if (!this._holes) { return; }

		var i, j, len, len2;

		for (i = 0, len = this._holes.length; i < len; i++) {
			this._holePoints[i] = [];

			for (j = 0, len2 = this._holes[i].length; j < len2; j++) {
				this._holePoints[i][j] = this._map.latLngToLayerPoint(this._holes[i][j]);
			}
		}
	},

	setLatLngs: function (latlngs) {
		if (latlngs && L.Util.isArray(latlngs[0]) && (typeof latlngs[0][0] !== 'number')) {
			this._initWithHoles(latlngs);
			return this.redraw();
		} else {
			return L.Polyline.prototype.setLatLngs.call(this, latlngs);
		}
	},

	_clipPoints: function () {
		var points = this._originalPoints,
		    newParts = [];

		this._parts = [points].concat(this._holePoints);

		if (this.options.noClip) { return; }

		for (var i = 0, len = this._parts.length; i < len; i++) {
			var clipped = L.PolyUtil.clipPolygon(this._parts[i], this._map._pathViewport);
			if (clipped.length) {
				newParts.push(clipped);
			}
		}

		this._parts = newParts;
	},

	_getPathPartStr: function (points) {
		var str = L.Polyline.prototype._getPathPartStr.call(this, points);
		return str + (L.Browser.svg ? 'z' : 'x');
	}
});

L.polygon = function (latlngs, options) {
	return new L.Polygon(latlngs, options);
};


/*
 * Contains L.MultiPolyline and L.MultiPolygon layers.
 */

(function () {
	function createMulti(Klass) {

		return L.FeatureGroup.extend({

			initialize: function (latlngs, options) {
				this._layers = {};
				this._options = options;
				this.setLatLngs(latlngs);
			},

			setLatLngs: function (latlngs) {
				var i = 0,
				    len = latlngs.length;

				this.eachLayer(function (layer) {
					if (i < len) {
						layer.setLatLngs(latlngs[i++]);
					} else {
						this.removeLayer(layer);
					}
				}, this);

				while (i < len) {
					this.addLayer(new Klass(latlngs[i++], this._options));
				}

				return this;
			},

			getLatLngs: function () {
				var latlngs = [];

				this.eachLayer(function (layer) {
					latlngs.push(layer.getLatLngs());
				});

				return latlngs;
			}
		});
	}

	L.MultiPolyline = createMulti(L.Polyline);
	L.MultiPolygon = createMulti(L.Polygon);

	L.multiPolyline = function (latlngs, options) {
		return new L.MultiPolyline(latlngs, options);
	};

	L.multiPolygon = function (latlngs, options) {
		return new L.MultiPolygon(latlngs, options);
	};
}());


/*
 * L.Rectangle extends Polygon and creates a rectangle when passed a LatLngBounds object.
 */

L.Rectangle = L.Polygon.extend({
	initialize: function (latLngBounds, options) {
		L.Polygon.prototype.initialize.call(this, this._boundsToLatLngs(latLngBounds), options);
	},

	setBounds: function (latLngBounds) {
		this.setLatLngs(this._boundsToLatLngs(latLngBounds));
	},

	_boundsToLatLngs: function (latLngBounds) {
		latLngBounds = L.latLngBounds(latLngBounds);
		return [
			latLngBounds.getSouthWest(),
			latLngBounds.getNorthWest(),
			latLngBounds.getNorthEast(),
			latLngBounds.getSouthEast()
		];
	}
});

L.rectangle = function (latLngBounds, options) {
	return new L.Rectangle(latLngBounds, options);
};


/*
 * L.Circle is a circle overlay (with a certain radius in meters).
 */

L.Circle = L.Path.extend({
	initialize: function (latlng, radius, options) {
		L.Path.prototype.initialize.call(this, options);

		this._latlng = L.latLng(latlng);
		this._mRadius = radius;
	},

	options: {
		fill: true
	},

	setLatLng: function (latlng) {
		this._latlng = L.latLng(latlng);
		return this.redraw();
	},

	setRadius: function (radius) {
		this._mRadius = radius;
		return this.redraw();
	},

	projectLatlngs: function () {
		var lngRadius = this._getLngRadius(),
		    latlng = this._latlng,
		    pointLeft = this._map.latLngToLayerPoint([latlng.lat, latlng.lng - lngRadius]);

		this._point = this._map.latLngToLayerPoint(latlng);
		this._radius = Math.max(this._point.x - pointLeft.x, 1);
	},

	getBounds: function () {
		var lngRadius = this._getLngRadius(),
		    latRadius = (this._mRadius / 40075017) * 360,
		    latlng = this._latlng;

		return new L.LatLngBounds(
		        [latlng.lat - latRadius, latlng.lng - lngRadius],
		        [latlng.lat + latRadius, latlng.lng + lngRadius]);
	},

	getLatLng: function () {
		return this._latlng;
	},

	getPathString: function () {
		var p = this._point,
		    r = this._radius;

		if (this._checkIfEmpty()) {
			return '';
		}

		if (L.Browser.svg) {
			return 'M' + p.x + ',' + (p.y - r) +
			       'A' + r + ',' + r + ',0,1,1,' +
			       (p.x - 0.1) + ',' + (p.y - r) + ' z';
		} else {
			p._round();
			r = Math.round(r);
			return 'AL ' + p.x + ',' + p.y + ' ' + r + ',' + r + ' 0,' + (65535 * 360);
		}
	},

	getRadius: function () {
		return this._mRadius;
	},

	// TODO Earth hardcoded, move into projection code!

	_getLatRadius: function () {
		return (this._mRadius / 40075017) * 360;
	},

	_getLngRadius: function () {
		return this._getLatRadius() / Math.cos(L.LatLng.DEG_TO_RAD * this._latlng.lat);
	},

	_checkIfEmpty: function () {
		if (!this._map) {
			return false;
		}
		var vp = this._map._pathViewport,
		    r = this._radius,
		    p = this._point;

		return p.x - r > vp.max.x || p.y - r > vp.max.y ||
		       p.x + r < vp.min.x || p.y + r < vp.min.y;
	}
});

L.circle = function (latlng, radius, options) {
	return new L.Circle(latlng, radius, options);
};


/*
 * L.CircleMarker is a circle overlay with a permanent pixel radius.
 */

L.CircleMarker = L.Circle.extend({
	options: {
		radius: 10,
		weight: 2
	},

	initialize: function (latlng, options) {
		L.Circle.prototype.initialize.call(this, latlng, null, options);
		this._radius = this.options.radius;
	},

	projectLatlngs: function () {
		this._point = this._map.latLngToLayerPoint(this._latlng);
	},

	_updateStyle : function () {
		L.Circle.prototype._updateStyle.call(this);
		this.setRadius(this.options.radius);
	},

	setLatLng: function (latlng) {
		L.Circle.prototype.setLatLng.call(this, latlng);
		if (this._popup && this._popup._isOpen) {
			this._popup.setLatLng(latlng);
		}
		return this;
	},

	setRadius: function (radius) {
		this.options.radius = this._radius = radius;
		return this.redraw();
	},

	getRadius: function () {
		return this._radius;
	}
});

L.circleMarker = function (latlng, options) {
	return new L.CircleMarker(latlng, options);
};


/*
 * Extends L.Polyline to be able to manually detect clicks on Canvas-rendered polylines.
 */

L.Polyline.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p, closed) {
		var i, j, k, len, len2, dist, part,
		    w = this.options.weight / 2;

		if (L.Browser.touch) {
			w += 10; // polyline click tolerance on touch devices
		}

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];
			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				if (!closed && (j === 0)) {
					continue;
				}

				dist = L.LineUtil.pointToSegmentDistance(p, part[k], part[j]);

				if (dist <= w) {
					return true;
				}
			}
		}
		return false;
	}
});


/*
 * Extends L.Polygon to be able to manually detect clicks on Canvas-rendered polygons.
 */

L.Polygon.include(!L.Path.CANVAS ? {} : {
	_containsPoint: function (p) {
		var inside = false,
		    part, p1, p2,
		    i, j, k,
		    len, len2;

		// TODO optimization: check if within bounds first

		if (L.Polyline.prototype._containsPoint.call(this, p, true)) {
			// click on polygon border
			return true;
		}

		// ray casting algorithm for detecting if point is in polygon

		for (i = 0, len = this._parts.length; i < len; i++) {
			part = this._parts[i];

			for (j = 0, len2 = part.length, k = len2 - 1; j < len2; k = j++) {
				p1 = part[j];
				p2 = part[k];

				if (((p1.y > p.y) !== (p2.y > p.y)) &&
						(p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {
					inside = !inside;
				}
			}
		}

		return inside;
	}
});


/*
 * Extends L.Circle with Canvas-specific code.
 */

L.Circle.include(!L.Path.CANVAS ? {} : {
	_drawPath: function () {
		var p = this._point;
		this._ctx.beginPath();
		this._ctx.arc(p.x, p.y, this._radius, 0, Math.PI * 2, false);
	},

	_containsPoint: function (p) {
		var center = this._point,
		    w2 = this.options.stroke ? this.options.weight / 2 : 0;

		return (p.distanceTo(center) <= this._radius + w2);
	}
});


/*
 * CircleMarker canvas specific drawing parts.
 */

L.CircleMarker.include(!L.Path.CANVAS ? {} : {
	_updateStyle: function () {
		L.Path.prototype._updateStyle.call(this);
	}
});


/*
 * L.GeoJSON turns any GeoJSON data into a Leaflet layer.
 */

L.GeoJSON = L.FeatureGroup.extend({

	initialize: function (geojson, options) {
		L.setOptions(this, options);

		this._layers = {};

		if (geojson) {
			this.addData(geojson);
		}
	},

	addData: function (geojson) {
		var features = L.Util.isArray(geojson) ? geojson : geojson.features,
		    i, len, feature;

		if (features) {
			for (i = 0, len = features.length; i < len; i++) {
				// Only add this if geometry or geometries are set and not null
				feature = features[i];
				if (feature.geometries || feature.geometry || feature.features || feature.coordinates) {
					this.addData(features[i]);
				}
			}
			return this;
		}

		var options = this.options;

		if (options.filter && !options.filter(geojson)) { return; }

		var layer = L.GeoJSON.geometryToLayer(geojson, options.pointToLayer, options.coordsToLatLng, options);
		layer.feature = L.GeoJSON.asFeature(geojson);

		layer.defaultOptions = layer.options;
		this.resetStyle(layer);

		if (options.onEachFeature) {
			options.onEachFeature(geojson, layer);
		}

		return this.addLayer(layer);
	},

	resetStyle: function (layer) {
		var style = this.options.style;
		if (style) {
			// reset any custom styles
			L.Util.extend(layer.options, layer.defaultOptions);

			this._setLayerStyle(layer, style);
		}
	},

	setStyle: function (style) {
		this.eachLayer(function (layer) {
			this._setLayerStyle(layer, style);
		}, this);
	},

	_setLayerStyle: function (layer, style) {
		if (typeof style === 'function') {
			style = style(layer.feature);
		}
		if (layer.setStyle) {
			layer.setStyle(style);
		}
	}
});

L.extend(L.GeoJSON, {
	geometryToLayer: function (geojson, pointToLayer, coordsToLatLng, vectorOptions) {
		var geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,
		    coords = geometry.coordinates,
		    layers = [],
		    latlng, latlngs, i, len;

		coordsToLatLng = coordsToLatLng || this.coordsToLatLng;

		switch (geometry.type) {
		case 'Point':
			latlng = coordsToLatLng(coords);
			return pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng);

		case 'MultiPoint':
			for (i = 0, len = coords.length; i < len; i++) {
				latlng = coordsToLatLng(coords[i]);
				layers.push(pointToLayer ? pointToLayer(geojson, latlng) : new L.Marker(latlng));
			}
			return new L.FeatureGroup(layers);

		case 'LineString':
			latlngs = this.coordsToLatLngs(coords, 0, coordsToLatLng);
			return new L.Polyline(latlngs, vectorOptions);

		case 'Polygon':
			if (coords.length === 2 && !coords[1].length) {
				throw new Error('Invalid GeoJSON object.');
			}
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.Polygon(latlngs, vectorOptions);

		case 'MultiLineString':
			latlngs = this.coordsToLatLngs(coords, 1, coordsToLatLng);
			return new L.MultiPolyline(latlngs, vectorOptions);

		case 'MultiPolygon':
			latlngs = this.coordsToLatLngs(coords, 2, coordsToLatLng);
			return new L.MultiPolygon(latlngs, vectorOptions);

		case 'GeometryCollection':
			for (i = 0, len = geometry.geometries.length; i < len; i++) {

				layers.push(this.geometryToLayer({
					geometry: geometry.geometries[i],
					type: 'Feature',
					properties: geojson.properties
				}, pointToLayer, coordsToLatLng, vectorOptions));
			}
			return new L.FeatureGroup(layers);

		default:
			throw new Error('Invalid GeoJSON object.');
		}
	},

	coordsToLatLng: function (coords) { // (Array[, Boolean]) -> LatLng
		return new L.LatLng(coords[1], coords[0], coords[2]);
	},

	coordsToLatLngs: function (coords, levelsDeep, coordsToLatLng) { // (Array[, Number, Function]) -> Array
		var latlng, i, len,
		    latlngs = [];

		for (i = 0, len = coords.length; i < len; i++) {
			latlng = levelsDeep ?
			        this.coordsToLatLngs(coords[i], levelsDeep - 1, coordsToLatLng) :
			        (coordsToLatLng || this.coordsToLatLng)(coords[i]);

			latlngs.push(latlng);
		}

		return latlngs;
	},

	latLngToCoords: function (latlng) {
		var coords = [latlng.lng, latlng.lat];

		if (latlng.alt !== undefined) {
			coords.push(latlng.alt);
		}
		return coords;
	},

	latLngsToCoords: function (latLngs) {
		var coords = [];

		for (var i = 0, len = latLngs.length; i < len; i++) {
			coords.push(L.GeoJSON.latLngToCoords(latLngs[i]));
		}

		return coords;
	},

	getFeature: function (layer, newGeometry) {
		return layer.feature ? L.extend({}, layer.feature, {geometry: newGeometry}) : L.GeoJSON.asFeature(newGeometry);
	},

	asFeature: function (geoJSON) {
		if (geoJSON.type === 'Feature') {
			return geoJSON;
		}

		return {
			type: 'Feature',
			properties: {},
			geometry: geoJSON
		};
	}
});

var PointToGeoJSON = {
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'Point',
			coordinates: L.GeoJSON.latLngToCoords(this.getLatLng())
		});
	}
};

L.Marker.include(PointToGeoJSON);
L.Circle.include(PointToGeoJSON);
L.CircleMarker.include(PointToGeoJSON);

L.Polyline.include({
	toGeoJSON: function () {
		return L.GeoJSON.getFeature(this, {
			type: 'LineString',
			coordinates: L.GeoJSON.latLngsToCoords(this.getLatLngs())
		});
	}
});

L.Polygon.include({
	toGeoJSON: function () {
		var coords = [L.GeoJSON.latLngsToCoords(this.getLatLngs())],
		    i, len, hole;

		coords[0].push(coords[0][0]);

		if (this._holes) {
			for (i = 0, len = this._holes.length; i < len; i++) {
				hole = L.GeoJSON.latLngsToCoords(this._holes[i]);
				hole.push(hole[0]);
				coords.push(hole);
			}
		}

		return L.GeoJSON.getFeature(this, {
			type: 'Polygon',
			coordinates: coords
		});
	}
});

(function () {
	function multiToGeoJSON(type) {
		return function () {
			var coords = [];

			this.eachLayer(function (layer) {
				coords.push(layer.toGeoJSON().geometry.coordinates);
			});

			return L.GeoJSON.getFeature(this, {
				type: type,
				coordinates: coords
			});
		};
	}

	L.MultiPolyline.include({toGeoJSON: multiToGeoJSON('MultiLineString')});
	L.MultiPolygon.include({toGeoJSON: multiToGeoJSON('MultiPolygon')});

	L.LayerGroup.include({
		toGeoJSON: function () {

			var geometry = this.feature && this.feature.geometry,
				jsons = [],
				json;

			if (geometry && geometry.type === 'MultiPoint') {
				return multiToGeoJSON('MultiPoint').call(this);
			}

			var isGeometryCollection = geometry && geometry.type === 'GeometryCollection';

			this.eachLayer(function (layer) {
				if (layer.toGeoJSON) {
					json = layer.toGeoJSON();
					jsons.push(isGeometryCollection ? json.geometry : L.GeoJSON.asFeature(json));
				}
			});

			if (isGeometryCollection) {
				return L.GeoJSON.getFeature(this, {
					geometries: jsons,
					type: 'GeometryCollection'
				});
			}

			return {
				type: 'FeatureCollection',
				features: jsons
			};
		}
	});
}());

L.geoJson = function (geojson, options) {
	return new L.GeoJSON(geojson, options);
};


/*
 * L.DomEvent contains functions for working with DOM events.
 */

L.DomEvent = {
	/* inspired by John Resig, Dean Edwards and YUI addEvent implementations */
	addListener: function (obj, type, fn, context) { // (HTMLElement, String, Function[, Object])

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler, originalHandler, newType;

		if (obj[key]) { return this; }

		handler = function (e) {
			return fn.call(context || obj, e || L.DomEvent._getEvent());
		};

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			return this.addPointerListener(obj, type, handler, id);
		}
		if (L.Browser.touch && (type === 'dblclick') && this.addDoubleTapListener) {
			this.addDoubleTapListener(obj, handler, id);
		}

		if ('addEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.addEventListener('DOMMouseScroll', handler, false);
				obj.addEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {

				originalHandler = handler;
				newType = (type === 'mouseenter' ? 'mouseover' : 'mouseout');

				handler = function (e) {
					if (!L.DomEvent._checkMouse(obj, e)) { return; }
					return originalHandler(e);
				};

				obj.addEventListener(newType, handler, false);

			} else if (type === 'click' && L.Browser.android) {
				originalHandler = handler;
				handler = function (e) {
					return L.DomEvent._filterClick(e, originalHandler);
				};

				obj.addEventListener(type, handler, false);
			} else {
				obj.addEventListener(type, handler, false);
			}

		} else if ('attachEvent' in obj) {
			obj.attachEvent('on' + type, handler);
		}

		obj[key] = handler;

		return this;
	},

	removeListener: function (obj, type, fn) {  // (HTMLElement, String, Function)

		var id = L.stamp(fn),
		    key = '_leaflet_' + type + id,
		    handler = obj[key];

		if (!handler) { return this; }

		if (L.Browser.pointer && type.indexOf('touch') === 0) {
			this.removePointerListener(obj, type, id);
		} else if (L.Browser.touch && (type === 'dblclick') && this.removeDoubleTapListener) {
			this.removeDoubleTapListener(obj, id);

		} else if ('removeEventListener' in obj) {

			if (type === 'mousewheel') {
				obj.removeEventListener('DOMMouseScroll', handler, false);
				obj.removeEventListener(type, handler, false);

			} else if ((type === 'mouseenter') || (type === 'mouseleave')) {
				obj.removeEventListener((type === 'mouseenter' ? 'mouseover' : 'mouseout'), handler, false);
			} else {
				obj.removeEventListener(type, handler, false);
			}
		} else if ('detachEvent' in obj) {
			obj.detachEvent('on' + type, handler);
		}

		obj[key] = null;

		return this;
	},

	stopPropagation: function (e) {

		if (e.stopPropagation) {
			e.stopPropagation();
		} else {
			e.cancelBubble = true;
		}
		L.DomEvent._skipped(e);

		return this;
	},

	disableScrollPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		return L.DomEvent
			.on(el, 'mousewheel', stop)
			.on(el, 'MozMousePixelScroll', stop);
	},

	disableClickPropagation: function (el) {
		var stop = L.DomEvent.stopPropagation;

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(el, L.Draggable.START[i], stop);
		}

		return L.DomEvent
			.on(el, 'click', L.DomEvent._fakeStop)
			.on(el, 'dblclick', stop);
	},

	preventDefault: function (e) {

		if (e.preventDefault) {
			e.preventDefault();
		} else {
			e.returnValue = false;
		}
		return this;
	},

	stop: function (e) {
		return L.DomEvent
			.preventDefault(e)
			.stopPropagation(e);
	},

	getMousePosition: function (e, container) {
		if (!container) {
			return new L.Point(e.clientX, e.clientY);
		}

		var rect = container.getBoundingClientRect();

		return new L.Point(
			e.clientX - rect.left - container.clientLeft,
			e.clientY - rect.top - container.clientTop);
	},

	getWheelDelta: function (e) {

		var delta = 0;

		if (e.wheelDelta) {
			delta = e.wheelDelta / 120;
		}
		if (e.detail) {
			delta = -e.detail / 3;
		}
		return delta;
	},

	_skipEvents: {},

	_fakeStop: function (e) {
		// fakes stopPropagation by setting a special event flag, checked/reset with L.DomEvent._skipped(e)
		L.DomEvent._skipEvents[e.type] = true;
	},

	_skipped: function (e) {
		var skipped = this._skipEvents[e.type];
		// reset when checking, as it's only used in map container and propagates outside of the map
		this._skipEvents[e.type] = false;
		return skipped;
	},

	// check if element really left/entered the event target (for mouseenter/mouseleave)
	_checkMouse: function (el, e) {

		var related = e.relatedTarget;

		if (!related) { return true; }

		try {
			while (related && (related !== el)) {
				related = related.parentNode;
			}
		} catch (err) {
			return false;
		}
		return (related !== el);
	},

	_getEvent: function () { // evil magic for IE
		/*jshint noarg:false */
		var e = window.event;
		if (!e) {
			var caller = arguments.callee.caller;
			while (caller) {
				e = caller['arguments'][0];
				if (e && window.Event === e.constructor) {
					break;
				}
				caller = caller.caller;
			}
		}
		return e;
	},

	// this is a horrible workaround for a bug in Android where a single touch triggers two click events
	_filterClick: function (e, handler) {
		var timeStamp = (e.timeStamp || e.originalEvent.timeStamp),
			elapsed = L.DomEvent._lastClick && (timeStamp - L.DomEvent._lastClick);

		// are they closer together than 1000ms yet more than 100ms?
		// Android typically triggers them ~300ms apart while multiple listeners
		// on the same event should be triggered far faster;
		// or check if click is simulated on the element, and if it is, reject any non-simulated events

		if ((elapsed && elapsed > 100 && elapsed < 1000) || (e.target._simulatedClick && !e._simulated)) {
			L.DomEvent.stop(e);
			return;
		}
		L.DomEvent._lastClick = timeStamp;

		return handler(e);
	}
};

L.DomEvent.on = L.DomEvent.addListener;
L.DomEvent.off = L.DomEvent.removeListener;


/*
 * L.Draggable allows you to add dragging capabilities to any element. Supports mobile devices too.
 */

L.Draggable = L.Class.extend({
	includes: L.Mixin.Events,

	statics: {
		START: L.Browser.touch ? ['touchstart', 'mousedown'] : ['mousedown'],
		END: {
			mousedown: 'mouseup',
			touchstart: 'touchend',
			pointerdown: 'touchend',
			MSPointerDown: 'touchend'
		},
		MOVE: {
			mousedown: 'mousemove',
			touchstart: 'touchmove',
			pointerdown: 'touchmove',
			MSPointerDown: 'touchmove'
		}
	},

	initialize: function (element, dragStartTarget) {
		this._element = element;
		this._dragStartTarget = dragStartTarget || element;
	},

	enable: function () {
		if (this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.on(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = true;
	},

	disable: function () {
		if (!this._enabled) { return; }

		for (var i = L.Draggable.START.length - 1; i >= 0; i--) {
			L.DomEvent.off(this._dragStartTarget, L.Draggable.START[i], this._onDown, this);
		}

		this._enabled = false;
		this._moved = false;
	},

	_onDown: function (e) {
		this._moved = false;

		if (e.shiftKey || ((e.which !== 1) && (e.button !== 1) && !e.touches)) { return; }

		L.DomEvent.stopPropagation(e);

		if (L.Draggable._disabled) { return; }

		L.DomUtil.disableImageDrag();
		L.DomUtil.disableTextSelection();

		if (this._moving) { return; }

		var first = e.touches ? e.touches[0] : e;

		this._startPoint = new L.Point(first.clientX, first.clientY);
		this._startPos = this._newPos = L.DomUtil.getPosition(this._element);

		L.DomEvent
		    .on(document, L.Draggable.MOVE[e.type], this._onMove, this)
		    .on(document, L.Draggable.END[e.type], this._onUp, this);
	},

	_onMove: function (e) {
		if (e.touches && e.touches.length > 1) {
			this._moved = true;
			return;
		}

		var first = (e.touches && e.touches.length === 1 ? e.touches[0] : e),
		    newPoint = new L.Point(first.clientX, first.clientY),
		    offset = newPoint.subtract(this._startPoint);

		if (!offset.x && !offset.y) { return; }

		L.DomEvent.preventDefault(e);

		if (!this._moved) {
			this.fire('dragstart');

			this._moved = true;
			this._startPos = L.DomUtil.getPosition(this._element).subtract(offset);

			L.DomUtil.addClass(document.body, 'leaflet-dragging');
			L.DomUtil.addClass((e.target || e.srcElement), 'leaflet-drag-target');
		}

		this._newPos = this._startPos.add(offset);
		this._moving = true;

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(this._updatePosition, this, true, this._dragStartTarget);
	},

	_updatePosition: function () {
		this.fire('predrag');
		L.DomUtil.setPosition(this._element, this._newPos);
		this.fire('drag');
	},

	_onUp: function (e) {
		L.DomUtil.removeClass(document.body, 'leaflet-dragging');
		L.DomUtil.removeClass((e.target || e.srcElement), 'leaflet-drag-target');

		for (var i in L.Draggable.MOVE) {
			L.DomEvent
			    .off(document, L.Draggable.MOVE[i], this._onMove)
			    .off(document, L.Draggable.END[i], this._onUp);
		}

		L.DomUtil.enableImageDrag();
		L.DomUtil.enableTextSelection();

		if (this._moved && this._moving) {
			// ensure drag is not fired after dragend
			L.Util.cancelAnimFrame(this._animRequest);

			this.fire('dragend', {
				distance: this._newPos.distanceTo(this._startPos)
			});
		}

		this._moving = false;
	}
});


/*
	L.Handler is a base class for handler classes that are used internally to inject
	interaction features like dragging to classes like Map and Marker.
*/

L.Handler = L.Class.extend({
	initialize: function (map) {
		this._map = map;
	},

	enable: function () {
		if (this._enabled) { return; }

		this._enabled = true;
		this.addHooks();
	},

	disable: function () {
		if (!this._enabled) { return; }

		this._enabled = false;
		this.removeHooks();
	},

	enabled: function () {
		return !!this._enabled;
	}
});


/*
 * L.Handler.MapDrag is used to make the map draggable (with panning inertia), enabled by default.
 */

L.Map.mergeOptions({
	dragging: true,

	inertia: !L.Browser.android23,
	inertiaDeceleration: 3400, // px/s^2
	inertiaMaxSpeed: Infinity, // px/s
	inertiaThreshold: L.Browser.touch ? 32 : 18, // ms
	easeLinearity: 0.25,

	// TODO refactor, move to CRS
	worldCopyJump: false
});

L.Map.Drag = L.Handler.extend({
	addHooks: function () {
		if (!this._draggable) {
			var map = this._map;

			this._draggable = new L.Draggable(map._mapPane, map._container);

			this._draggable.on({
				'dragstart': this._onDragStart,
				'drag': this._onDrag,
				'dragend': this._onDragEnd
			}, this);

			if (map.options.worldCopyJump) {
				this._draggable.on('predrag', this._onPreDrag, this);
				map.on('viewreset', this._onViewReset, this);

				map.whenReady(this._onViewReset, this);
			}
		}
		this._draggable.enable();
	},

	removeHooks: function () {
		this._draggable.disable();
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		var map = this._map;

		if (map._panAnim) {
			map._panAnim.stop();
		}

		map
		    .fire('movestart')
		    .fire('dragstart');

		if (map.options.inertia) {
			this._positions = [];
			this._times = [];
		}
	},

	_onDrag: function () {
		if (this._map.options.inertia) {
			var time = this._lastTime = +new Date(),
			    pos = this._lastPos = this._draggable._newPos;

			this._positions.push(pos);
			this._times.push(time);

			if (time - this._times[0] > 200) {
				this._positions.shift();
				this._times.shift();
			}
		}

		this._map
		    .fire('move')
		    .fire('drag');
	},

	_onViewReset: function () {
		// TODO fix hardcoded Earth values
		var pxCenter = this._map.getSize()._divideBy(2),
		    pxWorldCenter = this._map.latLngToLayerPoint([0, 0]);

		this._initialWorldOffset = pxWorldCenter.subtract(pxCenter).x;
		this._worldWidth = this._map.project([0, 180]).x;
	},

	_onPreDrag: function () {
		// TODO refactor to be able to adjust map pane position after zoom
		var worldWidth = this._worldWidth,
		    halfWidth = Math.round(worldWidth / 2),
		    dx = this._initialWorldOffset,
		    x = this._draggable._newPos.x,
		    newX1 = (x - halfWidth + dx) % worldWidth + halfWidth - dx,
		    newX2 = (x + halfWidth + dx) % worldWidth - halfWidth - dx,
		    newX = Math.abs(newX1 + dx) < Math.abs(newX2 + dx) ? newX1 : newX2;

		this._draggable._newPos.x = newX;
	},

	_onDragEnd: function (e) {
		var map = this._map,
		    options = map.options,
		    delay = +new Date() - this._lastTime,

		    noInertia = !options.inertia || delay > options.inertiaThreshold || !this._positions[0];

		map.fire('dragend', e);

		if (noInertia) {
			map.fire('moveend');

		} else {

			var direction = this._lastPos.subtract(this._positions[0]),
			    duration = (this._lastTime + delay - this._times[0]) / 1000,
			    ease = options.easeLinearity,

			    speedVector = direction.multiplyBy(ease / duration),
			    speed = speedVector.distanceTo([0, 0]),

			    limitedSpeed = Math.min(options.inertiaMaxSpeed, speed),
			    limitedSpeedVector = speedVector.multiplyBy(limitedSpeed / speed),

			    decelerationDuration = limitedSpeed / (options.inertiaDeceleration * ease),
			    offset = limitedSpeedVector.multiplyBy(-decelerationDuration / 2).round();

			if (!offset.x || !offset.y) {
				map.fire('moveend');

			} else {
				offset = map._limitOffset(offset, map.options.maxBounds);

				L.Util.requestAnimFrame(function () {
					map.panBy(offset, {
						duration: decelerationDuration,
						easeLinearity: ease,
						noMoveStart: true
					});
				});
			}
		}
	}
});

L.Map.addInitHook('addHandler', 'dragging', L.Map.Drag);


/*
 * L.Handler.DoubleClickZoom is used to handle double-click zoom on the map, enabled by default.
 */

L.Map.mergeOptions({
	doubleClickZoom: true
});

L.Map.DoubleClickZoom = L.Handler.extend({
	addHooks: function () {
		this._map.on('dblclick', this._onDoubleClick, this);
	},

	removeHooks: function () {
		this._map.off('dblclick', this._onDoubleClick, this);
	},

	_onDoubleClick: function (e) {
		var map = this._map,
		    zoom = map.getZoom() + (e.originalEvent.shiftKey ? -1 : 1);

		if (map.options.doubleClickZoom === 'center') {
			map.setZoom(zoom);
		} else {
			map.setZoomAround(e.containerPoint, zoom);
		}
	}
});

L.Map.addInitHook('addHandler', 'doubleClickZoom', L.Map.DoubleClickZoom);


/*
 * L.Handler.ScrollWheelZoom is used by L.Map to enable mouse scroll wheel zoom on the map.
 */

L.Map.mergeOptions({
	scrollWheelZoom: true
});

L.Map.ScrollWheelZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'mousewheel', this._onWheelScroll, this);
		L.DomEvent.on(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
		this._delta = 0;
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'mousewheel', this._onWheelScroll);
		L.DomEvent.off(this._map._container, 'MozMousePixelScroll', L.DomEvent.preventDefault);
	},

	_onWheelScroll: function (e) {
		var delta = L.DomEvent.getWheelDelta(e);

		this._delta += delta;
		this._lastMousePos = this._map.mouseEventToContainerPoint(e);

		if (!this._startTime) {
			this._startTime = +new Date();
		}

		var left = Math.max(40 - (+new Date() - this._startTime), 0);

		clearTimeout(this._timer);
		this._timer = setTimeout(L.bind(this._performZoom, this), left);

		L.DomEvent.preventDefault(e);
		L.DomEvent.stopPropagation(e);
	},

	_performZoom: function () {
		var map = this._map,
		    delta = this._delta,
		    zoom = map.getZoom();

		delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
		delta = Math.max(Math.min(delta, 4), -4);
		delta = map._limitZoom(zoom + delta) - zoom;

		this._delta = 0;
		this._startTime = null;

		if (!delta) { return; }

		if (map.options.scrollWheelZoom === 'center') {
			map.setZoom(zoom + delta);
		} else {
			map.setZoomAround(this._lastMousePos, zoom + delta);
		}
	}
});

L.Map.addInitHook('addHandler', 'scrollWheelZoom', L.Map.ScrollWheelZoom);


/*
 * Extends the event handling code with double tap support for mobile browsers.
 */

L.extend(L.DomEvent, {

	_touchstart: L.Browser.msPointer ? 'MSPointerDown' : L.Browser.pointer ? 'pointerdown' : 'touchstart',
	_touchend: L.Browser.msPointer ? 'MSPointerUp' : L.Browser.pointer ? 'pointerup' : 'touchend',

	// inspired by Zepto touch code by Thomas Fuchs
	addDoubleTapListener: function (obj, handler, id) {
		var last,
		    doubleTap = false,
		    delay = 250,
		    touch,
		    pre = '_leaflet_',
		    touchstart = this._touchstart,
		    touchend = this._touchend,
		    trackedTouches = [];

		function onTouchStart(e) {
			var count;

			if (L.Browser.pointer) {
				trackedTouches.push(e.pointerId);
				count = trackedTouches.length;
			} else {
				count = e.touches.length;
			}
			if (count > 1) {
				return;
			}

			var now = Date.now(),
				delta = now - (last || now);

			touch = e.touches ? e.touches[0] : e;
			doubleTap = (delta > 0 && delta <= delay);
			last = now;
		}

		function onTouchEnd(e) {
			if (L.Browser.pointer) {
				var idx = trackedTouches.indexOf(e.pointerId);
				if (idx === -1) {
					return;
				}
				trackedTouches.splice(idx, 1);
			}

			if (doubleTap) {
				if (L.Browser.pointer) {
					// work around .type being readonly with MSPointer* events
					var newTouch = { },
						prop;

					// jshint forin:false
					for (var i in touch) {
						prop = touch[i];
						if (typeof prop === 'function') {
							newTouch[i] = prop.bind(touch);
						} else {
							newTouch[i] = prop;
						}
					}
					touch = newTouch;
				}
				touch.type = 'dblclick';
				handler(touch);
				last = null;
			}
		}
		obj[pre + touchstart + id] = onTouchStart;
		obj[pre + touchend + id] = onTouchEnd;

		// on pointer we need to listen on the document, otherwise a drag starting on the map and moving off screen
		// will not come through to us, so we will lose track of how many touches are ongoing
		var endElement = L.Browser.pointer ? document.documentElement : obj;

		obj.addEventListener(touchstart, onTouchStart, false);
		endElement.addEventListener(touchend, onTouchEnd, false);

		if (L.Browser.pointer) {
			endElement.addEventListener(L.DomEvent.POINTER_CANCEL, onTouchEnd, false);
		}

		return this;
	},

	removeDoubleTapListener: function (obj, id) {
		var pre = '_leaflet_';

		obj.removeEventListener(this._touchstart, obj[pre + this._touchstart + id], false);
		(L.Browser.pointer ? document.documentElement : obj).removeEventListener(
		        this._touchend, obj[pre + this._touchend + id], false);

		if (L.Browser.pointer) {
			document.documentElement.removeEventListener(L.DomEvent.POINTER_CANCEL, obj[pre + this._touchend + id],
				false);
		}

		return this;
	}
});


/*
 * Extends L.DomEvent to provide touch support for Internet Explorer and Windows-based devices.
 */

L.extend(L.DomEvent, {

	//static
	POINTER_DOWN: L.Browser.msPointer ? 'MSPointerDown' : 'pointerdown',
	POINTER_MOVE: L.Browser.msPointer ? 'MSPointerMove' : 'pointermove',
	POINTER_UP: L.Browser.msPointer ? 'MSPointerUp' : 'pointerup',
	POINTER_CANCEL: L.Browser.msPointer ? 'MSPointerCancel' : 'pointercancel',

	_pointers: [],
	_pointerDocumentListener: false,

	// Provides a touch events wrapper for (ms)pointer events.
	// Based on changes by veproza https://github.com/CloudMade/Leaflet/pull/1019
	//ref http://www.w3.org/TR/pointerevents/ https://www.w3.org/Bugs/Public/show_bug.cgi?id=22890

	addPointerListener: function (obj, type, handler, id) {

		switch (type) {
		case 'touchstart':
			return this.addPointerListenerStart(obj, type, handler, id);
		case 'touchend':
			return this.addPointerListenerEnd(obj, type, handler, id);
		case 'touchmove':
			return this.addPointerListenerMove(obj, type, handler, id);
		default:
			throw 'Unknown touch event type';
		}
	},

	addPointerListenerStart: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    pointers = this._pointers;

		var cb = function (e) {

			L.DomEvent.preventDefault(e);

			var alreadyInArray = false;
			for (var i = 0; i < pointers.length; i++) {
				if (pointers[i].pointerId === e.pointerId) {
					alreadyInArray = true;
					break;
				}
			}
			if (!alreadyInArray) {
				pointers.push(e);
			}

			e.touches = pointers.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchstart' + id] = cb;
		obj.addEventListener(this.POINTER_DOWN, cb, false);

		// need to also listen for end events to keep the _pointers list accurate
		// this needs to be on the body and never go away
		if (!this._pointerDocumentListener) {
			var internalCb = function (e) {
				for (var i = 0; i < pointers.length; i++) {
					if (pointers[i].pointerId === e.pointerId) {
						pointers.splice(i, 1);
						break;
					}
				}
			};
			//We listen on the documentElement as any drags that end by moving the touch off the screen get fired there
			document.documentElement.addEventListener(this.POINTER_UP, internalCb, false);
			document.documentElement.addEventListener(this.POINTER_CANCEL, internalCb, false);

			this._pointerDocumentListener = true;
		}

		return this;
	},

	addPointerListenerMove: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		function cb(e) {

			// don't fire touch moves when mouse isn't down
			if ((e.pointerType === e.MSPOINTER_TYPE_MOUSE || e.pointerType === 'mouse') && e.buttons === 0) { return; }

			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches[i] = e;
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		}

		obj[pre + 'touchmove' + id] = cb;
		obj.addEventListener(this.POINTER_MOVE, cb, false);

		return this;
	},

	addPointerListenerEnd: function (obj, type, handler, id) {
		var pre = '_leaflet_',
		    touches = this._pointers;

		var cb = function (e) {
			for (var i = 0; i < touches.length; i++) {
				if (touches[i].pointerId === e.pointerId) {
					touches.splice(i, 1);
					break;
				}
			}

			e.touches = touches.slice();
			e.changedTouches = [e];

			handler(e);
		};

		obj[pre + 'touchend' + id] = cb;
		obj.addEventListener(this.POINTER_UP, cb, false);
		obj.addEventListener(this.POINTER_CANCEL, cb, false);

		return this;
	},

	removePointerListener: function (obj, type, id) {
		var pre = '_leaflet_',
		    cb = obj[pre + type + id];

		switch (type) {
		case 'touchstart':
			obj.removeEventListener(this.POINTER_DOWN, cb, false);
			break;
		case 'touchmove':
			obj.removeEventListener(this.POINTER_MOVE, cb, false);
			break;
		case 'touchend':
			obj.removeEventListener(this.POINTER_UP, cb, false);
			obj.removeEventListener(this.POINTER_CANCEL, cb, false);
			break;
		}

		return this;
	}
});


/*
 * L.Handler.TouchZoom is used by L.Map to add pinch zoom on supported mobile browsers.
 */

L.Map.mergeOptions({
	touchZoom: L.Browser.touch && !L.Browser.android23,
	bounceAtZoomLimits: true
});

L.Map.TouchZoom = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onTouchStart, this);
	},

	_onTouchStart: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || map._animatingZoom || this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]),
		    viewCenter = map._getCenterLayerPoint();

		this._startCenter = p1.add(p2)._divideBy(2);
		this._startDist = p1.distanceTo(p2);

		this._moved = false;
		this._zooming = true;

		this._centerOffset = viewCenter.subtract(this._startCenter);

		if (map._panAnim) {
			map._panAnim.stop();
		}

		L.DomEvent
		    .on(document, 'touchmove', this._onTouchMove, this)
		    .on(document, 'touchend', this._onTouchEnd, this);

		L.DomEvent.preventDefault(e);
	},

	_onTouchMove: function (e) {
		var map = this._map;

		if (!e.touches || e.touches.length !== 2 || !this._zooming) { return; }

		var p1 = map.mouseEventToLayerPoint(e.touches[0]),
		    p2 = map.mouseEventToLayerPoint(e.touches[1]);

		this._scale = p1.distanceTo(p2) / this._startDist;
		this._delta = p1._add(p2)._divideBy(2)._subtract(this._startCenter);

		if (this._scale === 1) { return; }

		if (!map.options.bounceAtZoomLimits) {
			if ((map.getZoom() === map.getMinZoom() && this._scale < 1) ||
			    (map.getZoom() === map.getMaxZoom() && this._scale > 1)) { return; }
		}

		if (!this._moved) {
			L.DomUtil.addClass(map._mapPane, 'leaflet-touching');

			map
			    .fire('movestart')
			    .fire('zoomstart');

			this._moved = true;
		}

		L.Util.cancelAnimFrame(this._animRequest);
		this._animRequest = L.Util.requestAnimFrame(
		        this._updateOnMove, this, true, this._map._container);

		L.DomEvent.preventDefault(e);
	},

	_updateOnMove: function () {
		var map = this._map,
		    origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),
		    zoom = map.getScaleZoom(this._scale);

		map._animateZoom(center, zoom, this._startCenter, this._scale, this._delta);
	},

	_onTouchEnd: function () {
		if (!this._moved || !this._zooming) {
			this._zooming = false;
			return;
		}

		var map = this._map;

		this._zooming = false;
		L.DomUtil.removeClass(map._mapPane, 'leaflet-touching');
		L.Util.cancelAnimFrame(this._animRequest);

		L.DomEvent
		    .off(document, 'touchmove', this._onTouchMove)
		    .off(document, 'touchend', this._onTouchEnd);

		var origin = this._getScaleOrigin(),
		    center = map.layerPointToLatLng(origin),

		    oldZoom = map.getZoom(),
		    floatZoomDelta = map.getScaleZoom(this._scale) - oldZoom,
		    roundZoomDelta = (floatZoomDelta > 0 ?
		            Math.ceil(floatZoomDelta) : Math.floor(floatZoomDelta)),

		    zoom = map._limitZoom(oldZoom + roundZoomDelta),
		    scale = map.getZoomScale(zoom) / this._scale;

		map._animateZoom(center, zoom, origin, scale);
	},

	_getScaleOrigin: function () {
		var centerOffset = this._centerOffset.subtract(this._delta).divideBy(this._scale);
		return this._startCenter.add(centerOffset);
	}
});

L.Map.addInitHook('addHandler', 'touchZoom', L.Map.TouchZoom);


/*
 * L.Map.Tap is used to enable mobile hacks like quick taps and long hold.
 */

L.Map.mergeOptions({
	tap: true,
	tapTolerance: 15
});

L.Map.Tap = L.Handler.extend({
	addHooks: function () {
		L.DomEvent.on(this._map._container, 'touchstart', this._onDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._map._container, 'touchstart', this._onDown, this);
	},

	_onDown: function (e) {
		if (!e.touches) { return; }

		L.DomEvent.preventDefault(e);

		this._fireClick = true;

		// don't simulate click or track longpress if more than 1 touch
		if (e.touches.length > 1) {
			this._fireClick = false;
			clearTimeout(this._holdTimeout);
			return;
		}

		var first = e.touches[0],
		    el = first.target;

		this._startPos = this._newPos = new L.Point(first.clientX, first.clientY);

		// if touching a link, highlight it
		if (el.tagName && el.tagName.toLowerCase() === 'a') {
			L.DomUtil.addClass(el, 'leaflet-active');
		}

		// simulate long hold but setting a timeout
		this._holdTimeout = setTimeout(L.bind(function () {
			if (this._isTapValid()) {
				this._fireClick = false;
				this._onUp();
				this._simulateEvent('contextmenu', first);
			}
		}, this), 1000);

		L.DomEvent
			.on(document, 'touchmove', this._onMove, this)
			.on(document, 'touchend', this._onUp, this);
	},

	_onUp: function (e) {
		clearTimeout(this._holdTimeout);

		L.DomEvent
			.off(document, 'touchmove', this._onMove, this)
			.off(document, 'touchend', this._onUp, this);

		if (this._fireClick && e && e.changedTouches) {

			var first = e.changedTouches[0],
			    el = first.target;

			if (el && el.tagName && el.tagName.toLowerCase() === 'a') {
				L.DomUtil.removeClass(el, 'leaflet-active');
			}

			// simulate click if the touch didn't move too much
			if (this._isTapValid()) {
				this._simulateEvent('click', first);
			}
		}
	},

	_isTapValid: function () {
		return this._newPos.distanceTo(this._startPos) <= this._map.options.tapTolerance;
	},

	_onMove: function (e) {
		var first = e.touches[0];
		this._newPos = new L.Point(first.clientX, first.clientY);
	},

	_simulateEvent: function (type, e) {
		var simulatedEvent = document.createEvent('MouseEvents');

		simulatedEvent._simulated = true;
		e.target._simulatedClick = true;

		simulatedEvent.initMouseEvent(
		        type, true, true, window, 1,
		        e.screenX, e.screenY,
		        e.clientX, e.clientY,
		        false, false, false, false, 0, null);

		e.target.dispatchEvent(simulatedEvent);
	}
});

if (L.Browser.touch && !L.Browser.pointer) {
	L.Map.addInitHook('addHandler', 'tap', L.Map.Tap);
}


/*
 * L.Handler.ShiftDragZoom is used to add shift-drag zoom interaction to the map
  * (zoom to a selected bounding box), enabled by default.
 */

L.Map.mergeOptions({
	boxZoom: true
});

L.Map.BoxZoom = L.Handler.extend({
	initialize: function (map) {
		this._map = map;
		this._container = map._container;
		this._pane = map._panes.overlayPane;
		this._moved = false;
	},

	addHooks: function () {
		L.DomEvent.on(this._container, 'mousedown', this._onMouseDown, this);
	},

	removeHooks: function () {
		L.DomEvent.off(this._container, 'mousedown', this._onMouseDown);
		this._moved = false;
	},

	moved: function () {
		return this._moved;
	},

	_onMouseDown: function (e) {
		this._moved = false;

		if (!e.shiftKey || ((e.which !== 1) && (e.button !== 1))) { return false; }

		L.DomUtil.disableTextSelection();
		L.DomUtil.disableImageDrag();

		this._startLayerPoint = this._map.mouseEventToLayerPoint(e);

		L.DomEvent
		    .on(document, 'mousemove', this._onMouseMove, this)
		    .on(document, 'mouseup', this._onMouseUp, this)
		    .on(document, 'keydown', this._onKeyDown, this);
	},

	_onMouseMove: function (e) {
		if (!this._moved) {
			this._box = L.DomUtil.create('div', 'leaflet-zoom-box', this._pane);
			L.DomUtil.setPosition(this._box, this._startLayerPoint);

			//TODO refactor: move cursor to styles
			this._container.style.cursor = 'crosshair';
			this._map.fire('boxzoomstart');
		}

		var startPoint = this._startLayerPoint,
		    box = this._box,

		    layerPoint = this._map.mouseEventToLayerPoint(e),
		    offset = layerPoint.subtract(startPoint),

		    newPos = new L.Point(
		        Math.min(layerPoint.x, startPoint.x),
		        Math.min(layerPoint.y, startPoint.y));

		L.DomUtil.setPosition(box, newPos);

		this._moved = true;

		// TODO refactor: remove hardcoded 4 pixels
		box.style.width  = (Math.max(0, Math.abs(offset.x) - 4)) + 'px';
		box.style.height = (Math.max(0, Math.abs(offset.y) - 4)) + 'px';
	},

	_finish: function () {
		if (this._moved) {
			this._pane.removeChild(this._box);
			this._container.style.cursor = '';
		}

		L.DomUtil.enableTextSelection();
		L.DomUtil.enableImageDrag();

		L.DomEvent
		    .off(document, 'mousemove', this._onMouseMove)
		    .off(document, 'mouseup', this._onMouseUp)
		    .off(document, 'keydown', this._onKeyDown);
	},

	_onMouseUp: function (e) {

		this._finish();

		var map = this._map,
		    layerPoint = map.mouseEventToLayerPoint(e);

		if (this._startLayerPoint.equals(layerPoint)) { return; }

		var bounds = new L.LatLngBounds(
		        map.layerPointToLatLng(this._startLayerPoint),
		        map.layerPointToLatLng(layerPoint));

		map.fitBounds(bounds);

		map.fire('boxzoomend', {
			boxZoomBounds: bounds
		});
	},

	_onKeyDown: function (e) {
		if (e.keyCode === 27) {
			this._finish();
		}
	}
});

L.Map.addInitHook('addHandler', 'boxZoom', L.Map.BoxZoom);


/*
 * L.Map.Keyboard is handling keyboard interaction with the map, enabled by default.
 */

L.Map.mergeOptions({
	keyboard: true,
	keyboardPanOffset: 80,
	keyboardZoomOffset: 1
});

L.Map.Keyboard = L.Handler.extend({

	keyCodes: {
		left:    [37],
		right:   [39],
		down:    [40],
		up:      [38],
		zoomIn:  [187, 107, 61, 171],
		zoomOut: [189, 109, 173]
	},

	initialize: function (map) {
		this._map = map;

		this._setPanOffset(map.options.keyboardPanOffset);
		this._setZoomOffset(map.options.keyboardZoomOffset);
	},

	addHooks: function () {
		var container = this._map._container;

		// make the container focusable by tabbing
		if (container.tabIndex === -1) {
			container.tabIndex = '0';
		}

		L.DomEvent
		    .on(container, 'focus', this._onFocus, this)
		    .on(container, 'blur', this._onBlur, this)
		    .on(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .on('focus', this._addHooks, this)
		    .on('blur', this._removeHooks, this);
	},

	removeHooks: function () {
		this._removeHooks();

		var container = this._map._container;

		L.DomEvent
		    .off(container, 'focus', this._onFocus, this)
		    .off(container, 'blur', this._onBlur, this)
		    .off(container, 'mousedown', this._onMouseDown, this);

		this._map
		    .off('focus', this._addHooks, this)
		    .off('blur', this._removeHooks, this);
	},

	_onMouseDown: function () {
		if (this._focused) { return; }

		var body = document.body,
		    docEl = document.documentElement,
		    top = body.scrollTop || docEl.scrollTop,
		    left = body.scrollLeft || docEl.scrollLeft;

		this._map._container.focus();

		window.scrollTo(left, top);
	},

	_onFocus: function () {
		this._focused = true;
		this._map.fire('focus');
	},

	_onBlur: function () {
		this._focused = false;
		this._map.fire('blur');
	},

	_setPanOffset: function (pan) {
		var keys = this._panKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.left.length; i < len; i++) {
			keys[codes.left[i]] = [-1 * pan, 0];
		}
		for (i = 0, len = codes.right.length; i < len; i++) {
			keys[codes.right[i]] = [pan, 0];
		}
		for (i = 0, len = codes.down.length; i < len; i++) {
			keys[codes.down[i]] = [0, pan];
		}
		for (i = 0, len = codes.up.length; i < len; i++) {
			keys[codes.up[i]] = [0, -1 * pan];
		}
	},

	_setZoomOffset: function (zoom) {
		var keys = this._zoomKeys = {},
		    codes = this.keyCodes,
		    i, len;

		for (i = 0, len = codes.zoomIn.length; i < len; i++) {
			keys[codes.zoomIn[i]] = zoom;
		}
		for (i = 0, len = codes.zoomOut.length; i < len; i++) {
			keys[codes.zoomOut[i]] = -zoom;
		}
	},

	_addHooks: function () {
		L.DomEvent.on(document, 'keydown', this._onKeyDown, this);
	},

	_removeHooks: function () {
		L.DomEvent.off(document, 'keydown', this._onKeyDown, this);
	},

	_onKeyDown: function (e) {
		var key = e.keyCode,
		    map = this._map;

		if (key in this._panKeys) {

			if (map._panAnim && map._panAnim._inProgress) { return; }

			map.panBy(this._panKeys[key]);

			if (map.options.maxBounds) {
				map.panInsideBounds(map.options.maxBounds);
			}

		} else if (key in this._zoomKeys) {
			map.setZoom(map.getZoom() + this._zoomKeys[key]);

		} else {
			return;
		}

		L.DomEvent.stop(e);
	}
});

L.Map.addInitHook('addHandler', 'keyboard', L.Map.Keyboard);


/*
 * L.Handler.MarkerDrag is used internally by L.Marker to make the markers draggable.
 */

L.Handler.MarkerDrag = L.Handler.extend({
	initialize: function (marker) {
		this._marker = marker;
	},

	addHooks: function () {
		var icon = this._marker._icon;
		if (!this._draggable) {
			this._draggable = new L.Draggable(icon, icon);
		}

		this._draggable
			.on('dragstart', this._onDragStart, this)
			.on('drag', this._onDrag, this)
			.on('dragend', this._onDragEnd, this);
		this._draggable.enable();
		L.DomUtil.addClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	removeHooks: function () {
		this._draggable
			.off('dragstart', this._onDragStart, this)
			.off('drag', this._onDrag, this)
			.off('dragend', this._onDragEnd, this);

		this._draggable.disable();
		L.DomUtil.removeClass(this._marker._icon, 'leaflet-marker-draggable');
	},

	moved: function () {
		return this._draggable && this._draggable._moved;
	},

	_onDragStart: function () {
		this._marker
		    .closePopup()
		    .fire('movestart')
		    .fire('dragstart');
	},

	_onDrag: function () {
		var marker = this._marker,
		    shadow = marker._shadow,
		    iconPos = L.DomUtil.getPosition(marker._icon),
		    latlng = marker._map.layerPointToLatLng(iconPos);

		// update shadow position
		if (shadow) {
			L.DomUtil.setPosition(shadow, iconPos);
		}

		marker._latlng = latlng;

		marker
		    .fire('move', {latlng: latlng})
		    .fire('drag');
	},

	_onDragEnd: function (e) {
		this._marker
		    .fire('moveend')
		    .fire('dragend', e);
	}
});


/*
 * L.Control is a base class for implementing map controls. Handles positioning.
 * All other controls extend from this class.
 */

L.Control = L.Class.extend({
	options: {
		position: 'topright'
	},

	initialize: function (options) {
		L.setOptions(this, options);
	},

	getPosition: function () {
		return this.options.position;
	},

	setPosition: function (position) {
		var map = this._map;

		if (map) {
			map.removeControl(this);
		}

		this.options.position = position;

		if (map) {
			map.addControl(this);
		}

		return this;
	},

	getContainer: function () {
		return this._container;
	},

	addTo: function (map) {
		this._map = map;

		var container = this._container = this.onAdd(map),
		    pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		L.DomUtil.addClass(container, 'leaflet-control');

		if (pos.indexOf('bottom') !== -1) {
			corner.insertBefore(container, corner.firstChild);
		} else {
			corner.appendChild(container);
		}

		return this;
	},

	removeFrom: function (map) {
		var pos = this.getPosition(),
		    corner = map._controlCorners[pos];

		corner.removeChild(this._container);
		this._map = null;

		if (this.onRemove) {
			this.onRemove(map);
		}

		return this;
	},

	_refocusOnMap: function () {
		if (this._map) {
			this._map.getContainer().focus();
		}
	}
});

L.control = function (options) {
	return new L.Control(options);
};


// adds control-related methods to L.Map

L.Map.include({
	addControl: function (control) {
		control.addTo(this);
		return this;
	},

	removeControl: function (control) {
		control.removeFrom(this);
		return this;
	},

	_initControlPos: function () {
		var corners = this._controlCorners = {},
		    l = 'leaflet-',
		    container = this._controlContainer =
		            L.DomUtil.create('div', l + 'control-container', this._container);

		function createCorner(vSide, hSide) {
			var className = l + vSide + ' ' + l + hSide;

			corners[vSide + hSide] = L.DomUtil.create('div', className, container);
		}

		createCorner('top', 'left');
		createCorner('top', 'right');
		createCorner('bottom', 'left');
		createCorner('bottom', 'right');
	},

	_clearControlPos: function () {
		this._container.removeChild(this._controlContainer);
	}
});


/*
 * L.Control.Zoom is used for the default zoom buttons on the map.
 */

L.Control.Zoom = L.Control.extend({
	options: {
		position: 'topleft',
		zoomInText: '+',
		zoomInTitle: 'Zoom in',
		zoomOutText: '-',
		zoomOutTitle: 'Zoom out'
	},

	onAdd: function (map) {
		var zoomName = 'leaflet-control-zoom',
		    container = L.DomUtil.create('div', zoomName + ' leaflet-bar');

		this._map = map;

		this._zoomInButton  = this._createButton(
		        this.options.zoomInText, this.options.zoomInTitle,
		        zoomName + '-in',  container, this._zoomIn,  this);
		this._zoomOutButton = this._createButton(
		        this.options.zoomOutText, this.options.zoomOutTitle,
		        zoomName + '-out', container, this._zoomOut, this);

		this._updateDisabled();
		map.on('zoomend zoomlevelschange', this._updateDisabled, this);

		return container;
	},

	onRemove: function (map) {
		map.off('zoomend zoomlevelschange', this._updateDisabled, this);
	},

	_zoomIn: function (e) {
		this._map.zoomIn(e.shiftKey ? 3 : 1);
	},

	_zoomOut: function (e) {
		this._map.zoomOut(e.shiftKey ? 3 : 1);
	},

	_createButton: function (html, title, className, container, fn, context) {
		var link = L.DomUtil.create('a', className, container);
		link.innerHTML = html;
		link.href = '#';
		link.title = title;

		var stop = L.DomEvent.stopPropagation;

		L.DomEvent
		    .on(link, 'click', stop)
		    .on(link, 'mousedown', stop)
		    .on(link, 'dblclick', stop)
		    .on(link, 'click', L.DomEvent.preventDefault)
		    .on(link, 'click', fn, context)
		    .on(link, 'click', this._refocusOnMap, context);

		return link;
	},

	_updateDisabled: function () {
		var map = this._map,
			className = 'leaflet-disabled';

		L.DomUtil.removeClass(this._zoomInButton, className);
		L.DomUtil.removeClass(this._zoomOutButton, className);

		if (map._zoom === map.getMinZoom()) {
			L.DomUtil.addClass(this._zoomOutButton, className);
		}
		if (map._zoom === map.getMaxZoom()) {
			L.DomUtil.addClass(this._zoomInButton, className);
		}
	}
});

L.Map.mergeOptions({
	zoomControl: true
});

L.Map.addInitHook(function () {
	if (this.options.zoomControl) {
		this.zoomControl = new L.Control.Zoom();
		this.addControl(this.zoomControl);
	}
});

L.control.zoom = function (options) {
	return new L.Control.Zoom(options);
};



/*
 * L.Control.Attribution is used for displaying attribution on the map (added by default).
 */

L.Control.Attribution = L.Control.extend({
	options: {
		position: 'bottomright',
		prefix: '<a href="http://leafletjs.com" title="A JS library for interactive maps">Leaflet</a>'
	},

	initialize: function (options) {
		L.setOptions(this, options);

		this._attributions = {};
	},

	onAdd: function (map) {
		this._container = L.DomUtil.create('div', 'leaflet-control-attribution');
		L.DomEvent.disableClickPropagation(this._container);

		for (var i in map._layers) {
			if (map._layers[i].getAttribution) {
				this.addAttribution(map._layers[i].getAttribution());
			}
		}
		
		map
		    .on('layeradd', this._onLayerAdd, this)
		    .on('layerremove', this._onLayerRemove, this);

		this._update();

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerAdd)
		    .off('layerremove', this._onLayerRemove);

	},

	setPrefix: function (prefix) {
		this.options.prefix = prefix;
		this._update();
		return this;
	},

	addAttribution: function (text) {
		if (!text) { return; }

		if (!this._attributions[text]) {
			this._attributions[text] = 0;
		}
		this._attributions[text]++;

		this._update();

		return this;
	},

	removeAttribution: function (text) {
		if (!text) { return; }

		if (this._attributions[text]) {
			this._attributions[text]--;
			this._update();
		}

		return this;
	},

	_update: function () {
		if (!this._map) { return; }

		var attribs = [];

		for (var i in this._attributions) {
			if (this._attributions[i]) {
				attribs.push(i);
			}
		}

		var prefixAndAttribs = [];

		if (this.options.prefix) {
			prefixAndAttribs.push(this.options.prefix);
		}
		if (attribs.length) {
			prefixAndAttribs.push(attribs.join(', '));
		}

		this._container.innerHTML = prefixAndAttribs.join(' | ');
	},

	_onLayerAdd: function (e) {
		if (e.layer.getAttribution) {
			this.addAttribution(e.layer.getAttribution());
		}
	},

	_onLayerRemove: function (e) {
		if (e.layer.getAttribution) {
			this.removeAttribution(e.layer.getAttribution());
		}
	}
});

L.Map.mergeOptions({
	attributionControl: true
});

L.Map.addInitHook(function () {
	if (this.options.attributionControl) {
		this.attributionControl = (new L.Control.Attribution()).addTo(this);
	}
});

L.control.attribution = function (options) {
	return new L.Control.Attribution(options);
};


/*
 * L.Control.Scale is used for displaying metric/imperial scale on the map.
 */

L.Control.Scale = L.Control.extend({
	options: {
		position: 'bottomleft',
		maxWidth: 100,
		metric: true,
		imperial: true,
		updateWhenIdle: false
	},

	onAdd: function (map) {
		this._map = map;

		var className = 'leaflet-control-scale',
		    container = L.DomUtil.create('div', className),
		    options = this.options;

		this._addScales(options, className, container);

		map.on(options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
		map.whenReady(this._update, this);

		return container;
	},

	onRemove: function (map) {
		map.off(this.options.updateWhenIdle ? 'moveend' : 'move', this._update, this);
	},

	_addScales: function (options, className, container) {
		if (options.metric) {
			this._mScale = L.DomUtil.create('div', className + '-line', container);
		}
		if (options.imperial) {
			this._iScale = L.DomUtil.create('div', className + '-line', container);
		}
	},

	_update: function () {
		var bounds = this._map.getBounds(),
		    centerLat = bounds.getCenter().lat,
		    halfWorldMeters = 6378137 * Math.PI * Math.cos(centerLat * Math.PI / 180),
		    dist = halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng) / 180,

		    size = this._map.getSize(),
		    options = this.options,
		    maxMeters = 0;

		if (size.x > 0) {
			maxMeters = dist * (options.maxWidth / size.x);
		}

		this._updateScales(options, maxMeters);
	},

	_updateScales: function (options, maxMeters) {
		if (options.metric && maxMeters) {
			this._updateMetric(maxMeters);
		}

		if (options.imperial && maxMeters) {
			this._updateImperial(maxMeters);
		}
	},

	_updateMetric: function (maxMeters) {
		var meters = this._getRoundNum(maxMeters);

		this._mScale.style.width = this._getScaleWidth(meters / maxMeters) + 'px';
		this._mScale.innerHTML = meters < 1000 ? meters + ' m' : (meters / 1000) + ' km';
	},

	_updateImperial: function (maxMeters) {
		var maxFeet = maxMeters * 3.2808399,
		    scale = this._iScale,
		    maxMiles, miles, feet;

		if (maxFeet > 5280) {
			maxMiles = maxFeet / 5280;
			miles = this._getRoundNum(maxMiles);

			scale.style.width = this._getScaleWidth(miles / maxMiles) + 'px';
			scale.innerHTML = miles + ' mi';

		} else {
			feet = this._getRoundNum(maxFeet);

			scale.style.width = this._getScaleWidth(feet / maxFeet) + 'px';
			scale.innerHTML = feet + ' ft';
		}
	},

	_getScaleWidth: function (ratio) {
		return Math.round(this.options.maxWidth * ratio) - 10;
	},

	_getRoundNum: function (num) {
		var pow10 = Math.pow(10, (Math.floor(num) + '').length - 1),
		    d = num / pow10;

		d = d >= 10 ? 10 : d >= 5 ? 5 : d >= 3 ? 3 : d >= 2 ? 2 : 1;

		return pow10 * d;
	}
});

L.control.scale = function (options) {
	return new L.Control.Scale(options);
};


/*
 * L.Control.Layers is a control to allow users to switch between different layers on the map.
 */

L.Control.Layers = L.Control.extend({
	options: {
		collapsed: true,
		position: 'topright',
		autoZIndex: true
	},

	initialize: function (baseLayers, overlays, options) {
		L.setOptions(this, options);

		this._layers = {};
		this._lastZIndex = 0;
		this._handlingClick = false;

		for (var i in baseLayers) {
			this._addLayer(baseLayers[i], i);
		}

		for (i in overlays) {
			this._addLayer(overlays[i], i, true);
		}
	},

	onAdd: function (map) {
		this._initLayout();
		this._update();

		map
		    .on('layeradd', this._onLayerChange, this)
		    .on('layerremove', this._onLayerChange, this);

		return this._container;
	},

	onRemove: function (map) {
		map
		    .off('layeradd', this._onLayerChange)
		    .off('layerremove', this._onLayerChange);
	},

	addBaseLayer: function (layer, name) {
		this._addLayer(layer, name);
		this._update();
		return this;
	},

	addOverlay: function (layer, name) {
		this._addLayer(layer, name, true);
		this._update();
		return this;
	},

	removeLayer: function (layer) {
		var id = L.stamp(layer);
		delete this._layers[id];
		this._update();
		return this;
	},

	_initLayout: function () {
		var className = 'leaflet-control-layers',
		    container = this._container = L.DomUtil.create('div', className);

		//Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
		container.setAttribute('aria-haspopup', true);

		if (!L.Browser.touch) {
			L.DomEvent
				.disableClickPropagation(container)
				.disableScrollPropagation(container);
		} else {
			L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
		}

		var form = this._form = L.DomUtil.create('form', className + '-list');

		if (this.options.collapsed) {
			if (!L.Browser.android) {
				L.DomEvent
				    .on(container, 'mouseover', this._expand, this)
				    .on(container, 'mouseout', this._collapse, this);
			}
			var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
			link.href = '#';
			link.title = 'Layers';

			if (L.Browser.touch) {
				L.DomEvent
				    .on(link, 'click', L.DomEvent.stop)
				    .on(link, 'click', this._expand, this);
			}
			else {
				L.DomEvent.on(link, 'focus', this._expand, this);
			}
			//Work around for Firefox android issue https://github.com/Leaflet/Leaflet/issues/2033
			L.DomEvent.on(form, 'click', function () {
				setTimeout(L.bind(this._onInputClick, this), 0);
			}, this);

			this._map.on('click', this._collapse, this);
			// TODO keyboard accessibility
		} else {
			this._expand();
		}

		this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
		this._separator = L.DomUtil.create('div', className + '-separator', form);
		this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

		container.appendChild(form);
	},

	_addLayer: function (layer, name, overlay) {
		var id = L.stamp(layer);

		this._layers[id] = {
			layer: layer,
			name: name,
			overlay: overlay
		};

		if (this.options.autoZIndex && layer.setZIndex) {
			this._lastZIndex++;
			layer.setZIndex(this._lastZIndex);
		}
	},

	_update: function () {
		if (!this._container) {
			return;
		}

		this._baseLayersList.innerHTML = '';
		this._overlaysList.innerHTML = '';

		var baseLayersPresent = false,
		    overlaysPresent = false,
		    i, obj;

		for (i in this._layers) {
			obj = this._layers[i];
			this._addItem(obj);
			overlaysPresent = overlaysPresent || obj.overlay;
			baseLayersPresent = baseLayersPresent || !obj.overlay;
		}

		this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
	},

	_onLayerChange: function (e) {
		var obj = this._layers[L.stamp(e.layer)];

		if (!obj) { return; }

		if (!this._handlingClick) {
			this._update();
		}

		var type = obj.overlay ?
			(e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
			(e.type === 'layeradd' ? 'baselayerchange' : null);

		if (type) {
			this._map.fire(type, obj);
		}
	},

	// IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
	_createRadioElement: function (name, checked) {

		var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
		if (checked) {
			radioHtml += ' checked="checked"';
		}
		radioHtml += '/>';

		var radioFragment = document.createElement('div');
		radioFragment.innerHTML = radioHtml;

		return radioFragment.firstChild;
	},

	_addItem: function (obj) {
		var label = document.createElement('label'),
		    input,
		    checked = this._map.hasLayer(obj.layer);

		if (obj.overlay) {
			input = document.createElement('input');
			input.type = 'checkbox';
			input.className = 'leaflet-control-layers-selector';
			input.defaultChecked = checked;
		} else {
			input = this._createRadioElement('leaflet-base-layers', checked);
		}

		input.layerId = L.stamp(obj.layer);

		L.DomEvent.on(input, 'click', this._onInputClick, this);

		var name = document.createElement('span');
		name.innerHTML = ' ' + obj.name;

		label.appendChild(input);
		label.appendChild(name);

		var container = obj.overlay ? this._overlaysList : this._baseLayersList;
		container.appendChild(label);

		return label;
	},

	_onInputClick: function () {
		var i, input, obj,
		    inputs = this._form.getElementsByTagName('input'),
		    inputsLen = inputs.length;

		this._handlingClick = true;

		for (i = 0; i < inputsLen; i++) {
			input = inputs[i];
			obj = this._layers[input.layerId];

			if (input.checked && !this._map.hasLayer(obj.layer)) {
				this._map.addLayer(obj.layer);

			} else if (!input.checked && this._map.hasLayer(obj.layer)) {
				this._map.removeLayer(obj.layer);
			}
		}

		this._handlingClick = false;

		this._refocusOnMap();
	},

	_expand: function () {
		L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
	},

	_collapse: function () {
		this._container.className = this._container.className.replace(' leaflet-control-layers-expanded', '');
	}
});

L.control.layers = function (baseLayers, overlays, options) {
	return new L.Control.Layers(baseLayers, overlays, options);
};


/*
 * L.PosAnimation is used by Leaflet internally for pan animations.
 */

L.PosAnimation = L.Class.extend({
	includes: L.Mixin.Events,

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._newPos = newPos;

		this.fire('start');

		el.style[L.DomUtil.TRANSITION] = 'all ' + (duration || 0.25) +
		        's cubic-bezier(0,0,' + (easeLinearity || 0.5) + ',1)';

		L.DomEvent.on(el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);
		L.DomUtil.setPosition(el, newPos);

		// toggle reflow, Chrome flickers for some reason if you don't do this
		L.Util.falseFn(el.offsetWidth);

		// there's no native way to track value updates of transitioned properties, so we imitate this
		this._stepTimer = setInterval(L.bind(this._onStep, this), 50);
	},

	stop: function () {
		if (!this._inProgress) { return; }

		// if we just removed the transition property, the element would jump to its final position,
		// so we need to make it stay at the current position

		L.DomUtil.setPosition(this._el, this._getPos());
		this._onTransitionEnd();
		L.Util.falseFn(this._el.offsetWidth); // force reflow in case we are about to start a new animation
	},

	_onStep: function () {
		var stepPos = this._getPos();
		if (!stepPos) {
			this._onTransitionEnd();
			return;
		}
		// jshint camelcase: false
		// make L.DomUtil.getPosition return intermediate position value during animation
		this._el._leaflet_pos = stepPos;

		this.fire('step');
	},

	// you can't easily get intermediate values of properties animated with CSS3 Transitions,
	// we need to parse computed style (in case of transform it returns matrix string)

	_transformRe: /([-+]?(?:\d*\.)?\d+)\D*, ([-+]?(?:\d*\.)?\d+)\D*\)/,

	_getPos: function () {
		var left, top, matches,
		    el = this._el,
		    style = window.getComputedStyle(el);

		if (L.Browser.any3d) {
			matches = style[L.DomUtil.TRANSFORM].match(this._transformRe);
			if (!matches) { return; }
			left = parseFloat(matches[1]);
			top  = parseFloat(matches[2]);
		} else {
			left = parseFloat(style.left);
			top  = parseFloat(style.top);
		}

		return new L.Point(left, top, true);
	},

	_onTransitionEnd: function () {
		L.DomEvent.off(this._el, L.DomUtil.TRANSITION_END, this._onTransitionEnd, this);

		if (!this._inProgress) { return; }
		this._inProgress = false;

		this._el.style[L.DomUtil.TRANSITION] = '';

		// jshint camelcase: false
		// make sure L.DomUtil.getPosition returns the final position value after animation
		this._el._leaflet_pos = this._newPos;

		clearInterval(this._stepTimer);

		this.fire('step').fire('end');
	}

});


/*
 * Extends L.Map to handle panning animations.
 */

L.Map.include({

	setView: function (center, zoom, options) {

		zoom = zoom === undefined ? this._zoom : this._limitZoom(zoom);
		center = this._limitCenter(L.latLng(center), zoom, this.options.maxBounds);
		options = options || {};

		if (this._panAnim) {
			this._panAnim.stop();
		}

		if (this._loaded && !options.reset && options !== true) {

			if (options.animate !== undefined) {
				options.zoom = L.extend({animate: options.animate}, options.zoom);
				options.pan = L.extend({animate: options.animate}, options.pan);
			}

			// try animating pan or zoom
			var animated = (this._zoom !== zoom) ?
				this._tryAnimatedZoom && this._tryAnimatedZoom(center, zoom, options.zoom) :
				this._tryAnimatedPan(center, options.pan);

			if (animated) {
				// prevent resize handler call, the view will refresh after animation anyway
				clearTimeout(this._sizeTimer);
				return this;
			}
		}

		// animation didn't start, just reset the map view
		this._resetView(center, zoom);

		return this;
	},

	panBy: function (offset, options) {
		offset = L.point(offset).round();
		options = options || {};

		if (!offset.x && !offset.y) {
			return this;
		}

		if (!this._panAnim) {
			this._panAnim = new L.PosAnimation();

			this._panAnim.on({
				'step': this._onPanTransitionStep,
				'end': this._onPanTransitionEnd
			}, this);
		}

		// don't fire movestart if animating inertia
		if (!options.noMoveStart) {
			this.fire('movestart');
		}

		// animate pan unless animate: false specified
		if (options.animate !== false) {
			L.DomUtil.addClass(this._mapPane, 'leaflet-pan-anim');

			var newPos = this._getMapPanePos().subtract(offset);
			this._panAnim.run(this._mapPane, newPos, options.duration || 0.25, options.easeLinearity);
		} else {
			this._rawPanBy(offset);
			this.fire('move').fire('moveend');
		}

		return this;
	},

	_onPanTransitionStep: function () {
		this.fire('move');
	},

	_onPanTransitionEnd: function () {
		L.DomUtil.removeClass(this._mapPane, 'leaflet-pan-anim');
		this.fire('moveend');
	},

	_tryAnimatedPan: function (center, options) {
		// difference between the new and current centers in pixels
		var offset = this._getCenterOffset(center)._floor();

		// don't animate too far unless animate: true specified in options
		if ((options && options.animate) !== true && !this.getSize().contains(offset)) { return false; }

		this.panBy(offset, options);

		return true;
	}
});


/*
 * L.PosAnimation fallback implementation that powers Leaflet pan animations
 * in browsers that don't support CSS3 Transitions.
 */

L.PosAnimation = L.DomUtil.TRANSITION ? L.PosAnimation : L.PosAnimation.extend({

	run: function (el, newPos, duration, easeLinearity) { // (HTMLElement, Point[, Number, Number])
		this.stop();

		this._el = el;
		this._inProgress = true;
		this._duration = duration || 0.25;
		this._easeOutPower = 1 / Math.max(easeLinearity || 0.5, 0.2);

		this._startPos = L.DomUtil.getPosition(el);
		this._offset = newPos.subtract(this._startPos);
		this._startTime = +new Date();

		this.fire('start');

		this._animate();
	},

	stop: function () {
		if (!this._inProgress) { return; }

		this._step();
		this._complete();
	},

	_animate: function () {
		// animation loop
		this._animId = L.Util.requestAnimFrame(this._animate, this);
		this._step();
	},

	_step: function () {
		var elapsed = (+new Date()) - this._startTime,
		    duration = this._duration * 1000;

		if (elapsed < duration) {
			this._runFrame(this._easeOut(elapsed / duration));
		} else {
			this._runFrame(1);
			this._complete();
		}
	},

	_runFrame: function (progress) {
		var pos = this._startPos.add(this._offset.multiplyBy(progress));
		L.DomUtil.setPosition(this._el, pos);

		this.fire('step');
	},

	_complete: function () {
		L.Util.cancelAnimFrame(this._animId);

		this._inProgress = false;
		this.fire('end');
	},

	_easeOut: function (t) {
		return 1 - Math.pow(1 - t, this._easeOutPower);
	}
});


/*
 * Extends L.Map to handle zoom animations.
 */

L.Map.mergeOptions({
	zoomAnimation: true,
	zoomAnimationThreshold: 4
});

if (L.DomUtil.TRANSITION) {

	L.Map.addInitHook(function () {
		// don't animate on browsers without hardware-accelerated transitions or old Android/Opera
		this._zoomAnimated = this.options.zoomAnimation && L.DomUtil.TRANSITION &&
				L.Browser.any3d && !L.Browser.android23 && !L.Browser.mobileOpera;

		// zoom transitions run with the same duration for all layers, so if one of transitionend events
		// happens after starting zoom animation (propagating to the map pane), we know that it ended globally
		if (this._zoomAnimated) {
			L.DomEvent.on(this._mapPane, L.DomUtil.TRANSITION_END, this._catchTransitionEnd, this);
		}
	});
}

L.Map.include(!L.DomUtil.TRANSITION ? {} : {

	_catchTransitionEnd: function (e) {
		if (this._animatingZoom && e.propertyName.indexOf('transform') >= 0) {
			this._onZoomTransitionEnd();
		}
	},

	_nothingToAnimate: function () {
		return !this._container.getElementsByClassName('leaflet-zoom-animated').length;
	},

	_tryAnimatedZoom: function (center, zoom, options) {

		if (this._animatingZoom) { return true; }

		options = options || {};

		// don't animate if disabled, not supported or zoom difference is too large
		if (!this._zoomAnimated || options.animate === false || this._nothingToAnimate() ||
		        Math.abs(zoom - this._zoom) > this.options.zoomAnimationThreshold) { return false; }

		// offset is the pixel coords of the zoom origin relative to the current center
		var scale = this.getZoomScale(zoom),
		    offset = this._getCenterOffset(center)._divideBy(1 - 1 / scale),
			origin = this._getCenterLayerPoint()._add(offset);

		// don't animate if the zoom origin isn't within one screen from the current center, unless forced
		if (options.animate !== true && !this.getSize().contains(offset)) { return false; }

		this
		    .fire('movestart')
		    .fire('zoomstart');

		this._animateZoom(center, zoom, origin, scale, null, true);

		return true;
	},

	_animateZoom: function (center, zoom, origin, scale, delta, backwards) {

		this._animatingZoom = true;

		// put transform transition on all layers with leaflet-zoom-animated class
		L.DomUtil.addClass(this._mapPane, 'leaflet-zoom-anim');

		// remember what center/zoom to set after animation
		this._animateToCenter = center;
		this._animateToZoom = zoom;

		// disable any dragging during animation
		if (L.Draggable) {
			L.Draggable._disabled = true;
		}

		this.fire('zoomanim', {
			center: center,
			zoom: zoom,
			origin: origin,
			scale: scale,
			delta: delta,
			backwards: backwards
		});
	},

	_onZoomTransitionEnd: function () {

		this._animatingZoom = false;

		L.DomUtil.removeClass(this._mapPane, 'leaflet-zoom-anim');

		this._resetView(this._animateToCenter, this._animateToZoom, true, true);

		if (L.Draggable) {
			L.Draggable._disabled = false;
		}
	}
});


/*
	Zoom animation logic for L.TileLayer.
*/

L.TileLayer.include({
	_animateZoom: function (e) {
		if (!this._animating) {
			this._animating = true;
			this._prepareBgBuffer();
		}

		var bg = this._bgBuffer,
		    transform = L.DomUtil.TRANSFORM,
		    initialTransform = e.delta ? L.DomUtil.getTranslateString(e.delta) : bg.style[transform],
		    scaleStr = L.DomUtil.getScaleString(e.scale, e.origin);

		bg.style[transform] = e.backwards ?
				scaleStr + ' ' + initialTransform :
				initialTransform + ' ' + scaleStr;
	},

	_endZoomAnim: function () {
		var front = this._tileContainer,
		    bg = this._bgBuffer;

		front.style.visibility = '';
		front.parentNode.appendChild(front); // Bring to fore

		// force reflow
		L.Util.falseFn(bg.offsetWidth);

		this._animating = false;
	},

	_clearBgBuffer: function () {
		var map = this._map;

		if (map && !map._animatingZoom && !map.touchZoom._zooming) {
			this._bgBuffer.innerHTML = '';
			this._bgBuffer.style[L.DomUtil.TRANSFORM] = '';
		}
	},

	_prepareBgBuffer: function () {

		var front = this._tileContainer,
		    bg = this._bgBuffer;

		// if foreground layer doesn't have many tiles but bg layer does,
		// keep the existing bg layer and just zoom it some more

		var bgLoaded = this._getLoadedTilesPercentage(bg),
		    frontLoaded = this._getLoadedTilesPercentage(front);

		if (bg && bgLoaded > 0.5 && frontLoaded < 0.5) {

			front.style.visibility = 'hidden';
			this._stopLoadingImages(front);
			return;
		}

		// prepare the buffer to become the front tile pane
		bg.style.visibility = 'hidden';
		bg.style[L.DomUtil.TRANSFORM] = '';

		// switch out the current layer to be the new bg layer (and vice-versa)
		this._tileContainer = bg;
		bg = this._bgBuffer = front;

		this._stopLoadingImages(bg);

		//prevent bg buffer from clearing right after zoom
		clearTimeout(this._clearBgBufferTimer);
	},

	_getLoadedTilesPercentage: function (container) {
		var tiles = container.getElementsByTagName('img'),
		    i, len, count = 0;

		for (i = 0, len = tiles.length; i < len; i++) {
			if (tiles[i].complete) {
				count++;
			}
		}
		return count / len;
	},

	// stops loading all tiles in the background layer
	_stopLoadingImages: function (container) {
		var tiles = Array.prototype.slice.call(container.getElementsByTagName('img')),
		    i, len, tile;

		for (i = 0, len = tiles.length; i < len; i++) {
			tile = tiles[i];

			if (!tile.complete) {
				tile.onload = L.Util.falseFn;
				tile.onerror = L.Util.falseFn;
				tile.src = L.Util.emptyImageUrl;

				tile.parentNode.removeChild(tile);
			}
		}
	}
});


/*
 * Provides L.Map with convenient shortcuts for using browser geolocation features.
 */

L.Map.include({
	_defaultLocateOptions: {
		watch: false,
		setView: false,
		maxZoom: Infinity,
		timeout: 10000,
		maximumAge: 0,
		enableHighAccuracy: false
	},

	locate: function (/*Object*/ options) {

		options = this._locateOptions = L.extend(this._defaultLocateOptions, options);

		if (!navigator.geolocation) {
			this._handleGeolocationError({
				code: 0,
				message: 'Geolocation not supported.'
			});
			return this;
		}

		var onResponse = L.bind(this._handleGeolocationResponse, this),
			onError = L.bind(this._handleGeolocationError, this);

		if (options.watch) {
			this._locationWatchId =
			        navigator.geolocation.watchPosition(onResponse, onError, options);
		} else {
			navigator.geolocation.getCurrentPosition(onResponse, onError, options);
		}
		return this;
	},

	stopLocate: function () {
		if (navigator.geolocation) {
			navigator.geolocation.clearWatch(this._locationWatchId);
		}
		if (this._locateOptions) {
			this._locateOptions.setView = false;
		}
		return this;
	},

	_handleGeolocationError: function (error) {
		var c = error.code,
		    message = error.message ||
		            (c === 1 ? 'permission denied' :
		            (c === 2 ? 'position unavailable' : 'timeout'));

		if (this._locateOptions.setView && !this._loaded) {
			this.fitWorld();
		}

		this.fire('locationerror', {
			code: c,
			message: 'Geolocation error: ' + message + '.'
		});
	},

	_handleGeolocationResponse: function (pos) {
		var lat = pos.coords.latitude,
		    lng = pos.coords.longitude,
		    latlng = new L.LatLng(lat, lng),

		    latAccuracy = 180 * pos.coords.accuracy / 40075017,
		    lngAccuracy = latAccuracy / Math.cos(L.LatLng.DEG_TO_RAD * lat),

		    bounds = L.latLngBounds(
		            [lat - latAccuracy, lng - lngAccuracy],
		            [lat + latAccuracy, lng + lngAccuracy]),

		    options = this._locateOptions;

		if (options.setView) {
			var zoom = Math.min(this.getBoundsZoom(bounds), options.maxZoom);
			this.setView(latlng, zoom);
		}

		var data = {
			latlng: latlng,
			bounds: bounds,
			timestamp: pos.timestamp
		};

		for (var i in pos.coords) {
			if (typeof pos.coords[i] === 'number') {
				data[i] = pos.coords[i];
			}
		}

		this.fire('locationfound', data);
	}
});


}(window, document));
},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/mustache.js/mustache.js":[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false*/

(function (root, factory) {
  if (typeof exports === "object" && exports) {
    factory(exports); // CommonJS
  } else {
    var mustache = {};
    factory(mustache);
    if (typeof define === "function" && define.amd) {
      define(mustache); // AMD
    } else {
      root.Mustache = mustache; // <script>
    }
  }
}(this, function (mustache) {

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var RegExp_test = RegExp.prototype.test;
  function testRegExp(re, string) {
    return RegExp_test.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace(string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var Object_toString = Object.prototype.toString;
  var isArray = Array.isArray || function (object) {
    return Object_toString.call(object) === '[object Array]';
  };

  function isFunction(object) {
    return typeof object === 'function';
  }

  function escapeRegExp(string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
  }

  var entityMap = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': '&quot;',
    "'": '&#39;',
    "/": '&#x2F;'
  };

  function escapeHtml(string) {
    return String(string).replace(/[&<>"'\/]/g, function (s) {
      return entityMap[s];
    });
  }

  function escapeTags(tags) {
    if (!isArray(tags) || tags.length !== 2) {
      throw new Error('Invalid tags: ' + tags);
    }

    return [
      new RegExp(escapeRegExp(tags[0]) + "\\s*"),
      new RegExp("\\s*" + escapeRegExp(tags[1]))
    ];
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate(template, tags) {
    tags = tags || mustache.tags;
    template = template || '';

    if (typeof tags === 'string') {
      tags = tags.split(spaceRe);
    }

    var tagRes = escapeTags(tags);
    var scanner = new Scanner(template);

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace() {
      if (hasTag && !nonSpace) {
        while (spaces.length) {
          delete tokens[spaces.pop()];
        }
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(tagRes[0]);
      if (value) {
        for (var i = 0, len = value.length; i < len; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push(['text', chr, start, start + 1]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n') {
            stripSpace();
          }
        }
      }

      // Match the opening tag.
      if (!scanner.scan(tagRes[0])) break;
      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(tagRes[1]);
      } else if (type === '{') {
        value = scanner.scanUntil(new RegExp('\\s*' + escapeRegExp('}' + tags[1])));
        scanner.scan(curlyRe);
        scanner.scanUntil(tagRes[1]);
        type = '&';
      } else {
        value = scanner.scanUntil(tagRes[1]);
      }

      // Match the closing tag.
      if (!scanner.scan(tagRes[1])) {
        throw new Error('Unclosed tag at ' + scanner.pos);
      }

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection) {
          throw new Error('Unopened section "' + value + '" at ' + start);
        }
        if (openSection[1] !== value) {
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
        }
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        tagRes = escapeTags(tags = value.split(spaceRe));
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();
    if (openSection) {
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
    }

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens(tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens(tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner(string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function () {
    return this.tail === "";
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function (re) {
    var match = this.tail.match(re);

    if (match && match.index === 0) {
      var string = match[0];
      this.tail = this.tail.substring(string.length);
      this.pos += string.length;
      return string;
    }

    return "";
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = "";
      break;
    case 0:
      match = "";
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context(view, parentContext) {
    this.view = view == null ? {} : view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function (name) {
    var value;
    if (name in this.cache) {
      value = this.cache[name];
    } else {
      var context = this;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;

          var names = name.split('.'), i = 0;
          while (value != null && i < names.length) {
            value = value[names[i++]];
          }
        } else {
          value = context.view[name];
        }

        if (value != null) break;

        context = context.parent;
      }

      this.cache[name] = value;
    }

    if (isFunction(value)) {
      value = value.call(this.view);
    }

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer() {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null) {
      tokens = cache[template] = parseTemplate(template, tags);
    }

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function (tokens, context, partials, originalTemplate) {
    var buffer = '';

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    var self = this;
    function subRender(template) {
      return self.render(template, context, partials);
    }

    var token, value;
    for (var i = 0, len = tokens.length; i < len; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
        value = context.lookup(token[1]);
        if (!value) continue;

        if (isArray(value)) {
          for (var j = 0, jlen = value.length; j < jlen; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
          }
        } else if (typeof value === 'object' || typeof value === 'string') {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== 'string') {
            throw new Error('Cannot use higher-order sections without the original template');
          }

          // Extract the portion of the original template that the section contains.
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

          if (value != null) buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate);
        }

        break;
      case '^':
        value = context.lookup(token[1]);

        // Use JavaScript's definition of falsy. Include empty arrays.
        // See https://github.com/janl/mustache.js/issues/186
        if (!value || (isArray(value) && value.length === 0)) {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate);
        }

        break;
      case '>':
        if (!partials) continue;
        value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) buffer += this.renderTokens(this.parse(value), context, partials, value);
        break;
      case '&':
        value = context.lookup(token[1]);
        if (value != null) buffer += value;
        break;
      case 'name':
        value = context.lookup(token[1]);
        if (value != null) buffer += mustache.escape(value);
        break;
      case 'text':
        buffer += token[1];
        break;
      }
    }

    return buffer;
  };

  mustache.name = "mustache.js";
  mustache.version = "0.8.1";
  mustache.tags = [ "{{", "}}" ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function (template, view, partials) {
    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.
  mustache.to_html = function (template, view, partials, send) {
    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/paper/dist/paper-full.js":[function(require,module,exports){
/*!
 * Paper.js v0.9.18 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Mon Apr 7 11:24:38 2014 +0200
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props) {
		for (var i in props)
			if (props.hasOwnProperty(i))
				obj[i] = props[i];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			ctor.prototype = create(this.prototype);
			ctor.base = base;
			define(ctor.prototype, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			return arguments.length ? this.inject.apply(ctor, arguments) : ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function() {
				for (var i = 0, l = arguments.length; i < l; i++)
					if (arguments[i] !== undefined)
						return arguments[i];
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

if (!Array.isArray) {
	Array.isArray = function(obj) {
		return Object.prototype.toString.call(obj) === '[object Array]';
	};
}

if (!document.head) {
	document.head = document.getElementsByTagName('head')[0];
}

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude) {
		if (props && Base.isPlainObject(props)) {
			var orig = props._filtering || props;
			for (var key in orig) {
				if (key in this && orig.hasOwnProperty(key)
						&& (!exclude || !exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true 
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			function checkKeys(o1, o2) {
				for (var i in o1)
					if (o1.hasOwnProperty(i) && !o2.hasOwnProperty(i))
						return false;
				return true;
			}
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (Array.isArray(obj1) && Array.isArray(obj2)) {
				if (obj1.length !== obj2.length)
					return false;
				for (var i = 0, l = obj1.length; i < l; i++) {
					if (!Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			if (obj1 && typeof obj1 === 'object'
					&& obj2 && typeof obj2 === 'object') {
				if (!checkKeys(obj1, obj2) || !checkKeys(obj2, obj1))
					return false;
				for (var i in obj1) {
					if (obj1.hasOwnProperty(i)
							&& !Base.equals(obj1[i], obj2[i]))
						return false;
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj) {
			return this.isPlainObject(obj) || Array.isArray(obj);
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				for (var i in obj)
					if (obj.hasOwnProperty(i))
						res[i] = Base.serialize(obj[i], options, compact,
								dictionary);
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data) {
			var res = json,
				isRoot = !_data;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (!isDictionary) {
					if (_data.dictionary && json.length == 1 && /^#/.test(type))
						return _data.dictionary[type];
					type = Base.exports[type];
				}
				res = [];
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data));
				if (isDictionary) {
					_data.dictionary = res[0];
				} else if (type) {
					var args = res;
					if (create) {
						res = create(type, args, isRoot);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args, isRoot) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (!isRoot && args.length === 1 && obj instanceof Item
								&& (!(obj instanceof Layer) || isTarget)) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Callback = {
	attach: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.attach(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type];
		if (entry) {
			var handlers = this._handlers = this._handlers || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) == -1) { 
				handlers.push(func);
				if (entry.install && handlers.length == 1)
					entry.install.call(this, type);
			}
		}
	},

	detach: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.detach(key, value);
			}, this);
			return;
		}
		var entry = this._eventTypes[type],
			handlers = this._handlers && this._handlers[type],
			index;
		if (entry && handlers) {
			if (!func || (index = handlers.indexOf(func)) != -1
					&& handlers.length == 1) {
				if (entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._handlers[type];
			} else if (index != -1) {
				handlers.splice(index, 1);
			}
		}
	},

	once: function(type, func) {
		this.attach(type, function() {
			func.apply(this, arguments);
			this.detach(type, func);
		});
	},

	fire: function(type, event) {
		var handlers = this._handlers && this._handlers[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1),
			that = this;
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(that, args) === false
					&& event && event.stop) {
				event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._handlers && this._handlers[type]);
	},

	on: '#attach',
	off: '#detach',
	trigger: '#fire',

	_installEvents: function(install) {
		var handlers = this._handlers,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var entry = this._eventTypes[type],
					func = entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i],
					events = src._events;
				if (events) {
					var types = {};
					Base.each(events, function(entry, key) {
						var isString = typeof entry === 'string',
							name = isString ? entry : key,
							part = Base.capitalize(name),
							type = name.substring(2).toLowerCase();
						types[type] = isString ? {} : entry;
						name = '_' + name;
						src['get' + part] = function() {
							return this[name];
						};
						src['set' + part] = function(func) {
							var prev = this[name];
							if (prev)
								this.detach(type, prev);
							if (func)
								this.attach(type, func);
							this[name] = func;
						};
					});
					src._eventTypes = types;
				}
				inject.base.call(this, src);
			}
			return this;
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope(script) {
		paper = this;
		this.settings = {
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		};
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = script && (script.getAttribute('id') || script.src)
				|| ('paperscope-' + (PaperScope._id++));
		if (script)
			script.setAttribute('id', this._id);
		PaperScope._scopes[this._id] = this;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			PaperScope.prototype.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}
	},

	version: '0.9.18',

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code) {
		paper.PaperScript.execute(code, this);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(canvas) {
		paper = this;
		this.project = new Project(canvas);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				if (id && id.getAttribute)
					id = id.getAttribute('id');
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Callback, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.fire('deactivate');
		this._scope[this._reference] = this;
		this.fire('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		cos = Math.cos,
		PI = Math.PI,
		TOLERANCE = 10e-6,
		EPSILON = 10e-12;

	function setupRoots(roots, min, max) {
		var unbound = min === undefined,
			minE = min - EPSILON,
			maxE = max + EPSILON,
			count = 0;
		return function(root) {
			if (unbound || root > minE && root < maxE)
				roots[count++] = root < min ? min : root > max ? max : root;
			return count;
		};
	}

	return {
		TOLERANCE: TOLERANCE,
		EPSILON: EPSILON,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return abs(val) <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = 0.5 * (b - a),
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0; 
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? 0.5 * (a + b) : nx;
				} else {
					a = x;
					x = nx >= b ? 0.5 * (a + b) : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var add = setupRoots(roots, min, max);

			if (abs(a) < EPSILON) {
				if (abs(b) >= EPSILON)
					return add(-c / b);
				return abs(c) < EPSILON ? -1 : 0; 
			}
			var p = b / (2 * a);
			var q = c / a;
			var p2 = p * p;
			if (p2 < q - EPSILON)
				return 0;
			var s = p2 > q ? sqrt(p2 - q) : 0,
				count = add(s - p);
			if (s > 0)
				count = add(-s - p);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			if (abs(a) < EPSILON)
				return Numerical.solveQuadratic(b, c, d, roots, min, max);

			b /= a;
			c /= a;
			d /= a;
			var add = setupRoots(roots, min, max),
				bb = b * b,
				p = (bb - 3 * c) / 9,
				q = (2 * bb * b - 9 * b * c + 27 * d) / 54,
				ppp = p * p * p,
				D = q * q - ppp;
			b /= 3;
			if (abs(D) < EPSILON) {
				if (abs(q) < EPSILON) 
					return add(-b);
				var sqp = sqrt(p),
					snq = q > 0 ? 1 : -1;
				add(-snq * 2 * sqp - b);
				return add(snq * sqp - b);
			}
			if (D < 0) { 
				var sqp = sqrt(p),
					phi = Math.acos(q / (sqp * sqp * sqp)) / 3,
					t = -2 * sqp,
					o = 2 * PI / 3;
				add(t * cos(phi) - b);
				add(t * cos(phi + o) - b);
				return add(t * cos(phi - o) - b);
			}
			var A = (q > 0 ? -1 : 1) * pow(abs(q) + sqrt(D), 1 / 3);
			return add(A + p / A - b);
		}
	};
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				return Math.acos(this.dot(point) / div);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			s = Math.sin(angle),
			c = Math.cos(angle);
		point = new Point(
			point.x * c - point.y * s,
			point.x * s + point.y * c
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function(rect) {
		return rect.contains(this);
	},

	isClose: function(point, tolerance) {
		return this.getDistance(point) < tolerance;
	},

	isColinear: function(point) {
		return Math.abs(this.cross(point)) < 0.00001;
	},

	isOrthogonal: function(point) {
		return Math.abs(this.dot(point)) < 0.00001;
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments);
		if (point.isZero()) {
			return new Point(0, 0);
		} else {
			var scale = this.dot(point) / point.dot(point);
			return new Point(
				point.x * scale,
				point.y * scale
			);
		}
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, new function() {
	return Base.each([
			['Top', 'Left'], ['Top', 'Right'],
			['Bottom', 'Left'], ['Bottom', 'Right'],
			['Left', 'Center'], ['Top', 'Center'],
			['Right', 'Center'], ['Bottom', 'Center']
		],
		function(parts, index) {
			var part = parts.join('');
			var xFirst = /^[RL]/.test(part);
			if (index >= 4)
				parts[1] += xFirst ? 'Y' : 'X';
			var x = parts[xFirst ? 0 : 1],
				y = parts[xFirst ? 1 : 0],
				getX = 'get' + x,
				getY = 'get' + y,
				setX = 'set' + x,
				setY = 'set' + y,
				get = 'get' + part,
				set = 'set' + part;
			this[get] = function(_dontLink) {
				var ctor = _dontLink ? Point : LinkedPoint;
				return new ctor(this[getX](), this[getY](), this, set);
			};
			this[set] = function() {
				var point = Point.read(arguments);
				this[setX](point.x);
				this[setY](point.y);
			};
		}, {
			beans: true
		});
});

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
}, new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function() {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = mx._a * a + mx._c * b;
		this._b = mx._b * a + mx._d * b;
		this._c = mx._a * c + mx._c * d;
		this._d = mx._b * c + mx._d * d;
		this._tx += mx._tx * a + mx._ty * b;
		this._ty += mx._tx * c + mx._ty * d;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a = this._a,
			b = this._b,
			c = this._c,
			d = this._d,
			tx = this._tx,
			ty = this._ty;
		this._a = mx._a * a + mx._b * c;
		this._b = mx._a * b + mx._b * d;
		this._c = mx._c * a + mx._d * c;
		this._d = mx._c * b + mx._d * d;
		this._tx = mx._a * tx + mx._b * ty + mx._tx;
		this._ty = mx._c * tx + mx._d * ty + mx._ty;
		this._changed();
		return this;
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, srcOffset, dst, dstOffset, count) {
		return arguments.length < 5
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, srcOffset, dst, dstOffset, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, srcOffset, dst, dstOffset, count) {
		var i = srcOffset,
			j = dstOffset,
			max = i + 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, 0, coords, 0, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = coords.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	statics: {
		intersect: function(apx, apy, avx, avy, bpx, bpy, bvx, bvy, asVector,
				isInfinite) {
			if (!asVector) {
				avx -= apx;
				avy -= apy;
				bvx -= bpx;
				bvy -= bpy;
			}
			var cross = bvy * avx - bvx * avy;
			if (!Numerical.isZero(cross)) {
				var dx = apx - bpx,
					dy = apy - bpy,
					ta = (bvx * dy - bvy * dx) / cross,
					tb = (avx * dy - avy * dx) / cross;
				if ((isInfinite || 0 <= ta && ta <= 1)
						&& (isInfinite || 0 <= tb && tb <= 1))
					return new Point(
								apx + ta * avx,
								apy + ta * avy);
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx; 
			if (ccw === 0) {
				ccw = v2x * vx + v2y * vy; 
				if (ccw > 0) {
					v2x -= vx;
					v2y -= vy;
					ccw = v2x * vx + v2y * vy;
					if (ccw < 0)
						ccw = 0;
				}
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var m = vy / vx, 
				b = py - m * px; 
			return (y - (m * x) - b) / Math.sqrt(m * m + 1);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this.activeLayer = new Layer();
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length <= 1
			&& (!this.activeLayer || this.activeLayer.isEmpty());
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	addChild: function(child) {
		if (child instanceof Layer) {
			Base.splice(this.layers, [child]);
			if (!this.activeLayer)
				this.activeLayer = child;
		} else if (child instanceof Item) {
			(this.activeLayer
				|| this.addChild(new Layer(Item.NO_INSERT))).addChild(child);
		} else {
			child = null;
		}
		return child;
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i].hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match, true);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, false);
	},

	importJSON: function(json) {
		this.activate();
		var layer = this.activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			trackTransforms: true,
			transforms: [matrix]
		});
		for (var i = 0, l = this.layers.length; i < l; i++)
			this.layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			for (var id in this._selectedItems) {
				var item = this._selectedItems[id],
					globalMatrix = item._globalMatrix,
					size = this._scope.settings.handleSize,
					half = size / 2;
				if (item._updateVersion === this._updateVersion
						&& (item._drawSelected || item._boundsSelected)
						&& globalMatrix) {
					var color = item.getSelectedColor()
							|| item.getLayer().getSelectedColor();
					ctx.strokeStyle = ctx.fillStyle = color
							? color.toCanvasStyle(ctx) : '#009dec';
					if (item._drawSelected)
						item._drawSelected(ctx, globalMatrix);
					if (item._boundsSelected) {
						var coords = globalMatrix._transformCorners(
								item.getInternalBounds());
						ctx.beginPath();
						for (var i = 0; i < 8; i++)
							ctx[i === 0 ? 'moveTo' : 'lineTo'](
									coords[i], coords[++i]);
						ctx.closePath();
						ctx.stroke();
						for (var i = 0; i < 8; i++)
							ctx.fillRect(coords[i] - half, coords[++i] - half,
									size, size);
					}
				}
			}
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = Symbol._id = (Symbol._id || 0) + 1;
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	}
});

var Item = Base.extend(Callback, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		applyMatrix: null,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var internal = props && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = paper.project;
		if (!internal)
			this._id = Item._id = (Item._id || 0) + 1;
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || props && props.insert === false) {
				this._setProject(project);
			} else {
				(project.activeLayer || new Layer()).addChild(this);
			}
		}
		return props && props !== Item.NO_INSERT
				? this._set(props, { insert: true }) 
				: true;
	},

	_events: new function() {

		var mouseFlags = {
			mousedown: {
				mousedown: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mouseup: {
				mouseup: 1,
				mousedrag: 1,
				click: 1,
				doubleclick: 1
			},
			mousemove: {
				mousedrag: 1,
				mousemove: 1,
				mouseenter: 1,
				mouseleave: 1
			}
		};

		var mouseEvent = {
			install: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags) {
						counters[key] = (counters[key] || 0)
								+ (mouseFlags[key][type] || 0);
					}
				}
			},
			uninstall: function(type) {
				var counters = this.getView()._eventCounters;
				if (counters) {
					for (var key in mouseFlags)
						counters[key] -= mouseFlags[key][type] || 0;
				}
			}
		};

		return Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
			function(name) {
				this[name] = mouseEvent;
			}, {
				onFrame: {
					install: function() {
						this._animateItem(true);
					},
					uninstall: function() {
						this._animateItem(false);
					}
				},

				onLoad: {}
			}
		);
	},

	_animateItem: function(animate) {
		this.getView()._animateItem(this, animate);
	},

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent && (flags
				& (8 | 32))) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props, { insert: true });
		return this;
	},

	getId: function() {
		return this._id;
	},

	getClassName: function() {
		return this._class;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		if (name && this._parent) {
			var children = this._parent._children,
				namedChildren = this._parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
}, {}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			for (var i = 0, l = this._children.length; i < l; i++)
				if (this._children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		if (this._children && this._selected) {
			for (var i = 0, l = this._children.length; i < l; i++)
				if (!this._children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setAnchor');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments);
		this._position = undefined;
	},

	_pivot: null,

	getRegistration: '#getPivot',
	setRegistration: '#setPivot'
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, null,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter, matrix, cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		var cacheParent = this._parent || this._parentSymbol;
		if (cacheItem && cacheParent) {
			var id = cacheItem._id,
				ref = cacheParent._boundsCache = cacheParent._boundsCache || {
					ids: {},
					list: []
				};
			if (!ref.ids[id]) {
				ref.list.push(cacheItem);
				ref.ids[id] = cacheItem;
			}
		}
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		matrix = !matrix
				? _matrix
				: _matrix
					? matrix.clone().concatenate(_matrix)
					: matrix;
		var bounds = this._getBounds(internalGetter || getter, matrix,
				cache ? this : cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_clearBoundsCache: function(item) {
			if (item._boundsCache) {
				for (var i = 0, list = item._boundsCache.list, l = list.length;
						i < l; i++) {
					var child = list[i];
					child._bounds = child._position = undefined;
					if (child !== item && child._boundsCache)
						Item._clearBoundsCache(child);
				}
				item._boundsCache = undefined;
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.scaling;
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current != null) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function(matrix) {
		this._matrix.initialize(matrix);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_internal) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion,
			viewMatrix = this.getView()._matrix;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			matrix.preConcatenate(this._parent
					? this._parent.getGlobalMatrix(true)
					: viewMatrix);
			matrix._updateVersion = updateVersion;
		}
		return _internal ? matrix : viewMatrix.inverted().concatenate(matrix);
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(transform) {
		if (this._applyMatrix = this._canApplyMatrix && !!transform)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert) {
		copy.setStyle(this._style);
		if (this._children) {
			for (var i = 0, l = this._children.length; i < l; i++)
				copy.addChild(this._children[i].clone(false), true);
		}
		if (insert || insert === undefined)
			copy.insertAbove(this);
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide', '_applyMatrix'];
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		copy._matrix.initialize(this._matrix);
		copy._data = this._data ? Base.clone(this._data) : null;
		copy.setSelected(this._selected);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ transforms: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	hitTest: function(point, options) {
		point = Point.read(arguments);
		options = HitResult.getOptions(Base.read(arguments));
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.clone().concatenate(matrix)
					: this.getGlobalMatrix().clone().preConcatenate(
							view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 0.00001)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var type,
			checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| (type = options.type) && (typeof type === 'string'
						? type !== Base.hyphenate(this._class)
						: !(this instanceof type))),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i].hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTest(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTest: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	}
}, { 
	matches: function(match) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		for (var key in match) {
			if (match.hasOwnProperty(key)) {
				var value = this[key],
					compare = match[key];
				if (value === undefined && key === 'type')
					value = Base.hyphenate(this._class);
				if (/^(constructor|class)$/.test(key)) {
					if (!(this instanceof compare))
						return false;
				} else if (compare instanceof RegExp) {
					if (!compare.test(value))
						return false;
				} else if (typeof compare === 'function') {
					if (!compare(value))
						return false;
				} else if (Base.isPlainObject(compare)) {
					if (!matchObject(compare, value))
						return false;
				} else if (!Base.equals(value, compare)) {
					return false;
				}
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, true);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, false);
	},

	statics: {
		_getItems: function _getItems(children, match, list) {
			var items = list && [];
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i];
				if (child.matches(match)) {
					if (list) {
						items.push(child);
					} else {
						return child;
					}
				}
				var res = _getItems(child._children, match, list);
				if (list) {
					items.push.apply(items, res);
				} else if (res) {
					return res;
				}
			}
			return list ? items : null;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = this.insertChildren(index, [item], _preserve);
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					item._remove(false, true);
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insert: function(above, item, _preserve) {
		if (!item._parent)
			return null;
		var index = item._index + (above ? 1 : 0);
		if (item._parent === this._parent && index > this._index)
			 index--;
		return item._parent.insertChild(index, this, _preserve);
	},

	insertAbove: function(item, _preserve) {
		return this._insert(true, item, _preserve);
	},

	insertBelow: function(item, _preserve) {
	 	return this._insert(false, item, _preserve);
	 },

	sendToBack: function() {
		return this._parent.insertChild(0, this);
	},

	bringToFront: function() {
		return this._parent.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var children = this._parent._children,
			namedChildren = this._parent._namedChildren,
			name = this._name,
			namedArray = namedChildren[name],
			index = namedArray ? namedArray.indexOf(this) : -1;
		if (index == -1)
			return;
		if (children[name] == this)
			delete children[name];
		namedArray.splice(index, 1);
		if (namedArray.length) {
			children[name] = namedArray[namedArray.length - 1];
		} else {
			delete namedChildren[name];
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length == 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
				&& (!_matrix.isIdentity() || matrix);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				pivot.transform(_matrix);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true);
			return true;
		}
	},

	globalToLocal: function() {
		var matrix = this.getGlobalMatrix();
		return matrix && matrix._inverseTransform(Point.read(arguments));
	},

	localToGlobal: function() {
		var matrix = this.getGlobalMatrix();
		return matrix && matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param) {
		if (!this._visible || this._opacity === 0)
			return;
		var updateVersion = this._updateVersion = this._project._updateVersion;
		var trackTransforms = param.trackTransforms,
			transforms = param.transforms,
			matrix = this._matrix,
			parentMatrix = transforms[transforms.length - 1],
			globalMatrix = parentMatrix.clone().concatenate(matrix);
		if (!globalMatrix.isInvertible())
			return;
		if (trackTransforms) {
			transforms.push(this._globalMatrix = globalMatrix);
			globalMatrix._updateVersion = updateVersion;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(parentMatrix);
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(
					bounds.getSize().ceil().add(new Size(1, 1)),
					param.pixelRatio);
		}
		ctx.save();
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		(direct ? matrix : globalMatrix).applyToContext(ctx);
		if (!direct && param.clipItem)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		this._draw(ctx, param);
		ctx.restore();
		if (trackTransforms)
			transforms.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(param.pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & (2 | 1024)) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg) 
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notify) {
		if (this._parent)
			return _remove.base.call(this, notify);
		if (this._index != null) {
			if (this._project.activeLayer === this)
				this._project.activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(this._project.layers, null, this._index, 1);
			this._installEvents(false);
			this._project._needsUpdate = true;
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project.activeLayer = this;
	},

	_insert: function _insert(above, item, _preserve) {
		if (item instanceof Layer && !item._parent) {
			this._remove(true, true);
			Base.splice(item._project.layers, [this],
					item._index + (above ? 1 : 0), 0);
			this._setProject(item._project, true);
			return this;
		}
		return _insert.base.call(this, above, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		});
		path.setStyle(this._style);
		path.transform(this._matrix);
		if (insert || insert === undefined)
			path.insertAbove(this);
		return path;
	},

	_draw: function(ctx, param) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip;
		if (hasFill || hasStroke || dontPaint) {
			var radius = this._radius,
				type = this._type;
			if (!param.dontStart)
				ctx.beginPath();
			if (type === 'circle') {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = radius.width,
					ry = radius.height,
					kappa = 0.5522847498307936;
				if (type === 'ellipse') {
					var	cx = rx * kappa,
						cy = ry * kappa;
					ctx.moveTo(-rx, 0);
					ctx.bezierCurveTo(-rx, -cy, -cx, -ry, 0, -ry);
					ctx.bezierCurveTo(cx, -ry, rx, -cy, rx, 0);
					ctx.bezierCurveTo(rx, cy, cx, ry, 0, ry);
					ctx.bezierCurveTo(-cx, ry, -rx, cy, -rx, 0);
				} else { 
					var size = this._size,
						width = size.width,
						height = size.height;
					if (rx === 0 && ry === 0) {
						ctx.rect(-width / 2, -height / 2, width, height);
					} else {
						kappa = 1 - kappa;
						var x = width / 2,
							y = height / 2,
							cx = rx * kappa,
							cy = ry * kappa;
						ctx.moveTo(-x, -y + ry);
						ctx.bezierCurveTo(-x, -y + cy, -x + cx, -y, -x + rx, -y);
						ctx.lineTo(x - rx, -y);
						ctx.bezierCurveTo(x - cx, -y, x, -y + cy, x, -y + ry);
						ctx.lineTo(x, y - ry);
						ctx.bezierCurveTo(x, y - cy, x - cx, y, x - rx, y);
						ctx.lineTo(-x + rx, y);
						ctx.bezierCurveTo(-x + cx, y, -x, y - cy, -x, y - ry);
					}
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() { 

	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTest: function _hitTest(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTest.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size)
			this._size = new Size();
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setCanvas(copyCanvas);
		}
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size.equals(size)) {
			var element = this.getElement();
			this.setCanvas(CanvasProvider.getCanvas(size));
			if (element)
				this.getContext(true).drawImage(element, 0, 0,
						size.width, size.height);
		}
	},

	getWidth: function() {
		return this._size.width;
	},

	getHeight: function() {
		return this._size.height;
	},

	isEmpty: function() {
		return this._size.width == 0 && this._size.height == 0;
	},

	getPpi: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image.getContext) {
			this._image = null;
			this._canvas = image;
		} else {
			this._image = image;
			this._canvas = null;
		}
		this._size = new Size(
				image.naturalWidth || image.width,
				image.naturalHeight || image.height);
		this._context = null;
		this._changed(9 | 513);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.fire('load');
				view.update();
			}
		}

			image = document.getElementById(src) || new Image();

		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, {
				load: loaded
			});
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getElement: function() {
		return this._canvas || this._image;
	},

	getSubCanvas: function(rect) { 
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function(rect) { 
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL() : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, transforms: [matrix] }));
		this._matrix.applyToContext(ctx);
		ctx.drawImage(this.getElement(),
				-this._size.width / 2, -this._size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function(point) { 
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function(rect) { 
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTest: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		return this.symbol._definition._getCachedBounds(getter, matrix,
				cacheItem);
	},

	_hitTest: function(point, options) {
		var res = this._symbol._definition.hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return options && options._merged ? options : new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false,
				_merged: true
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if (arg0.point) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else { 
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.isLinear() ? this._point
				: [this._point, this._handleIn, this._handleOut],
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curveIn, curveOut;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curveIn = curves[index - 1]
						|| path._closed && curves[curves.length - 1]))
				curveIn._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curveOut = curves[index]))
				curveOut._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	isLinear: function() {
		return this._handleIn.isZero() && this._handleOut.isZero();
	},

	setLinear: function() {
		this._handleIn.set(0, 0);
		this._handleOut.set(0, 0);
	},

	isColinear: function(segment) {
		var next1 = this.getNext(),
			next2 = segment.getNext();
		return this._handleOut.isZero() && next1._handleIn.isZero()
				&& segment._handleOut.isZero() && next2._handleIn.isZero()
				&& next1._point.subtract(this._point).isColinear(
					next2._point.subtract(segment._point));
	},

	isOrthogonal: function() {
		var prev = this.getPrevious(),
			next = this.getNext();
		return prev._handleOut.isZero() && this._handleIn.isZero()
			&& this._handleOut.isZero() && next._handleIn.isZero()
			&& this._point.subtract(prev._point).isOrthogonal(
					next._point.subtract(this._point));
	},

	isArc: function() {
		var next = this.getNext(),
			handle1 = this._handleOut,
			handle2 = next._handleIn,
			kappa = 0.5522847498307936;
		if (handle1.isOrthogonal(handle2)) {
			var from = this._point,
				to = next._point,
				corner = new Line(from, handle1, true).intersect(
						new Line(to, handle2, true), true);
			return corner && Numerical.isZero(handle1.getLength() /
					corner.subtract(from).getLength() - kappa)
				&& Numerical.isZero(handle2.getLength() /
					corner.subtract(to).getLength() - kappa);
		}
		return false;
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected, 
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	reverse: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn =  !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, 0, coords, 0, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) { 
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',
	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length;
		if (count === 3) {
			this._path = arg0;
			this._segment1 = arg1;
			this._segment2 = arg2;
		} else if (count === 0) {
			this._segment1 = new Segment();
			this._segment2 = new Segment();
		} else if (count === 1) {
			this._segment1 = new Segment(arg0.segment1);
			this._segment2 = new Segment(arg0.segment2);
		} else if (count === 2) {
			this._segment1 = new Segment(arg0);
			this._segment2 = new Segment(arg1);
		} else {
			var point1, handle1, handle2, point2;
			if (count === 4) {
				point1 = arg0;
				handle1 = arg1;
				handle2 = arg2;
				point2 = arg3;
			} else if (count === 8) {
				point1 = [arg0, arg1];
				point2 = [arg6, arg7];
				handle1 = [arg2 - arg0, arg3 - arg1];
				handle2 = [arg4 - arg6, arg5 - arg7];
			}
			this._segment1 = new Segment(point1, null, handle1);
			this._segment2 = new Segment(point2, handle2, null);
		}
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null) {
			this._length = this.isLinear()
				? this._segment2._point.getDistance(this._segment1._point)
				: Curve.getLength(this.getValues(), 0, 1);
		}
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	isLinear: function() {
		return this._segment1._handleOut.isZero()
				&& this._segment2._handleIn.isZero();
	},

	isHorizontal: function() {
		return this.isLinear() && Numerical.isZero(
				this._segment1._point._y - this._segment2._point._y);
	},

	getIntersections: function(curve) {
		return Curve.getIntersections(this.getValues(), curve.getValues(),
				this, curve, []);
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5 
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, ignoreLinear) {
		var parameter = this._getParameter(offset, isParameter),
			tolerance = 0.00001,
			res = null;
		if (parameter > tolerance && parameter < 1 - tolerance) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				isLinear = ignoreLinear ? false : this.isLinear(),
				left = parts[0],
				right = parts[1];

			if (!isLinear) {
				this._segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				this._segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}

			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						!isLinear && new Point(left[4] - x, left[5] - y),
						!isLinear && new Point(right[2] - x, right[3] - y));

			if (this._path) {
				if (this._segment1._index > 0 && this._segment2._index === 0) {
					this._path.add(segment);
				} else {
					this._path.insert(this._segment2._index, segment);
				}
				res = this; 
			} else {
				var end = this._segment2;
				this._segment2 = segment;
				res = new Curve(segment, end);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reverse: function() {
		return new Curve(this._segment2.reverse(), this._segment1.reverse());
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, 0, values, 0, 6);
		return values;
	},

	evaluate: function(v, t, type) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tolerance = 0.00001,
			x, y;

		if (type === 0 && (t < tolerance || t > 1 - tolerance)) {
			var isZero = t < tolerance;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tolerance && c1x === p1x && c1y === p1y
						|| t > 1 - tolerance && c2x === p2x && c2y === p2y) {
					x = p2x - p1x;
					y = p2y - p1y;
				} else if (t < tolerance) {
					x = cx;
					y = cy;
				} else if (t > 1 - tolerance) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by;
					return (x * y2 - y * x2) / Math.pow(x * x + y * y, 3 / 2);
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y], 
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y] 
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, x, y) {
		var tolerance = 0.00001;
		if (Math.abs(v[0] - x) < tolerance && Math.abs(v[1] - y) < tolerance)
			return 0;
		if (Math.abs(v[6] - x) < tolerance && Math.abs(v[7] - y) < tolerance)
			return 1;
		var txs = [],
			tys = [],
			sx = Curve.solveCubic(v, 0, x, txs),
			sy = Curve.solveCubic(v, 1, y, tys),
			tx, ty;
		for (var cx = 0;  sx == -1 || cx < sx;) {
			if (sx == -1 || (tx = txs[cx++]) >= 0 && tx <= 1) {
				for (var cy = 0; sy == -1 || cy < sy;) {
					if (sy == -1 || (ty = tys[cy++]) >= 0 && ty <= 1) {
						if (sx == -1) tx = ty;
						else if (sy == -1) ty = tx;
						if (Math.abs(tx - ty) < tolerance)
							return (tx + ty) * 0.5;
					}
				}
				if (sx == -1)
					break;
			}
		}
		return null;
	},

	getPart: function(v, from, to) {
		if (from > 0)
			v = Curve.subdivide(v, from)[1]; 
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0]; 
		return v;
	},

	isLinear: function(v) {
		var isZero = Numerical.isZero;
		return isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]);
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		return (  3.0 * c1y * p1x - 1.5 * c1y * c2x
				- 1.5 * c1y * p2x - 3.0 * p1y * c1x
				- 1.5 * p1y * c2x - 0.5 * p1y * p2x
				+ 1.5 * c2y * p1x + 1.5 * c2y * c1x
				- 3.0 * c2y * p2x + 0.5 * p2y * p1x
				+ 1.5 * p2y * c1x + 3.0 * p2y * c2x) / 10;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2), 
			max = min.slice(), 
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 0.00001,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				bounds = this._bounds[name] = Path[name]([this._segment1,
						this._segment2], false, this._path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each(['getPoint', 'getTangent', 'getNormal', 'getCurvature'],
	function(name, index) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve.evaluate(values, isParameter
					? offset : Curve.getParameterAt(values, offset, 0), index);
		};
		this[name] = function(parameter) {
			return Curve.evaluate(this.getValues(), parameter, index);
		};
	},
{
	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset,
				start !== undefined ? start : offset < 0 ? 1 : 0);
	},

	getParameterOf: function(point) { 
		var point = Point.read(arguments);
		return Curve.getParameterOf(this.getValues(), point.x, point.y);
	},

	getLocationAt: function(offset, isParameter) {
		if (!isParameter)
			offset = this.getParameterAt(offset);
		return new CurveLocation(this, offset);
	},

	getLocationOf: function(point) { 
		var point = Point.read(arguments),
			t = this.getParameterOf(point);
		return t != null ? new CurveLocation(this, t) : null;
	},

	getNearestLocation: function(point) { 
		var point = Point.read(arguments),
			values = this.getValues(),
			count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(
						Curve.evaluate(values, t, 0), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 0.00001) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		var pt = Curve.evaluate(values, minT, 0);
		return new CurveLocation(this, minT, pt, null, null, null,
				point.getDistance(pt));
	},

	getNearestPoint: function(point) {
		var point = Point.read(arguments);
		return this.getNearestLocation(point).getPoint();
	}

}),
new function() { 

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	return {
		statics: true,

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			var isZero = Numerical.isZero;
			if (a === 0 && b === 1
					&& isZero(v[0] - v[2]) && isZero(v[1] - v[3])
					&& isZero(v[6] - v[4]) && isZero(v[7] - v[5])) {
				var dx = v[6] - v[0], 
					dy = v[7] - v[1]; 
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (offset === 0)
				return start;
			var forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				offset = Math.abs(offset),
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (offset >= rangeLength)
				return forward ? b : a;
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				var count = getIterations(start, t);
				length += start < t
						? Numerical.integrate(ds, start, t, count)
						: -Numerical.integrate(ds, t, start, count);
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds,
					forward ? a + guess : b - guess, 
					a, b, 16, 0.00001);
		}
	};
}, new function() { 
	function addLocation(locations, include, curve1, t1, point1, curve2, t2,
			point2) {
		var loc = new CurveLocation(curve1, t1, point1, curve2, t2, point2);
		if (!include || include(loc))
			locations.push(loc);
	}

	function addCurveIntersections(v1, v2, curve1, curve2, locations, include,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (recursion > 20)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			tolerance = 0.00001,
			hullEpsilon = 1e-9,
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]) || 0,
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]) || 0,
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			tMinNew, tMaxNew, tDiff;
		if (q0x === q3x && uMax - uMin <= hullEpsilon && recursion > 3) {
			tMinNew = (tMax + tMin) / 2;
			tMaxNew = tMinNew;
			tDiff = 0;
		} else {
			var hull = getConvexHull(dp0, dp1, dp2, dp3),
				top = hull[0],
				bottom = hull[1],
				tMinClip, tMaxClip;
			tMinClip = clipConvexHull(top, bottom, dMin, dMax);
			top.reverse();
			bottom.reverse();
			tMaxClip = clipConvexHull(top, bottom, dMin, dMax);
			if (tMinClip == null || tMaxClip == null)
				return false;
			v1 = Curve.getPart(v1, tMinClip, tMaxClip);
			tDiff = tMaxClip - tMinClip;
			tMinNew = tMax * tMinClip + tMin * (1 - tMinClip);
			tMaxNew = tMax * tMaxClip + tMin * (1 - tMaxClip);
		}
		if (oldTDiff > 0.8 && tDiff > 0.8) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], curve2, curve1, locations, include,
					uMin, uMax, tMinNew, t, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					v2, parts[1], curve2, curve1, locations, include,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, curve2, curve1, locations, include,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
				addCurveIntersections(
					parts[1], v1, curve2, curve1, locations, include,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < tolerance) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			if (reverse) {
				addLocation(locations, include,
						curve2, t2, Curve.evaluate(v2, t2, 0),
						curve1, t1, Curve.evaluate(v1, t1, 0));
			} else {
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		} else { 
			addCurveIntersections(v2, v1, curve2, curve1, locations, include,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, ++recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			getSignedDistance = Line.getSignedDistance,
			dist1 = getSignedDistance(0, dq0, 1, dq3, 1 / 3, dq1),
			dist2 = getSignedDistance(0, dq0, 1, dq3, 2 / 3, dq2),
			flip = false,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
			flip = dist1 < 0;
		} else {
			var pmax, cross = 0,
				distZero = dist1 === 0 || dist2 === 0;
			if (Math.abs(dist1) > Math.abs(dist2)) {
				pmax = p1;
				cross = (dq3 - dq2 - (dq3 - dq0) / 3)
						* (2 * (dq3 - dq2) - dq3 + dq1) / 3;
			} else {
				pmax = p2;
				cross = (dq1 - dq0 + (dq0 - dq3) / 3)
						* (-2 * (dq0 - dq1) + dq0 - dq2) / 3;
			}
			hull = cross < 0 || distZero
					? [[p0, pmax, p3], [p0, p3]]
					: [[p0, p1, p2, p3], [p0, p3]];
			flip = dist1 ? dist1 < 0 : dist2 < 0;
		}
		return flip ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		var tProxy,
			tVal = null,
			px, py,
			qx, qy;
		for (var i = 0, l = hullBottom.length - 1; i < l; i++) {
			py = hullBottom[i][1];
			qy = hullBottom[i + 1][1];
			if (py < qy) {
				tProxy = null;
			} else if (qy <= dMax) {
				px = hullBottom[i][0];
				qx = hullBottom[i + 1][0];
				tProxy = px + (dMax  - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		if (hullTop[0][1] <= dMax)
			tProxy = hullTop[0][0];
		for (var i = 0, l = hullTop.length - 1; i < l; i++) {
			py = hullTop[i][1];
			qy = hullTop[i + 1][1];
			if (py >= dMin) {
				tVal = tProxy;
			} else if (py > qy) {
				tVal = null;
			} else if (qy >= dMin) {
				px = hullTop[i][0];
				qx = hullTop[i + 1][0];
				tVal = px + (dMin  - py) * (qx - px) / (qy - py);
			} else {
				continue;
			}
			break;
		}
		return tVal;
	}

	function addCurveLineIntersections(v1, v2, curve1, curve2, locations,
			include) {
		var flip = Curve.isLinear(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rlx2 = ldx * cos - ldy * sin,
			rvl = [0, 0, 0, 0, rlx2, 0, rlx2, 0],
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				y * cos + x * sin);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				x = Curve.evaluate(rvc, tc, 0).x;
			if (x >= 0 && x <= rlx2) {
				var tl = Curve.getParameterOf(rvl, x, 0),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				addLocation(locations, include,
						curve1, t1, Curve.evaluate(v1, t1, 0),
						curve2, t2, Curve.evaluate(v2, t2, 0));
			}
		}
	}

	function addLineIntersection(v1, v2, curve1, curve2, locations, include) {
		var point = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (point) {
			var x = point.x,
				y = point.y;
			addLocation(locations, include,
					curve1, Curve.getParameterOf(v1, x, y), point,
					curve2, Curve.getParameterOf(v2, x, y), point);
		}
	}

	return { statics: {
		getIntersections: function(v1, v2, curve1, curve2, locations, include) {
			var linear1 = Curve.isLinear(v1),
				linear2 = Curve.isLinear(v2);
			(linear1 && linear2
				? addLineIntersection
				: linear1 || linear2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, curve1, curve2, locations, include,
						0, 1, 0, 1, 0, false, 0);
			return locations;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point, _curve2,
			_parameter2, _point2, _distance) {
		this._id = CurveLocation._id = (CurveLocation._id || 0) + 1;
		this._curve = curve;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
		this._parameter = parameter;
		this._point = point;
		this._curve2 = _curve2;
		this._parameter2 = _parameter2;
		this._point2 = _point2;
		this._distance = _distance;
	},

	getSegment: function(_preferFirst) {
		if (!this._segment) {
			var curve = this.getCurve(),
				parameter = this.getParameter();
			if (parameter === 1) {
				this._segment = curve._segment2;
			} else if (parameter === 0 || _preferFirst) {
				this._segment = curve._segment1;
			} else if (parameter == null) {
				return null;
			} else {
				this._segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
		}
		return this._segment;
	},

	getCurve: function(_uncached) {
		if (!this._curve || _uncached) {
			this._curve = this._segment1.getCurve();
			if (this._curve.getParameterOf(this._point) == null)
				this._curve = this._segment2.getPrevious().getCurve();
		}
		return this._curve;
	},

	getIntersection: function() {
		var intersection = this._intersection;
		if (!intersection && this._curve2) {
			var param = this._parameter2;
			this._intersection = intersection = new CurveLocation(
					this._curve2, param, this._point2 || this._point, this);
			intersection._intersection = this;
		}
		return intersection;
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getOffset: function() {
		var path = this.getPath();
		return path && path._getOffset(this);
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getParameter: function(_uncached) {
		if ((this._parameter == null || _uncached) && this._point) {
			var curve = this.getCurve(_uncached && this._point);
			this._parameter = curve && curve.getParameterOf(this._point);
		}
		return this._parameter;
	},

	getPoint: function(_uncached) {
		if ((!this._point || _uncached) && this._parameter != null) {
			var curve = this.getCurve();
			this._point = curve && curve.getPointAt(this._parameter, true);
		}
		return this._point;
	},

	getTangent: function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve.getTangentAt(parameter, true);
	},

	getNormal: function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve.getNormalAt(parameter, true);
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(true);
		return curve && curve.divide(this.getParameter(true), true);
	},

	split: function() {
		var curve = this.getCurve(true);
		return curve && curve.split(this.getParameter(true), true);
	},

	equals: function(loc) {
		var isZero = Numerical.isZero;
		return this === loc
				|| loc
					&& this._curve === loc._curve
					&& this._curve2 === loc._curve2
					&& isZero(this._parameter - loc._parameter)
					&& isZero(this._parameter2 - loc._parameter2)
				|| false;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	}
});

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, _expand) {
		if (this === path)
			path = null;
		if (path && !this.getBounds().touches(path.getBounds()))
			return [];
		var locations = [],
			curves1 = this.getCurves(),
			curves2 = path ? path.getCurves() : curves1,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = path ? path._matrix.orNullIfIdentity() : matrix1,
			length1 = curves1.length,
			length2 = path ? curves2.length : length1,
			values2 = [],
			MIN = 1e-11,
			MAX = 1 - 1e-11;
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = path ? curve1.getValues(matrix1) : values2[i];
			if (!path) {
				var seg1 = curve1.getSegment1(),
					seg2 = curve1.getSegment2(),
					h1 = seg1._handleOut,
					h2 = seg2._handleIn;
				if (new Line(seg1._point.subtract(h1), h1.multiply(2), true)
						.intersect(new Line(seg2._point.subtract(h2),
						h2.multiply(2), true), false)) {
					var parts = Curve.subdivide(values1);
					Curve.getIntersections(
						parts[0], parts[1], curve1, curve1, locations,
						function(loc) {
							if (loc._parameter <= MAX) {
								loc._parameter /= 2;
								loc._parameter2 = 0.5 + loc._parameter2 / 2;
								return true;
							}
						}
					);
				}
			}
			for (var j = path ? 0 : i + 1; j < length2; j++) {
				Curve.getIntersections(
					values1, values2[j], curve1, curves2[j], locations,
					!path && (j === i + 1 || j === length2 - 1 && i === 0)
						&& function(loc) {
							var t = loc._parameter;
							return t >= MIN && t <= MAX;
						}
				);
			}
		}
		var last = locations.length - 1;
		for (var i = last; i >= 0; i--) {
			var loc = locations[i],
				next = loc._curve.getNext(),
				next2 = loc._curve2.getNext();
			if (next && loc._parameter >= MAX) {
				loc._parameter = 0;
				loc._curve = next;
			}
			if (next2 && loc._parameter2 >= MAX) {
				loc._parameter2 = 0;
				loc._curve2 = next2;
			}
		}

		function compare(loc1, loc2) {
			var path1 = loc1.getPath(),
				path2 = loc2.getPath();
			return path1 === path2
					? (loc1.getIndex() + loc1.getParameter())
							- (loc2.getIndex() + loc2.getParameter())
					: path1._id - path2._id;
		}

		if (last > 0) {
			locations.sort(compare);
			for (var i = last; i >= 0; i--) {
				if (locations[i].equals(locations[i === 0 ? last : i - 1])) {
					locations.splice(i, 1);
					last--;
				}
			}
		}
		if (_expand) {
			for (var i = last; i >= 0; i--)
				locations.push(locations[i].getIntersection());
			locations.sort(compare);
		}
		return locations;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				if (move && previous && previous !== 'z')
					this.closePath(true);
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[0], +coords[1]),
							+coords[2], +coords[4], +coords[3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined; 
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._clockwise = undefined;
			if (this._curves && !(flags & 16)) {
				for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
			this._monoCurves = undefined;
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_precision) {
		var segments = this._segments,
			f = Formatter.instance,
			parts = [];

		function addCurve(seg1, seg2, skipLine) {
			var point1 = seg1._point,
				point2 = seg2._point,
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn;
			if (handle1.isZero() && handle2.isZero()) {
				if (!skipLine) {
					parts.push('L' + f.point(point2, _precision));
				}
			} else {
				var end = point2.subtract(point1);
				parts.push('c' + f.point(handle1, _precision)
						+ ' ' + f.point(end.add(handle2), _precision)
						+ ' ' + f.point(end, _precision));
			}
		}

		if (segments.length === 0)
			return '';
		parts.push('M' + f.point(segments[0]._point));
		for (var i = 0, l = segments.length  - 1; i < l; i++)
			addCurve(segments[i], segments[i + 1], false);
		if (this._closed) {
			addCurve(segments[segments.length - 1], segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	isPolygon: function() {
		for (var i = 0, l = this._segments.length; i < l; i++) {
			if (!this._segments[i].isLinear())
				return false;
		}
		return true;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves || segs._curves) {
			if (!curves)
				curves = this._curves = [];
			var from = index > 0 ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, this._countCurves());
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1])
			curve._segment2 = segments[from] || segments[0];
		if (curve = curves[to])
			curve._segment1 = segments[to];
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length, 
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var flattener = new PathFlattener(this),
			pos = 0,
			step = flattener.length / Math.ceil(flattener.length / maxDistance),
			end = flattener.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(flattener.evaluate(pos, 0)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (curve.isLinear() && curve.getLength() === 0)
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			index = arg.index;
			parameter = arg.parameter;
		}
		var tolerance = 0.00001;
		if (parameter >= 1 - tolerance) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter > tolerance) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else if (index > 0) {
				path = this._clone(new Path().insertAbove(this, true));
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return Path.isClockwise(this._segments);
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (last1._point.equals(last2._point))
				path.reverse();
			var first1,
				first2 = path.getFirstSegment();
			if (last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				first1 = this.getFirstSegment();
				if (first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path.closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves();
			this._length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				this._length += curves[i].getLength();
		}
		return this._length;
	},

	getArea: function() {
		var curves = this.getCurves();
		var area = 0;
		for (var i = 0, l = curves.length; i < l; i++)
			area += curves[i].getArea();
		return area;
	},

	_getOffset: function(location) {
		var index = location && location.getIndex();
		if (index != null) {
			var curves = this.getCurves(),
				offset = 0;
			for (var i = 0; i < index; i++)
				offset += curves[i].getLength();
			var curve = curves[index],
				parameter = location.getParameter();
			if (parameter > 0)
				offset += curve.getPartLength(0, parameter);
			return offset;
		}
		return null;
	},

	getLocationOf: function(point) { 
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset; 
			return curves[index].getLocationAt(offset - index, true);
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getPointAt: function(offset, isParameter) {
		var loc = this.getLocationAt(offset, isParameter);
		return loc && loc.getPoint();
	},

	getTangentAt: function(offset, isParameter) {
		var loc = this.getLocationAt(offset, isParameter);
		return loc && loc.getTangent();
	},

	getNormalAt: function(offset, isParameter) {
		var loc = this.getLocationAt(offset, isParameter);
		return loc && loc.getNormal();
	},

	getNearestLocation: function(point) { 
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function(point) { 
		var point = Point.read(arguments);
		return this.getNearestLocation(point).getPoint();
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isColinear(i, j) {
			return segments[i].isColinear(segments[j]);
		}

		function isOrthogonal(i) {
			return segments[i].isOrthogonal();
		}

		function isArc(i) {
			return segments[i].isArc();
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (this.isPolygon() && segments.length === 4
				&& isColinear(0, 2) && isColinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isColinear(1, 5) && isColinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				});
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			shape.setStyle(this._style);
			if (insert || insert === undefined)
				shape.insertAbove(this);
			return shape;
		}
		return null;
	},

	_hitTest: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hasStroke = options.stroke && style.hasStroke(),
			hasFill = options.fill && style.hasFill(),
			radius = hasStroke ? style.getStrokeWidth() / 2
					: hasFill ? 0 : null;
		if (radius != null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius != null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else  if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hasFill && this._contains(point) || loc && !hasStroke
				? new HitResult('fill', this)
				: loc
					? new HitResult('stroke', this, {
						location: loc,
						point: loc.getPoint()
					})
					: null;
	}

}, new function() { 

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(i) {
			var segment = segments[i];
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX == curX && inY == curY && outX == prevX && outY == prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(i);
		if (path._closed && length > 0)
			drawSegment(0);
	}

	return {
		_draw: function(ctx, param) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip;
			if (!dontStart)
				ctx.beginPath();

			var style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var flattener = new PathFlattener(this),
							length = flattener.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								flattener.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
}, new function() { 

	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [], 
			tmp = [], 
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
}, new function() { 
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					EPSILON = 1e-11,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < EPSILON)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count =  ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {  

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	isClockwise: function(segments) {
		var sum = 0;
		for (var i = 0, l = segments.length; i < l; i++) {
			var v = Curve.getValues(
					segments[i], segments[i + 1 < l ? i + 1 : 0]);
			for (var j = 2; j < 8; j += 2)
				sum += (v[j - 2] - v[j]) * (v[j + 1] + v[j - 1]);
		}
		return sum > 0;
	},

	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2), 
			max = min.slice(), 
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i], 
					prevCoords[i + 4], 
					coords[i + 2], 
					coords[i], 
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isColinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().normalize(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() == 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j == 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++)
			paths.push(children[i].getPathData(_precision));
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			child._drawSelected(ctx, mx.isIdentity() ? matrix
					: matrix.clone().concatenate(child._matrix));
		}
	}
}, new function() { 
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current : new Path();
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	function computeBoolean(path1, path2, operator, subtract) {
		function preparePath(path) {
			return path.clone(false).reduce().reorient().transform(null, true);
		}

		var _path1 = preparePath(path1),
			_path2 = path2 && path1 !== path2 && preparePath(path2);
		if (!_path1.isClockwise())
			_path1.reverse();
		if (_path2 && !(subtract ^ _path2.isClockwise()))
			_path2.reverse();
		splitPath(_path1.getIntersections(_path2, true));

		var chain = [],
			windings = [],
			lengths = [],
			segments = [],
			monoCurves = [];

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		segments.sort(function(a, b) {
			var _a = a._intersection,
				_b = b._intersection;
			return !_a && !_b || _a && _b ? 0 : _a ? -1 : 1;
		});
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding != null)
				continue;
			chain.length = windings.length = lengths.length = 0;
			var totalLength = 0,
				startSeg = segment;
			do {
				chain.push(segment);
				lengths.push(totalLength += segment.getCurve().getLength());
				segment = segment.getNext();
			} while (segment && !segment._intersection && segment !== startSeg);
			for (var j = 0; j < 3; j++) {
				var length = totalLength * Math.random(),
					amount = lengths.length,
					k = 0;
				do {
					if (lengths[k] >= length) {
						if (k > 0)
							length -= lengths[k - 1];
						break;
					}
				} while (++k < amount);
				var curve = chain[k].getCurve(),
					point = curve.getPointAt(length),
					hor = curve.isHorizontal(),
					path = curve._path;
				if (path._parent instanceof CompoundPath)
					path = path._parent;
				windings[j] = subtract && _path2
						&& (path === _path1 && _path2._getWinding(point, hor)
						|| path === _path2 && !_path1._getWinding(point, hor))
						? 0
						: getWinding(point, monoCurves, hor);
			}
			windings.sort();
			var winding = windings[1];
			for (var j = chain.length - 1; j >= 0; j--)
				chain[j]._winding = winding;
		}
		var result = new CompoundPath();
		result.addChildren(tracePaths(segments, operator), true);
		_path1.remove();
		if (_path2)
			_path2.remove();
		return result.reduce();
	}

	function splitPath(intersections) {
		var TOLERANCE = 0.00001,
			linearSegments;

		function resetLinear() {
			for (var i = 0, l = linearSegments.length; i < l; i++) {
				var segment = linearSegments[i];
				segment._handleOut.set(0, 0);
				segment._handleIn.set(0, 0);
			}
		}

		for (var i = intersections.length - 1, curve, prevLoc; i >= 0; i--) {
			var loc = intersections[i],
				t = loc._parameter;
			if (prevLoc && prevLoc._curve === loc._curve
					&& prevLoc._parameter > 0) {
				t /= prevLoc._parameter;
			} else {
				if (linearSegments)
					resetLinear();
				curve = loc._curve;
				linearSegments = curve.isLinear() && [];
			}
			var newCurve,
				segment;
			if (newCurve = curve.divide(t, true, true)) {
				segment = newCurve._segment1;
				curve = newCurve.getPrevious();
			} else {
				segment = t < TOLERANCE
					? curve._segment1
					: t > 1 - TOLERANCE
						? curve._segment2
						: curve.getPartLength(0, t) < curve.getPartLength(t, 1)
							? curve._segment1
							: curve._segment2;
			}
			segment._intersection = loc.getIntersection();
			loc._segment = segment;
			if (linearSegments)
				linearSegments.push(segment);
			prevLoc = loc;
		}
		if (linearSegments)
			resetLinear();
	}

	function getWinding(point, curves, horizontal, testContains) {
		var TOLERANCE = 0.00001,
			x = point.x,
			y = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs,
			MAX = 1 - TOLERANCE;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = y - TOLERANCE,
				yAfter = y + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, x, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y0 = Curve.evaluate(values, roots[j], 0).y;
						if (y0 < yBefore && y0 > yTop) {
							yTop = y0;
						} else if (y0 > yAfter && y0 < yBottom) {
							yBottom = y0;
						}
					}
				}
			}
			yTop = (yTop + y) / 2;
			yBottom = (yBottom + y) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(x, yTop), curves);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(x, yBottom), curves);
		} else {
			var xBefore = x - TOLERANCE,
				xAfter = x + TOLERANCE;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding,
					next = curve.next;
				if (winding && (winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
					&& Curve.solveCubic(values, 1, y, roots, 0,
						!next.winding && next.values[1] === y ? 1 : MAX) === 1){
					var t = roots[0],
						x0 = Curve.evaluate(values, t, 0).x,
						slope = Curve.evaluate(values, t, 1).y;
					if (abs(slope) < TOLERANCE && !Curve.isLinear(values)
							|| t < TOLERANCE && slope * Curve.evaluate(
								curve.previous.values, t, 1).y < 0) {
						if (testContains && x0 >= xBefore && x0 <= xAfter) {
							++windLeft;
							++windRight;
						}
					} else if (x0 <= xBefore) {
						windLeft += winding;
					} else if (x0 >= xAfter) {
						windRight += winding;
					}
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function tracePaths(segments, operator, selfOp) {
		operator = operator || function() {
			return true;
		};
		var paths = [],
			ZERO = 1e-3,
			ONE = 1 - 1e-3;
		for (var i = 0, seg, startSeg, l = segments.length; i < l; i++) {
			seg = startSeg = segments[i];
			if (seg._visited || !operator(seg._winding))
				continue;
			var path = new Path(Item.NO_INSERT),
				inter = seg._intersection,
				startInterSeg = inter && inter._segment,
				added = false, 
				dir = 1;
			do {
				var handleIn = dir > 0 ? seg._handleIn : seg._handleOut,
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn,
					interSeg;
				if (added && (!operator(seg._winding) || selfOp)
						&& (inter = seg._intersection)
						&& (interSeg = inter._segment)
						&& interSeg !== startSeg) {
					if (selfOp) {
						seg._visited = interSeg._visited;
						seg = interSeg;
						dir = 1;
					} else {
						var c1 = seg.getCurve();
						if (dir > 0)
							c1 = c1.getPrevious();
						var t1 = c1.getTangentAt(dir < 1 ? ZERO : ONE, true),
							c4 = interSeg.getCurve(),
							c3 = c4.getPrevious(),
							t3 = c3.getTangentAt(ONE, true),
							t4 = c4.getTangentAt(ZERO, true),
							w3 = t1.cross(t3),
							w4 = t1.cross(t4);
						if (w3 * w4 !== 0) {
							var curve = w3 < w4 ? c3 : c4,
								nextCurve = operator(curve._segment1._winding)
									? curve
									: w3 < w4 ? c4 : c3,
								nextSeg = nextCurve._segment1;
							dir = nextCurve === c3 ? -1 : 1;
							if (nextSeg._visited && seg._path !== nextSeg._path
										|| !operator(nextSeg._winding)) {
								dir = 1;
							} else {
								seg._visited = interSeg._visited;
								seg = interSeg;
								if (nextSeg._visited)
									dir = 1;
							}
						} else {
							dir = 1;
						}
					}
					handleOut = dir > 0 ? seg._handleOut : seg._handleIn;
				}
				path.add(new Segment(seg._point, added && handleIn, handleOut));
				added = true;
				seg._visited = true;
				seg = dir > 0 ? seg.getNext() : seg. getPrevious();
			} while (seg && !seg._visited
					&& seg !== startSeg && seg !== startInterSeg
					&& (seg._intersection || operator(seg._winding)));
			if (seg && (seg === startSeg || seg === startInterSeg)) {
				path.firstSegment.setHandleIn((seg === startInterSeg
						? startInterSeg : seg)._handleIn);
				path.setClosed(true);
			} else {
				path.lastSegment._handleOut.set(0, 0);
			}
			if (path._segments.length >
					(path._closed ? path.isPolygon() ? 2 : 0 : 1))
				paths.push(path);
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1 || w === 0;
			}, false);
		},

		intersect: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 2;
			}, false);
		},

		subtract: function(path) {
			return computeBoolean(this, path, function(w) {
				return w === 1;
			}, true);
		},

		exclude: function(path) {
			return new Group([this.subtract(path), path.subtract(this)]);
		},

		divide: function(path) {
			return new Group([this.subtract(path), this.intersect(path)]);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0 
						: y0 > y1
							? -1 
							: 1, 
					previous: prevCurve,
					next: null 
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isLinear(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					TOLERANCE = 0.00001,
					roots = [];
				var count = Numerical.solveQuadratic(a, b, c, roots, TOLERANCE,
						1 - TOLERANCE);
				if (count === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (count > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.evaluate(values, roots[j], 0).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children =  this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		this.addChildren(children);
		var clockwise = children[0].isClockwise();
		for (var i = 1, l = children.length; i < l; i++) { 
			var point = children[i].getInteriorPoint(),
				counters = 0;
			for (var j = i - 1; j >= 0; j--) {
				if (children[j].contains(point))
					counters++;
			}
			children[i].setClockwise(counters % 2 === 0 && clockwise);
		}
		return this;
	}
});

var PathFlattener = Base.extend({
	initialize: function(path) {
		this.curves = []; 
		this.parts = []; 
		this.length = 0; 
		this.index = 0;

		var segments = path._segments,
			segment1 = segments[0],
			segment2,
			that = this;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2);
			that.curves.push(curve);
			that._computeParts(curve, segment1._index, 0, 1);
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);
	},

	_computeParts: function(curve, index, minT, maxT) {
		if ((maxT - minT) > 1 / 32 && !Curve.isFlatEnough(curve, 0.25)) {
			var curves = Curve.subdivide(curve);
			var halfT = (minT + maxT) / 2;
			this._computeParts(curves[0], index, minT, halfT);
			this._computeParts(curves[1], index, halfT, maxT);
		} else {
			var x = curve[6] - curve[0],
				y = curve[7] - curve[1],
				dist = Math.sqrt(x * x + y * y);
			if (dist > 0.00001) {
				this.length += dist;
				this.parts.push({
					offset: this.length,
					value: maxT,
					index: index
				});
			}
		}
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) /  (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	evaluate: function(offset, type) {
		var param = this.getParameterAt(offset);
		return Curve.evaluate(this.curves[param.index], param.value, type);
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
});

var PathFitter = Base.extend({
	initialize: function(path, error) {
		this.points = [];
		var segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				this.points.push(point);
				prev = point;
			}
		}
		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length;
		this.segments = length > 0 ? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());
		return this.segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-11,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X  = C[0][0] * X[1]    - C[1][0] * X[0],
				detXC1  = X[0]    * C[1][1] - X[1]    * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1);
		epsilon *= segLength;
		if (alpha1 < epsilon || alpha2 < epsilon) {
			alpha1 = alpha2 = segLength / 3;
		}

		return [pt1, pt1.add(tan1.normalize(alpha1)),
				pt2.add(tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 0.00001)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y; 
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {

	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1], 
		[2, 0, 1], 
		[1, 0, 3], 
		[1, 2, 0], 
		[3, 1, 0], 
		[0, 1, 2]  
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60; 
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h), 
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,						
					b * (1 - s),			
					b * (1 - s * f),		
					b * (1 - s * (1 - f))	
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:   ( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:            (r - g) / delta + 4) * 60, 
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				value = parser.call(this, value);
				if (value != null) {
					this._components[index] = value;
					this._changed();
				}
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1; 
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type];
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			if (type === 'gradient')
				this._id = Color._id = (Color._id || 0) + 1;
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
}, new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

Base.each(Color._types, function(properties, type) {
	var ctor = this[Base.capitalize(type) + 'Color'] = function(arg) {
			var argType = arg != null && typeof arg,
				components = argType === 'object' && arg.length != null
					? arg
					: argType === 'string'
						? null
						: arguments;
			return components
					? new Color(type, components)
					: new Color(arg);
		};
	if (type.length == 3) {
		var acronym = type.toUpperCase();
		Color[acronym] = this[acronym + 'Color'] = ctor;
	}
}, Base.exports);

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = Gradient._id = (Gradient._id || 0) + 1;
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient &&  this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif', 
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9, 
		leading: 9,
		justification: 9
	};

	var item = {},
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color() 
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old != value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
					this._values[key] = value;
				} else if (isColor && !(value && value.constructor === Color)) {
					this._values[key] = value = Color.read([value], 0,
							{ readNull: true, clone: true });
					if (value)
						value._owner = owner;
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function() {
			return this._style[get]();
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {

	var special = /^(checked|value|selected|disabled)$/i,
		translated = { text: 'textContent', html: 'innerHTML' },
		unitless = { lineHeight: 1, zoom: 1, zIndex: 1, opacity: 1 };

	function create(nodes, parent) {
		var res = [];
		for (var i =  0, l = nodes && nodes.length; i < l;) {
			var el = nodes[i++];
			if (typeof el === 'string') {
				el = document.createElement(el);
			} else if (!el || !el.nodeType) {
				continue;
			}
			if (Base.isPlainObject(nodes[i]))
				DomElement.set(el, nodes[i++]);
			if (Array.isArray(nodes[i]))
				create(nodes[i++], el);
			if (parent)
				parent.appendChild(el);
			res.push(el);
		}
		return res;
	}

	function handlePrefix(el, name, set, value) {
		var prefixes = ['webkit', 'moz', 'Moz', 'ms', 'o', ''],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		create: function(nodes, parent) {
			var isArray = Array.isArray(nodes),
				res = create(isArray ? nodes : arguments, isArray ? parent : null);
			return res.length == 1 ? res[0] : res;
		},

		find: function(selector, root) {
			return (root || document).querySelector(selector);
		},

		findAll: function(selector, root) {
			return (root || document).querySelectorAll(selector);
		},

		get: function(el, key) {
			return el
				? special.test(key)
					? key === 'value' || typeof el[key] !== 'string'
						? el[key]
						: true
					: key in translated
						? el[translated[key]]
						: el.getAttribute(key)
				: null;
		},

		set: function(el, key, value) {
			if (typeof key !== 'string') {
				for (var name in key)
					if (key.hasOwnProperty(name))
						this.set(el, name, key[name]);
			} else if (!el || value === undefined) {
				return el;
			} else if (special.test(key)) {
				el[key] = value;
			} else if (key in translated) {
				el[translated[key]] = value;
			} else if (key === 'style') {
				this.setStyle(el, value);
			} else if (key === 'events') {
				DomEvent.add(el, value);
			} else {
				el.setAttribute(key, value);
			}
			return el;
		},

		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getStyle: function(el, key) {
			return el && el.style[key] || this.getStyles(el)[key] || null;
		},

		setStyle: function(el, key, value) {
			if (typeof key !== 'string') {
				for (var name in key)
					if (key.hasOwnProperty(name))
						this.setStyle(el, name, key[name]);
			} else {
				if (/^-?[\d\.]+$/.test(value) && !(key in unitless))
					value += 'px';
				el.style[key] = value;
			}
			return el;
		},

		hasClass: function(el, cls) {
			return new RegExp('\\s*' + cls + '\\s*').test(el.className);
		},

		addClass: function(el, cls) {
			el.className = (el.className + ' ' + cls).trim();
		},

		removeClass: function(el, cls) {
			el.className = el.className.replace(
				new RegExp('\\s*' + cls + '\\s*'), ' ').trim();
		},

		remove: function(el) {
			if (el.parentNode)
				el.parentNode.removeChild(el);
		},

		removeChildren: function(el) {
			while (el.firstChild)
				el.removeChild(el.firstChild);
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop  || body.clientTop  || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return this.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return this.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return this.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !this.isInvisible(el) && this.getViewportBounds(el).intersects(
					this.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	DomEvent.add(window, {
		focus: function() {
			focused = true;
		},
		blur: function() {
			focused = false;
		}
	});

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Callback, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if (!this._pixelRatio)
			this._pixelRatio = window.devicePixelRatio || 1;
		this._id = element.getAttribute('id');
		if (this._id == null)
			element.setAttribute('id', this._id = 'view-' + View._id++);
		DomEvent.add(element, this._viewEvents);
		var none = 'none';
		DomElement.setPrefixed(element.style, {
			userSelect: none,
			touchAction: none,
			touchCallout: none,
			contentZooming: none,
			userDrag: none,
			tapHighlightColor: 'rgba(0,0,0,0)'
		});
		if (PaperScope.hasAttribute(element, 'resize')) {
			var offset = DomElement.getOffset(element, true),
				that = this;
			size = DomElement.getViewportBounds(element)
					.getSize().subtract(offset);
			this._windowEvents = {
				resize: function() {
					if (!DomElement.isInvisible(element))
						offset = DomElement.getOffset(element, true);
					that.setViewSize(DomElement.getViewportBounds(element)
							.getSize().subtract(offset));
				}
			};
			DomEvent.add(window, this._windowEvents);
		} else {
			size = DomElement.getSize(element);
			if (size.isNaN() || size.isZero()) {
				var getSize = function(name) {
					return element[name]
							|| parseInt(element.getAttribute(name), 10);
				};
				size = new Size(getSize('width'), getSize('height'));
			}
		}
		this._setViewSize(size);
		if (PaperScope.hasAttribute(element, 'stats')
				&& typeof Stats !== 'undefined') {
			this._stats = new Stats();
			var stats = this._stats.domElement,
				style = stats.style,
				offset = DomElement.getOffset(element);
			style.position = 'absolute';
			style.left = offset.x + 'px';
			style.top = offset.y + 'px';
			document.body.appendChild(stats);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.detach('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: {
		onFrame: {
			install: function() {
				this.play();
			},

			uninstall: function() {
				this.pause();
			}
		},

		onResize: {}
	},

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.fire('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.attach('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.detach('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.fire('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null; 
		this.fire('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function(center) {
		center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
}, new function() {
	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			var size = Size.read(arguments);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ canvas);
			canvas = CanvasProvider.getCanvas(size);
		}
		this._context = canvas.getContext('2d');
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (PaperScope.getAttribute(canvas, 'hidpi') !== 'off') {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var width = size.width,
			height = size.height,
			pixelRatio = this._pixelRatio,
			element = this._element,
			style = element.style;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			style.width = width + 'px';
			style.height = height + 'px';
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var ctx = this._context,
			prevFont = ctx.font;
		ctx.font = size + ' serif';
		size = parseFloat(ctx.font);
		ctx.font = prevFont;
		return size;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function() {
		var project = this._project;
		if (!project || !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
}, new function() { 

	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.fire(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: this._scope.settings.hitTolerance,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command', 
		224: 'command'  
	},

	specialChars = {
		9: true, 
		13: true, 
		32: true 
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {}, 
	keyMap = {}, 
	downCode; 

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers)
			modifiers[name] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.fire(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

 Base.extend(Callback, {
	_class: 'Palette',
	_events: [ 'onChange' ],

	initialize: function Palette(title, components, values) {
		var parent = DomElement.find('.palettejs-panel')
			|| DomElement.find('body').appendChild(
				DomElement.create('div', { 'class': 'palettejs-panel' }));
		this._element = parent.appendChild(
			DomElement.create('table', { 'class': 'palettejs-pane' }));
		this._title = title;
		if (!values)
			values = {};
		for (var name in (this.components = components)) {
			var component = components[name];
			if (!(component instanceof Component)) {
				if (component.value == null)
					component.value = values[name];
				component.name = name;
				component = components[name] = new Component(component);
			}
			this._element.appendChild(component._element);
			component._palette = this;
			if (values[name] === undefined)
				values[name] = component.value;
		}
		this.values = Base.each(values, function(value, name) {
			var component = components[name];
			if (component) {
				Base.define(values, name, {
					enumerable: true,
					configurable: true,
					get: function() {
						return component._value;
					},
					set: function(val) {
						component.setValue(val);
					}
				});
			}
		});
		if (window.paper)
			paper.palettes.push(this);
	},

	reset: function() {
		for (var i in this.components)
			this.components[i].reset();
	},

	remove: function() {
		DomElement.remove(this._element);
	}
});

var Component = Base.extend(Callback, {
	_class: 'Component',
	_events: [ 'onChange', 'onClick' ],

	_types: {
		'boolean': {
			type: 'checkbox',
			value: 'checked'
		},

		string: {
			type: 'text'
		},

		number: {
			type: 'number',
			number: true
		},

		button: {
			type: 'button'
		},

		text: {
			tag: 'div',
			value: 'text'
		},

		slider: {
			type: 'range',
			number: true
		},

		list: {
			tag: 'select',

			setOptions: function() {
				DomElement.removeChildren(this._input);
				DomElement.create(Base.each(this._options, function(option) {
					this.push('option', { value: option, text: option });
				}, []), this._input);
			}
		},

		color: {
			type: 'color',

			getValue: function(value) {
				return new Color(value);
			},

			setValue: function(value) {
				return new Color(value).toCSS(
						DomElement.get(this._input, 'type') === 'color');
			}
		}
	},

	initialize: function Component(obj) {
		this._id = Component._id = (Component._id || 0) + 1;
		this._type = obj.type in this._types
			? obj.type
			: 'options' in obj
				? 'list'
				: 'onClick' in obj
					? 'button'
					: typeof obj.value;
		this._meta = this._types[this._type] || { type: this._type };
		var that = this,
			id = 'component-' + this._id;
		this._dontFire = true;
		this._input = DomElement.create(this._meta.tag || 'input', {
			id: id,
			type: this._meta.type,
			events: {
				change: function() {
					that.setValue(
						DomElement.get(this, that._meta.value || 'value'));
				},
				click: function() {
					that.fire('click');
				}
			}
		});
		this.attach('change', function(value) {
			if (!this._dontFire)
				this._palette.fire('change', this, this.name, value);
		});
		this._element = DomElement.create('tr', [
			'td', [this._label = DomElement.create('label', { 'for': id })],
			'td', [this._input]
		]);
		Base.each(obj, function(value, key) {
			this[key] = value;
		}, this);
		this._defaultValue = this._value;
		this._dontFire = false;
	},

	getType: function() {
		return this._type;
	},

	getLabel: function() {
		return this.__label;
	},

	setLabel: function(label) {
		this.__label = label;
		DomElement.set(this._label, 'text', label + ':');
	},

	getOptions: function() {
		return this._options;
	},

	setOptions: function(options) {
		this._options = options;
		var setOptions = this._meta.setOptions;
		if (setOptions)
			setOptions.call(this);
	},

	getValue: function() {
		var value = this._value,
			getValue = this._meta.getValue;
		return getValue ? getValue.call(this, value) : value;
	},

	setValue: function(value) {
		var key = this._meta.value || 'value',
			setValue = this._meta.setValue;
		if (setValue)
			value = setValue.call(this, value);
		DomElement.set(this._input, key, value);
		value = DomElement.get(this._input, key);
		if (this._meta.number)
			value = parseFloat(value, 10);
		if (this._value !== value) {
			this._value = value;
			if (!this._dontFire)
				this.fire('change', this.getValue());
		}
	},

	getRange: function() {
		return [parseFloat(DomElement.get(this._input, 'min')),
				parseFloat(DomElement.get(this._input, 'max'))];
	},

	setRange: function(min, max) {
		var range = Array.isArray(min) ? min : [min, max];
		DomElement.set(this._input, { min: range[0], max: range[1] });
	},

	getMin: function() {
		return this.getRange()[0];
	},

	setMin: function(min) {
		this.setRange(min, this.getMax());
	},

	getMax: function() {
		return this.getRange()[1];
	},

	setMax: function(max) {
		this.setRange(this.getMin(), max);
	},

	getStep: function() {
		return parseFloat(DomElement.get(this._input, 'step'));
	},

	setStep: function(step) {
		DomElement.set(this._input, 'step', step);
	},

	reset: function() {
		this.setValue(this._defaultValue);
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
		 		? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._minDistance > this._maxDistance) {
			this._maxDistance = this._minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && this._maxDistance != null
				&& this._maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = distance;
		this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				var maxDist = maxDistance != null ? maxDistance : 0;
				if (maxDist != 0) {
					if (distance > maxDist) {
						point = this._point.add(vector.normalize(maxDist));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.fire(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback) {
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, true);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height, pixelRatio) {
		var canvas,
			init = true;
		if (typeof width === 'object') {
			pixelRatio = height;
			height = width.height;
			width = width.width;
		}
		if (!pixelRatio) {
			pixelRatio = 1;
		} else if (pixelRatio !== 1) {
			width *= pixelRatio;
			height *= pixelRatio;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (init)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		if (pixelRatio !== 1)
			ctx.scale(pixelRatio, pixelRatio);
		return canvas;
	},

	getContext: function(width, height, pixelRatio) {
		return this.getCanvas(width, height, pixelRatio).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa, 
		br, bg, bb, ba, 
		dr, dg, db;     

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b), 
			mn = min(r, g, b), 
			md; 
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst  = dstData.data,
				src  = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(item, coordinates, center) {
		var matrix = item._matrix,
			trans = matrix.getTranslation(),
			attrs = {};
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item) {
		var attrs = getTransform(item, true),
			size = item.getSize();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		if (options.matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs;
		if (segments.length === 0)
			return null;
		if (item.isPolygon()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs = {
					points: parts.join(' ')
				};
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs = {
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				};
			}
		} else {
			type = 'path';
			var data = item.getPathData();
			attrs = data && { d: data };
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect'; 
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item) {
		var attrs = getTransform(item, true);
		var data = item.getPathData();
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node) {
		var attrs = {},
			parent = item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (!parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (item._visibility != null && !item._visibility)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node && item._data) {
			var data = JSON.stringify(item._data);
			if (data !== '{}')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				size = this.getView().getSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				});
			for (var i = 0, l = layers.length; i < l; i++)
				node.appendChild(exportSVG(layers[i], options));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, isRoot, options) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& (child = importSVG(childNode, false, options))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return data.match(/m/gi).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, isRoot, options) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, isRoot, options);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.attach('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, isRoot, options) {
			return new Symbol(importGroup(node, type, isRoot, options), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split('('),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, isRoot, options) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, isRoot, options),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			prevApplyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, isRoot, options) || null;
		settings.applyMatrix = prevApplyMatrix;
		if (item) {
			if (!(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot)
			definitions = {};
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, true, options));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, true, options);
		}
	});
};

Base.exports.PaperScript = (function() {
	var exports, define,
		scope = this;
!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in hr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=hr[r]);mr=fr.sourceFile||null}function t(e,r){var t=vr(pr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=pr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(pr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,pr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=pr.charCodeAt(br+=2);dr>br&&10!==t&&13!==t&&8232!==t&&8329!==t;)++br,t=pr.charCodeAt(br);fr.onComment&&fr.onComment(!1,pr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;dr>br;){var e=pr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=pr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e)++br,++Ar,Sr=br;else if(14>e&&e>8)++br;else if(47===e){var r=pr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=pr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=pr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function p(){var e=pr.charCodeAt(br+1);return 61===e?x(Et,2):x(Ft,1)}function d(e){var r=pr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Vt,1)}function m(){var e=pr.charCodeAt(br+1);return 61===e?x(Et,2):x(Tt,1)}function h(e){var r=pr.charCodeAt(br+1);return r===e?x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=pr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===pr.charCodeAt(br+2)?3:2,61===pr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):(61===r&&(t=61===pr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=pr.charCodeAt(br+1);return 61===r?x(qt,61===pr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(ht);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(pt);case 123:return++br,i(dt);case 125:return++br,i(mt);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=pr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return p();case 124:case 38:return d(e);case 94:return m();case 43:case 45:return h(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=dr)return i(Br);var r=pr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=pr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=dr&&t(a,"Unterminated regular expression");var o=pr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=pr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=pr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(pr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===pr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===pr.charCodeAt(br)&&(++br,w(10),n=!0);var o=pr.charCodeAt(br);(69===o||101===o)&&(o=pr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(pr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=pr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Vr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=dr&&t(yr,"Unterminated string constant");var n=pr.charCodeAt(br);if(n===e)return++br,i(Fr,r);if(92===n){n=pr.charCodeAt(++br);var a=/^[0-7]+/.exec(pr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Vr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===pr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8329===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=pr.charCodeAt(br);if(Yt(a))Bt&&(e+=pr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=pr.slice(n,br)),Bt=!0,117!=pr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:pr.slice(n,br)}function L(){var e=I(),r=Dr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Vr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){for(Vr=e,br=Lr;Sr>br;)Sr=pr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function T(){this.type=null,this.start=yr,this.end=null}function V(){this.start=xr,this.end=null,null!==mr&&(this.source=mr)}function q(){var e=new T;return fr.locations&&(e.loc=new V),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new T;return r.start=e.start,fr.locations&&(r.loc=new V,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function F(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function D(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===mt||Gt.test(pr.slice(Lr,yr)))}function M(){D(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Vr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Vr=null,Tr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&F(n)&&R(!0),t=!1}return j(r,"Program")}function J(){wr===wt&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;D(yt)||B()?r.label=null:wr!==Dr?X():(r.label=lr(),M());for(var a=0;a<Tr.length;++a){var o=Tr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Tr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Tr.push(Zt),r.body=J(),Tr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Tr.push(Zt),z(ht),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),1===i.declarations.length&&D(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return D(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=D(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),D(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(dt),Tr.push(en);for(var s,c;wr!=mt;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Tr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(pr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(ht),l.param=lr(),Vr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=D($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),r=G(r),M(),r;case tt:return U(),r.test=P(),Tr.push(Zt),r.body=J(),Tr.pop(),j(r,"WhileStatement");case nt:return Vr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case dt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,p=K();if(e===Dr&&"Identifier"===p.type&&D(gt)){for(var a=0;a<Tr.length;++a)Tr[a].name===f&&t(p.start,"Label '"+f+"' is already declared");var d=wr.isLoop?"loop":wr===Yr?"switch":null;return Tr.push({name:f,kind:d}),r.body=J(),Tr.pop(),r.label=p,j(r,"LabeledStatement")}return r.expression=p,M(),j(r,"ExpressionStatement")}}function P(){z(ht);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(dt);!D(mt);){var o=J();t.body.push(o),n&&e&&F(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Tr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Tr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Vr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=D(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!D(bt))break}return j(e,"VariableDeclaration")}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];D(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(D(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var a=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(a,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,U(),e.argument=rr(),r?N(e.argument):Vr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(D(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(D(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(pt),nr(j(t,"MemberExpression"),r)}if(!r&&D(ht)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Dr:return lr();case Or:case Fr:case jr:var e=q();return e.value=Cr,e.raw=pr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case ht:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(pt,!0,!0),j(e,"ArrayExpression");case dt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=D(ht)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!D(mt);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&D(mt))break;var a,o={key:sr()},i=!1;if(D(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==ht&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Vr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Vr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Fr?ar():lr(!0)}function cr(e,r){wr===Dr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(ht);!D(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Tr;if(Rr=!0,Tr=[],e.body=H(!0),Rr=a,Tr=o,Vr||e.body.body.length&&F(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!D(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&D(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Dr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),U(),j(r,"Identifier")}e.version="0.3.2";var fr,pr,dr,mr;e.parse=function(e,t){return pr=String(e),dr=pr.length,r(t),o(),W(fr.program)};var hr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}pr=String(e),dr=pr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(pr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Tr,Vr,qr=[],Or={type:"num"},jr={type:"regexp"},Fr={type:"string"},Dr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},pt={type:"]"},dt={type:"{",beforeExpr:!0},mt={type:"}"},ht={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Tt={binop:4,beforeExpr:!0},Vt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Ft={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:pt,braceL:dt,braceR:mt,parenL:ht,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Dr,eof:Br,num:Or,regexp:jr,string:Fr};for(var Dt in lt)e.tokTypes["_"+Dt]=lt[Dt];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u2028\u2029\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': 'equals',
		'!=': 'equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': null
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function _$_(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $_(operator, value) {
		var handler = unaryOperators[operator];
		if (handler && value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function compile(code) {

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function walkAST(node, parent) {
			if (!node)
				return;
			for (var key in node) {
				if (key === 'range')
					continue;
				var value = node[key];
				if (Array.isArray(value)) {
					for (var i = 0, l = value.length; i < l; i++)
						walkAST(value[i], node);
				} else if (value && typeof value === 'object') {
					walkAST(value, node);
				}
			}
			switch (node && node.type) {
			case 'UnaryExpression': 
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$_("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression': 
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right);
					replaceCode(node, '_$_(' + left + ', "' + node.operator
							+ '", ' + right + ')');
				}
				break;
			case 'UpdateExpression': 
			case 'AssignmentExpression': 
				if (!(parent && (
						parent.type === 'ForStatement'
						|| parent.type === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parent.type === 'MemberExpression'
							&& parent.computed))) {
					if (node.type === 'UpdateExpression') {
						if (!node.prefix) {
							var arg = getCode(node.argument);
							replaceCode(node, arg + ' = _$_(' + arg + ', "'
									+ node.operator[0] + '", 1)');
						}
					} else { 
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right);
							replaceCode(node, left + ' = _$_(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')');
						}
					}
				}
				break;
			}
		}
		walkAST(scope.acorn.parse(code, { ranges: true }));
		return code;
	}

	function execute(code, scope) {
		paper = scope;
		var view = scope.getView(),
			tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
					? new Tool()
					: null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func;
		code = compile(code);
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp(
						'\\b' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ _$_: _$_, $_: $_, view: view, tool: tool }, true);
		expose(scope);
		handlers = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push(key + ': ' + key);
			}
		}, []).join(', ');
		if (handlers)
			code += '\nreturn { ' + handlers + ' };';
		var firefox = window.InstallTrigger;
		if (firefox || window.chrome) {
			var script = document.createElement('script'),
				head = document.head;
			if (firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'paper._execute = function(' + params + ') {' + code + '\n}'
			));
			head.appendChild(script);
			func = paper._execute;
			delete paper._execute;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var res = func.apply(scope, args) || {};
		Base.each(toolHandlers, function(key) {
			var value = res[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (res.onResize)
				view.setOnResize(res.onResize);
			view.fire('resize', {
				size: view.size,
				delta: new Point()
			});
			if (res.onFrame)
				view.setOnFrame(res.onFrame);
			view.update();
		}
	}

	function load() {
		Base.each(document.getElementsByTagName('script'), function(script) {
			if (/^text\/(?:x-|)paperscript$/.test(script.type)
					&& !script.getAttribute('data-paper-ignore')) {
				var canvas = PaperScope.getAttribute(script, 'canvas'),
					scope = PaperScope.get(canvas)
							|| new PaperScope(script).setup(canvas),
					src = script.src;
				if (src) {
					Http.request('get', src, function(code) {
						execute(code, scope);
					});
				} else {
					execute(script.innerHTML, scope);
				}
				script.setAttribute('data-paper-ignore', true);
			}
		}, this);
	}

	if (document.readyState === 'complete') {
		setTimeout(load);
	} else {
		DomEvent.add(window, { load: load });
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		lineNumberBase: 0
	};

}).call(this);

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	DomElement: DomElement,
	DomEvent: DomEvent,
	Http: Http,
	Key: Key
}))();

if (typeof define === 'function' && define.amd)
	define('paper', paper);

return paper;
};

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler.js":[function(require,module,exports){
var utils = require("./utils");

module.exports = {
  /*
   * Compiler passes.
   *
   * Each pass is a function that is passed the AST. It can perform checks on it
   * or modify it as needed. If the pass encounters a semantic error, it throws
   * |PEG.GrammarError|.
   */
  passes: {
    check: {
      reportMissingRules:  require("./compiler/passes/report-missing-rules"),
      reportLeftRecursion: require("./compiler/passes/report-left-recursion")
    },
    transform: {
      removeProxyRules:    require("./compiler/passes/remove-proxy-rules")
    },
    generate: {
      generateBytecode:    require("./compiler/passes/generate-bytecode"),
      generateJavascript:  require("./compiler/passes/generate-javascript")
    }
  },

  /*
   * Generates a parser from a specified grammar AST. Throws |PEG.GrammarError|
   * if the AST contains a semantic error. Note that not all errors are detected
   * during the generation and some may protrude to the generated parser and
   * cause its malfunction.
   */
  compile: function(ast, passes) {
    var options = arguments.length > 2 ? utils.clone(arguments[2]) : {},
        stage;

    /*
     * Extracted into a function just to silence JSHint complaining about
     * creating functions in a loop.
     */
    function runPass(pass) {
      pass(ast, options);
    }

    utils.defaults(options, {
      allowedStartRules:  [ast.rules[0].name],
      cache:              false,
      optimize:           "speed",
      output:             "parser"
    });

    for (stage in passes) {
      if (passes.hasOwnProperty(stage)) {
        utils.each(passes[stage], runPass);
      }
    }

    switch (options.output) {
      case "parser": return eval(ast.code);
      case "source": return ast.code;
    }
  }
};

},{"./compiler/passes/generate-bytecode":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/generate-bytecode.js","./compiler/passes/generate-javascript":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/generate-javascript.js","./compiler/passes/remove-proxy-rules":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/remove-proxy-rules.js","./compiler/passes/report-left-recursion":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/report-left-recursion.js","./compiler/passes/report-missing-rules":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/report-missing-rules.js","./utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/opcodes.js":[function(require,module,exports){
/* Bytecode instruction opcodes. */
module.exports = {
  /* Stack Manipulation */

  PUSH:             0,    // PUSH c
  PUSH_CURR_POS:    1,    // PUSH_CURR_POS
  POP:              2,    // POP
  POP_CURR_POS:     3,    // POP_CURR_POS
  POP_N:            4,    // POP_N n
  NIP:              5,    // NIP
  APPEND:           6,    // APPEND
  WRAP:             7,    // WRAP n
  TEXT:             8,    // TEXT

  /* Conditions and Loops */

  IF:               9,    // IF t, f
  IF_ERROR:         10,   // IF_ERROR t, f
  IF_NOT_ERROR:     11,   // IF_NOT_ERROR t, f
  WHILE_NOT_ERROR:  12,   // WHILE_NOT_ERROR b

  /* Matching */

  MATCH_ANY:        13,   // MATCH_ANY a, f, ...
  MATCH_STRING:     14,   // MATCH_STRING s, a, f, ...
  MATCH_STRING_IC:  15,   // MATCH_STRING_IC s, a, f, ...
  MATCH_REGEXP:     16,   // MATCH_REGEXP r, a, f, ...
  ACCEPT_N:         17,   // ACCEPT_N n
  ACCEPT_STRING:    18,   // ACCEPT_STRING s
  FAIL:             19,   // FAIL e

  /* Calls */

  REPORT_SAVED_POS: 20,   // REPORT_SAVED_POS p
  REPORT_CURR_POS:  21,   // REPORT_CURR_POS
  CALL:             22,   // CALL f, n, pc, p1, p2, ..., pN

  /* Rules */

  RULE:             23,   // RULE r

  /* Failure Reporting */

  SILENT_FAILS_ON:  24,   // SILENT_FAILS_ON
  SILENT_FAILS_OFF: 25    // SILENT_FAILS_FF
};

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/generate-bytecode.js":[function(require,module,exports){
var utils = require("../../utils"),
    op    = require("../opcodes");

/* Generates bytecode.
 *
 * Instructions
 * ============
 *
 * Stack Manipulation
 * ------------------
 *
 *  [0] PUSH c
 *
 *        stack.push(consts[c]);
 *
 *  [1] PUSH_CURR_POS
 *
 *        stack.push(currPos);
 *
 *  [2] POP
 *
 *        stack.pop();
 *
 *  [3] POP_CURR_POS
 *
 *        currPos = stack.pop();
 *
 *  [4] POP_N n
 *
 *        stack.pop(n);
 *
 *  [5] NIP
 *
 *        value = stack.pop();
 *        stack.pop();
 *        stack.push(value);
 *
 *  [6] APPEND
 *
 *        value = stack.pop();
 *        array = stack.pop();
 *        array.push(value);
 *        stack.push(array);
 *
 *  [7] WRAP n
 *
 *        stack.push(stack.pop(n));
 *
 *  [8] TEXT
 *
 *        stack.pop();
 *        stack.push(input.substring(stack.top(), currPos));
 *
 * Conditions and Loops
 * --------------------
 *
 *  [9] IF t, f
 *
 *        if (stack.top()) {
 *          interpret(ip + 3, ip + 3 + t);
 *        } else {
 *          interpret(ip + 3 + t, ip + 3 + t + f);
 *        }
 *
 * [10] IF_ERROR t, f
 *
 *        if (stack.top() === FAILED) {
 *          interpret(ip + 3, ip + 3 + t);
 *        } else {
 *          interpret(ip + 3 + t, ip + 3 + t + f);
 *        }
 *
 * [11] IF_NOT_ERROR t, f
 *
 *        if (stack.top() !== FAILED) {
 *          interpret(ip + 3, ip + 3 + t);
 *        } else {
 *          interpret(ip + 3 + t, ip + 3 + t + f);
 *        }
 *
 * [12] WHILE_NOT_ERROR b
 *
 *        while(stack.top() !== FAILED) {
 *          interpret(ip + 2, ip + 2 + b);
 *        }
 *
 * Matching
 * --------
 *
 * [13] MATCH_ANY a, f, ...
 *
 *        if (input.length > currPos) {
 *          interpret(ip + 3, ip + 3 + a);
 *        } else {
 *          interpret(ip + 3 + a, ip + 3 + a + f);
 *        }
 *
 * [14] MATCH_STRING s, a, f, ...
 *
 *        if (input.substr(currPos, consts[s].length) === consts[s]) {
 *          interpret(ip + 4, ip + 4 + a);
 *        } else {
 *          interpret(ip + 4 + a, ip + 4 + a + f);
 *        }
 *
 * [15] MATCH_STRING_IC s, a, f, ...
 *
 *        if (input.substr(currPos, consts[s].length).toLowerCase() === consts[s]) {
 *          interpret(ip + 4, ip + 4 + a);
 *        } else {
 *          interpret(ip + 4 + a, ip + 4 + a + f);
 *        }
 *
 * [16] MATCH_REGEXP r, a, f, ...
 *
 *        if (consts[r].test(input.charAt(currPos))) {
 *          interpret(ip + 4, ip + 4 + a);
 *        } else {
 *          interpret(ip + 4 + a, ip + 4 + a + f);
 *        }
 *
 * [17] ACCEPT_N n
 *
 *        stack.push(input.substring(currPos, n));
 *        currPos += n;
 *
 * [18] ACCEPT_STRING s
 *
 *        stack.push(consts[s]);
 *        currPos += consts[s].length;
 *
 * [19] FAIL e
 *
 *        stack.push(FAILED);
 *        fail(consts[e]);
 *
 * Calls
 * -----
 *
 * [20] REPORT_SAVED_POS p
 *
 *        reportedPos = stack[p];
 *
 * [21] REPORT_CURR_POS
 *
 *        reportedPos = currPos;
 *
 * [22] CALL f, n, pc, p1, p2, ..., pN
 *
 *        value = consts[f](stack[p1], ..., stack[pN]);
 *        stack.pop(n);
 *        stack.push(value);
 *
 * Rules
 * -----
 *
 * [23] RULE r
 *
 *        stack.push(parseRule(r));
 *
 * Failure Reporting
 * -----------------
 *
 * [24] SILENT_FAILS_ON
 *
 *        silentFails++;
 *
 * [25] SILENT_FAILS_OFF
 *
 *        silentFails--;
 */
module.exports = function(ast) {
  var consts = [];

  function addConst(value) {
    var index = utils.indexOf(consts, function(c) { return c === value; });

    return index === -1 ? consts.push(value) - 1 : index;
  }

  function addFunctionConst(params, code) {
    return addConst(
      "function(" + params.join(", ") + ") {" + code + "}"
    );
  }

  function buildSequence() {
    return Array.prototype.concat.apply([], arguments);
  }

  function buildCondition(condCode, thenCode, elseCode) {
    return condCode.concat(
      [thenCode.length, elseCode.length],
      thenCode,
      elseCode
    );
  }

  function buildLoop(condCode, bodyCode) {
    return condCode.concat([bodyCode.length], bodyCode);
  }

  function buildCall(functionIndex, delta, env, sp) {
    var params = utils.map( utils.values(env), function(p) { return sp - p; });

    return [op.CALL, functionIndex, delta, params.length].concat(params);
  }

  function buildSimplePredicate(expression, negative, context) {
    var undefinedIndex = addConst('void 0'),
        failedIndex    = addConst('peg$FAILED');

    return buildSequence(
      [op.PUSH_CURR_POS],
      [op.SILENT_FAILS_ON],
      generate(expression, {
        sp:     context.sp + 1,
        env:    { },
        action: null
      }),
      [op.SILENT_FAILS_OFF],
      buildCondition(
        [negative ? op.IF_ERROR : op.IF_NOT_ERROR],
        buildSequence(
          [op.POP],
          [negative ? op.POP : op.POP_CURR_POS],
          [op.PUSH, undefinedIndex]
        ),
        buildSequence(
          [op.POP],
          [negative ? op.POP_CURR_POS : op.POP],
          [op.PUSH, failedIndex]
        )
      )
    );
  }

  function buildSemanticPredicate(code, negative, context) {
    var functionIndex  = addFunctionConst(utils.keys(context.env), code),
        undefinedIndex = addConst('void 0'),
        failedIndex    = addConst('peg$FAILED');

    return buildSequence(
      [op.REPORT_CURR_POS],
      buildCall(functionIndex, 0, context.env, context.sp),
      buildCondition(
        [op.IF],
        buildSequence(
          [op.POP],
          [op.PUSH, negative ? failedIndex : undefinedIndex]
        ),
        buildSequence(
          [op.POP],
          [op.PUSH, negative ? undefinedIndex : failedIndex]
        )
      )
    );
  }

  function buildAppendLoop(expressionCode) {
    return buildLoop(
      [op.WHILE_NOT_ERROR],
      buildSequence([op.APPEND], expressionCode)
    );
  }

  var generate = utils.buildNodeVisitor({
    grammar: function(node) {
      utils.each(node.rules, generate);

      node.consts = consts;
    },

    rule: function(node) {
      node.bytecode = generate(node.expression, {
        sp:     -1,  // stack pointer
        env:    { }, // mapping of label names to stack positions
        action: null // action nodes pass themselves to children here
      });
    },

    named: function(node, context) {
      var nameIndex = addConst(
        '{ type: "other", description: ' + utils.quote(node.name) + ' }'
      );

      /*
       * The code generated below is slightly suboptimal because |FAIL| pushes
       * to the stack, so we need to stick a |POP| in front of it. We lack a
       * dedicated instruction that would just report the failure and not touch
       * the stack.
       */
      return buildSequence(
        [op.SILENT_FAILS_ON],
        generate(node.expression, context),
        [op.SILENT_FAILS_OFF],
        buildCondition([op.IF_ERROR], [op.FAIL, nameIndex], [])
      );
    },

    choice: function(node, context) {
      function buildAlternativesCode(alternatives, context) {
        return buildSequence(
          generate(alternatives[0], {
            sp:     context.sp,
            env:    { },
            action: null
          }),
          alternatives.length > 1
            ? buildCondition(
                [op.IF_ERROR],
                buildSequence(
                  [op.POP],
                  buildAlternativesCode(alternatives.slice(1), context)
                ),
                []
              )
            : []
        );
      }

      return buildAlternativesCode(node.alternatives, context);
    },

    action: function(node, context) {
      var env            = { },
          emitCall       = node.expression.type !== "sequence"
                        || node.expression.elements.length === 0,
          expressionCode = generate(node.expression, {
            sp:     context.sp + (emitCall ? 1 : 0),
            env:    env,
            action: node
          }),
          functionIndex  = addFunctionConst(utils.keys(env), node.code);

      return emitCall
        ? buildSequence(
            [op.PUSH_CURR_POS],
            expressionCode,
            buildCondition(
              [op.IF_NOT_ERROR],
              buildSequence(
                [op.REPORT_SAVED_POS, 1],
                buildCall(functionIndex, 1, env, context.sp + 2)
              ),
              []
            ),
            [op.NIP]
          )
        : expressionCode;
    },

    sequence: function(node, context) {
      var emptyArrayIndex;

      function buildElementsCode(elements, context) {
        var processedCount, functionIndex;

        if (elements.length > 0) {
          processedCount = node.elements.length - elements.slice(1).length;

          return buildSequence(
            generate(elements[0], {
              sp:     context.sp,
              env:    context.env,
              action: null
            }),
            buildCondition(
              [op.IF_NOT_ERROR],
              buildElementsCode(elements.slice(1), {
                sp:     context.sp + 1,
                env:    context.env,
                action: context.action
              }),
              buildSequence(
                processedCount > 1 ? [op.POP_N, processedCount] : [op.POP],
                [op.POP_CURR_POS],
                [op.PUSH, failedIndex]
              )
            )
          );
        } else {
          if (context.action) {
            functionIndex = addFunctionConst(
              utils.keys(context.env),
              context.action.code
            );

            return buildSequence(
              [op.REPORT_SAVED_POS, node.elements.length],
              buildCall(
                functionIndex,
                node.elements.length,
                context.env,
                context.sp
              ),
              [op.NIP]
            );
          } else {
            return buildSequence([op.WRAP, node.elements.length], [op.NIP]);
          }
        }
      }

      if (node.elements.length > 0) {
        failedIndex = addConst('peg$FAILED');

        return buildSequence(
          [op.PUSH_CURR_POS],
          buildElementsCode(node.elements, {
            sp:     context.sp + 1,
            env:    context.env,
            action: context.action
          })
        );
      } else {
        emptyArrayIndex = addConst('[]');

        return [op.PUSH, emptyArrayIndex];
      }
    },

    labeled: function(node, context) {
      context.env[node.label] = context.sp + 1;

      return generate(node.expression, {
        sp:     context.sp,
        env:    { },
        action: null
      });
    },

    text: function(node, context) {
      return buildSequence(
        [op.PUSH_CURR_POS],
        generate(node.expression, {
          sp:     context.sp + 1,
          env:    { },
          action: null
        }),
        buildCondition([op.IF_NOT_ERROR], [op.TEXT], []),
        [op.NIP]
      );
    },

    simple_and: function(node, context) {
      return buildSimplePredicate(node.expression, false, context);
    },

    simple_not: function(node, context) {
      return buildSimplePredicate(node.expression, true, context);
    },

    semantic_and: function(node, context) {
      return buildSemanticPredicate(node.code, false, context);
    },

    semantic_not: function(node, context) {
      return buildSemanticPredicate(node.code, true, context);
    },

    optional: function(node, context) {
      var nullIndex = addConst('null');

      return buildSequence(
        generate(node.expression, {
          sp:     context.sp,
          env:    { },
          action: null
        }),
        buildCondition(
          [op.IF_ERROR],
          buildSequence([op.POP], [op.PUSH, nullIndex]),
          []
        )
      );
    },

    zero_or_more: function(node, context) {
      var emptyArrayIndex = addConst('[]');
          expressionCode  = generate(node.expression, {
            sp:     context.sp + 1,
            env:    { },
            action: null
          });

      return buildSequence(
        [op.PUSH, emptyArrayIndex],
        expressionCode,
        buildAppendLoop(expressionCode),
        [op.POP]
      );
    },

    one_or_more: function(node, context) {
      var emptyArrayIndex = addConst('[]');
          failedIndex     = addConst('peg$FAILED');
          expressionCode  = generate(node.expression, {
            sp:     context.sp + 1,
            env:    { },
            action: null
          });

      return buildSequence(
        [op.PUSH, emptyArrayIndex],
        expressionCode,
        buildCondition(
          [op.IF_NOT_ERROR],
          buildSequence(buildAppendLoop(expressionCode), [op.POP]),
          buildSequence([op.POP], [op.POP], [op.PUSH, failedIndex])
        )
      );
    },

    rule_ref: function(node) {
      return [op.RULE, utils.indexOfRuleByName(ast, node.name)];
    },

    literal: function(node) {
      var stringIndex, expectedIndex;

      if (node.value.length > 0) {
        stringIndex = addConst(node.ignoreCase
          ? utils.quote(node.value.toLowerCase())
          : utils.quote(node.value)
        );
        expectedIndex = addConst([
          '{',
          'type: "literal",',
          'value: ' + utils.quote(node.value) + ',',
          'description: ' + utils.quote(utils.quote(node.value)),
          '}'
        ].join(' '));

        /*
         * For case-sensitive strings the value must match the beginning of the
         * remaining input exactly. As a result, we can use |ACCEPT_STRING| and
         * save one |substr| call that would be needed if we used |ACCEPT_N|.
         */
        return buildCondition(
          node.ignoreCase
            ? [op.MATCH_STRING_IC, stringIndex]
            : [op.MATCH_STRING, stringIndex],
          node.ignoreCase
            ? [op.ACCEPT_N, node.value.length]
            : [op.ACCEPT_STRING, stringIndex],
          [op.FAIL, expectedIndex]
        );
      } else {
        stringIndex = addConst('""');

        return [op.PUSH, stringIndex];
      }
    },

    "class": function(node) {
      var regexp, regexpIndex, expectedIndex;

      if (node.parts.length > 0) {
        regexp = '/^['
          + (node.inverted ? '^' : '')
          + utils.map(node.parts, function(part) {
              return part instanceof Array
                ? utils.quoteForRegexpClass(part[0])
                  + '-'
                  + utils.quoteForRegexpClass(part[1])
                : utils.quoteForRegexpClass(part);
            }).join('')
          + ']/' + (node.ignoreCase ? 'i' : '');
      } else {
        /*
         * IE considers regexps /[]/ and /[^]/ as syntactically invalid, so we
         * translate them into euqivalents it can handle.
         */
        regexp = node.inverted ? '/^[\\S\\s]/' : '/^(?!)/';
      }

      regexpIndex   = addConst(regexp);
      expectedIndex = addConst([
        '{',
        'type: "class",',
        'value: ' + utils.quote(node.rawText) + ',',
        'description: ' + utils.quote(node.rawText),
        '}'
      ].join(' '));

      return buildCondition(
        [op.MATCH_REGEXP, regexpIndex],
        [op.ACCEPT_N, 1],
        [op.FAIL, expectedIndex]
      );
    },

    any: function() {
      var expectedIndex = addConst('{ type: "any", description: "any character" }');

      return buildCondition(
        [op.MATCH_ANY],
        [op.ACCEPT_N, 1],
        [op.FAIL, expectedIndex]
      );
    }
  });

  generate(ast);
};

},{"../../utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js","../opcodes":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/opcodes.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/generate-javascript.js":[function(require,module,exports){
var utils = require("../../utils"),
    op    = require("../opcodes");

/* Generates parser JavaScript code. */
module.exports = function(ast, options) {
  /* These only indent non-empty lines to avoid trailing whitespace. */
  function indent2(code)  { return code.replace(/^(.+)$/gm, '  $1');         }
  function indent4(code)  { return code.replace(/^(.+)$/gm, '    $1');       }
  function indent8(code)  { return code.replace(/^(.+)$/gm, '        $1');   }
  function indent10(code) { return code.replace(/^(.+)$/gm, '          $1'); }

  function generateTables() {
    if (options.optimize === "size") {
      return [
        'peg$consts = [',
           indent2(ast.consts.join(',\n')),
        '],',
        '',
        'peg$bytecode = [',
           indent2(utils.map(
             ast.rules,
             function(rule) {
               return 'peg$decode('
                     + utils.quote(utils.map(
                         rule.bytecode,
                         function(b) { return String.fromCharCode(b + 32); }
                       ).join(''))
                     + ')';
             }
           ).join(',\n')),
        '],'
      ].join('\n');
    } else {
      return utils.map(
        ast.consts,
        function(c, i) { return 'peg$c' + i + ' = ' + c + ','; }
      ).join('\n');
    }
  }

  function generateCacheHeader(ruleIndexCode) {
    return [
      'var key    = peg$currPos * ' + ast.rules.length + ' + ' + ruleIndexCode + ',',
      '    cached = peg$cache[key];',
      '',
      'if (cached) {',
      '  peg$currPos = cached.nextPos;',
      '  return cached.result;',
      '}',
      ''
    ].join('\n');
  }

  function generateCacheFooter(resultCode) {
    return [
      '',
      'peg$cache[key] = { nextPos: peg$currPos, result: ' + resultCode + ' };'
    ].join('\n');
  }

  function generateInterpreter() {
    var parts = [];

    function generateCondition(cond, argsLength) {
      var baseLength      = argsLength + 3,
          thenLengthCode = 'bc[ip + ' + (baseLength - 2) + ']',
          elseLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';

      return [
        'ends.push(end);',
        'ips.push(ip + ' + baseLength + ' + ' + thenLengthCode + ' + ' + elseLengthCode + ');',
        '',
        'if (' + cond + ') {',
        '  end = ip + ' + baseLength + ' + ' + thenLengthCode + ';',
        '  ip += ' + baseLength + ';',
        '} else {',
        '  end = ip + ' + baseLength + ' + ' + thenLengthCode + ' + ' + elseLengthCode + ';',
        '  ip += ' + baseLength + ' + ' + thenLengthCode + ';',
        '}',
        '',
        'break;'
      ].join('\n');
    }

    function generateLoop(cond) {
      var baseLength     = 2,
          bodyLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';

      return [
        'if (' + cond + ') {',
        '  ends.push(end);',
        '  ips.push(ip);',
        '',
        '  end = ip + ' + baseLength + ' + ' + bodyLengthCode + ';',
        '  ip += ' + baseLength + ';',
        '} else {',
        '  ip += ' + baseLength + ' + ' + bodyLengthCode + ';',
        '}',
        '',
        'break;'
      ].join('\n');
    }

    function generateCall() {
      var baseLength       = 4,
          paramsLengthCode = 'bc[ip + ' + (baseLength - 1) + ']';

      return [
        'params = bc.slice(ip + ' + baseLength + ', ip + ' + baseLength + ' + ' + paramsLengthCode + ');',
        'for (i = 0; i < ' + paramsLengthCode + '; i++) {',
        '  params[i] = stack[stack.length - 1 - params[i]];',
        '}',
        '',
        'stack.splice(',
        '  stack.length - bc[ip + 2],',
        '  bc[ip + 2],',
        '  peg$consts[bc[ip + 1]].apply(null, params)',
        ');',
        '',
        'ip += ' + baseLength + ' + ' + paramsLengthCode + ';',
        'break;'
      ].join('\n');
    }

    parts.push([
      'function peg$decode(s) {',
      '  var bc = new Array(s.length), i;',
      '',
      '  for (i = 0; i < s.length; i++) {',
      '    bc[i] = s.charCodeAt(i) - 32;',
      '  }',
      '',
      '  return bc;',
      '}',
      '',
      'function peg$parseRule(index) {',
      '  var bc    = peg$bytecode[index],',
      '      ip    = 0,',
      '      ips   = [],',
      '      end   = bc.length,',
      '      ends  = [],',
      '      stack = [],',
      '      params, i;',
      ''
    ].join('\n'));

    if (options.cache) {
      parts.push(indent2(generateCacheHeader('index')));
    }

    parts.push([
      '  function protect(object) {',
      '    return Object.prototype.toString.apply(object) === "[object Array]" ? [] : object;',
      '  }',
      '',
      /*
       * The point of the outer loop and the |ips| & |ends| stacks is to avoid
       * recursive calls for interpreting parts of bytecode. In other words, we
       * implement the |interpret| operation of the abstract machine without
       * function calls. Such calls would likely slow the parser down and more
       * importantly cause stack overflows for complex grammars.
       */
      '  while (true) {',
      '    while (ip < end) {',
      '      switch (bc[ip]) {',
      '        case ' + op.PUSH + ':',             // PUSH c
      /*
       * Hack: One of the constants can be an empty array. It needs to be cloned
       * because it can be modified later on the stack by |APPEND|.
       */
      '          stack.push(protect(peg$consts[bc[ip + 1]]));',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.PUSH_CURR_POS + ':',    // PUSH_CURR_POS
      '          stack.push(peg$currPos);',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.POP + ':',              // POP
      '          stack.pop();',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.POP_CURR_POS + ':',     // POP_CURR_POS
      '          peg$currPos = stack.pop();',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.POP_N + ':',            // POP_N n
      '          stack.length -= bc[ip + 1];',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.NIP + ':',              // NIP
      '          stack.splice(-2, 1);',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.APPEND + ':',           // APPEND
      '          stack[stack.length - 2].push(stack.pop());',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.WRAP + ':',             // WRAP n
      '          stack.push(stack.splice(stack.length - bc[ip + 1], bc[ip + 1]));',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.TEXT + ':',             // TEXT
      '          stack.pop();',
      '          stack.push(input.substring(stack[stack.length - 1], peg$currPos));',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.IF + ':',               // IF t, f
                 indent10(generateCondition('stack[stack.length - 1]', 0)),
      '',
      '        case ' + op.IF_ERROR + ':',         // IF_ERROR t, f
                 indent10(generateCondition(
                   'stack[stack.length - 1] === peg$FAILED',
                   0
                 )),
      '',
      '        case ' + op.IF_NOT_ERROR + ':',     // IF_NOT_ERROR t, f
                 indent10(
                   generateCondition('stack[stack.length - 1] !== peg$FAILED',
                   0
                 )),
      '',
      '        case ' + op.WHILE_NOT_ERROR + ':',  // WHILE_NOT_ERROR b
                 indent10(generateLoop('stack[stack.length - 1] !== peg$FAILED')),
      '',
      '        case ' + op.MATCH_ANY + ':',        // MATCH_ANY a, f, ...
                 indent10(generateCondition('input.length > peg$currPos', 0)),
      '',
      '        case ' + op.MATCH_STRING + ':',     // MATCH_STRING s, a, f, ...
                 indent10(generateCondition(
                   'input.substr(peg$currPos, peg$consts[bc[ip + 1]].length) === peg$consts[bc[ip + 1]]',
                   1
                 )),
      '',
      '        case ' + op.MATCH_STRING_IC + ':',  // MATCH_STRING_IC s, a, f, ...
                 indent10(generateCondition(
                   'input.substr(peg$currPos, peg$consts[bc[ip + 1]].length).toLowerCase() === peg$consts[bc[ip + 1]]',
                   1
                 )),
      '',
      '        case ' + op.MATCH_REGEXP + ':',     // MATCH_REGEXP r, a, f, ...
                 indent10(generateCondition(
                   'peg$consts[bc[ip + 1]].test(input.charAt(peg$currPos))',
                   1
                 )),
      '',
      '        case ' + op.ACCEPT_N + ':',         // ACCEPT_N n
      '          stack.push(input.substr(peg$currPos, bc[ip + 1]));',
      '          peg$currPos += bc[ip + 1];',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.ACCEPT_STRING + ':',    // ACCEPT_STRING s
      '          stack.push(peg$consts[bc[ip + 1]]);',
      '          peg$currPos += peg$consts[bc[ip + 1]].length;',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.FAIL + ':',             // FAIL e
      '          stack.push(peg$FAILED);',
      '          if (peg$silentFails === 0) {',
      '            peg$fail(peg$consts[bc[ip + 1]]);',
      '          }',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.REPORT_SAVED_POS + ':', // REPORT_SAVED_POS p
      '          peg$reportedPos = stack[stack.length - 1 - bc[ip + 1]];',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.REPORT_CURR_POS + ':',  // REPORT_CURR_POS
      '          peg$reportedPos = peg$currPos;',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.CALL + ':',             // CALL f, n, pc, p1, p2, ..., pN
                 indent10(generateCall()),
      '',
      '        case ' + op.RULE + ':',             // RULE r
      '          stack.push(peg$parseRule(bc[ip + 1]));',
      '          ip += 2;',
      '          break;',
      '',
      '        case ' + op.SILENT_FAILS_ON + ':',  // SILENT_FAILS_ON
      '          peg$silentFails++;',
      '          ip++;',
      '          break;',
      '',
      '        case ' + op.SILENT_FAILS_OFF + ':', // SILENT_FAILS_OFF
      '          peg$silentFails--;',
      '          ip++;',
      '          break;',
      '',
      '        default:',
      '          throw new Error("Invalid opcode: " + bc[ip] + ".");',
      '      }',
      '    }',
      '',
      '    if (ends.length > 0) {',
      '      end = ends.pop();',
      '      ip = ips.pop();',
      '    } else {',
      '      break;',
      '    }',
      '  }'
    ].join('\n'));

    if (options.cache) {
      parts.push(indent2(generateCacheFooter('stack[0]')));
    }

    parts.push([
      '',
      '  return stack[0];',
      '}'
    ].join('\n'));

    return parts.join('\n');
  }

  function generateRuleFunction(rule) {
    var parts = [], code;

    function c(i) { return "peg$c" + i; } // |consts[i]| of the abstract machine
    function s(i) { return "s"     + i; } // |stack[i]| of the abstract machine

    var stack = {
          sp:    -1,
          maxSp: -1,

          push: function(exprCode) {
            var code = s(++this.sp) + ' = ' + exprCode + ';';

            if (this.sp > this.maxSp) { this.maxSp = this.sp; }

            return code;
          },

          pop: function() {
            var n, values;

            if (arguments.length === 0) {
              return s(this.sp--);
            } else {
              n = arguments[0];
              values = utils.map(utils.range(this.sp - n + 1, this.sp + 1), s);
              this.sp -= n;

              return values;
            }
          },

          top: function() {
            return s(this.sp);
          },

          index: function(i) {
            return s(this.sp - i);
          }
        };

    function compile(bc) {
      var ip    = 0,
          end   = bc.length,
          parts = [],
          value;

      function compileCondition(cond, argCount) {
        var baseLength = argCount + 3,
            thenLength = bc[ip + baseLength - 2],
            elseLength = bc[ip + baseLength - 1],
            baseSp     = stack.sp,
            thenCode, elseCode, thenSp, elseSp;

        ip += baseLength;
        thenCode = compile(bc.slice(ip, ip + thenLength));
        thenSp = stack.sp;
        ip += thenLength;

        if (elseLength > 0) {
          stack.sp = baseSp;
          elseCode = compile(bc.slice(ip, ip + elseLength));
          elseSp = stack.sp;
          ip += elseLength;

          if (thenSp !== elseSp) {
            throw new Error(
              "Branches of a condition must move the stack pointer in the same way."
            );
          }
        }

        parts.push('if (' + cond + ') {');
        parts.push(indent2(thenCode));
        if (elseLength > 0) {
          parts.push('} else {');
          parts.push(indent2(elseCode));
        }
        parts.push('}');
      }

      function compileLoop(cond) {
        var baseLength = 2,
            bodyLength = bc[ip + baseLength - 1],
            baseSp     = stack.sp,
            bodyCode, bodySp;

        ip += baseLength;
        bodyCode = compile(bc.slice(ip, ip + bodyLength));
        bodySp = stack.sp;
        ip += bodyLength;

        if (bodySp !== baseSp) {
          throw new Error("Body of a loop can't move the stack pointer.");
        }

        parts.push('while (' + cond + ') {');
        parts.push(indent2(bodyCode));
        parts.push('}');
      }

      function compileCall() {
        var baseLength   = 4,
            paramsLength = bc[ip + baseLength - 1];

        var value = c(bc[ip + 1]) + '('
              + utils.map(
                  bc.slice(ip + baseLength, ip + baseLength + paramsLength),
                  stackIndex
                ).join(', ')
              + ')';
        stack.pop(bc[ip + 2]);
        parts.push(stack.push(value));
        ip += baseLength + paramsLength;
      }

      /*
       * Extracted into a function just to silence JSHint complaining about
       * creating functions in a loop.
       */
      function stackIndex(p) {
        return stack.index(p);
      }

      while (ip < end) {
        switch (bc[ip]) {
          case op.PUSH:             // PUSH c
            /*
             * Hack: One of the constants can be an empty array. It needs to be
             * handled specially because it can be modified later on the stack
             * by |APPEND|.
             */
            parts.push(
              stack.push(ast.consts[bc[ip + 1]] === "[]" ? "[]" : c(bc[ip + 1]))
            );
            ip += 2;
            break;

          case op.PUSH_CURR_POS:    // PUSH_CURR_POS
            parts.push(stack.push('peg$currPos'));
            ip++;
            break;

          case op.POP:              // POP
            stack.pop();
            ip++;
            break;

          case op.POP_CURR_POS:     // POP_CURR_POS
            parts.push('peg$currPos = ' + stack.pop() + ';');
            ip++;
            break;

          case op.POP_N:            // POP_N n
            stack.pop(bc[ip + 1]);
            ip += 2;
            break;

          case op.NIP:              // NIP
            value = stack.pop();
            stack.pop();
            parts.push(stack.push(value));
            ip++;
            break;

          case op.APPEND:           // APPEND
            value = stack.pop();
            parts.push(stack.top() + '.push(' + value + ');');
            ip++;
            break;

          case op.WRAP:             // WRAP n
            parts.push(
              stack.push('[' + stack.pop(bc[ip + 1]).join(', ') + ']')
            );
            ip += 2;
            break;

          case op.TEXT:             // TEXT
            stack.pop();
            parts.push(
              stack.push('input.substring(' + stack.top() + ', peg$currPos)')
            );
            ip++;
            break;

          case op.IF:               // IF t, f
            compileCondition(stack.top(), 0);
            break;

          case op.IF_ERROR:         // IF_ERROR t, f
            compileCondition(stack.top() + ' === peg$FAILED', 0);
            break;

          case op.IF_NOT_ERROR:     // IF_NOT_ERROR t, f
            compileCondition(stack.top() + ' !== peg$FAILED', 0);
            break;

          case op.WHILE_NOT_ERROR:  // WHILE_NOT_ERROR b
            compileLoop(stack.top() + ' !== peg$FAILED', 0);
            break;

          case op.MATCH_ANY:        // MATCH_ANY a, f, ...
            compileCondition('input.length > peg$currPos', 0);
            break;

          case op.MATCH_STRING:     // MATCH_STRING s, a, f, ...
            compileCondition(
              eval(ast.consts[bc[ip + 1]]).length > 1
                ? 'input.substr(peg$currPos, '
                    + eval(ast.consts[bc[ip + 1]]).length
                    + ') === '
                    + c(bc[ip + 1])
                : 'input.charCodeAt(peg$currPos) === '
                    + eval(ast.consts[bc[ip + 1]]).charCodeAt(0),
              1
            );
            break;

          case op.MATCH_STRING_IC:  // MATCH_STRING_IC s, a, f, ...
            compileCondition(
              'input.substr(peg$currPos, '
                + eval(ast.consts[bc[ip + 1]]).length
                + ').toLowerCase() === '
                + c(bc[ip + 1]),
              1
            );
            break;

          case op.MATCH_REGEXP:     // MATCH_REGEXP r, a, f, ...
            compileCondition(
              c(bc[ip + 1]) + '.test(input.charAt(peg$currPos))',
              1
            );
            break;

          case op.ACCEPT_N:         // ACCEPT_N n
            parts.push(stack.push(
              bc[ip + 1] > 1
                ? 'input.substr(peg$currPos, ' + bc[ip + 1] + ')'
                : 'input.charAt(peg$currPos)'
            ));
            parts.push(
              bc[ip + 1] > 1
                ? 'peg$currPos += ' + bc[ip + 1] + ';'
                : 'peg$currPos++;'
            );
            ip += 2;
            break;

          case op.ACCEPT_STRING:    // ACCEPT_STRING s
            parts.push(stack.push(c(bc[ip + 1])));
            parts.push(
              eval(ast.consts[bc[ip + 1]]).length > 1
                ? 'peg$currPos += ' + eval(ast.consts[bc[ip + 1]]).length + ';'
                : 'peg$currPos++;'
            );
            ip += 2;
            break;

          case op.FAIL:             // FAIL e
            parts.push(stack.push('peg$FAILED'));
            parts.push('if (peg$silentFails === 0) { peg$fail(' + c(bc[ip + 1]) + '); }');
            ip += 2;
            break;

          case op.REPORT_SAVED_POS: // REPORT_SAVED_POS p
            parts.push('peg$reportedPos = ' + stack.index(bc[ip + 1]) + ';');
            ip += 2;
            break;

          case op.REPORT_CURR_POS:  // REPORT_CURR_POS
            parts.push('peg$reportedPos = peg$currPos;');
            ip++;
            break;

          case op.CALL:             // CALL f, n, pc, p1, p2, ..., pN
            compileCall();
            break;

          case op.RULE:             // RULE r
            parts.push(stack.push("peg$parse" + ast.rules[bc[ip + 1]].name + "()"));
            ip += 2;
            break;

          case op.SILENT_FAILS_ON:  // SILENT_FAILS_ON
            parts.push('peg$silentFails++;');
            ip++;
            break;

          case op.SILENT_FAILS_OFF: // SILENT_FAILS_OFF
            parts.push('peg$silentFails--;');
            ip++;
            break;

          default:
            throw new Error("Invalid opcode: " + bc[ip] + ".");
        }
      }

      return parts.join('\n');
    }

    code = compile(rule.bytecode);

    parts.push([
      'function peg$parse' + rule.name + '() {',
      '  var ' + utils.map(utils.range(0, stack.maxSp + 1), s).join(', ') + ';',
      ''
    ].join('\n'));

    if (options.cache) {
      parts.push(indent2(
        generateCacheHeader(utils.indexOfRuleByName(ast, rule.name))
      ));
    }

    parts.push(indent2(code));

    if (options.cache) {
      parts.push(indent2(generateCacheFooter(s(0))));
    }

    parts.push([
      '',
      '  return ' + s(0) + ';',
      '}'
    ].join('\n'));

    return parts.join('\n');
  }

  var parts = [],
      startRuleIndices,   startRuleIndex,
      startRuleFunctions, startRuleFunction;

  parts.push([
    '(function() {',
    '  /*',
    '   * Generated by PEG.js 0.8.0.',
    '   *',
    '   * http://pegjs.majda.cz/',
    '   */',
    '',
    '  function peg$subclass(child, parent) {',
    '    function ctor() { this.constructor = child; }',
    '    ctor.prototype = parent.prototype;',
    '    child.prototype = new ctor();',
    '  }',
    '',
    '  function SyntaxError(message, expected, found, offset, line, column) {',
    '    this.message  = message;',
    '    this.expected = expected;',
    '    this.found    = found;',
    '    this.offset   = offset;',
    '    this.line     = line;',
    '    this.column   = column;',
    '',
    '    this.name     = "SyntaxError";',
    '  }',
    '',
    '  peg$subclass(SyntaxError, Error);',
    '',
    '  function parse(input) {',
    '    var options = arguments.length > 1 ? arguments[1] : {},',
    '',
    '        peg$FAILED = {},',
    ''
  ].join('\n'));

  if (options.optimize === "size") {
    startRuleIndices = '{ '
                     + utils.map(
                         options.allowedStartRules,
                         function(r) { return r + ': ' + utils.indexOfRuleByName(ast, r); }
                       ).join(', ')
                     + ' }';
    startRuleIndex = utils.indexOfRuleByName(ast, options.allowedStartRules[0]);

    parts.push([
      '        peg$startRuleIndices = ' + startRuleIndices + ',',
      '        peg$startRuleIndex   = ' + startRuleIndex + ','
    ].join('\n'));
  } else {
    startRuleFunctions = '{ '
                     + utils.map(
                         options.allowedStartRules,
                         function(r) { return r + ': peg$parse' + r; }
                       ).join(', ')
                     + ' }';
    startRuleFunction = 'peg$parse' + options.allowedStartRules[0];

    parts.push([
      '        peg$startRuleFunctions = ' + startRuleFunctions + ',',
      '        peg$startRuleFunction  = ' + startRuleFunction + ','
    ].join('\n'));
  }

  parts.push('');

  parts.push(indent8(generateTables()));

  parts.push([
    '',
    '        peg$currPos          = 0,',
    '        peg$reportedPos      = 0,',
    '        peg$cachedPos        = 0,',
    '        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },',
    '        peg$maxFailPos       = 0,',
    '        peg$maxFailExpected  = [],',
    '        peg$silentFails      = 0,', // 0 = report failures, > 0 = silence failures
    ''
  ].join('\n'));

  if (options.cache) {
    parts.push('        peg$cache = {},');
  }

  parts.push([
    '        peg$result;',
    ''
  ].join('\n'));

  if (options.optimize === "size") {
    parts.push([
      '    if ("startRule" in options) {',
      '      if (!(options.startRule in peg$startRuleIndices)) {',
      '        throw new Error("Can\'t start parsing from rule \\"" + options.startRule + "\\".");',
      '      }',
      '',
      '      peg$startRuleIndex = peg$startRuleIndices[options.startRule];',
      '    }'
    ].join('\n'));
  } else {
    parts.push([
      '    if ("startRule" in options) {',
      '      if (!(options.startRule in peg$startRuleFunctions)) {',
      '        throw new Error("Can\'t start parsing from rule \\"" + options.startRule + "\\".");',
      '      }',
      '',
      '      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];',
      '    }'
    ].join('\n'));
  }

  parts.push([
    '',
    '    function text() {',
    '      return input.substring(peg$reportedPos, peg$currPos);',
    '    }',
    '',
    '    function offset() {',
    '      return peg$reportedPos;',
    '    }',
    '',
    '    function line() {',
    '      return peg$computePosDetails(peg$reportedPos).line;',
    '    }',
    '',
    '    function column() {',
    '      return peg$computePosDetails(peg$reportedPos).column;',
    '    }',
    '',
    '    function expected(description) {',
    '      throw peg$buildException(',
    '        null,',
    '        [{ type: "other", description: description }],',
    '        peg$reportedPos',
    '      );',
    '    }',
    '',
    '    function error(message) {',
    '      throw peg$buildException(message, null, peg$reportedPos);',
    '    }',
    '',
    '    function peg$computePosDetails(pos) {',
    '      function advance(details, startPos, endPos) {',
    '        var p, ch;',
    '',
    '        for (p = startPos; p < endPos; p++) {',
    '          ch = input.charAt(p);',
    '          if (ch === "\\n") {',
    '            if (!details.seenCR) { details.line++; }',
    '            details.column = 1;',
    '            details.seenCR = false;',
    '          } else if (ch === "\\r" || ch === "\\u2028" || ch === "\\u2029") {',
    '            details.line++;',
    '            details.column = 1;',
    '            details.seenCR = true;',
    '          } else {',
    '            details.column++;',
    '            details.seenCR = false;',
    '          }',
    '        }',
    '      }',
    '',
    '      if (peg$cachedPos !== pos) {',
    '        if (peg$cachedPos > pos) {',
    '          peg$cachedPos = 0;',
    '          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };',
    '        }',
    '        advance(peg$cachedPosDetails, peg$cachedPos, pos);',
    '        peg$cachedPos = pos;',
    '      }',
    '',
    '      return peg$cachedPosDetails;',
    '    }',
    '',
    '    function peg$fail(expected) {',
    '      if (peg$currPos < peg$maxFailPos) { return; }',
    '',
    '      if (peg$currPos > peg$maxFailPos) {',
    '        peg$maxFailPos = peg$currPos;',
    '        peg$maxFailExpected = [];',
    '      }',
    '',
    '      peg$maxFailExpected.push(expected);',
    '    }',
    '',
    '    function peg$buildException(message, expected, pos) {',
    '      function cleanupExpected(expected) {',
    '        var i = 1;',
    '',
    '        expected.sort(function(a, b) {',
    '          if (a.description < b.description) {',
    '            return -1;',
    '          } else if (a.description > b.description) {',
    '            return 1;',
    '          } else {',
    '            return 0;',
    '          }',
    '        });',
    '',
    /*
     * This works because the bytecode generator guarantees that every
     * expectation object exists only once, so it's enough to use |===| instead
     * of deeper structural comparison.
     */
    '        while (i < expected.length) {',
    '          if (expected[i - 1] === expected[i]) {',
    '            expected.splice(i, 1);',
    '          } else {',
    '            i++;',
    '          }',
    '        }',
    '      }',
    '',
    '      function buildMessage(expected, found) {',
    '        function stringEscape(s) {',
    '          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }',
    '',
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
     * literal except for the closing quote character, backslash, carriage
     * return, line separator, paragraph separator, and line feed. Any character
     * may appear in the form of an escape sequence.
     *
     * For portability, we also escape all control and non-ASCII characters.
     * Note that "\0" and "\v" escape sequences are not used because JSHint does
     * not like the first and IE the second.
     */
    '          return s',
    '            .replace(/\\\\/g,   \'\\\\\\\\\')', // backslash
    '            .replace(/"/g,    \'\\\\"\')',      // closing double quote
    '            .replace(/\\x08/g, \'\\\\b\')',     // backspace
    '            .replace(/\\t/g,   \'\\\\t\')',     // horizontal tab
    '            .replace(/\\n/g,   \'\\\\n\')',     // line feed
    '            .replace(/\\f/g,   \'\\\\f\')',     // form feed
    '            .replace(/\\r/g,   \'\\\\r\')',     // carriage return
    '            .replace(/[\\x00-\\x07\\x0B\\x0E\\x0F]/g, function(ch) { return \'\\\\x0\' + hex(ch); })',
    '            .replace(/[\\x10-\\x1F\\x80-\\xFF]/g,    function(ch) { return \'\\\\x\'  + hex(ch); })',
    '            .replace(/[\\u0180-\\u0FFF]/g,         function(ch) { return \'\\\\u0\' + hex(ch); })',
    '            .replace(/[\\u1080-\\uFFFF]/g,         function(ch) { return \'\\\\u\'  + hex(ch); });',
    '        }',
    '',
    '        var expectedDescs = new Array(expected.length),',
    '            expectedDesc, foundDesc, i;',
    '',
    '        for (i = 0; i < expected.length; i++) {',
    '          expectedDescs[i] = expected[i].description;',
    '        }',
    '',
    '        expectedDesc = expected.length > 1',
    '          ? expectedDescs.slice(0, -1).join(", ")',
    '              + " or "',
    '              + expectedDescs[expected.length - 1]',
    '          : expectedDescs[0];',
    '',
    '        foundDesc = found ? "\\"" + stringEscape(found) + "\\"" : "end of input";',
    '',
    '        return "Expected " + expectedDesc + " but " + foundDesc + " found.";',
    '      }',
    '',
    '      var posDetails = peg$computePosDetails(pos),',
    '          found      = pos < input.length ? input.charAt(pos) : null;',
    '',
    '      if (expected !== null) {',
    '        cleanupExpected(expected);',
    '      }',
    '',
    '      return new SyntaxError(',
    '        message !== null ? message : buildMessage(expected, found),',
    '        expected,',
    '        found,',
    '        pos,',
    '        posDetails.line,',
    '        posDetails.column',
    '      );',
    '    }',
    ''
  ].join('\n'));

  if (options.optimize === "size") {
    parts.push(indent4(generateInterpreter()));
    parts.push('');
  } else {
    utils.each(ast.rules, function(rule) {
      parts.push(indent4(generateRuleFunction(rule)));
      parts.push('');
    });
  }

  if (ast.initializer) {
    parts.push(indent4(ast.initializer.code));
    parts.push('');
  }

  if (options.optimize === "size") {
    parts.push('    peg$result = peg$parseRule(peg$startRuleIndex);');
  } else {
    parts.push('    peg$result = peg$startRuleFunction();');
  }

  parts.push([
    '',
    '    if (peg$result !== peg$FAILED && peg$currPos === input.length) {',
    '      return peg$result;',
    '    } else {',
    '      if (peg$result !== peg$FAILED && peg$currPos < input.length) {',
    '        peg$fail({ type: "end", description: "end of input" });',
    '      }',
    '',
    '      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);',
    '    }',
    '  }',
    '',
    '  return {',
    '    SyntaxError: SyntaxError,',
    '    parse:       parse',
    '  };',
    '})()'
  ].join('\n'));

  ast.code = parts.join('\n');
};

},{"../../utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js","../opcodes":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/opcodes.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/remove-proxy-rules.js":[function(require,module,exports){
var utils = require("../../utils");

/*
 * Removes proxy rules -- that is, rules that only delegate to other rule.
 */
module.exports = function(ast, options) {
  function isProxyRule(node) {
    return node.type === "rule" && node.expression.type === "rule_ref";
  }

  function replaceRuleRefs(ast, from, to) {
    function nop() {}

    function replaceInExpression(node, from, to) {
      replace(node.expression, from, to);
    }

    function replaceInSubnodes(propertyName) {
      return function(node, from, to) {
        utils.each(node[propertyName], function(subnode) {
          replace(subnode, from, to);
        });
      };
    }

    var replace = utils.buildNodeVisitor({
      grammar:      replaceInSubnodes("rules"),
      rule:         replaceInExpression,
      named:        replaceInExpression,
      choice:       replaceInSubnodes("alternatives"),
      sequence:     replaceInSubnodes("elements"),
      labeled:      replaceInExpression,
      text:         replaceInExpression,
      simple_and:   replaceInExpression,
      simple_not:   replaceInExpression,
      semantic_and: nop,
      semantic_not: nop,
      optional:     replaceInExpression,
      zero_or_more: replaceInExpression,
      one_or_more:  replaceInExpression,
      action:       replaceInExpression,

      rule_ref:
        function(node, from, to) {
          if (node.name === from) {
            node.name = to;
          }
        },

      literal:      nop,
      "class":      nop,
      any:          nop
    });

    replace(ast, from, to);
  }

  var indices = [];

  utils.each(ast.rules, function(rule, i) {
    if (isProxyRule(rule)) {
      replaceRuleRefs(ast, rule.name, rule.expression.name);
      if (!utils.contains(options.allowedStartRules, rule.name)) {
        indices.push(i);
      }
    }
  });

  indices.reverse();

  utils.each(indices, function(index) {
    ast.rules.splice(index, 1);
  });
};

},{"../../utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/report-left-recursion.js":[function(require,module,exports){
var utils        = require("../../utils"),
    GrammarError = require("../../grammar-error");

/* Checks that no left recursion is present. */
module.exports = function(ast) {
  function nop() {}

  function checkExpression(node, appliedRules) {
    check(node.expression, appliedRules);
  }

  function checkSubnodes(propertyName) {
    return function(node, appliedRules) {
      utils.each(node[propertyName], function(subnode) {
        check(subnode, appliedRules);
      });
    };
  }

  var check = utils.buildNodeVisitor({
    grammar:     checkSubnodes("rules"),

    rule:
      function(node, appliedRules) {
        check(node.expression, appliedRules.concat(node.name));
      },

    named:       checkExpression,
    choice:      checkSubnodes("alternatives"),
    action:      checkExpression,

    sequence:
      function(node, appliedRules) {
        if (node.elements.length > 0) {
          check(node.elements[0], appliedRules);
        }
      },

    labeled:      checkExpression,
    text:         checkExpression,
    simple_and:   checkExpression,
    simple_not:   checkExpression,
    semantic_and: nop,
    semantic_not: nop,
    optional:     checkExpression,
    zero_or_more: checkExpression,
    one_or_more:  checkExpression,

    rule_ref:
      function(node, appliedRules) {
        if (utils.contains(appliedRules, node.name)) {
          throw new GrammarError(
            "Left recursion detected for rule \"" + node.name + "\"."
          );
        }
        check(utils.findRuleByName(ast, node.name), appliedRules);
      },

    literal:      nop,
    "class":      nop,
    any:          nop
  });

  check(ast, []);
};

},{"../../grammar-error":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/grammar-error.js","../../utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler/passes/report-missing-rules.js":[function(require,module,exports){
var utils        = require("../../utils"),
    GrammarError = require("../../grammar-error");

/* Checks that all referenced rules exist. */
module.exports = function(ast) {
  function nop() {}

  function checkExpression(node) { check(node.expression); }

  function checkSubnodes(propertyName) {
    return function(node) { utils.each(node[propertyName], check); };
  }

  var check = utils.buildNodeVisitor({
    grammar:      checkSubnodes("rules"),
    rule:         checkExpression,
    named:        checkExpression,
    choice:       checkSubnodes("alternatives"),
    action:       checkExpression,
    sequence:     checkSubnodes("elements"),
    labeled:      checkExpression,
    text:         checkExpression,
    simple_and:   checkExpression,
    simple_not:   checkExpression,
    semantic_and: nop,
    semantic_not: nop,
    optional:     checkExpression,
    zero_or_more: checkExpression,
    one_or_more:  checkExpression,

    rule_ref:
      function(node) {
        if (!utils.findRuleByName(ast, node.name)) {
          throw new GrammarError(
            "Referenced rule \"" + node.name + "\" does not exist."
          );
        }
      },

    literal:      nop,
    "class":      nop,
    any:          nop
  });

  check(ast);
};

},{"../../grammar-error":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/grammar-error.js","../../utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/grammar-error.js":[function(require,module,exports){
var utils = require("./utils");

/* Thrown when the grammar contains an error. */
module.exports = function(message) {
  this.name = "GrammarError";
  this.message = message;
};

utils.subclass(module.exports, Error);

},{"./utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/parser.js":[function(require,module,exports){
module.exports = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { grammar: peg$parsegrammar },
        peg$startRuleFunction  = peg$parsegrammar,

        peg$c0 = peg$FAILED,
        peg$c1 = null,
        peg$c2 = [],
        peg$c3 = function(initializer, rules) {
              return {
                type:        "grammar",
                initializer: initializer,
                rules:       rules
              };
            },
        peg$c4 = function(code) {
              return {
                type: "initializer",
                code: code
              };
            },
        peg$c5 = function(name, displayName, expression) {
              return {
                type:        "rule",
                name:        name,
                expression:  displayName !== null
                  ? {
                      type:       "named",
                      name:       displayName,
                      expression: expression
                    }
                  : expression
              };
            },
        peg$c6 = function(head, tail) {
              if (tail.length > 0) {
                var alternatives = [head].concat(utils.map(
                    tail,
                    function(element) { return element[1]; }
                ));
                return {
                  type:         "choice",
                  alternatives: alternatives
                };
              } else {
                return head;
              }
            },
        peg$c7 = function(elements, code) {
              var expression = elements.length !== 1
                ? {
                    type:     "sequence",
                    elements: elements
                  }
                : elements[0];
              return {
                type:       "action",
                expression: expression,
                code:       code
              };
            },
        peg$c8 = function(elements) {
              return elements.length !== 1
                ? {
                    type:     "sequence",
                    elements: elements
                  }
                : elements[0];
            },
        peg$c9 = function(label, expression) {
              return {
                type:       "labeled",
                label:      label,
                expression: expression
              };
            },
        peg$c10 = function(expression) {
              return {
                type:       "text",
                expression: expression
              };
            },
        peg$c11 = function(code) {
              return {
                type: "semantic_and",
                code: code
              };
            },
        peg$c12 = function(expression) {
              return {
                type:       "simple_and",
                expression: expression
              };
            },
        peg$c13 = function(code) {
              return {
                type: "semantic_not",
                code: code
              };
            },
        peg$c14 = function(expression) {
              return {
                type:       "simple_not",
                expression: expression
              };
            },
        peg$c15 = function(expression) {
              return {
                type:       "optional",
                expression: expression
              };
            },
        peg$c16 = function(expression) {
              return {
                type:       "zero_or_more",
                expression: expression
              };
            },
        peg$c17 = function(expression) {
              return {
                type:       "one_or_more",
                expression: expression
              };
            },
        peg$c18 = void 0,
        peg$c19 = function(name) {
              return {
                type: "rule_ref",
                name: name
              };
            },
        peg$c20 = function() { return { type: "any" }; },
        peg$c21 = function(expression) { return expression; },
        peg$c22 = { type: "other", description: "action" },
        peg$c23 = function(braced) { return braced.substr(1, braced.length - 2); },
        peg$c24 = "{",
        peg$c25 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c26 = "}",
        peg$c27 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c28 = /^[^{}]/,
        peg$c29 = { type: "class", value: "[^{}]", description: "[^{}]" },
        peg$c30 = "=",
        peg$c31 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c32 = function() { return "="; },
        peg$c33 = ":",
        peg$c34 = { type: "literal", value: ":", description: "\":\"" },
        peg$c35 = function() { return ":"; },
        peg$c36 = ";",
        peg$c37 = { type: "literal", value: ";", description: "\";\"" },
        peg$c38 = function() { return ";"; },
        peg$c39 = "/",
        peg$c40 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c41 = function() { return "/"; },
        peg$c42 = "&",
        peg$c43 = { type: "literal", value: "&", description: "\"&\"" },
        peg$c44 = function() { return "&"; },
        peg$c45 = "!",
        peg$c46 = { type: "literal", value: "!", description: "\"!\"" },
        peg$c47 = function() { return "!"; },
        peg$c48 = "$",
        peg$c49 = { type: "literal", value: "$", description: "\"$\"" },
        peg$c50 = function() { return "$"; },
        peg$c51 = "?",
        peg$c52 = { type: "literal", value: "?", description: "\"?\"" },
        peg$c53 = function() { return "?"; },
        peg$c54 = "*",
        peg$c55 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c56 = function() { return "*"; },
        peg$c57 = "+",
        peg$c58 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c59 = function() { return "+"; },
        peg$c60 = "(",
        peg$c61 = { type: "literal", value: "(", description: "\"(\"" },
        peg$c62 = function() { return "("; },
        peg$c63 = ")",
        peg$c64 = { type: "literal", value: ")", description: "\")\"" },
        peg$c65 = function() { return ")"; },
        peg$c66 = ".",
        peg$c67 = { type: "literal", value: ".", description: "\".\"" },
        peg$c68 = function() { return "."; },
        peg$c69 = { type: "other", description: "identifier" },
        peg$c70 = "_",
        peg$c71 = { type: "literal", value: "_", description: "\"_\"" },
        peg$c72 = function(chars) { return chars; },
        peg$c73 = { type: "other", description: "literal" },
        peg$c74 = "i",
        peg$c75 = { type: "literal", value: "i", description: "\"i\"" },
        peg$c76 = function(value, flags) {
              return {
                type:       "literal",
                value:      value,
                ignoreCase: flags === "i"
              };
            },
        peg$c77 = { type: "other", description: "string" },
        peg$c78 = function(string) { return string; },
        peg$c79 = "\"",
        peg$c80 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c81 = function(chars) { return chars.join(""); },
        peg$c82 = "\\",
        peg$c83 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c84 = { type: "any", description: "any character" },
        peg$c85 = function(char_) { return char_; },
        peg$c86 = "'",
        peg$c87 = { type: "literal", value: "'", description: "\"'\"" },
        peg$c88 = { type: "other", description: "character class" },
        peg$c89 = "[",
        peg$c90 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c91 = "^",
        peg$c92 = { type: "literal", value: "^", description: "\"^\"" },
        peg$c93 = "]",
        peg$c94 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c95 = function(inverted, parts, flags) {
              var partsConverted = utils.map(parts, function(part) { return part.data; });
              var rawText = "["
                + (inverted !== null ? inverted : "")
                + utils.map(parts, function(part) { return part.rawText; }).join("")
                + "]"
                + (flags !== null ? flags : "");

              return {
                type:       "class",
                parts:      partsConverted,
                // FIXME: Get the raw text from the input directly.
                rawText:    rawText,
                inverted:   inverted === "^",
                ignoreCase: flags === "i"
              };
            },
        peg$c96 = "-",
        peg$c97 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c98 = function(begin, end) {
              if (begin.data.charCodeAt(0) > end.data.charCodeAt(0)) {
                error(
                  "Invalid character range: " + begin.rawText + "-" + end.rawText + "."
                );
              }

              return {
                data:    [begin.data, end.data],
                // FIXME: Get the raw text from the input directly.
                rawText: begin.rawText + "-" + end.rawText
              };
            },
        peg$c99 = function(char_) {
              return {
                data:    char_,
                // FIXME: Get the raw text from the input directly.
                rawText: utils.quoteForRegexpClass(char_)
              };
            },
        peg$c100 = "x",
        peg$c101 = { type: "literal", value: "x", description: "\"x\"" },
        peg$c102 = "u",
        peg$c103 = { type: "literal", value: "u", description: "\"u\"" },
        peg$c104 = function(char_) {
              return char_
                .replace("b", "\b")
                .replace("f", "\f")
                .replace("n", "\n")
                .replace("r", "\r")
                .replace("t", "\t")
                .replace("v", "\x0B"); // IE does not recognize "\v".
            },
        peg$c105 = "\\0",
        peg$c106 = { type: "literal", value: "\\0", description: "\"\\\\0\"" },
        peg$c107 = function() { return "\x00"; },
        peg$c108 = "\\x",
        peg$c109 = { type: "literal", value: "\\x", description: "\"\\\\x\"" },
        peg$c110 = function(digits) {
              return String.fromCharCode(parseInt(digits, 16));
            },
        peg$c111 = "\\u",
        peg$c112 = { type: "literal", value: "\\u", description: "\"\\\\u\"" },
        peg$c113 = function(eol) { return eol; },
        peg$c114 = /^[0-9]/,
        peg$c115 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c116 = /^[0-9a-fA-F]/,
        peg$c117 = { type: "class", value: "[0-9a-fA-F]", description: "[0-9a-fA-F]" },
        peg$c118 = /^[a-z]/,
        peg$c119 = { type: "class", value: "[a-z]", description: "[a-z]" },
        peg$c120 = /^[A-Z]/,
        peg$c121 = { type: "class", value: "[A-Z]", description: "[A-Z]" },
        peg$c122 = { type: "other", description: "comment" },
        peg$c123 = "//",
        peg$c124 = { type: "literal", value: "//", description: "\"//\"" },
        peg$c125 = "/*",
        peg$c126 = { type: "literal", value: "/*", description: "\"/*\"" },
        peg$c127 = "*/",
        peg$c128 = { type: "literal", value: "*/", description: "\"*/\"" },
        peg$c129 = { type: "other", description: "end of line" },
        peg$c130 = "\n",
        peg$c131 = { type: "literal", value: "\n", description: "\"\\n\"" },
        peg$c132 = "\r\n",
        peg$c133 = { type: "literal", value: "\r\n", description: "\"\\r\\n\"" },
        peg$c134 = "\r",
        peg$c135 = { type: "literal", value: "\r", description: "\"\\r\"" },
        peg$c136 = "\u2028",
        peg$c137 = { type: "literal", value: "\u2028", description: "\"\\u2028\"" },
        peg$c138 = "\u2029",
        peg$c139 = { type: "literal", value: "\u2029", description: "\"\\u2029\"" },
        peg$c140 = /^[\n\r\u2028\u2029]/,
        peg$c141 = { type: "class", value: "[\\n\\r\\u2028\\u2029]", description: "[\\n\\r\\u2028\\u2029]" },
        peg$c142 = { type: "other", description: "whitespace" },
        peg$c143 = /^[ \t\x0B\f\xA0\uFEFF\u1680\u180E\u2000-\u200A\u202F\u205F\u3000]/,
        peg$c144 = { type: "class", value: "[ \\t\\x0B\\f\\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]", description: "[ \\t\\x0B\\f\\xA0\\uFEFF\\u1680\\u180E\\u2000-\\u200A\\u202F\\u205F\\u3000]" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parsegrammar() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parse__();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseinitializer();
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parserule();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parserule();
            }
          } else {
            s3 = peg$c0;
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c3(s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseinitializer() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseaction();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesemicolon();
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c4(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parserule() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsestring();
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseequals();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsechoice();
            if (s4 !== peg$FAILED) {
              s5 = peg$parsesemicolon();
              if (s5 === peg$FAILED) {
                s5 = peg$c1;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c5(s1, s2, s4);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsechoice() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsesequence();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$parseslash();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsesequence();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$parseslash();
          if (s4 !== peg$FAILED) {
            s5 = peg$parsesequence();
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c6(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsesequence() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parselabeled();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parselabeled();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseaction();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c7(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = [];
        s2 = peg$parselabeled();
        while (s2 !== peg$FAILED) {
          s1.push(s2);
          s2 = peg$parselabeled();
        }
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c8(s1);
        }
        s0 = s1;
      }

      return s0;
    }

    function peg$parselabeled() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecolon();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseprefixed();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c9(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseprefixed();
      }

      return s0;
    }

    function peg$parseprefixed() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsedollar();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsesuffixed();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c10(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseand();
        if (s1 !== peg$FAILED) {
          s2 = peg$parseaction();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c11(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseand();
          if (s1 !== peg$FAILED) {
            s2 = peg$parsesuffixed();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c12(s2);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsenot();
            if (s1 !== peg$FAILED) {
              s2 = peg$parseaction();
              if (s2 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c13(s2);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parsenot();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsesuffixed();
                if (s2 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c14(s2);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
              if (s0 === peg$FAILED) {
                s0 = peg$parsesuffixed();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesuffixed() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parseprimary();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsequestion();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c15(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseprimary();
        if (s1 !== peg$FAILED) {
          s2 = peg$parsestar();
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c16(s1);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseprimary();
          if (s1 !== peg$FAILED) {
            s2 = peg$parseplus();
            if (s2 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c17(s1);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
          if (s0 === peg$FAILED) {
            s0 = peg$parseprimary();
          }
        }
      }

      return s0;
    }

    function peg$parseprimary() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parseidentifier();
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$currPos;
        s4 = peg$parsestring();
        if (s4 === peg$FAILED) {
          s4 = peg$c1;
        }
        if (s4 !== peg$FAILED) {
          s5 = peg$parseequals();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c18;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c19(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      if (s0 === peg$FAILED) {
        s0 = peg$parseliteral();
        if (s0 === peg$FAILED) {
          s0 = peg$parseclass();
          if (s0 === peg$FAILED) {
            s0 = peg$currPos;
            s1 = peg$parsedot();
            if (s1 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c20();
            }
            s0 = s1;
            if (s0 === peg$FAILED) {
              s0 = peg$currPos;
              s1 = peg$parselparen();
              if (s1 !== peg$FAILED) {
                s2 = peg$parsechoice();
                if (s2 !== peg$FAILED) {
                  s3 = peg$parserparen();
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s0;
                    s1 = peg$c21(s2);
                    s0 = s1;
                  } else {
                    peg$currPos = s0;
                    s0 = peg$c0;
                  }
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parseaction() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsebraced();
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c23(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c22); }
      }

      return s0;
    }

    function peg$parsebraced() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 123) {
        s2 = peg$c24;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c25); }
      }
      if (s2 !== peg$FAILED) {
        s3 = [];
        s4 = peg$parsebraced();
        if (s4 === peg$FAILED) {
          s4 = peg$parsenonBraceCharacters();
        }
        while (s4 !== peg$FAILED) {
          s3.push(s4);
          s4 = peg$parsebraced();
          if (s4 === peg$FAILED) {
            s4 = peg$parsenonBraceCharacters();
          }
        }
        if (s3 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 125) {
            s4 = peg$c26;
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c27); }
          }
          if (s4 !== peg$FAILED) {
            s2 = [s2, s3, s4];
            s1 = s2;
          } else {
            peg$currPos = s1;
            s1 = peg$c0;
          }
        } else {
          peg$currPos = s1;
          s1 = peg$c0;
        }
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        s1 = input.substring(s0, peg$currPos);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsenonBraceCharacters() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsenonBraceCharacter();
      if (s1 !== peg$FAILED) {
        while (s1 !== peg$FAILED) {
          s0.push(s1);
          s1 = peg$parsenonBraceCharacter();
        }
      } else {
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsenonBraceCharacter() {
      var s0;

      if (peg$c28.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c29); }
      }

      return s0;
    }

    function peg$parseequals() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 61) {
        s1 = peg$c30;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c31); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c32();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsecolon() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c33;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c34); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c35();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsesemicolon() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 59) {
        s1 = peg$c36;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c37); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c38();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseslash() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 47) {
        s1 = peg$c39;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c40); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c41();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseand() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 38) {
        s1 = peg$c42;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c44();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsenot() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 33) {
        s1 = peg$c45;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c46); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c47();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsedollar() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 36) {
        s1 = peg$c48;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c49); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c50();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsequestion() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 63) {
        s1 = peg$c51;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c53();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsestar() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 42) {
        s1 = peg$c54;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c56();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseplus() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 43) {
        s1 = peg$c57;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c59();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parselparen() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 40) {
        s1 = peg$c60;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c62();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parserparen() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 41) {
        s1 = peg$c63;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c64); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c65();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsedot() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 46) {
        s1 = peg$c66;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c67); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c68();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseidentifier() {
      var s0, s1, s2, s3, s4, s5;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$currPos;
      s2 = peg$currPos;
      s3 = peg$parseletter();
      if (s3 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 95) {
          s3 = peg$c70;
          peg$currPos++;
        } else {
          s3 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c71); }
        }
      }
      if (s3 !== peg$FAILED) {
        s4 = [];
        s5 = peg$parseletter();
        if (s5 === peg$FAILED) {
          s5 = peg$parsedigit();
          if (s5 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 95) {
              s5 = peg$c70;
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c71); }
            }
          }
        }
        while (s5 !== peg$FAILED) {
          s4.push(s5);
          s5 = peg$parseletter();
          if (s5 === peg$FAILED) {
            s5 = peg$parsedigit();
            if (s5 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 95) {
                s5 = peg$c70;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c71); }
              }
            }
          }
        }
        if (s4 !== peg$FAILED) {
          s3 = [s3, s4];
          s2 = s3;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
      } else {
        peg$currPos = s2;
        s2 = peg$c0;
      }
      if (s2 !== peg$FAILED) {
        s2 = input.substring(s1, peg$currPos);
      }
      s1 = s2;
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c72(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c69); }
      }

      return s0;
    }

    function peg$parseliteral() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsedoubleQuotedString();
      if (s1 === peg$FAILED) {
        s1 = peg$parsesingleQuotedString();
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 105) {
          s2 = peg$c74;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c75); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parse__();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c76(s1, s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c73); }
      }

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsedoubleQuotedString();
      if (s1 === peg$FAILED) {
        s1 = peg$parsesingleQuotedString();
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parse__();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c78(s1);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c77); }
      }

      return s0;
    }

    function peg$parsedoubleQuotedString() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 34) {
        s1 = peg$c79;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsedoubleQuotedCharacter();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsedoubleQuotedCharacter();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s3 = peg$c79;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c80); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c81(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsedoubleQuotedCharacter() {
      var s0;

      s0 = peg$parsesimpleDoubleQuotedCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesimpleEscapeSequence();
        if (s0 === peg$FAILED) {
          s0 = peg$parsezeroEscapeSequence();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehexEscapeSequence();
            if (s0 === peg$FAILED) {
              s0 = peg$parseunicodeEscapeSequence();
              if (s0 === peg$FAILED) {
                s0 = peg$parseeolEscapeSequence();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesimpleDoubleQuotedCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 34) {
        s2 = peg$c79;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c80); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c82;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c83); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseeolChar();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c18;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c84); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c85(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsesingleQuotedString() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 39) {
        s1 = peg$c86;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c87); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsesingleQuotedCharacter();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsesingleQuotedCharacter();
        }
        if (s2 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 39) {
            s3 = peg$c86;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c87); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c81(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsesingleQuotedCharacter() {
      var s0;

      s0 = peg$parsesimpleSingleQuotedCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesimpleEscapeSequence();
        if (s0 === peg$FAILED) {
          s0 = peg$parsezeroEscapeSequence();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehexEscapeSequence();
            if (s0 === peg$FAILED) {
              s0 = peg$parseunicodeEscapeSequence();
              if (s0 === peg$FAILED) {
                s0 = peg$parseeolEscapeSequence();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesimpleSingleQuotedCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 39) {
        s2 = peg$c86;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c87); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c82;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c83); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseeolChar();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c18;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c84); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c85(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseclass() {
      var s0, s1, s2, s3, s4, s5, s6;

      peg$silentFails++;
      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 91) {
        s1 = peg$c89;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c90); }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 94) {
          s2 = peg$c91;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c92); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c1;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseclassCharacterRange();
          if (s4 === peg$FAILED) {
            s4 = peg$parseclassCharacter();
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parseclassCharacterRange();
            if (s4 === peg$FAILED) {
              s4 = peg$parseclassCharacter();
            }
          }
          if (s3 !== peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 93) {
              s4 = peg$c93;
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c94); }
            }
            if (s4 !== peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 105) {
                s5 = peg$c74;
                peg$currPos++;
              } else {
                s5 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c75); }
              }
              if (s5 === peg$FAILED) {
                s5 = peg$c1;
              }
              if (s5 !== peg$FAILED) {
                s6 = peg$parse__();
                if (s6 !== peg$FAILED) {
                  peg$reportedPos = s0;
                  s1 = peg$c95(s2, s3, s5);
                  s0 = s1;
                } else {
                  peg$currPos = s0;
                  s0 = peg$c0;
                }
              } else {
                peg$currPos = s0;
                s0 = peg$c0;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c0;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c88); }
      }

      return s0;
    }

    function peg$parseclassCharacterRange() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseclassCharacter();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c96;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c97); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parseclassCharacter();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c98(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseclassCharacter() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsebracketDelimitedCharacter();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c99(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsebracketDelimitedCharacter() {
      var s0;

      s0 = peg$parsesimpleBracketDelimitedCharacter();
      if (s0 === peg$FAILED) {
        s0 = peg$parsesimpleEscapeSequence();
        if (s0 === peg$FAILED) {
          s0 = peg$parsezeroEscapeSequence();
          if (s0 === peg$FAILED) {
            s0 = peg$parsehexEscapeSequence();
            if (s0 === peg$FAILED) {
              s0 = peg$parseunicodeEscapeSequence();
              if (s0 === peg$FAILED) {
                s0 = peg$parseeolEscapeSequence();
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsesimpleBracketDelimitedCharacter() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$currPos;
      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 93) {
        s2 = peg$c93;
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c94); }
      }
      if (s2 === peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 92) {
          s2 = peg$c82;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c83); }
        }
        if (s2 === peg$FAILED) {
          s2 = peg$parseeolChar();
        }
      }
      peg$silentFails--;
      if (s2 === peg$FAILED) {
        s1 = peg$c18;
      } else {
        peg$currPos = s1;
        s1 = peg$c0;
      }
      if (s1 !== peg$FAILED) {
        if (input.length > peg$currPos) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c84); }
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c85(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsesimpleEscapeSequence() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c82;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parsedigit();
        if (s3 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 120) {
            s3 = peg$c100;
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c101); }
          }
          if (s3 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 117) {
              s3 = peg$c102;
              peg$currPos++;
            } else {
              s3 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c103); }
            }
            if (s3 === peg$FAILED) {
              s3 = peg$parseeolChar();
            }
          }
        }
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c18;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s3 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c84); }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c104(s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsezeroEscapeSequence() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c105) {
        s1 = peg$c105;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c106); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        peg$silentFails++;
        s3 = peg$parsedigit();
        peg$silentFails--;
        if (s3 === peg$FAILED) {
          s2 = peg$c18;
        } else {
          peg$currPos = s2;
          s2 = peg$c0;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c107();
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsehexEscapeSequence() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c108) {
        s1 = peg$c108;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c109); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parsehexDigit();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsehexDigit();
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c110(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseunicodeEscapeSequence() {
      var s0, s1, s2, s3, s4, s5, s6, s7;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c111) {
        s1 = peg$c111;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c112); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$currPos;
        s3 = peg$currPos;
        s4 = peg$parsehexDigit();
        if (s4 !== peg$FAILED) {
          s5 = peg$parsehexDigit();
          if (s5 !== peg$FAILED) {
            s6 = peg$parsehexDigit();
            if (s6 !== peg$FAILED) {
              s7 = peg$parsehexDigit();
              if (s7 !== peg$FAILED) {
                s4 = [s4, s5, s6, s7];
                s3 = s4;
              } else {
                peg$currPos = s3;
                s3 = peg$c0;
              }
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        if (s3 !== peg$FAILED) {
          s3 = input.substring(s2, peg$currPos);
        }
        s2 = s3;
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c110(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseeolEscapeSequence() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 92) {
        s1 = peg$c82;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseeol();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c113(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsedigit() {
      var s0;

      if (peg$c114.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c115); }
      }

      return s0;
    }

    function peg$parsehexDigit() {
      var s0;

      if (peg$c116.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c117); }
      }

      return s0;
    }

    function peg$parseletter() {
      var s0;

      s0 = peg$parselowerCaseLetter();
      if (s0 === peg$FAILED) {
        s0 = peg$parseupperCaseLetter();
      }

      return s0;
    }

    function peg$parselowerCaseLetter() {
      var s0;

      if (peg$c118.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c119); }
      }

      return s0;
    }

    function peg$parseupperCaseLetter() {
      var s0;

      if (peg$c120.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c121); }
      }

      return s0;
    }

    function peg$parse__() {
      var s0, s1;

      s0 = [];
      s1 = peg$parsewhitespace();
      if (s1 === peg$FAILED) {
        s1 = peg$parseeol();
        if (s1 === peg$FAILED) {
          s1 = peg$parsecomment();
        }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        s1 = peg$parsewhitespace();
        if (s1 === peg$FAILED) {
          s1 = peg$parseeol();
          if (s1 === peg$FAILED) {
            s1 = peg$parsecomment();
          }
        }
      }

      return s0;
    }

    function peg$parsecomment() {
      var s0, s1;

      peg$silentFails++;
      s0 = peg$parsesingleLineComment();
      if (s0 === peg$FAILED) {
        s0 = peg$parsemultiLineComment();
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c122); }
      }

      return s0;
    }

    function peg$parsesingleLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c123) {
        s1 = peg$c123;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c124); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        s5 = peg$parseeolChar();
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c18;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c84); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          s5 = peg$parseeolChar();
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c18;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c84); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parsemultiLineComment() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 2) === peg$c125) {
        s1 = peg$c125;
        peg$currPos += 2;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c126); }
      }
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$currPos;
        s4 = peg$currPos;
        peg$silentFails++;
        if (input.substr(peg$currPos, 2) === peg$c127) {
          s5 = peg$c127;
          peg$currPos += 2;
        } else {
          s5 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c128); }
        }
        peg$silentFails--;
        if (s5 === peg$FAILED) {
          s4 = peg$c18;
        } else {
          peg$currPos = s4;
          s4 = peg$c0;
        }
        if (s4 !== peg$FAILED) {
          if (input.length > peg$currPos) {
            s5 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c84); }
          }
          if (s5 !== peg$FAILED) {
            s4 = [s4, s5];
            s3 = s4;
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        } else {
          peg$currPos = s3;
          s3 = peg$c0;
        }
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$currPos;
          s4 = peg$currPos;
          peg$silentFails++;
          if (input.substr(peg$currPos, 2) === peg$c127) {
            s5 = peg$c127;
            peg$currPos += 2;
          } else {
            s5 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c128); }
          }
          peg$silentFails--;
          if (s5 === peg$FAILED) {
            s4 = peg$c18;
          } else {
            peg$currPos = s4;
            s4 = peg$c0;
          }
          if (s4 !== peg$FAILED) {
            if (input.length > peg$currPos) {
              s5 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s5 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c84); }
            }
            if (s5 !== peg$FAILED) {
              s4 = [s4, s5];
              s3 = s4;
            } else {
              peg$currPos = s3;
              s3 = peg$c0;
            }
          } else {
            peg$currPos = s3;
            s3 = peg$c0;
          }
        }
        if (s2 !== peg$FAILED) {
          if (input.substr(peg$currPos, 2) === peg$c127) {
            s3 = peg$c127;
            peg$currPos += 2;
          } else {
            s3 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c128); }
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c0;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c0;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c0;
      }

      return s0;
    }

    function peg$parseeol() {
      var s0, s1;

      peg$silentFails++;
      if (input.charCodeAt(peg$currPos) === 10) {
        s0 = peg$c130;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c131); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 2) === peg$c132) {
          s0 = peg$c132;
          peg$currPos += 2;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c133); }
        }
        if (s0 === peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 13) {
            s0 = peg$c134;
            peg$currPos++;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c135); }
          }
          if (s0 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 8232) {
              s0 = peg$c136;
              peg$currPos++;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c137); }
            }
            if (s0 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 8233) {
                s0 = peg$c138;
                peg$currPos++;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c139); }
              }
            }
          }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c129); }
      }

      return s0;
    }

    function peg$parseeolChar() {
      var s0;

      if (peg$c140.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c141); }
      }

      return s0;
    }

    function peg$parsewhitespace() {
      var s0, s1;

      peg$silentFails++;
      if (peg$c143.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c144); }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c142); }
      }

      return s0;
    }


      var utils = require("./utils");


    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

},{"./utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/peg.js":[function(require,module,exports){
var utils = require("./utils");

module.exports = {
  /* PEG.js version (uses semantic versioning). */
  VERSION: "0.8.0",

  GrammarError: require("./grammar-error"),
  parser:       require("./parser"),
  compiler:     require("./compiler"),

  /*
   * Generates a parser from a specified grammar and returns it.
   *
   * The grammar must be a string in the format described by the metagramar in
   * the parser.pegjs file.
   *
   * Throws |PEG.parser.SyntaxError| if the grammar contains a syntax error or
   * |PEG.GrammarError| if it contains a semantic error. Note that not all
   * errors are detected during the generation and some may protrude to the
   * generated parser and cause its malfunction.
   */
  buildParser: function(grammar) {
    function convertPasses(passes) {
      var converted = {}, stage;

      for (stage in passes) {
        if (passes.hasOwnProperty(stage)) {
          converted[stage] = utils.values(passes[stage]);
        }
      }

      return converted;
    }

    var options = arguments.length > 1 ? utils.clone(arguments[1]) : {},
        plugins = "plugins" in options ? options.plugins : [],
        config  = {
          parser: this.parser,
          passes: convertPasses(this.compiler.passes)
        };

    utils.each(plugins, function(p) { p.use(config, options); });

    return this.compiler.compile(
      config.parser.parse(grammar),
      config.passes,
      options
    );
  }
};

},{"./compiler":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/compiler.js","./grammar-error":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/grammar-error.js","./parser":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/parser.js","./utils":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/utils.js":[function(require,module,exports){
var utils = {
  /* Like Python's |range|, but without |step|. */
  range: function(start, stop) {
    if (stop === undefined) {
      stop = start;
      start = 0;
    }

    var result = new Array(Math.max(0, stop - start));
    for (var i = 0, j = start; j < stop; i++, j++) {
      result[i] = j;
    }
    return result;
  },

  find: function(array, callback) {
    var length = array.length;
    for (var i = 0; i < length; i++) {
      if (callback(array[i])) {
        return array[i];
      }
    }
  },

  indexOf: function(array, callback) {
    var length = array.length;
    for (var i = 0; i < length; i++) {
      if (callback(array[i])) {
        return i;
      }
    }
    return -1;
  },

  contains: function(array, value) {
    /*
     * Stupid IE does not have Array.prototype.indexOf, otherwise this function
     * would be a one-liner.
     */
    var length = array.length;
    for (var i = 0; i < length; i++) {
      if (array[i] === value) {
        return true;
      }
    }
    return false;
  },

  each: function(array, callback) {
    var length = array.length;
    for (var i = 0; i < length; i++) {
      callback(array[i], i);
    }
  },

  map: function(array, callback) {
    var result = [];
    var length = array.length;
    for (var i = 0; i < length; i++) {
      result[i] = callback(array[i], i);
    }
    return result;
  },

  pluck: function(array, key) {
    return utils.map(array, function (e) { return e[key]; });
  },

  keys: function(object) {
    var result = [];
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        result.push(key);
      }
    }
    return result;
  },

  values: function(object) {
    var result = [];
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        result.push(object[key]);
      }
    }
    return result;
  },

  clone: function(object) {
    var result = {};
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        result[key] = object[key];
      }
    }
    return result;
  },

  defaults: function(object, defaults) {
    for (var key in defaults) {
      if (defaults.hasOwnProperty(key)) {
        if (!(key in object)) {
          object[key] = defaults[key];
        }
      }
    }
  },

  /*
   * The code needs to be in sync with the code template in the compilation
   * function for "action" nodes.
   */
  subclass: function(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  },

  /*
   * Returns a string padded on the left to a desired length with a character.
   *
   * The code needs to be in sync with the code template in the compilation
   * function for "action" nodes.
   */
  padLeft: function(input, padding, length) {
    var result = input;

    var padLength = length - input.length;
    for (var i = 0; i < padLength; i++) {
      result = padding + result;
    }

    return result;
  },

  /*
   * Returns an escape sequence for given character. Uses \x for characters <=
   * 0xFF to save space, \u for the rest.
   *
   * The code needs to be in sync with the code template in the compilation
   * function for "action" nodes.
   */
  escape: function(ch) {
    var charCode = ch.charCodeAt(0);
    var escapeChar;
    var length;

    if (charCode <= 0xFF) {
      escapeChar = 'x';
      length = 2;
    } else {
      escapeChar = 'u';
      length = 4;
    }

    return '\\' + escapeChar + utils.padLeft(charCode.toString(16).toUpperCase(), '0', length);
  },

  /*
   * Surrounds the string with quotes and escapes characters inside so that the
   * result is a valid JavaScript string.
   *
   * The code needs to be in sync with the code template in the compilation
   * function for "action" nodes.
   */
  quote: function(s) {
    /*
     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a string
     * literal except for the closing quote character, backslash, carriage
     * return, line separator, paragraph separator, and line feed. Any character
     * may appear in the form of an escape sequence.
     *
     * For portability, we also escape all control and non-ASCII characters.
     * Note that "\0" and "\v" escape sequences are not used because JSHint does
     * not like the first and IE the second.
     */
    return '"' + s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/"/g, '\\"')    // closing quote character
      .replace(/\x08/g, '\\b') // backspace
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x00-\x07\x0B\x0E-\x1F\x80-\uFFFF]/g, utils.escape)
      + '"';
  },

  /*
   * Escapes characters inside the string so that it can be used as a list of
   * characters in a character class of a regular expression.
   */
  quoteForRegexpClass: function(s) {
    /*
     * Based on ECMA-262, 5th ed., 7.8.5 & 15.10.1.
     *
     * For portability, we also escape all control and non-ASCII characters.
     */
    return s
      .replace(/\\/g, '\\\\')  // backslash
      .replace(/\//g, '\\/')   // closing slash
      .replace(/\]/g, '\\]')   // closing bracket
      .replace(/\^/g, '\\^')   // caret
      .replace(/-/g,  '\\-')   // dash
      .replace(/\0/g, '\\0')   // null
      .replace(/\t/g, '\\t')   // horizontal tab
      .replace(/\n/g, '\\n')   // line feed
      .replace(/\v/g, '\\x0B') // vertical tab
      .replace(/\f/g, '\\f')   // form feed
      .replace(/\r/g, '\\r')   // carriage return
      .replace(/[\x01-\x08\x0E-\x1F\x80-\uFFFF]/g, utils.escape);
  },

  /*
   * Builds a node visitor -- a function which takes a node and any number of
   * other parameters, calls an appropriate function according to the node type,
   * passes it all its parameters and returns its value. The functions for
   * various node types are passed in a parameter to |buildNodeVisitor| as a
   * hash.
   */
  buildNodeVisitor: function(functions) {
    return function(node) {
      return functions[node.type].apply(null, arguments);
    };
  },

  findRuleByName: function(ast, name) {
    return utils.find(ast.rules, function(r) { return r.name === name; });
  },

  indexOfRuleByName: function(ast, name) {
    return utils.indexOf(ast.rules, function(r) { return r.name === name; });
  }
};

module.exports = utils;

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/rbush.js":[function(require,module,exports){
/*
 (c) 2013, Vladimir Agafonkin
 RBush, a JavaScript library for high-performance 2D spatial indexing of points and rectangles.
 https://github.com/mourner/rbush
*/

(function () { 'use strict';

function rbush(maxEntries, format) {

    // jshint newcap: false, validthis: true
    if (!(this instanceof rbush)) { return new rbush(maxEntries, format); }

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [];

        if (!this._intersects(bbox, node.bbox)) { return result; }

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                childBBox = node.leaf ? this.toBBox(child) : child.bbox;

                if (this._intersects(bbox, childBBox)) {

                    if (node.leaf) {
                        result.push(child);

                    } else if (this._contains(bbox, childBBox)) {
                        this._all(child, result);

                    } else {
                        nodesToSearch.push(child);
                    }
                }
            }

            node = nodesToSearch.pop();
        }

        return result;
    },

    load: function (data) {
        if (!(data && data.length)) { return this; }

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from stratch using OMT algorithm
        var node = this._build(data.slice(), 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) {
            this._insert(item, this.data.height - 1);
        }
        return this;
    },

    clear: function () {
        this.data = {
            children: [],
            leaf: true,
            bbox: this._empty(),
            height: 1
        };
        return this;
    },

    remove: function (item) {
        if (!item) { return this; }

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = node.children.indexOf(item);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && this._contains(node.bbox, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else { // nothing found
                node = null;
            }
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: function (a, b) { return a[0] - b[0]; },
    compareMinY: function (a, b) { return a[1] - b[1]; },

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) {
                result.push.apply(result, node.children);
            } else {
                nodesToSearch.push.apply(nodesToSearch, node.children);
            }
            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, level, height) {

        var N = items.length,
            M = this._maxEntries,
            node;

        if (N <= M) {
            node = {
                children: items,
                leaf: true,
                height: 1
            };
            this._calcBBox(node);
            return node;
        }

        if (!level) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));

            items.sort(this.compareMinX);
        }

        // TODO eliminate recursion?

        node = {
            children: [],
            height: height
        };

        var N1 = Math.ceil(N / M) * Math.ceil(Math.sqrt(M)),
            N2 = Math.ceil(N / M),
            compare = level % 2 === 1 ? this.compareMinX : this.compareMinY,
            i, j, slice, sliceLen, childNode;

        // split the items into M mostly square tiles
        for (i = 0; i < N; i += N1) {
            slice = items.slice(i, i + N1).sort(compare);

            for (j = 0, sliceLen = slice.length; j < sliceLen; j += N2) {
                // pack each entry recursively
                childNode = this._build(slice.slice(j, j + N2), level + 1, height - 1);
                node.children.push(childNode);
            }
        }

        this._calcBBox(node);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) { break; }

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = this._area(child.bbox);
                enlargement = this._enlargedArea(bbox, child.bbox) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode;
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var bbox = isNode ? item.bbox : this.toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        this._extend(node.bbox, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else {
              break;
            }
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var newNode = {
            children: node.children.splice(this._chooseSplitIndex(node, m, M)),
            height: node.height
        };

        if (node.leaf) {
            newNode.leaf = true;
        }

        this._calcBBox(node);
        this._calcBBox(newNode);

        if (level) {
            insertPath[level - 1].children.push(newNode);
        } else {
            this._splitRoot(node, newNode);
        }
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = {};
        this.data.children = [node, newNode];
        this.data.height = node.height + 1;
        this._calcBBox(this.data);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = this._distBBox(node, 0, i);
            bbox2 = this._distBBox(node, i, M);

            overlap = this._intersectionArea(bbox1, bbox2);
            area = this._area(bbox1) + this._area(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : this._compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : this._compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY

        if (xMargin < yMargin) {
            node.children.sort(compareMinX);
        }
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var leftBBox = this._distBBox(node, 0, m),
            rightBBox = this._distBBox(node, M - m, M),
            margin = this._margin(leftBBox) + this._margin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            this._extend(leftBBox, node.leaf ? this.toBBox(child) : child.bbox);
            margin += this._margin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            this._extend(rightBBox, node.leaf ? this.toBBox(child) : child.bbox);
            margin += this._margin(rightBBox);
        }

        return margin;
    },

    // min bounding rectangle of node children from k to p-1
    _distBBox: function (node, k, p) {
        var bbox = this._empty();

        for (var i = k, child; i < p; i++) {
            child = node.children[i];
            this._extend(bbox, node.leaf ? this.toBBox(child) : child.bbox);
        }

        return bbox;
    },

    // calculate node's bbox from bboxes of its children
    _calcBBox: function (node) {
        node.bbox = this._distBBox(node, 0, node.children.length);
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            this._extend(path[i].bbox, bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);
                } else {
                    this.clear();
                }
            } else {
                this._calcBBox(path[i]);
            }
        }
    },

    _contains: function(a, b) {
        return a[0] <= b[0] &&
               a[1] <= b[1] &&
               b[2] <= a[2] &&
               b[3] <= a[3];
    },

    _intersects: function (a, b) {
        return b[0] <= a[2] &&
               b[1] <= a[3] &&
               b[2] >= a[0] &&
               b[3] >= a[1];
    },

    _extend: function (a, b) {
        a[0] = Math.min(a[0], b[0]);
        a[1] = Math.min(a[1], b[1]);
        a[2] = Math.max(a[2], b[2]);
        a[3] = Math.max(a[3], b[3]);
        return a;
    },

    _area:   function (a) { return (a[2] - a[0]) * (a[3] - a[1]); },
    _margin: function (a) { return (a[2] - a[0]) + (a[3] - a[1]); },

    _enlargedArea: function (a, b) {
        return (Math.max(b[2], a[2]) - Math.min(b[0], a[0])) *
               (Math.max(b[3], a[3]) - Math.min(b[1], a[1]));
    },

    _intersectionArea: function (a, b) {
        var minX = Math.max(a[0], b[0]),
            minY = Math.max(a[1], b[1]),
            maxX = Math.min(a[2], b[2]),
            maxY = Math.min(a[3], b[3]);

        return Math.max(0, maxX - minX) *
               Math.max(0, maxY - minY);
    },

    _empty: function () { return [Infinity, Infinity, -Infinity, -Infinity]; },

    _compareNodeMinX: function (a, b) { return a.bbox[0] - b.bbox[0]; },
    _compareNodeMinY: function (a, b) { return a.bbox[1] - b.bbox[1]; },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        // jshint evil: true

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a', 'return [a' + format.join(', a') + '];');
    }
};

if (typeof define === 'function' && define.amd) {
    define(function() {
        return rbush;
    });
} else if (typeof module !== 'undefined') {
    module.exports = rbush;
} else if (typeof self !== 'undefined') {
    self.rbush = rbush;
} else {
    window.rbush = rbush;
}

})();

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/LayerLoader.js":[function(require,module,exports){
require("./SMC.js");
/**
 * Class able of creating SMC Viewer layer objects from configuration.
 * @class
 * @abstract
 * @mixin SMC.LayerLoader
 * @extends L.Class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.LayerLoader = L.Class.extend(
    /** @lends SMC.layers.LayerLoader# */
    {

        loadedLayers: {},
        labelLayers:{},

        /**
         * Creates layers from a Javascript object (or its javascript reprsentantion) defining the type and options of the layers to be loaded.
         *
         * @method
         * @param {(Object|JSON)} layersConfig - Configuration to load a layer
         */
        loadLayers: function(layersConfig) {
            if (!layersConfig) {
                throw new Error("SMC.layers.LayerLoader::loadLayers: no layers config received");
            }

            if (typeof layersConfig === "object" && layersConfig.url) {
                var self = this;
                $.ajax({
                    url: layersConfig.url,
                    dataType: "json",
                    success: function(data, textStatus, jqXHR) {
                        self._loadJsonArray(data);
                    }
                });
            } else {
                this._loadJsonArray(layersConfig);
            }
        },

        _loadJsonArray: function(layersConfig) {
            if (typeof layersConfig == "string") {
                layersConfig = JSON.parse(layersConfig);
            }
            if (!L.Util.isArray(layersConfig)) {
                throw new Error("SMC.layers.LayerLoader::loadLayers: layers config is not an array");
            }
            for (var i = 0; i < layersConfig.length; i++) {
                var layerConfig = layersConfig[i];

                this._loadLayerConfig(layerConfig, i + 1);

            }
        },

        _loadLayerConfig: function(layerConfig, idx) {
            var type = layerConfig.type;
            var layer = null;
            if (!type) {
                throw new Error("SMC.layers.LayerLoader::_loadLayerConfig: layer config in position " + idx + " doesn't define a type");
            } else if (typeof type != "string") {
                throw new Error("SMC.layers.LayerLoader::_loadLayerConfig: layer config in position " + idx + " doesn't define a type as a class name string.");
            }

            var params = [];
            var url = "";
            var label = '';
            var typePaths = type.split(".");
            for (var i = 0; i < typePaths.length; i++) {
                label = typePaths[i];
            }


            if (type === "folder") {
                // Folders are a special case in which we allow a shortcut to ease configuration.
                layerClass = SMC.layers.Folder;
                if (!layerConfig.layers) {
                    throw new Error("SMC.layers.LayerLoader::_loadLayerConfig: layer config in position " + idx + " is of type 'folder' but doesn't define a layers array.");
                }
                /*if (!layerConfig.label) {
                    throw new Error("SMC.layers.LayerLoader::_loadLayerConfig: layer config in position " + idx + " is of type 'folder' but doesn't define a label property.");
                }*/
                params = [{
                    layersConfig: layerConfig.layers,
                    label: layerConfig.label || label
                }];

    
            }
            else{
                if (layerConfig.params) {
                    params = layerConfig.params;
                }
                if (layerConfig.url) {
                    url = layerConfig.url;
                }

                if (typeof params == "string") {
                    params = JSON.parse(params);
                }

                if(params){
                     if (Array.isArray(params) && params.length >0) {
                        if(!params[0].label)
                            params[0].label= label
                    } else {
                        if(!params.label)
                            params.label= label    
                    }
                    
                }

                if (!layerConfig.params) {
                    params = [{
                        label: layerConfig.label || label
                    }];
                }

                if (!layerConfig.params && layerConfig.layers) {
                    params = [{
                        layersConfig: layerConfig.layers,
                        label: layerConfig.label || label,
                        active: layerConfig.active
                    }];
                }

                // We traverse the speficied class 'packages' from the root (window) to obtain the actual class object.
                layerClass = SMC.Util.getClass(type);
            }

            // Class instantiation code from http://stackoverflow.com/questions/1606797/use-of-apply-with-new-operator-is-this-possible
            var constructor = SMC.Util.getConstructor(layerClass);

            if (url) {
                if (Array.isArray(params)) {
                    params[0].url = url;
                    this._setLabel(params[0].label);

                } else {
                    params.url = url;
                    this._setLabel(params.label);    
                }
            } 

             if (Array.isArray(params)) {
                    params[0].label = this._setLabel(params[0].label);

            } else {
                params.label = this._setLabel(params.label);    
            }

            layer = constructor(params);

            if (layerConfig.listeners) {
                for (var eventName in layerConfig.listeners) {
                    layer.on(eventName, layerConfig.listeners[eventName]);
                }
            }

            // If we have triggers and the layer is reloadable, we add the triggers.
            if (layerConfig.reloadTriggers && (typeof layer.addReloadTrigger === "function")) {
                for (var tIdx = 0; tIdx < layerConfig.reloadTriggers.length; tIdx++) {
                    var triggerConfig = layerConfig.reloadTriggers[tIdx];
                    layer.addReloadTrigger(triggerConfig);
                }
            }
            // The layer loader is mixed in into a map (or Folder) so we can add layers to that.
            layer._map = this;

            if(type ===  "SMC.layers.geometry.SolrGeometryHistoryLayer"){
                layer.doFeaturesLoading();
            }

            layer.addTo(this);

            // The loader (that is, the map or Folder) is the layer's parent
           
            layer.parent = this;
  
          

            var id;
            if (layerConfig.id) {
                id = layerConfig.id;
            } else {
                id = "layer" + L.stamp(layer);
            }

            this.loadedLayers[id] = layer;
        },

        _setLabel: function(label){
            var exist = false;
            var newLabel = '';
            for(var l in this.labelLayers){
                if(l == label){
                    exist = true;
                }
               
            }
            if(!exist){
                this.labelLayers[label] = [];
                newLabel = label;
                this.labelLayers[label].push(newLabel);

            }
            else{
                var i = this.labelLayers[label].length;
                newLabel = label+" " +i.toString();
                while(this.labelLayers[newLabel]){
                    i++;
                    newLabel = label+" " +i.toString();
                    for(var lb in this.labelLayers[label]){
                        if(this.labelLayers[label][lb] == newLabel){
                           i++;
                           newLabel = label+" " +i.toString();
                        }
                    }
                }

                this.labelLayers[label].push(newLabel);
            }
            return newLabel;
        }
    });


},{"./SMC.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/Map.js":[function(require,module,exports){
require("./SMC.js");
require("./Util.js");
require("./LayerLoader.js");

/**
 * The map viewer component of SMC.
 * Extends [Leaflet's map component]{@link http://leafletjs.com/reference.html#map-class}
 * to include our needed functionality.
 *
 * @class The map viewer component of SMC.
 * @extends L.Map
 * @mixes SMC.LayerLoader
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.Map = L.Map.extend(
	/** @lends SMC.Map# */
	{
	
		
	}, [SMC.LayerLoader]);

/**
 * API factory method for creating SMCViewer's Maps.
 * @method
 * @param {(HTMLElement|String)} element - The id of the element the map will be created in
 * @param {Object} options - Configuration for the map
 */
SMC.map = function(element, options) {
	return new SMC.Map(element, options);
};
},{"./LayerLoader.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/LayerLoader.js","./SMC.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js","./Util.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/Util.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js":[function(require,module,exports){
require("../lib/leaflet/leaflet-src.js");
require("./Util.js");

/**
 * Global namespace for classes making up the SMC's map viewer
 * @namespace
 * @author Luis Román (lroman@emergya.com)
 */
SMC = {
	/**
     * Base url where resources are
     * @property {string} BASE_URL - The default url value.
     * @default ../dist/
     */
	BASE_URL: "../../dist/"
};

},{"../lib/leaflet/leaflet-src.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet/leaflet-src.js","./Util.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/Util.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/Util.js":[function(require,module,exports){
require("./SMC.js");


SMC.Util = {
    /**
     * Returns a class object from its name (including path).
     */
    getClass: function(className) {
        var typePaths = className.split(".");
        var classObject = window;
        for (var i = 0; i < typePaths.length; i++) {
            classObject = classObject[typePaths[i]];
        }

        if (!classObject.prototype) {
            throw new Error("SMC.layers.LayerLoader::_loadLayerConfig: layer config in position " + idx + " defined type '" + type + "' is not a valid class");
        }

        return classObject;
    },

    /**
     * Gets a constructor function for the specified class.
     */
    getConstructor: function(classObject) {
        return (function() {
            function F(args) {
                if (arguments.length > 1) {
                    return classObject.apply(this, args);
                } else {
                    return classObject.apply(this, args[0]);
                }

            }
            F.prototype = classObject.prototype;

            return function(args) {
                return new F(arguments);
            };
        })();
    }
};
},{"./SMC.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/IsochroneControl.js":[function(require,module,exports){
require("./controls.js");
require("../../lib/leaflet.draw/dist/leaflet.draw-src.js");

SMC.controls.IsochroneControl = L.Control.Draw.extend({
	options: {
		 draw: {
            polyline: false,
            polygon: false,
            rectangle: false,
            circle: false,
            marker:false
         },
     
	},
	inputs:{
            walkTime: "num",
            mode: {
            	walk: {
            		content:'WALK',
            		label:'Walk'
            	},
            	transit: {
            		content: 'TRANSIT,WALK',
            		label: 'Transit'
            	},
            	bus: {
            		content:'BUSISH,WALK',
            		label: 'Bus only'
            	},
            	train: {
            		content: 'TRAINISH,WALK',
            		label: 'Train only'
            	},
            	bicycle: {
            		content:'BICYCLE',
            		label: 'Bicycle only'
            	},
            	rented_bicycle: {
            		content:'WALK,BICYCLE',
            		label: 'Rented bicycle'
            	},
            	transit_bicycle: {
            		content:'TRANSIT,BICYCLE',
            		label: 'Transit & Bicycle'
            	},
            	transit_rented_bicycle: {
            		content:'TRANSIT,WALK,BICYCLE',
            		label: 'Transit &  Rented Bicycle'
            	},
            	car: {
            		content: 'CAR',
            		label: 'Car'
            	}
            },
            maxWalkDistance: "num",
            time: "date",
            arriveBy: {
            	yes:{
					 content: 'yes',
					 label: 'Yes'
				},
            	no: {
            		content:'no',
            		label: 'No'
            	}
            },
            walkSpeed: 'num',
            bikeSpeed: 'num', 
            output: {
            	shed:{
            	 content:'SHED',
            	 label: 'Polygon'
            	},
            	edges:{
            		content:'EDGES',
            		label: 'Lines'
            	}
            },
            label:"text"
     },
     params:{
     	label: 'Isocrona'
     },

	

	initialize: function (map) {
		if(map.iso){
			return;
		}
		L.Control.Draw.prototype.initialize.call(this, this.options);
		map.addControl(this);
		map.iso = true;

		var self = this;
		map.on('draw:startIso', function(e){
				self.setForm(e.toolbar);	
		});

		map.on('draw:created', function (e) {
				var lat = e.layer._latlng.lat;
				var lng = e.layer._latlng.lng;
				var paramsRequest = self.params;
				paramsRequest.fromPlace = lat +"," + lng;
	            map.loadLayers([{
		            type: "SMC.layers.IsochroneLayer",
		            params:[paramsRequest]
		         },{
	   			 type: "L.Marker",
	             params: [
	                [lat, lng], {
	                    label: self.params.label + ' Marker'
	                }
	            ]

			    }]);
			
	    });

       
	},

	

	setForm: function(toolbar){
		toolbar._disabled();
		var self = this;
		
		var container = this._container;
		container.style.width = '26px';
		var table = document.createElement('table');
		table.id = 'formIsochrone';
		table.className = 'leaflet-form';
		table.onmouseenter = function() {
			self._map.dragging.disable();
			self._map.keyboard.disable();
			return false;
		}

		table.onmouseleave = function() {
			self._map.dragging.enable();
			self._map.keyboard.enable();
		}
		for(var i in this.inputs){
			var e = this.inputs[i];
			var tr = document.createElement('tr');
			var td1 = document.createElement('td');
			var label = document.createElement('span');
			label.innerHTML = i;
			td1.appendChild(label);
			tr.appendChild(td1);
			var td2 = document.createElement('td');
			var input;
			if(e == 'num' || e == 'text'){
				input = document.createElement('input');
				input.type = 'text';
				label.appendChild(input);
				if(e == 'num'){
					input.onkeypress = function(event){
						if ((event.keyCode < 48) || (event.keyCode > 57)) 
  							event.returnValue = false;
					}
				}
			}
			if(e == 'date'){
				input = document.createElement('input');
				input.type = 'datetime-local';
				label.appendChild(input);
			}
			
			if(e instanceof Object){
				var input = document.createElement('select');
				for(var o in e){
					var option = document.createElement('option');
					option.value = e[o].content;
					option.innerHTML = e[o].label;
					input.appendChild(option);
					
				}
			
			}
			input.id = i;
			input.style.width = '120px';
			input.style.float = 'right';
			
			td2.appendChild(input);
			tr.appendChild(td2);
			table.appendChild(tr);
			
		}
		
		
		var buttons = document.createElement('tr');
		var tdsave = document.createElement('td');
		var save =  document.createElement('input');
		save.type = 'button';
		save.value = 'Save';
		tdsave.appendChild(save);
		tdsave.style.textAlign = 'right';
		buttons.appendChild(tdsave);
		var tdcancel = document.createElement('td');
		var cancel =  document.createElement('input');
		cancel.type = 'button';
		cancel.value = 'Cancel';
		tdcancel.appendChild(cancel);
		buttons.appendChild(tdcancel);
		table.appendChild(buttons);
		container.appendChild(table);
		
		cancel.onclick = function(){
			self._cancel(toolbar);
		}
		save.onclick = function(){
			self._save(toolbar, table);
		}


	},

	_cancel: function(toolbar){
		toolbar._enabled();
		$('#formIsochrone').remove();
		this._map.dragging.enable();
		this._map.keyboard.enable();

	},
	_save: function(toolbar, form){
		$('#formIsochrone').remove();
		var form = form.getElementsByTagName('tr');
		for(var i= 0; i < form.length -1; i++){
			var option = form[i].lastChild.children[0];
			if(option.value != ''){
				this.params[option.id] = option.value;
			}
		}
		toolbar._enabled();
		this._map.dragging.enable();
		this._map.keyboard.enable();


	}



 
	
});

SMC.isochroneControl = function(map) {
    return new SMC.controls.IsochroneControl(map);
};
},{"../../lib/leaflet.draw/dist/leaflet.draw-src.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet.draw/dist/leaflet.draw-src.js","./controls.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/controls.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/controls.js":[function(require,module,exports){
require("../SMC.js");

/**
 * Namespace of SMC map viewer controls.
 * @namespace
 * @memberof SMC
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.controls = {};

},{"../SMC.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeControl.js":[function(require,module,exports){
require("./layerTree.js");
/**
 * Base class for layer tree controls.
 * @class
 * @extends L.Control
 * @param {SMC.controls.layerTree.LayerTreeControl~options} options - The configuration for the class
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.controls.layerTree.LayerTreeControl = L.Control.extend(
    /** @lends SMC.controls.layerTree.LayerTreeControl# */
    {
        /**
         * @typedef {Object} SMC.controls.layerTree.LayerTreeControl~options
         * @property {boolean} collapsed=true - Default collapsed value
         * @property {string} position='topright' - Default position value
         * @property {boolean} autoZIndex=true - Default autoZIndex value
         */
        options: {
            collapsed: true,
            position: 'topright',
            autoZIndex: true
        },
        /**
         * Initialize the object with the params
         * @param {SMC.layers} baseLayers - Layers as a base layers
         * @param {Object} options - Object with extra information
         */
        initialize: function(baseLayers, options) {
            L.Util.setOptions(this, options);

            this._baseLayers = [];
            this._layers = {};
            this._parents = {};
            this._lastZIndex = 0;
            this._handlingClick = false;
            this._groupList = [];
            this._domGroups = [];

            for (var i in baseLayers) {
                this._addLayer(baseLayers[i], i);
            }

        },

        /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
        getMap: function() {
            return this._map;
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         * @returns {object} Tree control container
         */
        onAdd: function(map) {
            this._initLayout();
            this._update();

            map
                .on('layeradd', this._onLayerChange, this)
                .on('layerremove', this._onLayerChange, this);


            return this._container;
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be removed
         */
        onRemove: function(map) {
            map
                .off('layeradd', this._onLayerChange)
                .off('layerremove', this._onLayerChange);
        },

        /**
         * Method to add layer as a base layer
         * @param {SMC.layers} layer - Layer to be added
         * @param {String} name - Layer name
         */
        addBaseLayer: function(layer, name) {
            this._addLayer(layer, name);
            this._update();
            return this;
        },

        /**
         * Method to add layer as an overlay layer
         * @function
         * @param {SMC.layers} layer - Layer to be added
         * returns {object} Tree control
         */
        addOverlay: function(layer) {
            this._methodRecursive(layer);
            this._update();
            return this;
        },

        /**
         * Method to remove a layer from the map
         * @param {SMC.layers} layer - Layer to be removed
         * returns {object} Tree control
         */
        removeLayer: function(layer) {
            var id = L.Util.stamp(layer);
            delete this._layers[id];
            this._update();
            return this;
        },

        _initLayout: function() {
            var className = 'leaflet-control-layers',
                container = this._container = L.DomUtil.create('div', className);

            //Makes this work on IE10 Touch devices by stopping it from firing a mouseout event when the touch is released
            container.setAttribute('aria-haspopup', true);

            if (!L.Browser.touch) {
                L.DomEvent.disableClickPropagation(container);
                L.DomEvent.on(container, 'wheel', L.DomEvent.stopPropagation);
            } else {
                L.DomEvent.on(container, 'click', L.DomEvent.stopPropagation);
            }

            var form = this._form = L.DomUtil.create('form', className + '-list');

            if (this.options.collapsed) {
                if (!L.Browser.android) {
                    L.DomEvent
                        .on(container, 'mouseover', this._expand, this)
                        .on(container, 'mouseout', this._collapse, this);
                }
                var link = this._layersLink = L.DomUtil.create('a', className + '-toggle', container);
                link.href = '#';
                link.title = 'Layers';

                if (L.Browser.touch) {
                    L.DomEvent
                        .on(link, 'click', L.DomEvent.stop)
                        .on(link, 'click', this._expand, this);
                } else {
                    L.DomEvent.on(link, 'focus', this._expand, this);
                }

                this._map.on('click', this._collapse, this);
                // TODO keyboard accessibility
            } else {
                this._expand();
            }

            this._baseLayersList = L.DomUtil.create('div', className + '-base', form);
            this._separator = L.DomUtil.create('div', className + '-separator', form);
            this._overlaysList = L.DomUtil.create('div', className + '-overlays', form);

            container.appendChild(form);
        },

        _addLayer: function(layer, name) {
            var id = L.Util.stamp(layer);

            this._layers[id] = {
                layer: layer,
                name: name,
                overlay: false
            };

            if (this.options.autoZIndex && layer.setZIndex) {
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
            }
        },

        _update: function() {
            if (!this._container) {
                return;
            }

            this._baseLayersList.innerHTML = '';
            this._overlaysList.innerHTML = '';
            this._domGroups.length = 0;

            var baseLayersPresent = false,
                overlaysPresent = false,
                i, obj;

            for (i in this._layers) {
                obj = this._layers[i];
                this._addItem(obj);
                overlaysPresent = overlaysPresent || obj.overlay;
                baseLayersPresent = baseLayersPresent || !obj.overlay;
            }


            var map = this.getMap();

            if (map) {
                for (var j in map._layers) {
                    obj = map._layers[j];
                    if (obj instanceof SMC.layers.aggregation.MultiModeLayer) {
                        obj._initializeTree();
                    }

                }
            }

            this._separator.style.display = overlaysPresent && baseLayersPresent ? '' : 'none';
        },

        _methodRecursive: function(layer) {
            var id = L.Util.stamp(layer);
            var name = "";
            if (layer.createNodeHTML) {
                name = layer.createNodeHTML();
            } else {
                name = layer.options.label;
            }
            if (!this._layers[id]) {
                var element = {
                    name: name,
                    layer: layer,
                    overlay: true,
                    parent: null
                };
                if (layer.loadLayers) {
                    this._parents[id] = element;
                } else {
                    this._layers[id] = element;

                }

                if (layer.parent) {
                    element.parent = L.Util.stamp(layer.parent);
                    this._methodRecursive(layer.parent);
                } else if (layer.options.parent) {
                    element.parent = layer.options.parent;
                    this._methodRecursive(this._parents[element.parent].layer);
                }

            }
            if (this.options.autoZIndex && layer.setZIndex) {
                this._lastZIndex++;
                layer.setZIndex(this._lastZIndex);
            }
        },

        _onLayerChange: function(e) {
            if (e.layer instanceof L.Marker) {
                // We don't want to trigger tree rebuilding when adding each marker of a layer.
                return;
            }

            if (e.layer._slidermove) {
                return;
            }
            if (e.layer._group) {
                if (e.layer._group._slidermove)
                    return;
            }


            var obj = this._layers[L.Util.stamp(e.layer)];
            if (e.layer.deleteTree) {
                delete this._layers[L.Util.stamp(e.layer)];
                this._update();
                return;
            }

            if (e.layer._map) {
                if (!obj) {
                    if (e.layer.options && e.layer.options.label) {
                        this._methodRecursive(e.layer);
                        this._update();
                    }
                } else {
                    var type = obj.overlay ?
                        (e.type === 'layeradd' ? 'overlayadd' : 'overlayremove') :
                        (e.type === 'layeradd' ? 'baselayerchange' : null);
                    if (type) {
                        this._map.fire(type, obj);
                    }
                }

                if (!this._handlingClick) {
                    this._update();
                }
            } else {
                if (!this._handlingClick) {
                    delete this._layers[L.Util.stamp(e.layer)];
                    this._update();
                }
            }

        },



        // IE7 bugs out if you create a radio dynamically, so you have to do it this hacky way (see http://bit.ly/PqYLBe)
        _createRadioElement: function(name, checked) {

            var radioHtml = '<input type="radio" class="leaflet-control-layers-selector" name="' + name + '"';
            if (checked) {
                radioHtml += ' checked="checked"';
            }
            radioHtml += '/>';

            var radioFragment = document.createElement('div');
            radioFragment.innerHTML = radioHtml;

            return radioFragment.firstChild;
        },

        _getLabel: function(obj) {
            var label = document.createElement('label'),
                input,
                checked = this._map.hasLayer(obj.layer);

            if (obj.overlay) {
                input = document.createElement('input');
                input.type = 'checkbox';
                input.className = 'leaflet-control-layers-selector';
                input.id = obj.layer._leaflet_id;
                input.defaultChecked = checked;
                L.DomEvent.on(input, 'click', this._onInputClick, this);
            } else {
                input = this._createRadioElement('leaflet-base-layers', checked);
                L.DomEvent.on(input, 'click', this._onRadioClick, this);
            }

            input.layerId = L.Util.stamp(obj.layer);

            if (obj.layer && obj.layer.createNodeHTML) {
                var nodeContent = obj.layer.createNodeHTML();
                if (nodeContent) {
                    obj.name = nodeContent;
                }

            }

            var name = document.createElement('span');
            //name.innerHTML = ' ' + obj.name;
            if (typeof obj.name == 'string') {
                name.innerHTML = ' ' + obj.name;
            } else {
                name.appendChild(obj.name);
            }
            if (obj.layer instanceof SMC.layers.geometry.SolrGeometryHistoryLayer) {
                label = document.createElement('div');
                label.appendChild(name);
                return label;
            }

            label.appendChild(input);
            label.appendChild(name);

            return label;
        },

        _getGroupContainer: function(obj) {
            var groupContainer = document.createElement('div');
            groupContainer.className = 'leaflet-control-layers-group';
            groupContainer.id = 'leaflet-control-layers-group-' + L.Util.stamp(obj.layer);
            // Create span folder title
            var groupLabel = this._getGroupLabel(obj);
            // Add folder label to group container
            groupContainer.appendChild(groupLabel);

            return groupContainer;
        },

        _getGroupLabel: function(obj) {
            var groupLabel = document.createElement('span');
            groupLabel.className = 'leaflet-control-layers-group-name';
            groupLabel.appendChild(obj.name);

            return groupLabel;
        },

        _getGroupContent: function(obj) {
            var groupContent = document.createElement('div');
            groupContent.className = 'leaflet-control-layers-group-content';
            if (obj.name.className.indexOf("open") == -1) {
                groupContent.style.display = 'none';
            }

            return groupContent;
        },

        _addItemRecursively: function(obj) {
            if (obj.parent) {
                var parent = this._parents[obj.parent];
                this._addItemRecursively(parent);
                if (obj.layer.loadedLayers) {
                    var folderId = L.Util.stamp(obj.layer);
                    if (!this._domGroups[folderId]) {
                        var parentDom = this._getParentDom(obj.parent);
                        var parentContent = parentDom.getElementsByClassName(
                            "leaflet-control-layers-group-content")[0];
                        this._addFolderToOverlays(obj, parentContent);
                    }
                } else {
                    // It's a layer
                    this._addLayerToOverlays(obj);
                }
            } else {
                if (obj.layer.loadedLayers) {
                    // It's a folder
                    var folderId = L.Util.stamp(obj.layer);
                    if (!this._domGroups[folderId]) {
                        this._addFolderToOverlays(obj);
                    }
                } else {
                    // It's a layer
                    this._addLayerToOverlays(obj);
                }
            }
        },

        _addFolderToOverlays: function(obj, parent) {
            // Create group container div
            var groupContainer = this._getGroupContainer(obj);
            // Create group content div
            groupContent = this._getGroupContent(obj);
            // Add group content to group container
            groupContainer.appendChild(groupContent);
            // Add group container to container
            if (parent) {
                parent.appendChild(groupContainer);
            } else {
                container.appendChild(groupContainer);
            }
            // Add group container to domGroups
            this._domGroups[L.Util.stamp(obj.layer)] = groupContainer;
        },

        _getParentDom: function(id) {
            var parent = null;
            for (el in this._domGroups) {
                var groupId = this._domGroups[el].id.split("-")[4];
                if (groupId == id) {
                    parent = this._domGroups[el];
                }
            }
            return parent;
        },

        _addLayerToOverlays: function(obj) {
            var label = this._getLabel(obj);
            if (obj.parent) {
                var parent = this._getParentDom(obj.parent);
                var parentContent = parent.getElementsByClassName("leaflet-control-layers-group-content")[0];
                parentContent.appendChild(label);
            } else {
                container.appendChild(label);
            }
        },

        _addItem: function(obj) {
            var label = this._getLabel(obj);
            if (obj.overlay) {
                container = this._overlaysList;
                this._addItemRecursively(obj);
            } else {
                container = this._baseLayersList;
                container.appendChild(label);
            }

            return label;
        },

        _onInputClick: function() {
            var i, input, obj,
                inputs = $('input[type=checkbox]', this._from),
                inputsLen = inputs.length;

            this._handlingClick = true;

            for (i = 0; i < inputsLen; i++) {
                input = inputs[i];
                obj = this._layers[input.layerId];
                if (obj) {
                    if (input.checked && !this._map.hasLayer(obj.layer)) {
                        this._map.addLayer(obj.layer);
                    } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                        this._map.removeLayer(obj.layer);
                    }
                }
            }
            this._handlingClick = false;
        },

        _onRadioClick: function() {
            var i, input, obj,
                inputs = $('input[type=radio]', this._from),
                inputsLen = inputs.length;

            this._handlingClick = true;

            for (i = 0; i < inputsLen; i++) {
                input = inputs[i];
                obj = this._layers[input.layerId];
                if (obj) {
                    if (input.checked && !this._map.hasLayer(obj.layer)) {
                        this._map.addLayer(obj.layer);
                    } else if (!input.checked && this._map.hasLayer(obj.layer)) {
                        this._map.removeLayer(obj.layer);
                    }
                }
            }
            this._handlingClick = false;
        },

        _expand: function() {
            L.DomUtil.addClass(this._container, 'leaflet-control-layers-expanded');
        },

        _collapse: function() {
            this._container.className = this._container.className.replace(' leaflet-control-layers-expanded',
                '');
        }
    }
);
/**
 * API factory method for ease creation of LayerTreeControl.
 * @param {Object} baseLayer - Javascript object with base layer name and its layer
 * @param {Object} overlays - Javascript object with overalys layer name ans its layer
 * @param {Object} options - Javascript object with the options params
 */
SMC.layerTreeControl = function(baseLayers, overlays, options) {
    return new SMC.controls.layerTree.LayerTreeControl(baseLayers, overlays, options);
};
},{"./layerTree.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/layerTree.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeFolder.js":[function(require,module,exports){
require("./LayerTreeNode.js");
/**
 * Base class for make a layer tree folder.
 * @class
 * @extends SMC.controls.layerTree.LayerTreeNode
 * @param {object} options - Object with initialized parameters
 * @mixin
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.controls.layerTree.LayerTreeFolder = SMC.controls.layerTree.LayerTreeNode.extend(
    /** @lends SMC.controls.layerTree.LayerTreeFolder# */
    {
        /**
         * Options property
         * @property {string} options.label - label layer tree
         */
        options: {
            label: null
        },
        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },
        /**
         * Method to create a node html that represents the layer label
         * @returns {string} String that represents the label layer
         */
        createNodeHTML: function() {
            return this.options.label;
        }
    }
);

},{"./LayerTreeNode.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeNode.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeLeaf.js":[function(require,module,exports){
require('./layerTree.js');
require("./LayerTreeNode.js");
/**
 * Base class for layer tree controls.
 * @class
 * @extends SMC.controls.layerTree.LayerTreeNode
 * @param {SMC.controls.layerTree.LayerTreeLeaf~options} options - The configuration for the class
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.controls.layerTree.LayerTreeLeaf = SMC.controls.layerTree.LayerTreeNode.extend(
    /** @lends SMC.controls.layerTree.LayerTreeLeaf# */
    {
        /**
         * @typedef {Object} SMC.controls.layerTree.LayerTreeLeaf~options
         * @property {string} label=null - label layer tree
         * @property {boolean} baseLayer=false - base layer
         */
        options: {
            label: null,
            baseLayer: false
        },

        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },
        /**
         * Method to create an HTML node for the name of the layer.
         *
         * Unless overriden by inheriting classes, it returns the layer's label.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {
            return this.options.label;
        }
    }
);

},{"./LayerTreeNode.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeNode.js","./layerTree.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/layerTree.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeNode.js":[function(require,module,exports){
require('./layerTree.js');
require("./LayerTreeControl.js");
/**
 * Base class for layer tree controls.
 * @class
 * @extends L.Class
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.controls.layerTree.LayerTreeNode = L.Class.extend(
    /** @lends SMC.controls.layerTree.LayerTreeNode# */
    {

        /**
         * Layer visibility property
         * @property {string} visible - layer visibility property
         * @default true
         */
        visible: true,

        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },

        /**
         * Implementations of LayerTreeNode must contain an override of this method, so HTML nodes can be loaded from their source.
         * @abstract
         */
        createNodeHTML: function() {
            throw new Error("LayerTreeNode::createNodeHTML must be implemented by derivate classes.");
        },

        /**
         * Method to know if a layer is visible
         * @returns {Boolean} True is the layer is visible
         */
        isVisible: function() {
            return visible;
        },

        /**
         * Method to set the visibility of a tree node.
         * @method
         * @param {Boolean} visible - Boolean param to set visibilty true or false.
         */
        setVisible: function(visible) {
            visible = visible;
            // TODO: Handle visibility change.
        }
    }
);

},{"./LayerTreeControl.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeControl.js","./layerTree.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/layerTree.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/layerTree.js":[function(require,module,exports){
require("../controls.js");

/**
 * Namespace of LayerTree controls.
 * @namespace
 * @memberof SMC.controls
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.controls.layerTree = {};

},{"../controls.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/controls.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/EditableLayer.js":[function(require,module,exports){
require("./SingleLayer.js");
/**
 * Base class for all SMC viewer layer which are both reloadable and editable layers.
 * @class
 * @extends SMC.layers.SingleLayer
 * @abstract
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.layers.EditableLayer = SMC.layers.SingleLayer.extend(
    /** @lends SMC.layers.EditableLayer# */
    {
        options: {
            editButtonLabel: "Start Edition",
            confirmButtonLabel: "Finish Edition"
        },

        _editing: false,
        _button: null,

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },
        /**
         * Method to add edit control to map
         * @private
         * @param {Object} options - Event to handler
         */
        _startEditControl: function(options) {
            throw new Error(
                "SMC.layers.EditableLayer::_addEditControl: must be implemented in derivate classes.");
        },
        /**
         * Method to add edit control to map
         * @private
         * @param {Object} options - Event to handler
         */
        _finishEditControl: function(options) {
            throw new Error(
                "SMC.layers.EditableLayer::_addEditControl: must be implemented in derivate classes.");
        },
        /**
         * Method to add edit button to layer tree panel
         * @private
         */
        _addEditButton: function() {
            var node = document.createElement("div");
            node.id = this.options.label;
            node.style.display = "inherit";
            // Create label
            var label = document.createElement("i");
            label.style.cursor = "pointer";
            label.innerHTML = this.options.label;
            node.appendChild(label);
            // Create space
            var br = document.createElement("br");
            node.appendChild(br);
            // Create start edition button
            var button = document.createElement("input");
            button.setAttribute("type", "button");
            button.setAttribute("value", this.options.editButtonLabel);
            button.style.cursor = "pointer";
            node.appendChild(button);
            var _this = this;
            button.onclick = function(event) {
                if (_this._editing) {
                    _this._finishEditControl(event);
                } else {
                    _this._startEditControl(event);
                }
                _this._editing = !_this._editing;
                button.setAttribute("value",
                    _this._editing ? _this.options.confirmButtonLabel : _this.options.editButtonLabel);

                return false; // So the event doesnt propagate.
            };
            node.onclick = function(){
                return false;
            };
            
            this._button = button;

            return node;
        },


        onAdd: function(map) {
            if (this._button) {
                this._button.style.display = "";
            }
        },

        onRemove: function(map) {
            if (this._button) {
                this._button.style.display = "none";
            }
        },


        /**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {
            var node = this._addEditButton();
            return node;
        }
    }
);

},{"./SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/Folder.js":[function(require,module,exports){
require("./layers.js");
require("../controls/layerTree/LayerTreeFolder.js");
require("../LayerLoader.js");

/**
 * Base class for folder.
 * @class
 * @extends L.LayerGroup
 * @mixes SMC.controls.layerTree.LayerTreeFolder
 * @mixes SMC.LayerLoader
 * 
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.layers.Folder = L.LayerGroup.extend(
    /** @lends SMC.layers.Folder# */
    {


        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
            L.LayerGroup.prototype.initialize.call(this, options);
            SMC.controls.layerTree.LayerTreeFolder.prototype.initialize.call(this, options);

            if (this.options.layersConfig) {
                // We use the LayerLoader functionality.
                this.loadLayers(this.options.layersConfig);
            } else if (this.options.layers) {
                for (var i = 0; i < options.layers.length; i++) {
                    this.options.layers[i].addTo(this);
                    this.options.layers[i].parent = this;
                }
            } else {
                throw new Error("SMC.layers.Folder::initialize: Either layersConfig or layers must be passed as an initialization option!");
            }
        },

        /**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {
            var node = document.createElement("i");
            node.className = 'fa fa-folder-open';
            node.style.cursor = "pointer";
            node.onclick = this._clickOnFolder;
            node.innerHTML = (this.options.label || this.options.typeName);
            return node;
        },

        _clickOnFolder: function(evt){
            if(evt.target.className.indexOf("open") != -1){
                // Folder opened
                var labels = evt.target.parentElement.parentElement.getElementsByClassName("leaflet-control-layers-group-content");
                labels[0].style.display = 'none';
                evt.target.removeAttribute("class");
                evt.target.className = "fa fa-folder";
            }else{
                // Folder closed
                var labels = evt.target.parentElement.parentElement.getElementsByClassName("leaflet-control-layers-group-content");
                labels[0].style.display = 'block';
                evt.target.removeAttribute("class");
                evt.target.className = "fa fa-folder-open";
            }
        }
    },[SMC.controls.layerTree.LayerTreeFolder, SMC.LayerLoader]);

},{"../LayerLoader.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/LayerLoader.js","../controls/layerTree/LayerTreeFolder.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeFolder.js","./layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/IsochroneLayer.js":[function(require,module,exports){
require("./layers");
require("./SingleLayer.js");


/**
 * Wrapper for [Leaflet's WMS layer]{@link http://leafletjs.com/reference.html#tilelayer-wms } so its integrated in the SMC's viewer layer architecture.
 *
 * @class
 * @extends L.TileLayer.WMS
 * @mixes SMC.layers.SingleLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.IsochroneLayer = SMC.layers.geometry.WFSGeometryLayer.extend(
    /** @lends SMC.layers.WMSLayer# */
    {
        /**
         * @typedef {Object} SMC.layers.IsochroneLayer~options
         * @property {SMC.layers.IsochroneLayer~requestParams} requestParams - Default wfs request parameters
         * @property {string} serverURL=null - The wfs server url path parameter
         */

        options: {
            /** @typedef {Object} SMC.layers.IsochroneLayer~requestParams - Default wfs request parameters 
             * @property {string} batch="true" - Goal direction is turned off
             * @property {string} walTime=null - Default travel time
             * @property {string} styles="color30" - Default styles
             * @property {string} mode="WALK" - Default travel mode
             * @property {string} maxWalkDistance=null - Default maximun travel distance
             * @property {string} time=null - Default time
             * @property {string} arriveBy="false" - By default trip should depart at the specified date and time
             * @property {string} walkSpeed=null - Default walk speed
             * @property {string} bikeSpedd=null - Default bike speed
             * @property {string} output="SHED" - Default output geometry
             * @property {string} outputFormat="text/javascript" - Default wfs output format parameter
             
             */
            requestParams: {
                batch: "true",
                walkTime: "15",
                styles: "color30",
                mode: "WALK",
                maxWalkDistance: null,
                time: null,
                fromPlace: null,
                toPlace: "none",
                arriveBy: "false",
                walkSpeed: null,
                bikeSpeed: null,
                output: "SHED",
                outputFormat: "text/javascript",
            },
            serverURL: 'http://107.170.88.62:8080/opentripplanner-api-webapp/ws/iso'
        },

        _getDate: function() {
            var today = new Date();
            var dd = today.getDate();
            var mm = today.getMonth() + 1;
            var yyyy = today.getFullYear();
            var hh = today.getHours();
            var mi = today.getMinutes();
            var ss = today.getSeconds();

            if (dd < 10) {
                dd = '0' + dd;
            }
            if (mm < 10) {
                mm = '0' + mm;
            }
            if (hh < 10) {
                hh = '0' + hh;
            }
            if (mi < 10) {
                mi = '0' + mi;
            }
            if (ss < 10) {
                ss = '0' + ss;
            }


            today = yyyy + '-' + mm + '-' + dd + 'T' + hh + ':' + mi + ':' + ss;
            this.options.time = today;
        },



        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            if (this.options.time == null) {
                this._getDate();
            }
            if (!options.serverURL) {
                options.serverURL = this.options.serverURL;
            }
            if (typeof(options.serverURL) !== "string") {
                throw new Error("SMC.layers.IsochroneLayer::initialize: options must contain an url attribute of type string.");
            }
            SMC.layers.geometry.WFSGeometryLayer.prototype.initialize.call(this, options.serverURL, options);
            SMC.layers.SingleLayer.prototype.initialize.call(this, options);
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onAdd: function(map) {
            SMC.layers.geometry.WFSGeometryLayer.prototype.onAdd.call(this, map);

        },

        /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
        getMap: function() {
            return this._map;
        },


        load: function() {
            var self = this;
            this.doFeaturesLoading().then(function(response) {
                var output = [];
                for (var i in response.coordinates) {
                    var feature = {};
                    feature.type = 'Feature';
                    feature.geometry = {};
                    feature.geometry.type = response.type;
                    feature.geometry.coordinates = response.coordinates[i];
                    output.push(feature);
                }

                self.onFeaturesLoaded(output);

            });

        },

        doFeaturesLoading: function() {
            var self = this;
            var jsonpRandom = this._makeid();
            this.options.format_options = "callback:" + jsonpRandom;
            var stylesheet = '*{fillColor: "rgba(43,140,190,0.5)"; color: "rgba(43,140,190,0.5)";}';
            if (!this.options.stylesheet) {
                this.options.stylesheet = stylesheet;
            }
            return $.ajax({
                type: 'GET',
                url: self.options.serverURL,
                data: self.getParamsFromOptions(),
                jsonpCallback: jsonpRandom,
                dataType: "jsonp",
                async: false
            });


        },



        /**
         * Method to unload the layer.
         */
        unload: function() {
            this._needsload = true;
            this._reset();
        }


    }, [SMC.layers.SingleLayer]);

/**
 * API factory method for ease creation of WMS layers.
 * @params {Object} options - Options for the layer. Must contain a field url of type string.
 */
SMC.isochroneLayer = function(options) {
    return new SMC.layers.IsochroneLayer(options);
};
},{"./SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js","./layers":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/Layer.js":[function(require,module,exports){
require("./layers.js");
require("../controls/layerTree/LayerTreeLeaf.js");

/**
 * Base class for all layer types supporting data providers.
 * @class
 * @abstract
 * @extends L.Class
 * @mixes SMC.controls.layerTree.LayerTreeLeaf
 */
SMC.layers.Layer = L.Class.extend(
    /** @lends SMC.layers.Layer# */
    {
        visible: true,


        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.controls.layerTree.LayerTreeLeaf.prototype.initialize.call(this, options);
        },

        /**
         * Implementations of FeatureProvider must contain an override of this method, so features can be loaded from their source.
         * @abstract
         */
        onAdd: function() {
            throw new Error("FeaturesProvider::doFeaturesLoading must be implemented by derivate classes.");
        },

        /**
         * Method to set the visibility of a tree layer.
         * @param {Boolean} visible - Boolean param to set visibilty true or false.
         */
        setVisible: function(visible) {
             this.visible = visible;
        }
    }, [SMC.controls.layerTree.LayerTreeLeaf]);

},{"../controls/layerTree/LayerTreeLeaf.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeLeaf.js","./layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js":[function(require,module,exports){
require("./layers");
require("./Layer.js");
require("./reloaders/LayerReloader.js");

/**
 * Base class for all SMC viewer layer which are both reloadable and aggregable in grouping layers.
 * @class
 * @extends SMC.layers.Layer
 * @abstract
 * @mixes SMC.layers.reloaders.LayerReloader
 * @mixin SMC.layers.SingleLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.SingleLayer = SMC.layers.Layer.extend(
    /** @lends SMC.layers.SingleLayer# */
    {

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
            SMC.layers.Layer.prototype.initialize.call(this, options);
            SMC.layers.reloaders.LayerReloader.prototype.initialize.call(this, options);
        },
        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onAdd: function(map) {
            this.map = map;
            this.load();
        },

        /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
        getMap: function() {
           return this.map;
        }

    }, [SMC.layers.reloaders.LayerReloader]);
},{"./Layer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/Layer.js","./layers":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js","./reloaders/LayerReloader.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/LayerReloader.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/TileLayer.js":[function(require,module,exports){
require("./layers");
require("./SingleLayer.js");

/**
 * Wrapper for [Leaflet's WMS layer]{@link http://leafletjs.com/reference.html#tilelayer}
 * so its integrated in the SMC's viewer layer architecture.
 *
 * @class
 * @extends L.TileLayer
 * @mixes SMC.layers.SingleLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.TileLayer = L.TileLayer.extend(
    /** @lends SMC.layers.TileLayer# */
    {

         /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            if (!options.url || typeof(options.url) !== "string") {
                throw new Error("SMC.layers.TileLayer::initialize: options must contain an url attribute of type string.");
            }
            L.TileLayer.prototype.initialize.call(this, options.url, options);
            SMC.layers.SingleLayer.prototype.initialize.call(this, options);
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onAdd: function(map) {
            L.TileLayer.prototype.onAdd.call(this, map);
            SMC.layers.SingleLayer.prototype.onAdd.call(this, map);
        },

         /**
         * Retrieves the features from its source.
         */
        load: function() {
            if (this._needsload) {
                this._update();
                this._needsload = false;
            }
        },

         /**
         * Method to unload the layer.
         */
        unload: function() {
            this._reset();
            this._needsload = true;
        }
    }, [SMC.layers.SingleLayer]);

/**
 * API factory method for ease creation of tile layers.
 * @params {Object} options - Options for the layer.
 */
SMC.tileLayer = function(options) {
    return new SMC.layers.TileLayer(options);
};

},{"./SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js","./layers":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/WMSLayer.js":[function(require,module,exports){
require("./layers");
require("./SingleLayer.js");


/**
 * Wrapper for [Leaflet's WMS layer]{@link http://leafletjs.com/reference.html#tilelayer-wms } so its integrated in the SMC's viewer layer architecture.
 *
 * @class
 * @extends L.TileLayer.WMS
 * @mixes SMC.layers.SingleLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.WMSLayer = L.TileLayer.WMS.extend(
    /** @lends SMC.layers.WMSLayer# */
    {

       defaultWmsParams: {
            service: 'WMS',
            request: 'GetMap',
            version: '1.1.1',
            layers: '',
            styles: '',
            format: 'image/png',
            transparent: true
        },

      
         /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
        
            if (!options.url || typeof(options.url) !== "string") {
                throw new Error("SMC.layers.WMSLayer::initialize: options must contain an url attribute of type string.");
            }
            L.TileLayer.WMS.prototype.initialize.call(this, options.url, options);
            SMC.layers.SingleLayer.prototype.initialize.call(this, options);
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onAdd: function(map) {
            L.TileLayer.WMS.prototype.onAdd.call(this, map);
            SMC.layers.SingleLayer.prototype.onAdd.call(this, map);
        },

        /**
         * Retrieves the features from its source.
         */
        load: function() {
            if (this._needsload) {
                this._update();
                this._needsload = false;
            }
        },

         /**
         * Method to unload the layer.
         */
        unload: function() {
            this._needsload = true;
            this._reset();
        },

        getTileUrl: function(tilePoint) {
            var url = L.TileLayer.WMS.prototype.getTileUrl.apply(this, [tilePoint]);
            if(this._needsload) {
               url+="&_dc="+Math.random();
            }

            return url;
        },


    }, [SMC.layers.SingleLayer]);

/**
 * API factory method for ease creation of WMS layers.
 * @params {Object} options - Options for the layer. Must contain a field url of type string.
 */
SMC.wmsLayer = function(options) {
    return new SMC.layers.WMSLayer(options);
};

},{"./SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js","./layers":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/AggregatingLayer.js":[function(require,module,exports){
require("./aggregation.js");
require("../../controls/layerTree/LayerTreeFolder.js");
require("../../LayerLoader.js");

/**
 * Class formed by the aggregation of several layers.
 *
 * @class
 * @extends SMC.layers.Layer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.aggregation.AggregatingLayer = L.LayerGroup.extend(
	/** @lends SMC.layers.aggregation.AggregatingLayer# */
	{

		_aggregatingLayers: {},
		

		/**
         * Initialize the object with the params
         * @param {Object} options - Object with extra information
         */
		initialize: function(options) {
			L.Util.setOptions(this, options);
			this._aggregatingLayers = {};

		},

		/**
		 * Adds a sublayer to the layer.
		 * @param {string} layerId - Layer Identifier
		 * @param {SMC.layers} layer - Layer object
		 */
		addLayer: function(layerId, layer) {

			if (layerId.layersConfig) {
				// We use the LayerLoader functionality.
				this.loadLayers(layerId.layersConfig);


			} else if (typeof layerId === "object") {
				console.log(layerId.options.typeName || layerId.options.label);
				this._aggregatingLayers[L.stamp(layerId)] = layerId;

			}

		},

		 /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
		getMap: function() {
			if (this.parent) {
				if (this.parent.map) {
					map = this.parent.map;
				}else if(this.parent._map){
					map = this.parent._map;
				} else if (this.parent.parent) {
					if (this.parent.parent.map)
						map = this.parent.parent.map;
					else if (this.parent.parent._map)
						map = this.parent.parent._map;
				}

				return map;
			}
			else if(this._map){
				map = this._map;
				return map;
			}
		}

		// onAdd: function(map) {
		// 	L.LayerGroup.prototype.onAdd.call(this, map);

		// },

		// onRemove: function(map){
		// 	L.LayerGroup.prototype.onRemove.call(this, map);
		// },

		// addTo: function(map){
		// 	L.LayerGroup.prototype.addTo.call(this, map);
		// }



	}, [SMC.LayerLoader]);
},{"../../LayerLoader.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/LayerLoader.js","../../controls/layerTree/LayerTreeFolder.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/controls/layerTree/LayerTreeFolder.js","./aggregation.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/aggregation.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/MultiModeLayer.js":[function(require,module,exports){
require("../layers.js");
require("../../LayerLoader.js");
require("./AggregatingLayer.js");



/**
 * Class formed by the aggregation of several layers.
 *
 * @class
 * @extends SMC.aggregation.AggregatingLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.aggregation.MultiModeLayer = SMC.layers.aggregation.AggregatingLayer.extend(
	/** @lends SMC.layers.history.AggregatingHistoryLayer# */
	{
		node: null,

		/**
         * Initialize the object with the params
         * @param {Object} options - Object with extra information
         */
		initialize: function(options) {
			L.Util.setOptions(this, options);
			SMC.layers.aggregation.AggregatingLayer.prototype.initialize.apply(this, arguments);
			L.LayerGroup.prototype.initialize.call(this, arguments);
			this.checked = true;
		},

		 /**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
		createNodeHTML: function() {

			var node = document.createElement("div");
			node.id = this._leaflet_id;

			var label = document.createElement('label');
			var checked = this.getMap().hasLayer(this);

			var input = document.createElement('input');
			input.type = 'checkbox';
			input.defaultChecked = checked;
			var name = document.createElement('span');
			name.innerHTML = ' ' + this.options.label;

			label.appendChild(input);
			label.appendChild(name);

			label.style.cursor = "pointer";


			input.onchange = function(event) {
				self._clickOnMultiLayer(node);
			};


			node.appendChild(label);

			var layers = this._aggregatingLayers;

			//create buttons container
			var modes = document.createElement("div");

			for (var l in layers) {
				//create buttons
				var button = document.createElement("input");
				button.setAttribute('type', 'button');
				button.style.cursor = "pointer";
				button.value = layers[l].options.label;

				modes.appendChild(button);
				var self = this;
				button.onclick = function(event) {
					self._onActive(event, modes);
				};

			};


			node.appendChild(modes);
			if (this.node == null) {
				this.node = node;
				this._initializeButtons(modes);
				var active = this._getActiveLayer();

			}

			return node;
		},

		_initializeButtons: function(modes) {
			var active = this._getActiveLayer();
			var buttons = modes.children;
			for (var i = 0; i < buttons.length; i++) {
				if (buttons[i].value == active.options.label) {
					buttons[i].style.backgroundColor = '#ddd';
				} else
					buttons[i].style.backgroundColor = '#fff';
			}

			var multiLayers = this._aggregatingLayers;

			for (var l in multiLayers) {
				multiLayers[l].addTo(this.getMap());
				if (!multiLayers[l].active) {
					L.FeatureGroup.prototype.onRemove.call(this, map);
					multiLayers[l].onRemove(map);
				}

			};
		},

		/**
         * Retrieves the features from its source.
         */
		load: function() {

		},

		_initializeTree: function() {

			var multiLayers = this._aggregatingLayers;
			for (var l in multiLayers) {
				if (multiLayers[l].active) {
					if(multiLayers[l] instanceof SMC.layers.markers.WFSTMarkerLayer){
						multiLayers[l]._setButtonText();
					}
					//add node of active layer
					if ((multiLayers[l] instanceof SMC.layers.aggregation.AggregatingLayer || multiLayers[l] instanceof SMC.layers.markers.WFSTMarkerLayer) && this.checked) {
						this._addNode(multiLayers[l].options.label);
					} else
						this._addNode('none');

				}

			}

		},



		_getActiveLayer: function(multiLayers) {
			var i = 0;
			var multiLayers = this._aggregatingLayers;
			var active;
			var defaultActive;
			for (var l in multiLayers) {
				if (i == 0) {
					defaultActive = multiLayers[l];
				}
				if (multiLayers[l].options.active || multiLayers[l].active) {
					multiLayers[l].active = true;
					active = multiLayers[l];
					multiLayers[l].setVisible(true);

				} else {
					multiLayers[l].active = false;

				}
				i++;

			}

			if (!active) {
				defaultActive.active = true;
				active = defaultActive;

			}

			return active;


		},

		_onActive: function(event, modes) {
			//active/desactive layers
			var multiLayers = this._aggregatingLayers;
			var buttons = modes.children;
			for (var i = 0; i < buttons.length; i++) {
				if (buttons[i] == event.target) {
					buttons[i].style.backgroundColor = '#ddd';
				} else
					buttons[i].style.backgroundColor = '#fff';
			}

			for (var l in multiLayers) {
				var layer;
				if (multiLayers[l].options.label != event.target.value) {

					if (multiLayers[l].active) {
						var pause = document.getElementsByClassName('fa fa-pause');
						for (var i = 0; i < pause.length; i++) {
							pause[i].className = 'fa fa-play';
						}
						clearInterval(multiLayers[l]._timer);

						if (multiLayers[l]._finishEditControl) {
							multiLayers[l]._finishEditControl();
						}

						multiLayers[l].onRemove(map);
						multiLayers[l].active = false;
					}



				} else {
					if (!multiLayers[l].active) {

						multiLayers[l].onAdd(map);
						multiLayers[l].active = true;

					}

				}

			}
			this._initializeTree();

			

		},

		_addNode: function(label) {
			var id = this._leaflet_id;
			var tree = document.getElementById(id);
			if (!tree) {
				return;
			}
			var treeNodes = tree.parentNode.nextElementSibling;
			var tree = treeNodes.children;
			
			treeNodes.style.display = 'block';
			for (var i = 0; i < tree.length; i++) {
				
					tree[i].style.display = 'none';
					search(tree[i]);

			}

			//search node active layer
			function search(tree) {
				var node = tree.children;
				for (var i = 0; i < node.length; i++) {
					if (node[i].innerHTML.trim() != label) {
							if(node[i].type == 'checkbox' || node[i].nodeName == 'BR'){
								node[i].style.display = 'none';	

							}
						
						if (node[i].children.length != 0)
							search(node[i]);


					} else {
						node[i].style.display = 'none';
						node[i].parentNode.style.display = 'block';
						node[i].parentNode.parentNode.style.display = 'block';
						node[i].parentNode.parentNode.parentNode.style.display = 'block';
						node[i].parentNode.parentNode.parentNode.parentNode.style.display = 'block';
						

					}
				}

			}



		},

		_clickOnMultiLayer: function(node) {
			//active/desactive multimode layer

			var id = this._leaflet_id;
			var tree = document.getElementById(id);
			if (!tree) {
				return;
			}
			var treeNodes = tree.parentNode.nextElementSibling;
			var pause = treeNodes.getElementsByClassName('fa fa-pause');
			var multiLayers = this._aggregatingLayers;

			if (node.children[1].style.display != 'none') {
				this.checked = false;
				node.children[1].style.display = 'none';
				treeNodes.style.display = 'none';
				node.children[0].children[0].checked = false;
				for (var d in multiLayers) {
					if (multiLayers[d].active) {
						if (multiLayers[d] instanceof SMC.layers.history.AggregatingHistoryLayer) {
							for (var i = 0; i < pause.length; i++) {
								clearInterval(multiLayers[d]._timer);
								pause[i].className = 'fa fa-play';
							}
							
						}

						if (multiLayers[d] instanceof SMC.layers.markers.WFSTMarkerLayer) {
							multiLayers[d]._finishEditControl();
						}
						multiLayers[d].onRemove(map);
					}
				}
			} else {
				this.checked = true;
				node.children[1].style.display = 'block';
				treeNodes.style.display = 'block';
				node.children[0].children[0].checked = true;
				for (var l in multiLayers) {
					if (multiLayers[l].active) {
						multiLayers[l].onAdd(map);
						if ((multiLayers[l] instanceof SMC.layers.aggregation.AggregatingLayer || multiLayers[l] instanceof SMC.layers.markers.WFSTMarkerLayer) && this.checked) {
							this._addNode(multiLayers[l].options.label);
						} else
							this._addNode('none');
						
					}
				}



			}

		},


	}, [SMC.layers.SingleLayer]);
},{"../../LayerLoader.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/LayerLoader.js","../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js","./AggregatingLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/AggregatingLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/aggregation/aggregation.js":[function(require,module,exports){
/**
 * Namespace for agreggating layers, e.g., layers that are the result of the composition
 * of several other layers.
 *
 * @namespace
 * @memberof SMC.layers
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.aggregation = {};
},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/CanvasRenderer.js":[function(require,module,exports){
require("../stylers/MapCssStyler.js");
/**
 * Global variable that represents paper library functionality
 * @property {paper} - paper variable
 */
var paper = require("../../../lib/paper/dist/paper-full.js").exports;
var rbush = require("../../../lib/rbush.js");

/**
 * Base class for layers using client side rendering of canvas renderer.
 * @class
 * @abstract
 * @extends L.Class
 * @mixes SMC.layers.stylers.MapCssStyler
 * @param {SMC.layers.geometry.CanvasRenderer~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.geometry.CanvasRenderer = L.Class.extend(
    /** @lends SMC.layers.geometry.CanvasRenderer# */
    {

        canvasTree: null,

        // This map will be used to store ctx related events, of which exist one per canvas,
        // so we are able of removing them to avoid performance regressions.
        _ctxEvents: null,

        /**
         * @typedef {Object} SMC.layers.geometry.CanvasRenderer~options
         * @property {boolean} draggingUpdates=true - Default dragging updates value
         */
        options: {
            draggingUpdates: true,
            mouseOver: false,
            debug: false
        },

        _visible: false,

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            SMC.layers.stylers.MapCssStyler.prototype.initialize.apply(this, arguments);

            L.Util.setOptions(this, options);
            this.fireEvent('layerLoad', {
                features: this.features
            });
        },

        _onMapClicked: function(event) {

            if (this.canvasTree) {

                var canvasBbox = this._searchCanvas(event);
                for (var i = 0; i < canvasBbox.length; i++) {
                    var ctx = canvasBbox[i].ctx;
                    this._onMouseClick(ctx, event);
                }
            }
        },

        _onMapMoveEnded: function() {
            if (this.canvasTree) {
                this.canvasTree.clear();
            }
            this.getMap().fireEvent("dragend");
        },

        _onMapDragStarted: function() {
            this.dragging = true;
            if (this.canvasTree) {
                this.canvasTree.clear();
            }

            console.debug("moving disabled!");
            this.getMap().off("mousemove", this._onMapMouseMoved, this);
        },

        _onMapMouseMoved: function(event) {
            if (this.canvasTree) {
                this._onMouseMoveAux(event);
            }
        },

        _onMouseMoveAux: function(event) {



            if (this.dragging || !this.options.mouseOver) {
                return;
            }

            var canvasBbox = this._searchCanvas(event);
            console.debug("Mouse move canvases searched: " + canvasBbox.length);
            for (var i = 0; i < canvasBbox.length; i++) {
                var ctx = canvasBbox[i].ctx;
                this._onMouseMove(ctx, event);

            }
        },


        /**
         * Method to render a layer with canvas component
         * @param {object} ctx - canvas context
         * @param {object} features - object that represents a features set
         * @param {SMC.Map} map - map where load the features
         * @returns {SMC.layers.Layer} layer to show on the map
         */
        renderCanvas: function(ctx, features, map) {

            if (!this._visible) {
                return;
            }

            this._initCtx(ctx, map);
            var zBuffer = [];

            if (!this.options.draggingUpdates && this.dragging) {
                // We don't draw while dragging, as it eats A LOT of CPU.
                return;
            }

            ctx.features = features;

            this.labels = [];
            var canvas = ctx.canvas;

            var mypaper;
            if (!canvas._paper) {
                mypaper = new paper.PaperScope();
                mypaper.setup(canvas);
                canvas._paper = mypaper;
                canvas._map = map;

            }

            mypaper = canvas._paper;

            if (canvas._initialized) {
                mypaper.activate();
                mypaper.project.activeLayer.removeChildren();
            }

            var canvasLabel;
            if (ctx.tile) {
                canvasLabel = "(" + ctx.tile.x + " , " + ctx.tile.y + ")";
            } else {
                canvasLabel = mypaper._id;
            }

            console.time("render " + canvasLabel);



            if (ctx.tile) {
                ctx.canvas._s = ctx.tile.multiplyBy(ctx.canvas.width);
            } else {
                ctx.canvas._s = ctx.canvas._map.getPixelBounds().min;
            }

            console.time("applyStyles " + canvasLabel);

            var layer = new mypaper.Group();
            layer.applyMatrix = false;
            layer.translate(new paper.Point(-ctx.canvas._s.x, -ctx.canvas._s.y));

            var z;
            for (var i = 0; i < features.length; i++) {
                var feature = features[i];

                var styles;
                if (feature._clean && !ctx.forceStyles) {
                    styles = feature._styles;
                } else {
                    styles = feature._styles = this._applyStyles(feature, ctx);
                }

                z = {
                    style: styles,
                    zIndex: styles.zIndex,
                    feature: feature
                };

                zBuffer.push(z);
            }

            zBuffer.sort(function(f1, f2) {
                return f1.zIndex - f2.zIndex;
            });

            var items = [];

            for (i = 0; i < zBuffer.length; i++) {
                z = zBuffer[i];
                var item = this._addFeature(ctx, z);
                items.push(item);

                if (z.feature.selected) {
                    item.selected = true;
                }
            }

            layer.addChildren(items);

            console.timeEnd("applyStyles " + canvasLabel);

            console.time("draw " + canvasLabel);

            // Visual debug info:

            if (this.options.debug) {
                var text = new mypaper.PointText({
                    point: [5, 10],
                    content: canvasLabel,
                    fillColor: 'red',
                    fontFamily: 'Courier New',
                    fontWeight: 'bold',
                    fontSize: 10
                });

                var border = new mypaper.Path.Rectangle(0, 0, canvas.clientWidth, canvas.clientHeight);
                border.style.strokeColor = "gray";

            }

            mypaper.view.draw();

            console.timeEnd("draw " + canvasLabel);
            console.timeEnd("render " + canvasLabel);

            return layer;
        },

        _initCtx: function(ctx, map) {

            if (ctx.canvas._initialized) {
                return;
            }

            ctx.canvas._initialized = true;

            if (!map) {
                map = this.getMap();
            }
            var zoom = map.getZoom();
            if (this.canvasTree === null || this.lastZoom != zoom) {
                this.canvasTree = rbush(9, ['.minx', '.miny', '.maxx', '.maxy']);
                this.lastZoom = zoom;
            }

            var treeNode = this._createTreeNode(ctx);
            this.canvasTree.insert(treeNode);

            this._registerCtxEvent("zoomend", function() {
                this._onViewChanged(ctx);
            });


            this._registerCtxEvent("dragend", function() {
                this.dragging = false;

                console.debug("moving renabled!");
                map.on("mousemove", this._onMouseMoveAux, this);

                var treeNode = this._createTreeNode(ctx);
                this.canvasTree.insert(treeNode);

                if (!this.options.draggingUpdates) {
                    this.renderCanvas(ctx, ctx.features, ctx.canvas._map);
                }
            });
        },

        _registerCtxEvent: function(eventName, fn) {
            if (!this._ctxEvents) {
                this._ctxEvents = {};
            }

            if (!this._ctxEvents[eventName]) {
                this._ctxEvents[eventName] = [];
            }

            this._ctxEvents[eventName].push(fn);

            var map = this.getMap();
            if (!map && this.parent) {
                if (this.parent._map) {
                    map = this.parent._map;
                } else if (this.parent.parent) {
                    map = this.parent.parent._map;
                }
            }

            map.on(eventName, fn, this);
        },

        _createTreeNode: function(ctx) {
            var points = ctx.canvas.getBoundingClientRect();
            var bbox = L.bounds([points.top, points.left], [points.bottom, points.right]);


            return {
                ctx: ctx,
                minx: bbox.min.x,
                maxx: bbox.max.x,
                miny: bbox.min.y,
                maxy: bbox.max.y,
                tilePoint: ctx.tile
            };

        },

        _searchCanvas: function(event) {
            var bbox = L.bounds([event.containerPoint.y, event.containerPoint.x], [event.containerPoint.y,
                event.containerPoint.x
            ]);


            var canvas = [];
            if (this.canvasTree) {
                canvas = this.canvasTree.search([bbox.min.x, bbox.min.y, bbox.max.x, bbox.max.y]);
            }

            return canvas;
        },


        _addFeature: function(ctx, elem) {
            var feature = elem.feature;

            if (feature._clean) {
                return feature._item;
            }

            var styles = elem.style;

            var geom = feature.geometry.coordinates;
            if (geom[0]) {
                while (L.Util.isArray(geom[0][0])) {
                    geom = geom[0];
                }
            }

            var labels = this._addLabels(feature, ctx);
            var stylePopup = this._addPopUp(feature, ctx);


            var type = feature.geometry.type;

            var item, path;
            switch (type) {
                case 'Point':
                case 'MultiPoint':

                    var point = this._canvasPoint(geom, ctx, feature._clean);
                    styles.path.position = point;
                    path = styles.path;

                    break;

                case 'LineString':
                case 'MultiLineString':

                    path = this._createGeometry(ctx, geom, feature, styles.offset, feature._clean);
                    break;

                case 'Polygon':
                case 'MultiPolygon':

                    path = this._createGeometry(ctx, geom, feature, null, feature._clean);
                    path.closed = true;

                    break;

            }


            feature._clean = true;
            path._feature = feature;
            item = this._createItem(path, styles, labels, stylePopup, ctx);
            feature._item = item;
            return item;

        },

        _getCtxId: function(ctx) {

            if (ctx.id) {
                return ctx.id;
            }



            if (ctx.tile) {
                ctx.id = ctx.tile.x + ":" + ctx.tile.y;
            } else {
                ctx.id = "ctx"; // Just one ctx anyway so any id should work.
            }

            return ctx.id;
        },

        _canvasPoint: function(coords, ctx, clean) {

            // actual coords to tile 'space'
            var p;
            var zoom = ctx.zoom;
            if (coords._projCoords && clean) {
                p = coords._projCoords;
            } else {
                p = coords._projCoords = ctx.canvas._map.project(new L.LatLng(coords[1], coords[0]), zoom);
            }

            return {
                x: p.x,
                y: p.y
            };
        },



        _createGeometry: function(ctx, geom, feature, offset, clean) {
            var path; // = new ctx.paper.Path();

            var points = [];
            for (var i = 0; i < geom.length; i++) {
                points[i] = this._canvasPoint(geom[i], ctx, clean);

            }
            points = L.LineUtil.simplify(points, 1);

            if (offset && offset !== 0) {
                points = this._addOffset(points, offset, ctx);
            }

            path = new ctx.canvas._paper.Path({
                segments: points
            });

            return path;

        },


        _applyStyles: function(feature, ctx) {
            var zoom = ctx.canvas._map.getZoom();
            var style = this.applyStyle(feature, ctx, zoom);
            return style;
        },

        _addLabels: function(feature, ctx) {
            var zoom = ctx.canvas._map.getZoom();
            var label = this.addLabelStyle(feature, zoom);
            return label;

        },

        _addPopUp: function(feature, ctx) {
            var zoom = ctx.canvas._map.getZoom();
            var popUpStyle = this.addPopUp(feature, zoom);
            return popUpStyle;
        },

        _createItem: function(path, styles, labels, stylePopup, ctx) {

            path.style = styles.pathStyle;
            path.opacity = styles.opacity;
            path.visible = styles.visible;
            if (typeof styles.visible === "undefined") {
                path.visible = true;
            }
            path._feature.stylePopup = stylePopup;


            var item = new ctx.canvas._paper.Group();
            item.addChild(path);
            item.zIndex = styles.zIndex;

            if (labels.content && path.visible) {
                var pointText = new ctx.canvas._paper.PointText(path.interiorPoint);
                pointText.content = labels.content;
                pointText.style = labels.style;
                item.addChild(pointText);
            }

            return item;
        },

        _onMouseClick: function(ctx, event) {

            var popup;
            var hitResult = this._hitTest(ctx, event);

            if (hitResult && hitResult.item._class == 'Path') {
                event._hit = hitResult;

                this.fireEvent("featureClick", {
                    feature: hitResult.item._feature,
                    event: event,

                });


                this.updateFeature(hitResult.item._feature);
                var stylePopup = this._addPopUp(hitResult.item._feature, ctx);

                if (stylePopup.content != null) {

                    popup = L.popup({
                            offset: stylePopup.offset
                        })
                        .setLatLng(event.latlng)
                        .setContent(stylePopup.content)
                        .openOn(ctx.canvas._map);
                }
            }

        },

        _onMouseMove: function(ctx, event) {

            var hitResult = this._hitTest(ctx, event);

            if (hitResult && hitResult.item._class == 'Path') {
                event._hit = hitResult;
            }

            ctx.canvas._map.getContainer().style.cursor = event._hit ? 'pointer ' : '';
        },


        _hitTest: function(ctx, event) {

            //console.time("hitTest");
            var cPoint = this._canvasPoint([event.latlng.lng, event.latlng.lat], ctx);

            var s = ctx.canvas._map.getPixelBounds().min;


            cPoint.x -= ctx.canvas._s.x;
            cPoint.y -= ctx.canvas._s.y;
            var fill = true;

            var options = {
                tolerance: 10,
                fill: true,
                stroke: true
            };


            var hitResult = ctx.canvas._paper.project.hitTest(cPoint, options);
            //console.timeEnd("hitTest");

            return hitResult;
        },

        _onViewChanged: function(ctx) {
            for (var i = 0; i < this.features.length; i++) {
                var f = this.features[i];
                f._clean = false;
                this.canvasTree.clear();
            }

        },

        _addOffset: function(proj, offset, ctx) {
            var points = [];
            for (var j = 0; j < proj.length; j++) {
                var p = proj[j];

                p.lat = p.x;
                p.lng = p.y;

                if (j === 0) {
                    nextPoint = proj[j + 1];
                    normal = this._calculateNormal(p, nextPoint);
                    p.x = p.x + offset * normal.x;
                    p.y = p.y + offset * normal.y;
                } else if (j == proj.length - 1) {
                    prevPoint = proj[j - 1];
                    normal = this._calculateNormal(prevPoint, p);
                    p.x = p.x + offset * normal.x;
                    p.y = p.y + offset * normal.y;
                } else {

                    prevPoint = proj[j - 1];
                    normal0 = this._calculateNormal(prevPoint, p);

                    var x1 = prevPoint.x + offset * normal0.x;
                    var y1 = prevPoint.y + offset * normal0.y;

                    var x2 = p.x + offset * normal0.x;
                    var y2 = p.y + offset * normal0.y;

                    nextPoint = nextPoint = proj[j + 1];
                    normal1 = this._calculateNormal(p, nextPoint);
                    var x3 = p.x + offset * normal1.x;
                    var y3 = p.y + offset * normal1.y;

                    var x4 = nextPoint.x + offset * normal1.x;
                    var y4 = nextPoint.y + offset * normal1.y;


                    var d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

                    if (d < 0.000000000001) {
                        // Very small denominators make the calculation go crazy.
                        p.x = p.x + offset * normal.x;
                        p.y = p.y + offset * normal.y;
                    } else {

                        var n1 = (x1 * y2 - y1 * x2);
                        var n2 = (x3 * y4 - y3 * x4);

                        p.x = (n1 * (x3 - x4) - (x1 - x2) * n2) / d;
                        p.y = (n1 * (y3 - y4) - (y1 - y2) * n2) / d;

                    }
                }
                proj[j] = {
                    x: p.lat,
                    y: p.lng
                };
                points[j] = {
                    x: p.x,
                    y: p.y
                };


            }


            return points;
        },

        _calculateNormal: function(p0, p1) {

            var ry = p1.y - p0.y;
            var rx = p1.x - p0.x;

            var d = Math.sqrt(rx * rx + ry * ry);

            return {
                x: -ry / d,
                y: rx / d
            };

        },

        /**
         * Method to add a layer from the map
         */
        onAdd: function() {
            this._ctxEvents = {};
            var map = this.getMap();
            map.on("dragstart", this._onMapDragStarted, this);

            map.on("mousemove", this._onMapMouseMoved, this);
            map.on("moveend", this._onMapMoveEnded, this);
            map.on("click", this._onMapClicked, this);

            this._visible = true;
        },

        /**
         * Method to remove a layer from the map
         */
        onRemove: function() {
            // We need to remove all events associated with the layer, or performance will be sorely affected.

            var map = this.getMap();

            map.off("click", this._onMapClicked, this);
            map.off("mousemove", this._onMapMouseMoved, this);
            map.off("dragstart", this._onMapDragStarted, this);
            map.off("moveend", this._onMapMoveEnded, this);

            for (var eventName in this._ctxEvents) {
                var eventHandlers = this._ctxEvents[eventName];
                for (var i = 0; i < eventHandlers.length; i++) {
                    map.off(eventName, eventHandlers[i], this);
                }
            }

            this._visible = false;
        }

    }, [SMC.layers.stylers.MapCssStyler]);
},{"../../../lib/paper/dist/paper-full.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/paper/dist/paper-full.js","../../../lib/rbush.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/rbush.js","../stylers/MapCssStyler.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/MapCssStyler.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/GeometryLayer.js":[function(require,module,exports){
require("./geometry.js");
require("../SingleLayer.js");
require("./CanvasRenderer.js");
require("../stylers/MapCssStyler.js");
require("../../../lib/canvasLayer/leaflet_canvas_layer.js");
/**
 * Base class for layers using client side rendering of geographical features in the SCM map viewer component.
 * @class
 * @abstract
 * @extends L.CanvasLayer
 * @mixes SMC.layers.SingleLayer
 * @mixes SMC.layers.geometry.CanvasRenderer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.geometry.GeometryLayer = L.CanvasLayer.extend(
    /** @lends SMC.layers.geometry.GeometryLayer# */
    {

		features: [],
		/**
		 * Initialize the object with the params
		 * @param {object} options - object with need parameters
		 */
		initialize: function(options) {
			L.CanvasLayer.prototype.initialize.apply(this, arguments);
			SMC.layers.stylers.MapCssStyler.prototype.initialize.apply(this, arguments);
			SMC.layers.SingleLayer.prototype.initialize.apply(this, arguments);
			L.Util.setOptions(this, options);
		},
		/**
		 * Method to load the control in the map
		 * @param {SMC.Map} map - Map to be added
		 */
		onAdd: function(map) {
			L.CanvasLayer.prototype.onAdd.call(this, map);
			SMC.layers.geometry.CanvasRenderer.prototype.onAdd.call(this, map);
			SMC.layers.SingleLayer.prototype.onAdd.call(this, map);
		   
			var self = this;
			
			map.on("popupopen", function(event) {
				if (map._autopan) {
					this._resizeAllCanvas();
					}
					map._autopan = false;

			}, this);

			map.on("autopanstart", function() {
				map._autopan = true;
			}, this);


			map.on("resize", function(event) {
					this._resizeAllCanvas();
			}, this);

			map.on("dragend", function(){
          this._resizeAllCanvas();
      }, this);

			map.on('zoomend', function(){
				self._onViewChanged();
			})


		},

        _resizeCanvas: function(){
            var p = this.getMap()._mapPane._leaflet_pos;
                 if (p) {
                         L.DomUtil.setPosition(this._canvas, {
                                x: -p.x,
                                y: -p.y
                            });
                  }
        },

        _resizeAllCanvas: function(){
            var layers = this.getMap()._layers;
            for (var l in layers){
                    if(layers[l] instanceof SMC.layers.geometry.GeometryLayer){
                        layers[l]._resizeCanvas();
                    }
             }
        },

	    load: function(){
            this.addGeometryFromFeatures(this.features);
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onRemove: function(map) {
            SMC.layers.geometry.CanvasRenderer.prototype.onRemove.call(this);
            L.CanvasLayer.prototype.onRemove.apply(this, arguments);
        },

        /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
        getMap: function() {
            return this._map;
        },

        /**
         * Method to render a layer on the map
         */
        render: function() {
            var canvas = this.getCanvas();

            if (this._renderTimeout) {
                clearTimeout(this._renderTimeout);
            }

            var this_ = this;
            this._renderTimeout = setTimeout(function() {
                if (this_.features.length !== 0) {
                    this_.renderCanvas({
                        canvas: canvas
                    }, this_.features, this_.getMap());
                }
           }, 0);
        },

        /**
         * Method to add geometries from features
         * @param {object} features - Features to get its geometries
         */
        addGeometryFromFeatures: function(features) {
            if (L.Util.isArray(features)) {
                this.features = features;
            } else if (arguments.length > 1) {
                this.features = arguments;
            } else {
                this.features = [features];
            }

            for (var i = 0; i < this.features.length; i++) {
                this._setProperties(this.features[i]);
            }

            SMC.layers.geometry.CanvasRenderer.prototype.initialize.call(this, this.options);
            this.render();
        },

        _setProperties: function(feature) {
            var id = this.options.idField;
            if (feature.hasOwnProperty(id))
                feature.id = feature[id];
            else {

                for (var propKey in feature) {
                    if (feature[propKey].hasOwnProperty(id)) {
                        feature.id = feature[propKey][id];
                    }
                }

            }
        },

        /**
         * Method to update the style of a feature
         * @param {object} feature - feature to be updated
         */
        updateFeature: function(feature) {
            for (var i = 0; i < this.features.length; i++) {
                if (this.features[i].id == feature.id) {
                    feature._clean = false;
                    this.features[i] = feature;
                }
            }
            this.render();

        }


    }, [SMC.layers.SingleLayer, SMC.layers.geometry.CanvasRenderer]);

},{"../../../lib/canvasLayer/leaflet_canvas_layer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/canvasLayer/leaflet_canvas_layer.js","../SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js","../stylers/MapCssStyler.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/MapCssStyler.js","./CanvasRenderer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/CanvasRenderer.js","./geometry.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/geometry.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/SolrGeometryHistoryLayer.js":[function(require,module,exports){
require("./GeometryLayer.js");
require("../../providers/SolrHistoryProvider.js");


/**
 * Base class for layers using a Solr provider to get the features
 *
 * @class
 * @abstract
 * @extends SMC.layers.geometry.GeometryLayer
 * @mixes SMC.providers.SolrHistoryProvider
 *
 */
SMC.layers.geometry.SolrGeometryHistoryLayer = SMC.layers.geometry.GeometryLayer.extend(
    /** @lends SMC.layers.geometry.SolrGeometryHistoryLayer# */
    {
        _historyLayers: {},
        _timer: null,
        _node: null,

        currentTime: 0,

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            SMC.layers.geometry.GeometryLayer.prototype.initialize.call(this, options);
            SMC.providers.SolrHistoryProvider.prototype.initialize.call(this, options);
            L.Util.setOptions(this, options);
            this.setZIndex(1000);
        },



        /**
         * Method to load the features
         */
        load: function() {


        },

        /**
         * Method to create an HTML node for the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {

            var node = document.createElement("div");
            node.id = "node_" + this._leaflet_id;

            var label = document.createElement('span'),
                input,
                checked = this.getMap().hasLayer(this);

            input = document.createElement('input');
            input.type = 'checkbox';
            input.defaultChecked = checked;
            input.style.cursor = "pointer";
            var name = document.createElement('span');
            name.innerHTML = ' ' + (this.options.label || this.options.typeName);

            label.appendChild(input);
            label.appendChild(name);
            node.appendChild(label);
            if ($.isEmptyObject(this._featuresForLayer)) {
                return node;
            }

            var sliderControl = document.createElement("table");
            sliderControl.style.marginLeft = '10px';
            sliderControl.style.marginTop = '5px';
            sliderControl.className = 'leaflet-bar leaflet-update-interval ';

            var sliderControlLabel = document.createElement("span");
            this.sliderControlLabel = sliderControlLabel;
            sliderControlLabel.style.float = 'left';
            sliderControl.style.font = '12px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif';

            var inputInterval = document.createElement('input');
            inputInterval.type = 'range';
            inputInterval.id = "interval_" + this._leaflet_id;
            inputInterval.name = "interval_" + this._leaflet_id;
            inputInterval.min = 0;
            inputInterval.max = Object.keys(this._featuresForLayer).length - 1;
            inputInterval.step = 1;
            inputInterval.value = this.currentTime;

            var time = inputInterval.value;

            var play_pause = document.createElement("i");
            play_pause.className = 'fa fa-play';
            play_pause.style.cursor = "pointer";

            this.showTimeData(this.currentTime);

            var self = this;
            L.DomEvent.addListener(inputInterval, 'mousedown', L.DomEvent.stopPropagation);
            L.DomEvent.addListener(inputInterval, 'mouseup', function(e) {
                time = inputInterval.value;
                self.showTimeData(time);
                L.DomEvent.stopPropagation(e);
            });
            L.DomEvent.addListener(inputInterval, 'touchstart', L.DomEvent.stopPropagation);
            L.DomEvent.addListener(inputInterval, 'touchend', L.DomEvent.stopPropagation);

            var tr = document.createElement('tr');
            var td1 = document.createElement('td');
            var td2 = document.createElement('td');
            var td3 = document.createElement('td');
            td1.appendChild(sliderControlLabel);
            td2.appendChild(play_pause);
            td3.appendChild(inputInterval);
            tr.appendChild(td1);
            tr.appendChild(td2);
            tr.appendChild(td3);

            sliderControl.appendChild(tr);


            node.appendChild(sliderControl);

            play_pause.onclick = function() {
                self._onPlayPause(node, time);
            };
            label.onchange = function(event) {
                self._clickOnLayer(node);
            };
            this._node = node;
            return node;

        },

        /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
        getMap: function() {
            if (this.parent) {
                if (this.parent.map) {
                    map = this.parent.map;
                } else if (this.parent._map) {
                    map = this.parent._map;
                } else if (this.parent.parent) {
                    if (this.parent.parent.map)
                        map = this.parent.parent.map;
                    else if (this.parent.parent._map)
                        map = this.parent.parent._map;
                }

                return map;
            } else if (this._map) {
                map = this._map;
                return map;
            }

        },


        /**
         * Method to change the set of features for the layer
         */
        showTimeData: function(time) {
            var i = 0;
            var data = this._featuresForLayer;
            if (time % 1 !== 0) {
                time = time - (time % 1);
            }



            this.currentTime = time;

            for (var d in data) {
                if (data[d].actual) {
                    data[d].actual = false;
                }
                if (i == time) {
                    if (!data[d].actual) {

                        data[d].actual = true;
                        this.features = [];
                        if (data[d].lastZoom && (data[d].lastZoom != this.getMap().getZoom())) {
                            for (var f in data[d]) {
                                data[d][f]._clean = false;
                            }
                        }
                        this.addGeometryFromFeatures(data[d]);
                        data[d].lastZoom = this.getMap().getZoom();

                        // Update layer label
                        this.sliderControlLabel.innerHTML = d;
                    }
                }

                i++;

            }



        },

        _clickOnLayer: function(node) {
            var pause = node.getElementsByClassName('fa fa-pause')[0];
            if (pause) {
                this._onPlayPause(node);
            }
            var data = this._featuresForLayer;
            if (node.children[1].style.display != 'none') {
                node.children[1].style.display = 'none';
                node.children[0].checked = false;
                for (var d in data) {
                    if (data[d].actual) {
                        this.onRemove(this.getMap());
                    }
                }
            } else {
                node.children[1].style.display = 'block';
                node.children[0].checked = true;
                for (var d in data) {
                    if (data[d].actual) {
                        this.onAdd(this.getMap());
                        this.addGeometryFromFeatures(data[d]);

                    }
                }
            }

        },

        _onPlayPause: function(node, time) {
            var data = this._featuresForLayer;
            var slider = node.children[1].children[0].children[2].children[0];
            var maxValue = slider.max;
            var sliderControlLabel = node.children[1].children[0].children[0].children[0];
            var play = node.children[1].children[0].children[1].children[0];

            if (play.className == 'fa fa-play') {
                play.className = 'fa fa-pause';
                if (slider.value == maxValue) {
                    slider.value = 0;
                }


                var i = parseFloat(slider.value);
                var self = this;
                this._timer = setInterval(function() {

                    self.showTimeData(i);
                    if (i < maxValue) {
                        slider.value = i;

                    } else {
                        clearInterval(self._timer);
                        play.className = 'fa fa-play';
                        slider.value = maxValue;

                    }
                    i += parseFloat(slider.step);

                }, this.options.time);

            } else {

                play.className = 'fa fa-play';
                clearInterval(this._timer);
            }
        },



    }, [SMC.providers.SolrHistoryProvider]);

/**
 * API factory method for easy creation of Solr geometry history layer.
 * @params {Object} options - Options to initialize the Solr request
 */
SMC.solrGeometryHistoryLayer = function(options) {
    return new SMC.layers.geometry.SolrGeometryHistoryLayer(options);
};

},{"../../providers/SolrHistoryProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/SolrHistoryProvider.js","./GeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/GeometryLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/TiledGeometryLayer.js":[function(require,module,exports){
require("./geometry.js");
require("../layers.js");
require("../SingleLayer.js");
require("./CanvasRenderer.js");
require("../stylers/MapCssStyler.js");
require("../../../lib/canvasLayer/leaflet_canvas_layer.js");
// RBush inserts itself as NodeJs module so we must retrieve it this way.
/**
 * Global variable that represents RBush library functionality
 * @property {rbush} - rbush variable
 */
var rbush = require("../../../lib/rbush.js");
/**
 * Base class for layers using client side rendering of tiles containing geographical features in the SMC map viewer component.
 *
 * The tiles contents will be retrieved using a data provided supporting tiling as needed to cover the viewing area.
 *
 * @class
 * @abstract
 * @extends L.TileLayer.Canvas
 * @mixes SMC.layers.SingleLayer
 * @mixes SMC.layers.geometry.CanvasRenderer
 * @param {SMC.layers.geometry.TiledGeometryLayer~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.geometry.TiledGeometryLayer = L.TileLayer.Canvas.extend(
    /** @lends SMC.layers.geometry.TiledGeometryLayer# */
    {

        /**
         * @typedef {Object} SMC.layers.geometry.TiledGeometryLayer~options
         * @property {number} tileSize=256 - Default tile size value
         */
        options: {
            tileSize: 256, 
            fieldGeom: 'the_geom'   
        },
        /**
         * Global tree
         * @property {string} globalTree - Default global tree
         * @default null
         */
        globalTree: null,
        /**
         * Features array
         * @property {object[]} features - Default features array
         * @default []
         */
        features: [],
        /**
         * Tiles load variable
         * @property {number} tilesLoad - Default tiles load variable
         * @default 0
         */
        tilesLoad: 0,
        /**
         * Tiles to load
         * @property {object} tilesToLoad - Default tiles to load
         * @default null
         */
        tilesToLoad: null,
        

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
            L.TileLayer.Canvas.prototype.initialize.call(this, options);
            SMC.layers.geometry.CanvasRenderer.prototype.initialize.call(this, options);
            SMC.layers.stylers.MapCssStyler.prototype.initialize.apply(this, arguments);

            this._setFieldGeom();
           
            this.drawTile = function(canvas, tilePoint, zoom) {
                var ctx = {
                    canvas: canvas,
                    tile: tilePoint,
                    zoom: this._getZoomForUrl()
                };

                if (this.globalTree === null || this.lastZoom != zoom) {
                    this.globalTree = rbush(9, ['.minx', '.miny', '.maxx', '.maxy']);
                    this.lastZoom = zoom;

                }

                ctx.canvas.tree = null;

                if (ctx.canvas.tree === null || this.lastZoom != zoom) {
                    ctx.canvas.tree = rbush(9, ['.minx', '.miny', '.maxx', '.maxy']);
                    this.lastZoom = zoom;
                }

                this._draw(ctx);
               

                if (!this.tilesToLoad) {
                    this.tilesToLoad = this._tilesToLoad;
                }
            };
 

        },

        _setFieldGeom: function(){

            var jsonpRandom = this._makeid();
            this.options.format_options = "callback:" + jsonpRandom;
            var self = this;
            $.ajax({
                        type: "GET",
                        url: this.options.serverURL + "?request=DescribeFeatureType&version=1.1.0&typename=" +
                    this.options.typeName + '&outputFormat=text/javascript' +'&format_options=' +this.options.format_options,
                        dataType: "jsonp",
                        jsonp:false,
                        jsonpCallback: jsonpRandom,
                        success: function(response) {
                            var attributes = response.featureTypes[0].properties;
                            for (var i = 0; i < attributes.length; i++) {
                                if (attributes[i].type.substring(0,3) == "gml") {
                                    self.options.fieldGeom = attributes[i].name;
                                }
                            }
                            
                     }
                 });
        },

        /**
         * Method to load the layer on the map
         */
        load: function() {

        },

        /**
         * Method to load a tile on the map
         * @abstract
         */
        loadTile: function() {
            throw new Error("TiledGeometrylayer::loadTile must be implemented by derivate classes.");
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         * @fires SMC.layers.geometry.TiledGeometryLayer#layeradd
         */
        onAdd: function(map) {
            L.TileLayer.Canvas.prototype.onAdd.call(this, map);
            SMC.layers.geometry.CanvasRenderer.prototype.onAdd.apply(this, arguments);
            SMC.layers.SingleLayer.prototype.onAdd.call(this, map);
             /**
                 * Layer add event.
                 *
                 * @event SMC.layers.geometry.TiledGeometryLayer#layeradd
                 * @type {object}
                 * @property {object} layer - Layer to be added.
                 */
            map.fire('layeradd',{
                layer: this
            });

        },

         /**
         * Method to remove the control in the map
         * @param {SMC.Map} map - Map to be removed
         */
        onRemove: function(map) {
            SMC.layers.geometry.CanvasRenderer.prototype.onRemove.call(this);
            L.TileLayer.Canvas.prototype.onRemove.call(this, map);
            //SMC.layers.SingleLayer.prototype.onRemove.call(this, map);

        },

        /**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
        getMap: function() {
            return this._map;
        },

        _draw: function(ctx) {

            var bounds = this._tileBounds(ctx);
            var self = this;

            this.loadTile(bounds).then(function(featuresCollection) {
                console.log(featuresCollection.features);
                self.addTiledGeometryFromFeatures(featuresCollection.features, ctx);
            });
            

        },

        /**
         * Method to add a tiled geometry from a features set
         * @param {object} features - features set to get its geometries
         * @param {object} ctx - function context
         * @param {object} skipTree - variable to skip tree
         */
        addTiledGeometryFromFeatures: function(features, ctx, skipTree) {
            var f;
            if (L.Util.isArray(features)) {
                f = features;
            } else if (arguments.length > 1) {
                f = arguments;
            } else {
                f = [features];
            }



            for (i = 0; i < f.length; i++) {
                var feature = f[i];
                this._setProperties(feature);


                if(feature.geometry.coordinates.length > 0){
                    //We store the retrieved features in a search tree.
                    if (!skipTree) {
                        var treeNode = this._createTreeData(feature, ctx.tile);
                        ctx.canvas.tree.insert(treeNode);
                        this.globalTree.insert(treeNode);

                    }
                }
            }


            if (f.length !== 0) {

                this.renderCanvas(ctx, f, this._map);
            }
            this.tilesLoad++;
            if (this.tilesLoad == this.tilesToLoad) {
                SMC.layers.geometry.CanvasRenderer.prototype.initialize.call(this, this.options);
            }


        },

        _setProperties: function(feature) {
            var id = this.options.idField;
            if (feature.hasOwnProperty(id)) {
                feature.id = feature[id];
            } else {

                for (var propKey in feature) {
                    if (feature[propKey].hasOwnProperty(id)) {
                        feature.id = feature[propKey][id];
                    }
                }

            }


            if (this.features.length == 0) {
                this.features.push(feature);

            } else {
                var sameFeature = false;
                for (var j = 0; j < this.features.length; j++) {
                    if (feature.id == this.features[j].id) {
                        feature.id = this.features[j].id;
                        feature.selected = this.features[j].selected;
                        feature.properties = this.features[j].properties;
                        sameFeature = true;
                        break;
                    }

                }

                if (!sameFeature) {
                    this.features.push(feature);
                }
            }


        },



        _createTreeData: function(feature, tilePoint) {

            var bbox = this._featureBBox(feature);

            return {
                id: feature.properties.id,
                feature: feature,
                minx: bbox.min.x,
                maxx: bbox.max.x,
                miny: bbox.min.y,
                maxy: bbox.max.y,
                tilePoint: tilePoint
            };
            

        },

        _featureBBox: function(feature) {
            var points = [];

            var geom = feature.geometry.coordinates;
            var type = feature.geometry.type;
            switch (type) {
                case 'Point':
                case 'LineString':
                case 'Polygon':
                    points = [geom];
                    break;

                case 'MultiPoint':
                case 'MultiLineString':

                    for (var j = 0; j < geom.length; j++) {
                        points = points.concat(geom[j]);
                    }

                    break;
                case 'MultiPolygon':
                    if (L.Util.isArray(geom[0])) {
                        geom = geom[0];

                    }

                    for (var j = 0; j < geom.length; j++) {
                        points = points.concat(geom[j]);
                    }

                    break;

                default:
                    throw new Error('Unmanaged type: ' + type);
            }


            return L.bounds(points);
        },



        _tileBounds: function(ctx) {
            var nwPoint = ctx.tile.multiplyBy(this.options.tileSize);
            var sePoint = nwPoint.add(new L.Point(this.options.tileSize, this.options.tileSize));

            // optionally, enlarge request area.
            // with this I can draw points with coords outside this tile area,
            // but with part of the graphics actually inside this tile.
            // NOTE: that you should use this option only if you're actually drawing points!
            var buf = this.options.buffer;
            if (buf > 0) {
                var diff = new L.Point(buf, buf);
                nwPoint = nwPoint.subtract(diff);
                sePoint = sePoint.add(diff);
            }

            var nwCoord = this._map.unproject(nwPoint, ctx.zoom, true);
            var seCoord = this._map.unproject(sePoint, ctx.zoom, true);
            return [nwCoord.lng, seCoord.lat, seCoord.lng, nwCoord.lat];
        },

        /**
         * Method to update the style of a feature
         * @param {object} feature - feature to be updated
         */
        updateFeature: function(feature) {

            for (var k = 0; k < this.features.length; k++) {
                if (feature.id == this.features[k].id) {
                    if (feature.selected !== undefined) {
                        this.features[k].selected = feature.selected;
                    }
                    this.features[k].properties = feature.properties;
                    break;
                }
            }

            var bbox = this._featureBBox(feature);

            var intersectingFeatureNodes = this.globalTree.search([bbox.min.x, bbox.min.y, bbox.max.x, bbox.max.y]);


            // we determine the tiles to be redrawn from the features.
            var readdedTileKeys = [];

            for (var i = 0; i < intersectingFeatureNodes.length; i++) {
                var featureTilePoint = intersectingFeatureNodes[i].tilePoint;


                var key = featureTilePoint.x + ":" + featureTilePoint.y;

                if (readdedTileKeys.indexOf(key) < 0) {

                    readdedTileKeys.push(key);
                    var tile = this._tiles[key];
                    if (this._map) { // If we removed the layer we don't want updates.


                        var ctx = {
                            canvas: tile,
                            tile: featureTilePoint,
                            zoom: this._map.getZoom() // fix for https://github.com/CloudMade/Leaflet/pull/993
                        };


                        var tileFeatures = ctx.canvas.tree.search(this._tileBounds(ctx));

                        var updatedFeatures = [];

                        for (var j = 0; j < tileFeatures.length; j++) {
                            var existingFeature = tileFeatures[j].feature;


                            if (existingFeature.id == feature.id) {
                                // We update the data!!!!

                                existingFeature.properties = feature.properties;
                                if (feature.selected != undefined) {
                                    existingFeature.selected = feature.selected;
                                }
                                existingFeature._clean = false;


                            }



                            updatedFeatures.push(existingFeature);

                        }


                        this.renderCanvas(ctx, updatedFeatures, this._map);


                    }

                }
            }


        },

        /**
         * Method to create a request to get features
         * @param {object} bounds - bound limit to request
         * @param {object} ctx - function context
         */
        createRequest: function(bounds, ctx) {
            // override with your code
        }

    }, [SMC.layers.SingleLayer, SMC.layers.geometry.CanvasRenderer]);
},{"../../../lib/canvasLayer/leaflet_canvas_layer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/canvasLayer/leaflet_canvas_layer.js","../../../lib/rbush.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/rbush.js","../SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js","../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js","../stylers/MapCssStyler.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/MapCssStyler.js","./CanvasRenderer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/CanvasRenderer.js","./geometry.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/geometry.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/WFSGeometryLayer.js":[function(require,module,exports){
require("./GeometryLayer.js");
require("../../providers/WFSProvider.js");

/**
 * Base class for layers using a WFS provider to get the features
 *
 * @class
 * @abstract
 * @extends SMC.layers.geometry.GeometryLayer
 * @mixes SMC.providers.WFSProvider
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.geometry.WFSGeometryLayer = SMC.layers.geometry.GeometryLayer.extend(
    /** @lends SMC.layers.geometry.WFSGeometryLayer# */
    {

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            SMC.layers.geometry.GeometryLayer.prototype.initialize.call(this, options);
            SMC.providers.WFSProvider.prototype.initialize.call(this, options);
            L.Util.setOptions(this, options);
            this.setZIndex(1000);
        },

        /**
         * Method to load the features on the map
         * @param {Object} features - Features to be loaded
         */
        onFeaturesLoaded: function(features) {
            this.addGeometryFromFeatures(features);
        },

        /**
         * Method to load the features
         */
        load: function() {
            this.loadFeatures();
        },

        /**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {
            return this.options.label || this.options.typeName;
        }
        
    }, [SMC.providers.WFSProvider]);

/**
 * API factory method for easy creation of wfs geometry layer.
 * @params {Object} options - Options to initialize the WFS 
 */
SMC.wfsGeometryLayer = function(options) {
    return new SMC.layers.geometry.WFSGeometryLayer(options);
};
},{"../../providers/WFSProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSProvider.js","./GeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/GeometryLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/WFSTiledGeometryLayer.js":[function(require,module,exports){
require("./TiledGeometryLayer.js");
require("../../providers/WFSProvider.js");
/**
 * Base class for layers using a WFS provider to get the features
 *
 * @class
 * @abstract
 * @extends SMC.layers.geometry.TiledGeometryLayer
 * @mixes SMC.providers.WFSProvider
 * @param {SMC.layers.geometry.TiledGeometryLayer~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.geometry.WFSTiledGeometryLayer = SMC.layers.geometry.TiledGeometryLayer.extend(
    /** @lends SMC.layers.geometry.WFSTiledGeometryLayer# */
    {

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            SMC.layers.geometry.TiledGeometryLayer.prototype.initialize.call(this, options);
            SMC.providers.WFSProvider.prototype.initialize.call(this, options);
            L.Util.setOptions(this, options);
            this.setZIndex(1000);
        },

        /**
         * Method to load a tile on the map
         * @param {Object} bbox - bounding box of the tile to load
         */
        loadTile: function(bbox){
            return this.doFeaturesLoading(bbox);
        },

        /**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {
            return this.options.label || this.options.typeName;
        }
        
    }, [SMC.providers.WFSProvider]);

/**
 * API factory method for easy creation of wfs tiled geometry layer.
 * @params {Object} options - Options to initialize the WFS tiled 
 */
SMC.wfsTiledGeometryLayer = function(options) {
    return new SMC.layers.geometry.WFSTiledGeometryLayer(options);
};
},{"../../providers/WFSProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSProvider.js","./TiledGeometryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/TiledGeometryLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/geometry/geometry.js":[function(require,module,exports){
require("../layers.js");
/**
 * Namespace of SMC.Viewer's layers displayed using client side geometry rendering .
 * @namespace
 * @memberof SMC.layers
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.geometry = {};
},{"../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/AggregatingHistoryLayer.js":[function(require,module,exports){
require("./history.js");
require("./DataHistoryLayer.js");
/**
 * Class formed by the aggregation of several history layers.
 *
 * @class
 * @extends SMC.aggregation.AggregatingLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.history.AggregatingHistoryLayer = SMC.layers.aggregation.AggregatingLayer.extend(
	/** @lends SMC.layers.history.AggregatingHistoryLayer# */
	{

		options:{
			time: 1000
		},

		 /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
		initialize: function(options) {
			SMC.layers.aggregation.AggregatingLayer.prototype.initialize.apply(this, arguments);
			SMC.layers.history.DataHistoryLayer.prototype.initialize.call(this, arguments);
			
		},

		/**
		 * Adds a sublayer to the layer.
		 * @param {string} layerId - Layer Identifier
		 * @param {SMC.layers} layer - Layer object
		 * @abstract
		 */
		addTimeData: function(time, data){
			throw new Error("Unimplemented method!");
			
		},

		/**
         * Method to load the layer on the map
         */
		load: function(){
			
		},

		 /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
		onAdd: function(map) {	
			SMC.layers.history.DataHistoryLayer.prototype.onAdd.call(this, map);
            SMC.layers.aggregation.AggregatingLayer.prototype.onAdd.call(this, map);
                     
        },

 		/**
         * Method to remove the control in the map
         * @param {SMC.Map} map - Map to be removed
         */
        onRemove: function(map){
        	SMC.layers.history.DataHistoryLayer.prototype.onRemove.call(this, map);
        	SMC.layers.aggregation.AggregatingLayer.prototype.onRemove.call(this, map);
        }

	}, [SMC.layers.history.DataHistoryLayer]);
},{"./DataHistoryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/DataHistoryLayer.js","./history.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/history.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/DataHistoryLayer.js":[function(require,module,exports){
require("./AggregatingHistoryLayer.js");
require("../layers.js");
require("../../LayerLoader.js");

/**
 * Class formed by the aggregation of several history layers.
 *
 * @class
 * @extends SMC.layers.SingleLayer
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.history.DataHistoryLayer = SMC.layers.SingleLayer.extend(
	/** @lends SMC.layers.history.DataHistoryLayer# */
	{
		_historyLayers: {},
		_timer: null,
		_node: null,

		 /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
		initialize: function(options) {
			L.Util.setOptions(this, options);
			L.LayerGroup.prototype.initialize.call(this, options);
			//SMC.layers.SingleLayer.prototype.initialize.apply(this, options);


		},

		/**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
		createNodeHTML: function() {
			this._historyLayers = this._orderLayers();
			var layers = this._historyLayers;

			 var node = document.createElement("div");
            var label = document.createElement('span'),
                input,
                checked = this.getMap().hasLayer(this);

            input = document.createElement('input');
            input.type = 'checkbox';
            input.defaultChecked = checked;
            input.style.cursor = "pointer";
            var name = document.createElement('span');
            name.innerHTML = ' ' + (this.options.label || this.options.typeName);

            label.appendChild(input);
            label.appendChild(name);


            var sliderControl = document.createElement("table");
            sliderControl.style.marginLeft = '10px';
            sliderControl.style.marginTop = '5px';
            sliderControl.className = 'leaflet-bar leaflet-update-interval ';
            sliderControl.style.font = '12px/1.5 "Helvetica Neue", Arial, Helvetica, sans-serif';

            var sliderControlLabel = document.createElement("span");
            sliderControlLabel.style.float = 'left';
            

            var inputInterval = document.createElement('input');
            inputInterval.type = 'range';
            inputInterval.id = "interval_" + this._leaflet_id;
            inputInterval.name = "interval_" + this._leaflet_id;
            inputInterval.min = 0;
            inputInterval.max = Object.keys(layers).length - 1;
            inputInterval.step = 1;
            inputInterval.value = 0;
            //sliderControl.innerHTML += '<input id="interval_' + this._leaflet_id + '" name="interval_' + this._leaflet_id + '" min="0" max="' + (Object.keys(this._featuresForLayer).length - 1) + '" type="range" step="1" value="0"/>';
           

            var time = inputInterval.value;

            var play_pause = document.createElement("i"); 
            play_pause.className = 'fa fa-play';
            play_pause.style.cursor = "pointer";

            this._addTimeData(time);
            this._showLabel(sliderControlLabel);

            var self = this;
            L.DomEvent.addListener(inputInterval, 'mousedown', L.DomEvent.stopPropagation);
            L.DomEvent.addListener(inputInterval, 'change', function() {
                time = inputInterval.value;
                self.showTimeData(time);
                self._showLabel(sliderControlLabel);
                L.DomEvent.stopPropagation;
            });
            L.DomEvent.addListener(inputInterval, 'touchstart', L.DomEvent.stopPropagation);
            L.DomEvent.addListener(inputInterval, 'touchend', L.DomEvent.stopPropagation);

            var tr = document.createElement('tr');
            var td1 = document.createElement('td');
            var td2 = document.createElement('td');
            var td3 = document.createElement('td');
            td1.appendChild(sliderControlLabel);
            td2.appendChild(play_pause);
            td3.appendChild(inputInterval);
            tr.appendChild(td1);
            tr.appendChild(td2);
            tr.appendChild(td3);

            sliderControl.appendChild(tr);
           
            node.appendChild(label);
            node.appendChild(sliderControl);

            play_pause.onclick = function() {
                self._onPlayPause(node, time);
            };
            label.onchange = function(event) {
                self._clickOnLayer(node);
            };
            this._node = node;
            return node;
		},

		_orderLayers: function() {
			var layers;
			var exists = true;
			for (var d in this._aggregatingLayers) {
				var date = this._aggregatingLayers[d].options.date;
				if (!date) {
					exists = false;
					break;
				}
			}

			if (!exists) {
				layers = this._aggregatingLayers;

			} else {

				var layersObj = {};
				var layersArray = [];
				for (var l in this._aggregatingLayers) {
					layersArray.push(this._aggregatingLayers[l]);
				}

				layersArray.sort(function(a, b) {
					return (a.options.date - b.options.date)
				});

				for (var i = 0; i < layersArray.length; i++) {
					if (!layersObj[layersArray[i].options.date]) {
						layersObj[layersArray[i].options.date] = layersArray[i];
					} else {
						layersObj[layersArray[i].options.label] = layersArray[i];
					}
				}
				layers = layersObj;
			}
			return layers;

		},


		 /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
		addTo: function(map) {
			SMC.layers.aggregation.AggregatingLayer.prototype.addTo.call(this, map);
		},

		/**
         * Method to get the map
         * @returns {SMC.Map} map - Map layer
         */
		getMap: function() {
			SMC.layers.aggregation.AggregatingLayer.prototype.getMap.call(this, arguments);
			return map;
		},

		/**
         * Method to show the correct history layer
         * @param {string} time - Value of the slider control
         */
		showTimeData: function(time) {
			var i = 0;
			var data = this._historyLayers;
			if (time % 1 !== 0) {
				time = time - (time % 1);
			}
			for (var d in data) {
				// if (i == time && data[d].actual) {
				// 	break;
				// }
				data[d]._slidermove = true;
				if (data[d].actual) {
					var id = L.stamp(data[d]);
					var input = document.getElementById(id);
					if(input)
						input.checked = false;
					this.getMap().removeLayer(data[d]);
					data[d].actual = false;

				}

				if (i == time) {
					if (!data[d].actual) {
						
						data[d].actual = true;
						if(data[d].lastZoom && (data[d].lastZoom != this.getMap().getZoom())){
							 for(var f in data[d].features){
	                            data[d].features[f]._clean = false;
	                        }
	                    }

						data[d].addTo(this.getMap());
						data[d].lastZoom = this.getMap().getZoom();
						//recalculate canvas position for geometry layers (important)
						if(data[d] instanceof SMC.layers.geometry.GeometryLayer){
							data[d]._resizeCanvas();
						}
					}
				}

				i++;

			}
			

		},

		_addTimeData: function(time) {
			var i = 0;
			var data = this._historyLayers;
			for (var d in data) {

				if (i == time) {
					this.getMap().addLayer(data[d]);
					this._historyLayers[d].actual = true;
				}
				i++;

			}

		},

		_showLabel: function(sliderControlLabel) {
			var data = this._historyLayers;
			for (var d in data) {
				if (data[d].actual) {
					sliderControlLabel.innerHTML = data[d].options.label || data[d].options.typeName;
				}
			}
		},

		_clickOnLayer: function(node) {
			var pause = node.getElementsByClassName('fa fa-pause')[0];
			if (pause) {
				this._onPlayPause(node);
			}
			var data = this._historyLayers;
			if (node.children[1].style.display != 'none') {
				node.children[1].style.display = 'none';
				node.children[0].checked = false;
				for (var d in data) {
					if (data[d].actual) {

						data[d].onRemove(this.getMap());

					}
				}
			} else {
				node.children[1].style.display = 'block';
				node.children[0].checked = true;
				for (var d in data) {
					if (data[d].actual) {
						data[d].onAdd(this.getMap());

					}
				}
			}

		},

		_onPlayPause: function(node, time) {
			var data = this._historyLayers;

           var slider = node.children[1].children[0].children[2].children[0];
           var maxValue = slider.max;
           var sliderControlLabel = node.children[1].children[0].children[0].children[0];
           var play = node.children[1].children[0].children[1].children[0];

            if (play.className == 'fa fa-play') {
                play.className = 'fa fa-pause';
                if (slider.value == maxValue) {
                   slider.value = 0;
                }


                var i = parseFloat(slider.value);
                var self = this;
                this._timer = setInterval(function() {
                    
                    self.showTimeData(i);
                    self._showLabel(sliderControlLabel);
                    if (i < maxValue) {
                        slider.value = i;

                    } else {
                        clearInterval(self._timer);
                        play.className = 'fa fa-play';
                        slider.value = maxValue;

                    }
                    i += parseFloat(slider.step);

                }, this.options.time);

            } else {

                play.className = 'fa fa-play';
                clearInterval(this._timer);
            }
		},

		 /**
         * Method to remove the control in the map
         * @param {SMC.Map} map - Map to be removed
         */
		onRemove: function(map) {
			var data = this._historyLayers;
			for (var d in data) {
				if (data[d].actual) {
					data[d]._slidermove = false;
					data[d].onRemove(map);

				}

			}

		},

 		/**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
		onAdd: function(map) {
			SMC.layers.aggregation.AggregatingLayer.prototype.addTo.call(this, map);
			var value;
			if (this._node != null) {
				value = this._node.children[1].children[0].value;
			} else
				value = 0;

			var data = this._historyLayers;
			for (var d in data) {
				if (data[d].actual) {
					data[d]._slidermove = false;
					data[d].onAdd(map);


				}
			}

		

		}



	});
},{"../../LayerLoader.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/LayerLoader.js","../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js","./AggregatingHistoryLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/AggregatingHistoryLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/history/history.js":[function(require,module,exports){
/**
 * Namespace for agreggating layers, e.g., layers that are the result of the composition
 * of several other layers.
 *
 * @namespace
 * @memberof SMC.layers
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.history = {};
},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js":[function(require,module,exports){
require("../SMC.js");
require("../Map.js");
/**
 * Namespace for layers using SMC's viewer infrasctructure.
 * @namespace
 * @memberof SMC
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers = {};
},{"../Map.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/Map.js","../SMC.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/AtmosphereRTMarkerLayer.js":[function(require,module,exports){
require("./markers.js");
require("./MarkerLayer.js");
require("../../providers/AtmosphereRTFeatureProvider.js");


/**
 * Marker layer able to retrieve and update its markers from an Atmosphere
 * real time source.
 * @class
 * @extends SMC.layers.markers.MarkerLayer
 * @mixes SMC.providers.AtmosphereRTFeatureProvider
 *
 * @author Luis Román (marcos@emergya.com)
 */
SMC.layers.markers.AtmosphereRTMarkerLayer = SMC.layers.markers.MarkerLayer.extend(
    /** @lends SMC.layers.markers.AtmosphereRTMarkerLayer# */
    {

        _markersMap: {},

        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.layers.markers.MarkerLayer.prototype.initialize.call(this, options);
            SMC.providers.AtmosphereRTFeatureProvider.prototype.initialize.call(this, options);
        },

        /**
         * Method to load the features into marker layer
         * @param {object} features - features to be loaded
         */
        onFeaturesLoaded: function(features) {
            this.addMarkerFromFeature(features);
        },

        /**
         * Method to remove the features from the map
         * @param {object} features - features to be deleted
         */
        onFeaturesDeleted: function(features) {
            for (var i = 0; i < features.length; i++) {
                var feature = features[i];
                var featureId = feature[this.options.featureId];
                var layer = this._markersMap[featureId];
                this.removeLayer(layer);

                delete this._markersMap[featureId];
            }
        },

        /**
         * Method to set the features from the map
         * @param {object} features - features to be updated
         */
        onFeaturesModified: function(features) {
            this.onFeaturesDeleted(features);
            this.onFeaturesLoaded(features);
        },

        /**
         * Retrieves the features from its source.
         */
        load: function() {
            this.loadFeatures();
        },

        /**
         * Method to load the features from the map
         * @returns {object} Deferred object from jQuery
         */
        doFeaturesLoading: function() {
            return $.Deferred();
        },


    }, [SMC.providers.AtmosphereRTFeatureProvider]);
/**
 * API factory method for ease creation of atmosphere powered realtime marker layers.
 * @param {Object} options - Options for the marker layer and Atmosphere provider.
 */
SMC.atmosphereRTMarkerLayer = function(options) {
    return new SMC.layers.markers.AtmosphereRTMarkerLayer(options);
};

},{"../../providers/AtmosphereRTFeatureProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/AtmosphereRTFeatureProvider.js","./MarkerLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/MarkerLayer.js","./markers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/markers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/MarkerLayer.js":[function(require,module,exports){
require("./markers.js");
require("../SingleLayer.js");
require("../stylers/MarkerCssStyler.js");

require("../../../lib/leaflet.markercluster/dist/leaflet.markercluster-src.js");
require("../../../lib/LeafletHtmlIcon.js");


/**
 * Base layer for all SMC map viewer's layers rendered using markers.
 * @class
 * @abstract
 * @mixes SMC.layers.SingleLayer
 * @mixes SMC.layers.stylers.MarkerCssStyler
 */
SMC.layers.markers.MarkerLayer = L.FeatureGroup.extend(
    /** @lends SMC.layers.markers.MarkerLayer# */
    {

        _markersMap: {},

        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            this.clusterGroup = new L.MarkerClusterGroup({
                polygonOptions: {
                    fill: false,
                    stroke: false
                }
            });

            this.noClusterGroup = new L.FeatureGroup();
            SMC.layers.stylers.MarkerCssStyler.prototype.initialize.apply(this, arguments);
            SMC.layers.SingleLayer.prototype.initialize.apply(this, arguments);
        },

        /**
         * Method to remove a layer from the map
         * @param {SMC.Layers.Layer} layer - layer to be removed
         */
        removeLayer: function(layer) {
            if (this.clusterGroup.hasLayer(layer)) {
                this.clusterGroup.removeLayer(layer);
            } else if (this.noClusterGroup.hasLayer(layer)) {
                this.noClusterGroup.removeLayer(layer);
            } else {
                this.getMap().removeLayer(layer);
            }

        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onAdd: function(map) {

            this._cleanMarkers(map);
            SMC.layers.SingleLayer.prototype.onAdd.call(this, map);
            L.FeatureGroup.prototype.onAdd.call(this, map);
           
            map.addLayer(this.noClusterGroup);
            map.addLayer(this.clusterGroup);

            if (map) {
                map.on("zoomend", this._onViewChanged, this);
            }
        },

        /**
         * Method to remove the control in the map
         * @param {SMC.Map} map - Map to be removed
         */
        onRemove: function(map) {
            this._cleanMarkers(map);
        },

        _cleanMarkers: function (map) {
            if (this._slidermove) {
                this.noClusterGroup._slidermove = true;
                this.clusterGroup._slidermove = true;
            }
            var self = this;

            var clusterGroup = this.clusterGroup.getLayers();
            $.each(clusterGroup, function(index, marker) {
                marker.parent = self;
            });
            this.clusterGroup.clearLayers();
            map.removeLayer(this.clusterGroup);


            var noClusterGroup = this.noClusterGroup.getLayers();
            $.each(noClusterGroup, function(index, marker) {
                marker.parent = self;
            });
            this.noClusterGroup.clearLayers();
            map.removeLayer(this.noClusterGroup);

            L.FeatureGroup.prototype.onRemove.call(this, map);

            if (map) {
                map.off("zoomend", this._onViewChanged, this);
            }
        },

        /**
         * Method to add layer on the map
         * @param {SMC.layers.Layer} layer - layer to be added
         */
        addLayer: function(layer) {

            if (layer instanceof L.Marker) {
                var marker = layer;
                this._applyStyles(marker);

                marker.on("click", function() {
                    this.onFeatureClicked(marker);
                }, this);

                return marker;

            } else
                throw new Error("This is not a marker");

        },

        _sendFeatures: function(features) {
            var self = this;
            $.each(features, function(index, feature) {
                self._addMarker(feature);
            });
        },

        /**
         * Method to load markers from fetaures on the map
         * @param {object} features - features to be added
         */
        addMarkerFromFeature: function(features) {
            if (L.Util.isArray(features)) {
                features = features;
            } else if (arguments.length > 1) {
                features = arguments;
            } else {
                features = [features];
            }

           
            for (var i = 0; i < features.length; i++) {
                this._setProperties(features[i]);
            }

            this._sendFeatures(features);
        },

        _setProperties: function(feature) {
            var id = this.options.idField;
            if (feature.hasOwnProperty(id))
                feature.id = feature[id];
            else {

                for (var propKey in feature) {
                    if (feature[propKey].hasOwnProperty(id)) {
                        feature.id = feature[propKey][id];
                    }
                }

            }
        },

        _addMarker: function(f) {

            if (!f.geometry || !f.geometry) {
                console.debug("Received no Feature object");
                return;
            }

            // For GeoJSON standar the first coordinate is the longitude
            // Documentation http://geojson.org/geojson-spec.html#positions
            var markerLocation;

            var geometry = f.geometry;
            var coordinates = geometry.coordinates;
            if(geometry.type==="MultiPoint") {
                coordinates = coordinates[0];
            }

            if (L.Util.isArray(coordinates)) {
                markerLocation = new L.LatLng(coordinates[1], coordinates[0]);
            } else {
                markerLocation = new L.LatLng(coordinates.latitude, coordinates.longitude);
            }

            var marker = new L.Marker(markerLocation);
            // We store this here so is avalaible later, on restylings because of zoom changes.
            marker.feature = f;

            var featureId = f[this.options.idField];
            this._markersMap[featureId] = marker;

            this.addLayer(marker);
        },

        /**
         * Method to run wjen a feature has been clicked
         * @param {object} feature - feature clicked
         */
        onFeatureClicked: function(feature) {
            this.fireEvent("featureClick", feature);
            //alert(feature.properties.name);
        },

        _applyStyles: function(marker, inCluster) {
            if (!marker.feature) {
                this.noClusterGroup.addLayer(marker);
                return;
            }

            var zoom;
            try {
              zoom = this.getMap().getZoom();  
            } catch(e) {
                return;
            }
            var style = this.applyStyle(marker.feature, zoom);
            if (style.icon) {
                marker.setIcon(style.icon);
            }
            if (style.opacity) {
                marker.setOpacity(style.opacity);
            }

            if (inCluster) {
                this.clusterGroup.removeLayer(marker);
            } else {
                this.noClusterGroup.removeLayer(marker);
            }



            if (style.disableClustering) {
                this.noClusterGroup.addLayer(marker);
            } else {
                this.clusterGroup.addLayer(marker);
            }


            this.addPopUp(marker, zoom);
        },

        _onViewChanged: function() {
            var markersCluster = this.clusterGroup.getLayers();
            var markersNoCluster = this.noClusterGroup.getLayers();

            // Recorrer cluster
            var i, marker;
            for (i = 0; i < markersCluster.length; i++) {
                marker = markersCluster[i];
                if (this.clusterGroup) {
                    if (this._slidermove) {
                        marker._slidermove = true;
                    }
                    this._applyStyles(marker, true);
                }
            }

            for (i = 0; i < markersNoCluster.length; i++) {
                marker = markersNoCluster[i];
                if (this.noClusterGroup) {
                    if (this._slidermove) {
                        marker._slidermove = true;
                    }
                    this._applyStyles(marker, false);
                }

            }
        },

        /**
         * Method to unload the layer on the map
         */
        unload: function() {
            if (this.noClusterGroup) {
                this.noClusterGroup.clearLayers();
            }

            if (this.clusterGroup) {
                this.clusterGroup.clearLayers();
            }
        }



    }, [SMC.layers.SingleLayer, SMC.layers.stylers.MarkerCssStyler]);

},{"../../../lib/LeafletHtmlIcon.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/LeafletHtmlIcon.js","../../../lib/leaflet.markercluster/dist/leaflet.markercluster-src.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet.markercluster/dist/leaflet.markercluster-src.js","../SingleLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/SingleLayer.js","../stylers/MarkerCssStyler.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/MarkerCssStyler.js","./markers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/markers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/WFSMarkerLayer.js":[function(require,module,exports){
require("./MarkerLayer.js");
require("../../providers/WFSProvider.js");
require("../EditableLayer.js");

/**
 * Layer for all SMC map viewer's WFS layers rendered using markers.
 * @class
 * @extends SMC.layers.markers.MarkerLayer
 * @mixes SMC.providers.WFSProvider
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.layers.markers.WFSMarkerLayer = SMC.layers.markers.MarkerLayer.extend(
    /** @lends SMC.layers.markers.WFSMarkerLayer# */
    {

         /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            SMC.layers.markers.MarkerLayer.prototype.initialize.call(this, options);
            SMC.providers.WFSProvider.prototype.initialize.call(this, options);
        },

        /**
         * Method to load the features into marker layer
         * @param {Object} features - Features to be loaded
         */
        onFeaturesLoaded: function(features) {
            this.addMarkerFromFeature(features);
        },

        /**
         * Retrieves the features from its source.
         */
        load: function() {
            this.loadFeatures();
        },

        /**
         * Method to create an HTML node for the name of the layer.
         * @returns {String} HTML code representing the code to be added to the layer's entry in the layer tree.
         */
        createNodeHTML: function() {
            return this.options.label || this.options.typeName;
        }

    }, [SMC.providers.WFSProvider]);
/**
 * API factory method for ease creation of wfs features providers.
 * @param {Object} options - Options for wfs the provider.
 */
SMC.wfsMarkerLayer = function(options) {
    return new SMC.layers.markers.WFSMarkerLayer(options);
};

},{"../../providers/WFSProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSProvider.js","../EditableLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/EditableLayer.js","./MarkerLayer.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/MarkerLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/WFSTMarkerLayer.js":[function(require,module,exports){
require("./MarkerLayer");
require("../../providers/WFSTProvider.js");
require("../EditableLayer");
require("../../../lib/leaflet.draw/dist/leaflet.draw-src.js");
var editable_layers = [];

/**
 * Layer for all SMC map viewer's WFS-T layers rendered using markers.
 * @class
 * @extends SMC.layers.markers.MarkerLayer
 * @mixes SMC.providers.WFSTProvider
 * @mixes SMC.layers.EditableLayer
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.layers.markers.WFSTMarkerLayer = SMC.layers.markers.MarkerLayer.extend(
    /** @lends SMC.layers.markers.WFSTMarkerLayer# */
    {
        featuresEdited: new L.LayerGroup(),

        /**
         * Initialize the object with the params
         * @param {object} options - object with need parameters
         */
        initialize: function(options) {
            SMC.layers.markers.MarkerLayer.prototype.initialize.call(this, options);
            SMC.providers.WFSTProvider.prototype.initialize.call(this, options);
            SMC.layers.EditableLayer.prototype.initialize.call(this, options);
        },

        /**
         * Method to load the features into marker layer
         * @param {Object} features - Features to be loaded
         */
        onFeaturesLoaded: function(features) {
            this.addMarkerFromFeature(features);
        },

        /**
         * Retrieves the features from its source.
         */
        load: function() {
            this.loadFeatures();
        },

        /**
         * Method to load the control in the map
         * @param {SMC.Map} map - Map to be added
         */
        onAdd: function(map) {
            editable_layers.push(this);
            SMC.layers.EditableLayer.prototype.onAdd.call(this, map);
            SMC.layers.markers.MarkerLayer.prototype.onAdd.call(this, map);
            this._setButtonState(this);
        },
        /**
         * Method to remove the control in the map
         * @param {SMC.Map} map - Map to be removed
         */
        onRemove: function(map) {
            this._editing = false;
            this._finishEditControl(this.options);

            var index = this._getIndexFromEditableLayer(this);
            if (index > -1) {
                editable_layers.splice(index, 1);
            }
            SMC.layers.EditableLayer.prototype.onRemove.call(this, map);
            SMC.layers.markers.MarkerLayer.prototype.onRemove.call(this, map);

        },

        _setButtonState: function(layer){
            var editing;
            for (var i = 0; i < editable_layers.length; i++) {
                if(editable_layers[i]._editing){
                   editing = true;
                }
            }
            var label = layer.options.label;
            var layer_div = $("[id='" + label + "']")[0];
            var buttons = $("input[type=button]", layer_div);
            for (j = 0; j < buttons.length; j++) {
                if(editing){
                    buttons[j].disabled = true;
                }else{
                    buttons[j].disabled = false;
                }
            }
           
                   
        },

        _setButtonText: function(){
            var label = this.options.label;
            var layer_div = $("[id='" + label + "']")[0];
            var buttons = $("input[type=button]", layer_div);
            buttons[0].setAttribute("value",
                    this._editing ? this.options.confirmButtonLabel : this.options.editButtonLabel);
        },


        /**
         * Method to add edit control to map
         * @private
         * @param {Object} options - Event to handler
         */
        _startEditControl: function(options) {
            if (this._map && !this._drawControl) {
                for (var i = 0; i < editable_layers.length; i++) {
                    if (editable_layers[i]._leaflet_id != this._leaflet_id) {
                        var label = editable_layers[i].options.label;
                        var layer_div = $("[id='" + label + "']")[0];
                        var buttons = $("input[type=button]", layer_div);
                        var check = $("input[type=checkbox][id=" + editable_layers[i]._leaflet_id + "]")[0];
                        for (j = 0; j < buttons.length; j++) {
                            if (check.checked && !buttons[j].disabled) {
                                buttons[j].disabled = true;
                            }
                        }
                    }
                }
                var self = this;
                // Initialise the draw control and pass it the FeatureGroup of editable layers
                this._drawControl = new L.Control.Draw({
                    draw: {
                        polyline: false,
                        polygon: false,
                        rectangle: false,
                        circle: false,
                        isochrone: false
                    },
                    edit: {
                        featureGroup: this.noClusterGroup
                    }
                });
                this._map.addControl(this._drawControl);
                // Marker created
                this._map.on('draw:created', function(e) {
                    var layer = e.layer;
                    self.removeLayer(e.layer);
                    // Update the added features
                    self._insert(layer);
                    



                });
                // Marker edited
                this._map.on('draw:edited', function(e) {
                    var layers = e.layers;
                    // Update the edited features
                    if (!$.isEmptyObject(layers._layers)) {
                        self._update(layers);
                    }
                });

                //Marker attributes edited
                this._map.on('editAttributes', function(e) {
                    var layer = e.layer;
                    layer.closePopup();
                    //Open attributes edition popup
                    var content = self._setAttrEditor(layer);
                    layer.bindPopup(content).openPopup();


                });

                //Save marker attributes edited
                this._map.on('draw:editedData', function(e) {
                    var layers = self.featuresEdited;

                    // Update the edited features
                    layers.save = true;
                    if (!$.isEmptyObject(layers._layers)) {
                        self._update(layers);
                    }

                    //Update properties of changed layers
                    for (var i in layers._layers) {
                        layers._layers[i].propertiesInicial = layers._layers[i].feature.properties;
                    }


                });

                this._map.on('draw:editDatastop', function() {
                    var layers = self.featuresEdited;
                    if (!$.isEmptyObject(layers._layers)){
                        if (!layers.save) {
                            for (var i in layers._layers) {
                                var f = layers._layers[i].feature;
                                var propIni = layers._layers[i].propertiesInicial;
                                if (propIni) {
                                    for (var j in f.properties) {
                                        f.properties[j] = propIni[j];
                                    }
                                }
                            }
                        }
                        layers.save = false;
                        for (var i in layers._layers) {
                            layers._layers[i].closePopup();
                            self._applyStyles(layers._layers[i], false);
                        }
                    }
                });
                // Marker removed
                this._map.on('draw:deleted', function(e) {
                    var layers = e.layers;
                    // Remove the deleted features
                    self._delete(layers);
                });
            }
        },

        /**
         * Method to add edit control to map
         * @private
         * @param {Object} options - Event to handler
         */
        _finishEditControl: function(options) {
            if (this._drawControl) {
                for (var i = 0; i < editable_layers.length; i++) {
                    editable_layers[i].featuresEdited.clearLayers();
                    if (editable_layers[i]._leaflet_id != this._leaflet_id) {
                        var label = editable_layers[i].options.label;
                        var layer_div = $("[id='" + label + "']")[0];
                        var buttons = $("input[type=button]", layer_div);
                        var check = $("input[type=checkbox][id=" + editable_layers[i]._leaflet_id + "]")[0];
                        for (j = 0; j < buttons.length; j++) {
                            if (check.checked) {
                                if (buttons[j].disabled) {
                                    buttons[j].disabled = false;   
                                }
                            }
                        }
                    }
                    else{
                        var label = this.options.label;
                        var layer_div = $("[id='" + label + "']")[0];
                        var buttons = $("input[type=button]", layer_div);
                        for (j = 0; j < buttons.length; j++) {
                            buttons[j].setAttribute("value", this.options.editButtonLabel);
                        }
                        
                    }
                }
                this._map.removeControl(this._drawControl);
                this._drawControl = null;
                this._map.off('draw:created');
                this._map.off('draw:deleted');
             
            }
        },

       

        _setAttrEditor: function(layer) {
            var self = this;
            var content = document.createElement('div');
            var header = document.createElement('div');
            header.innerHTML = layer.feature.id;
            header.style.borderBottom = '1px #000 solid';
            header.style.fontWeight = 'bold';
            content.appendChild(header);

            var table = document.createElement('table');  
            var prop = layer.feature.properties;
            var noEditables = this._getNotEditables();
            for (var i in prop) {
                var noNull = false;
                var value = prop[i];
                if (value == null) {
                    value = '';
                }
                for (var j = 0; j < noEditables.length; j++) {
                    if (i == noEditables[j]) {
                        noNull = true;
                    }
                }



                var row = document.createElement('tr');
                var td = document.createElement("td");
                td.style.fontSize = "10pt";
                td.innerHTML = i + ": ";
                row.appendChild(td);
                var rowInput = document.createElement('input');
                if (noNull) {
                    rowInput.disabled = true;
                }
                rowInput.type = 'text';
                rowInput.value = value;
                rowInput.style.width = '120px';
                rowInput.style.float = 'right';
                rowInput.className = 'attributes';
                td = document.createElement("td");
                td.appendChild(rowInput);
                row.appendChild(td);
                table.appendChild(row);
            }

            content.appendChild(table);

            var buttons = document.createElement('center');
            var save = document.createElement('input');
            save.type = 'button';
            save.value = 'Save edition';
            save.onclick = function() {

                self._save(layer, content);
            }
            buttons.appendChild(save);
            var cancel = document.createElement('input');
            cancel.type = 'button';
            cancel.value = 'Cancel';
            cancel.onclick = function() {
                layer.closePopup();

            }
            buttons.appendChild(cancel);
            content.appendChild(buttons);
            this.featuresEdited.addLayer(layer);

            return content;

        },

        _getNotEditables: function() {
            var noEditables = this.options.readOnlyFields;
            var _this = this;
            $.ajax({
                type: "GET",
                url: this.options.serverURL + "?request=DescribeFeatureType&version=1.1.0&typename=" +
                    this.options.typeName,
                dataType: "xml",
                contentType: "text/xml",
                async: false,
                success: function(xml, status, object) {
                    var attributes = _this._getElementsByTagNameNS(_this._getElementsByTagNameNS(xml,'xsd', 'sequence')[0], 'xsd', 'element');
                    
                    for (var i = 0; i < attributes.length; i++) {
                        if (attributes[i].getAttribute('nillable') == "false") {
                            noEditables.push(attributes[i].getAttribute('name'));
                        }
                    }
                }
            });
            return noEditables;
        },

        _save: function(layer, content) {
            var prop = layer.feature.properties;
            var propInitial = {};
            var attributes = content.getElementsByClassName('attributes');
            var i = 0;
            for (var j in prop) {
                propInitial[j] = prop[j];
                prop[j] = attributes[i].value;
                i++;
            }
            layer.propertiesInicial = propInitial;

            layer.closePopup();

        },

        _applyStyles: function(marker, inCluster) {
            if (!marker.feature) {
                this.noClusterGroup.addLayer(marker);
                return;
            }

            // var zoom = this._map.getZoom();
            if (!zoom) {
                var zoom = this.getMap().getZoom();
            }
            var style = this.applyStyle(marker.feature, zoom);
            if (style.icon) {
                marker.setIcon(style.icon);
            }
            if (style.opacity) {
                marker.setOpacity(style.opacity);
            }
            this.noClusterGroup.removeLayer(marker);
            this.noClusterGroup.addLayer(marker);

            this.addPopUp(marker, zoom);
        },
        _getIndexFromEditableLayer: function(layer) {
            var index = -1;
            for (var i = 0; i < editable_layers.length; i++) {
                if (editable_layers[i]._leaflet_id == layer._leaflet_id) {
                    index = i;
                    break;
                }
            }
            return index;
        },
    }, [SMC.layers.EditableLayer, SMC.providers.WFSTProvider]);

/**
 * API factory method for ease creation of wfs features providers.
 * @param {Object} options - Options for wfs the provider.
 */
SMC.wfstMarkerLayer = function(options) {
    return new SMC.layers.markers.WFSTMarkerLayer(options);
};

},{"../../../lib/leaflet.draw/dist/leaflet.draw-src.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/leaflet.draw/dist/leaflet.draw-src.js","../../providers/WFSTProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSTProvider.js","../EditableLayer":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/EditableLayer.js","./MarkerLayer":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/MarkerLayer.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/markers/markers.js":[function(require,module,exports){
require("../layers.js");
/**
 * Namespace of SMC.Viewer's layers displayed using markers in the map. 
 * @namespace
 * @memberof SMC.layers
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.markers = {};
},{"../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/AtmosphereRTReloadTrigger.js":[function(require,module,exports){
require("./reloaders.js");
require("./ReloadTrigger.js");
require("../../providers/AtmosphereConnector.js");
require("../../../lib/atmosphere-jquery/jquery.atmosphere.js");

/**
 * Implementation of a SMC viewer's layer reload trigger using Atmosphere pub/sub javascript client, so we reload layers
 * when a notification is received.
 *
 * @class
 * @extends SMC.layers.reloaders.ReloadTrigger
 * @mixes SMC.providers.AtmosphereConnector
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.reloaders.AtmosphereRTReloadTrigger = SMC.layers.reloaders.ReloadTrigger.extend(
    /** @lends SMC.layers.reloaders.TimerReloadTrigger# */
    {

        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.layers.reloaders.ReloadTrigger.prototype.initialize.call(this, options);
            SMC.providers.AtmosphereConnector.prototype.initialize.call(this, options);
            L.Util.setOptions(this, options);
        },

        /**
         * Implementation of the initTrigger method using setTimeout.
         */
        initTrigger: function() {
            this._createSubscription();
        },

        _onMessage: function(response) {
            console.debug(response);
            this._notifyReload();
        }

    }, [SMC.providers.AtmosphereConnector]);

},{"../../../lib/atmosphere-jquery/jquery.atmosphere.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/atmosphere-jquery/jquery.atmosphere.js","../../providers/AtmosphereConnector.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/AtmosphereConnector.js","./ReloadTrigger.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/ReloadTrigger.js","./reloaders.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/reloaders.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/LayerReloader.js":[function(require,module,exports){
require("./reloaders.js");

/**
 * Layer reloader. Allows setting triggers so a layer's data can be re-retrieved from its original data.
 *
 * Intended for being mixed in into a SMC.layer.SingleLayer.
 *
 * @class
 * @extends L.Class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.reloaders.LayerReloader = L.Class.extend(
    /** @lends SMC.layers.reloaders.LayerReloader# */
    {
        _triggers: [],

        initialize: function(options) {
            if (options.reloadTriggers && options.reloadTriggers.length > 0) {
                for (var i = 0; i < options.reloadTriggers.length; i++) {
                    var trigger = options.reloadTriggers[i];
                    this.addReloadTrigger(trigger);
                }
            }
        },

        /**
         * Load a layer's data
         * @abstract
         */
        load: function() {
            throw new Error("SMC.layers.reloaders.LayerReloader::load method must be implemented by an inheriting class");
        },

        /**
         * Unload a layer's data
         * @abstract
         */
        unload: function() {
            throw new Error("SMC.layers.reloaders.LayerReloader::unload method must be implemented by an inheriting class");
        },

        /**
         * Method to reload the trigger
         * @param {object} trigger - trigger to reload the control
         */
        addReloadTrigger: function(trigger) {
            if (typeof trigger.type !== "undefined") {
                trigger = this._createTriggerFromConfig(trigger);
            }

            this._triggers.push(trigger);
            trigger.on("reloadTriggered", this._onReloadTriggered, this);
            trigger.initTrigger();
        },

        _createTriggerFromConfig: function(triggerConfig) {
            if (!triggerConfig.type || typeof triggerConfig.type !== "string") {
                throw new Error("SMC.layers.reloaders.LayerReloader::_createTriggerFromConfig: triggerConfig must include a type field (string)");
            }

            var triggerClass = SMC.Util.getClass(triggerConfig.type);

            var triggerConstructor = SMC.Util.getConstructor(triggerClass);

            return triggerConstructor(triggerConfig.params);
        },

        _onReloadTriggered: function() {
            // Reloads the layer.
            this.unload();
            this.load();
        }
    });

},{"./reloaders.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/reloaders.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/ReloadTrigger.js":[function(require,module,exports){
require("./reloaders.js");

/**
 * Base class for SMC viewer's layer reloader triggers.
 *
 * @class
 * @abstract
 * @extends L.Class
 * @mixes L.Mixin.Events
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.reloaders.ReloadTrigger = L.Class.extend(
	/** @lends SMC.layers.reloaders.ReloadTrigger# */
	{
		includes: [L.Mixin.Events],


		initialize: function() {

		},


		/**
		 * Initializes the trigger so it will monitor for the need of a reload.
		 *
		 * @abstract
		 */
		initTrigger: function() {
			throw new Error("ReloadTrigger::initTrigger: classes extending ReloadTrigger must implement this method.");
		},

		/**
		 * Helper method to hide the launching of the event from implementing classes.
		 *
		 * @protected
		 * @fires SMC.layers.reloaders.ReloadTrigger#reloadTriggered
		 */
		_notifyReload: function() {
			/**
			 * Layer reload event. SMC.layers.reloaders.LayerReloader will listen for this event and then reload the layer.
			 *
			 * @event SMC.layers.reloaders.ReloadTrigger#reloadTriggered
			 */
			this.fire("reloadTriggered");
		}

	});

},{"./reloaders.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/reloaders.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/TimerReloadTrigger.js":[function(require,module,exports){
require("./ReloadTrigger.js");

/**
 * Implementation of a SMC viewer's layer reload trigger using calls to JavaScript's setTimeout function.
 *
 * @class
 * @extends SMC.layers.reloaders.ReloadTrigger
 * @param {SMC.layers.reloaders.TimerReloadTrigger~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.reloaders.TimerReloadTrigger = SMC.layers.reloaders.ReloadTrigger.extend(
	/** @lends SMC.layers.reloaders.TimerReloadTrigger# */
	{
		/**
		 * @typedef {Object} SMC.layers.reloaders.TimerReloadTrigger~options
		 * @property {int} triggerDelay=5000 - The delay beetween a reload is triggered
		 */
		options: {
			triggerDelay: 5000
		},

		/**
		 * Initialize the object with the params
		 * @param {object} options - default options
		 */
		initialize: function(options) {
			L.Util.setOptions(this, options);
		},

		/**
		 * Implementation of the initTrigger method using setTimeout.
		 */
		initTrigger: function() {
			var self = this;
			setTimeout(function() {
				self._notifyReload();

				// We start the process again.
				self.initTrigger();
			}, this.options.triggerDelay);
		}

	});

},{"./ReloadTrigger.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/ReloadTrigger.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/reloaders/reloaders.js":[function(require,module,exports){
require("../layers.js");

/**
 * Namespace for layer reloaders for  SMC Viewer's layers.
 * @namespace
 * @memberof SMC.layers
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.reloaders = {};
},{"../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/MapCssStyler.js":[function(require,module,exports){
require("./Styler.js");


/**
 * MapCSS styles parser, for user with SMC Viewer's geometry layers.
 *
 * @class
 * @extends SMC.layers.stylers.Styler
 * @mixin SMC.layers.stylers.MapCssStyler
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.stylers.MapCssStyler = SMC.layers.stylers.Styler.extend(
    /** @lends SMC.layers.stylers.MapCssStyler# */
    {
        /**
         * @property {Array} labels - The labels array
         * @default null
         */
        labels: [],
        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            this._parser_url = SMC.BASE_URL + "resources/parser.txt";
            SMC.layers.stylers.Styler.prototype.initialize.apply(this, arguments);
        },

        /**
         * Adds style properties to the received features, so the can be represented as intended by the style for the layer.
         * @param {object} feature - An object that represents the geometry element being styled.
         * @param {object} ctx - An object that represents the context function.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         * @returns {object} style - Style from the feature
         */
        applyStyle: function(feature, ctx, zoom) {

            var style = this._createStyles(feature, zoom);
            if (!style)
                style = "";

            var path;
            if (feature.geometry.type == 'Point' || feature.geometry.type == 'MultiPoint') {
                switch (style.symbol) {
                    case 'Circle':
                        path = new ctx.canvas._paper.Path.Circle({
                            radius: style.radius || 3
                        });
                        break;

                    case 'Rectangle':
                        path = new ctx.canvas._paper.Path.Rectangle({
                            size: style.size || [10, 10]
                        });
                        break;

                    case 'Ellipse':
                        path = new ctx.canvas._paper.Path.Ellipse({
                            size: style.size || [10, 8]
                        });
                        break;

                    case 'RegularPolygon':
                        path = new ctx.canvas._paper.Path.RegularPolygon({
                            sides: style.sides || 3,
                            radius: style.radius || 5
                        });
                        break;

                    case 'Star':
                        path = new ctx.canvas._paper.Path.Star({
                            points: style.points || 5,
                            radius1: style.radius1 || 3,
                            radius2: style.radius2 || 5
                        });
                        break;
                    default:
                        path = new ctx.canvas._paper.Path.Circle({
                            radius: 3
                        });
                        break;

                }


            }


             var pathStyle = {
                strokeColor: style.strokeColor || style.fillColor || "black",
                strokeWidth: style.strokeWidth || 2,
                strokeJoin: style.strokeJoin || 'miter',
                dashArray: style.dashArray || [],
                strokeCap: style.strokeCap || 'butt',
                dashOffset: style.dashOffset || 0,
                miterLimit: style.miterLimit || 10,
                windingRule: style.windingRule || 'nonzero',
                selectedColor: style.selectedColor || 'aqua',
                shadowColor: style.shadowColor || 'black',
                shadowBlur: style.shadowBlur || 0,
                shadowOffset: style.shadowOffset || []

            };


            if (feature.geometry.type == 'LineString' || feature.geometry.type == 'MultiLineString') {
                pathStyle.strokeColor = style.strokeColor || "black";
                 pathStyle.fillColor = null;
            } else {
                pathStyle.fillColor = style.fillColor || 'rgba(0,0,0,0)'
            }

            var opacity = style.opacity ? style.opacity : 1;
            var offset = style.offset ? style.offset : 0;
            var zIndex = style.zIndex ? style.zIndex : 0;
            var visible = !style.invisible ? true : false;
            var popUpStyle = {
              popUpTemplate: style.popUpTemplate,
              popUpUrl: style.popUpUrl,
              noPopUp: style.noPopUp,
              offsetLeft: style.popUpOffsetLeft,
              offsetTop: style.popUpOffsetTop
            }

            feature._styles = {
                popUpStyle: popUpStyle,
                pathStyle: pathStyle,
                opacity: opacity,
                path: path,
                offset: offset,
                zIndex: zIndex,
                visible: visible
            };
            return feature._styles;
        },

        /**
         * Adds style label to the received features, so the can be represented as intended by the style for the layer.
         * @param {object} feature - An object that represents the geometry element being styled.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         * @returns {object} style - Style from the label feature
         */
        addLabelStyle: function(feature, zoom) {

            var labelStyle = this._createLabel(feature, zoom);


            var content;
            if (labelStyle.content) {
                if (labelStyle.uniqueLabel) {

                    if (!this.labels.length) {
                        this.labels.push(labelStyle.content);
                        content = labelStyle.content;
                    } else {
                        var i = 0;
                        var exists = false;
                        while ((i < this.labels.length) && !exists) {
                            if (labelStyle.content == this.labels[i]) {
                                exists = true;
                            }
                            i++;
                        }
                        if (!exists) {
                            this.labels.push(labelStyle.content);
                            content = labelStyle.content;
                        }
                    }


                } else
                    content = labelStyle.content;
            }

            var style = {
                defaultPopUp: true,
                fillColor: labelStyle.fillColor || 'black',
                fontFamily: labelStyle.fontFamily || 'sans-serif',
                fontWeight: labelStyle.fontWeight || 'normal',
                fontSize: labelStyle.fontSize || 10,
                leading: labelStyle.leading || labelStyle.fontSize * 1.2,
                shadowColor: labelStyle.shadowColor || 'black',
                shadowBlur: labelStyle.shadowBlur || 0,
                shadowOffset: labelStyle.shadowOffset || []
            };

            return {
                content: content,
                style: style
            };
        },

        _createLabel: function(feature, zoom) {
            return {
                labelStyle: null
            };
        },

        /**
         * Adds style popup to the received features, so the can be represented as intended by the style for the layer.
         * @param {object} feature - An object that represents the geometry element being styled.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         * @returns {object} style - Style from the popup feature
         */
        addPopUp: function(feature, zoom) {
            var style = feature._styles.popUpStyle;
            var offsetLeft = style.offsetLeft || 0;
            var offsetTop = style.offsetTop || 0;


            var content, propKey;
            var data = {};
            if (style.popUpTemplate) {
                content = this._contentFromTemplate(feature, style.popUpTemplate);
            } else if (style.popUpUrl) {
                content = "<iframe src=" + style.popUpUrl + "/>";

            } else if (style.noPopUp) {
                content = null;

            } else {
                // Default template, one entry per field
                content = this._contentFromTemplate(feature, "");
            }
            var offset = [offsetLeft, offsetTop];

            return {
                content: content,
                offset: offset
            };
        }
    });

},{"./Styler.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/Styler.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/MarkerCssStyler.js":[function(require,module,exports){
require("./Styler.js");
require("../../../lib/LeafletHtmlIcon.js");
var Mustache = require("../../../lib/mustache.js/mustache.js");
/**
 * Parser of MarkerCSS, for user with SMC Viewer's marker layers.
 *
 * @class
 * @extends SMC.layers.stylers.Styler
 * @mixin SMC.layers.stylers.MarkerCssStyler
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.stylers.MarkerCssStyler = SMC.layers.stylers.Styler.extend(
    /** @lends SMC.layers.stylers.MarkerCssStyler# */
    {
        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            this._parser_url = SMC.BASE_URL + "resources/parser.txt";
            SMC.layers.stylers.Styler.prototype.initialize.apply(this, arguments);
        },

        /**
         * Adds style properties to the received features, so the can be represented as intended by the style for the layer.
         * @param {object} feature - An object that represents the geometry element being styled.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         * @returns {object} style - Style from the marker
         */
        applyStyle: function(feature, zoom) {
            var properties = feature.properties;
            var style = this._createStyles(feature, zoom);
            if (!style) {
                style = "";
            }

            feature._style = style;


            var icon, width, height, anchorLeft, anchorTop;

            width = style.markerWidth || 0;
            height = style.markerHeight || 0;

            anchorLeft = style.anchorLeft || 0;
            anchorTop = style.anchorTop || 0;

            var disableClustering = !!style.disableClustering;
            var opacity = style.opacity ? style.opacity : 1;
            //var visible = !style.invisible ? true : false;
            // var visible;
            // if(style.invisible == 'false'){
            //     visible = true;
            // }else
            // visible = false;

            if (style.iconUrl) {
                // Load normal marker icon with the specified url.


                icon = new L.icon({
                    iconUrl: style.iconUrl,
                    iconSize: [width, height],
                    iconAnchor: [anchorLeft, anchorTop]
                });

            } else if (style.templateUrl) {
                // Load the given page from its url in an iframe.

                icon = new L.HtmlIcon({
                    //html: "<iframe src=" + style.templateUrl + ' style=" border: none;width:' + width + 'px;height:' + height + 'px;margin-top:-' + anchorTop + 'px;margin-left:-' + anchorLeft + 'px"></iframe>',
                    html: this._createHTMLElement("iframe", {
                        "src": style.templateUrl
                    }, {
                        "border": "none",
                        "width": {
                            value: width,
                            units: "px"
                        },
                        "height": {
                            value: height,
                            units: "px",
                        },
                        "margin-top": {
                            value: "-" + anchorTop,
                            units: "px"
                        },
                        "margin-left": {
                            value: "-" + anchorLeft,
                            units: "px"
                        }
                    })
                });


            } else if (style.htmlTemplate) {
                // Load the template into the marker.
                // TODO: "inflate the template" using mustache.
                var data = {};
                for (var propKey in properties) {
                    data[propKey] = properties[propKey];
                }


                var output = Mustache.render(style.htmlTemplate, data);


                //var container = '<div style=" width:' + width + 'px;height:' + height + 'px;margin-top:-' + anchorTop + 'px;margin-left:-' + anchorLeft + 'px">' + output + "</div>";

                icon = new L.HtmlIcon({
                    html: this._createHTMLElement("div", {

                    }, {
                        "width": {
                            value: width,
                            units: "px"
                        },
                        "height": {
                            value: height,
                            units: "px",
                        },
                        "margin-top": {
                            value: "-" + anchorTop,
                            units: "px"
                        },
                        "margin-left": {
                            value: "-" + anchorLeft,
                            units: "px"
                        }
                    }, output),

                });

            } else if (style.iconClassName) {

                icon = new L.HtmlIcon({
                    //html: '<div class="'+style.iconClassName+'" style=" border: none;width:' + width + 'px;height:' + height + 'px;margin-top:-' + anchorTop + 'px;margin-left:-' + anchorLeft + 'px"></div>',
                    html: this._createHTMLElement("div", {
                        "class": style.iconClassName
                    }, {
                        "border": "none",
                        "width": {
                            value: width,
                            units: "px"
                        },
                        "height": {
                            value: height,
                            units: "px",
                        },
                        "margin-top": {
                            value: anchorTop,
                            units: "px"
                        },
                        "margin-left": {
                            value: anchorLeft,
                            units: "px"
                        }
                    })
                });
            } else {
                icon = new L.icon({
                    iconUrl: L.Icon.Default.imagePath + "/marker-icon.png",
                    iconAnchor: [13, 41]
                });
            }

            return {
                icon: icon,
                disableClustering: disableClustering,
                opacity: opacity
            };

        },

        _createHTMLElement: function(elementType, attributes, styles, content) {

            if (!content) {
                content = "";
            }

            var attributesString = "";
            for (var attrKey in attributes) {
                attributesString += attrKey + '="' + attributes[attrKey] + '"';
            }

            var stylesString = "";
            for (var styleKey in styles) {
                var style = styles[styleKey];
                if (!style) {
                    continue;
                } else if (typeof style == "object") {
                    if (style.value) {
                        stylesString += styleKey + ":" + style.value;
                        if (style.units) {
                            stylesString += style.units;
                        }
                        stylesString += ";";
                    }
                } else {
                    stylesString += styleKey + ":" + style;
                    stylesString += ";";
                }

            }


            return "<" + elementType + " " + attributesString + " style=\"position:absolute;" + stylesString + "\">" + content + "</" + elementType + ">";
        },

        /**
         * Adds style popup to the received features, so the can be represented as intended by the style for the layer.
         * @param {object} marker - An object that represents the geometry element being styled.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         */
        addPopUp: function(marker, zoom) {

            if (marker.popup) {
                marker.unbindPopup();
            }
            var style = null;
            if(marker.feature && marker.feature._style){
                style = marker.feature._style;
            }else{
                style = "";
            }
            var offsetLeft = style.popUpOffsetLeft || 0;
            var offsetTop = style.popUpOffsetTop || 0;


            var content, propKey;
            var data = {};
            if (style.popUpTemplate) {


                content = this._contentFromTemplate(marker.feature, style.popUpTemplate);

            } else if (style.popUpUrl) {
                content = "<iframe src=" + style.popUpUrl + "/>";

            } else if (style.noPopUp) {
                marker.unbindPopup();

            } else {
                // Default template, one entry per field;
                content = this._contentFromTemplate(marker.feature, "");
            }
            var offset = [offsetLeft, offsetTop];
            if (content) {
                marker.bindPopup(content, {
                    offset: offset
                });
            }
        }
    });

},{"../../../lib/LeafletHtmlIcon.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/LeafletHtmlIcon.js","../../../lib/mustache.js/mustache.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/mustache.js/mustache.js","./Styler.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/Styler.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/ParserFunction.js":[function(require,module,exports){
SMC.layers.stylers.PARSER_FUNCTION = (function() {
  /*
   * Generated by PEG.js 0.8.0.
   *
   * http://pegjs.majda.cz/
   */

  function peg$subclass(child, parent) {
    function ctor() { this.constructor = child; }
    ctor.prototype = parent.prototype;
    child.prototype = new ctor();
  }

  function SyntaxError(message, expected, found, offset, line, column) {
    this.message  = message;
    this.expected = expected;
    this.found    = found;
    this.offset   = offset;
    this.line     = line;
    this.column   = column;

    this.name     = "SyntaxError";
  }

  peg$subclass(SyntaxError, Error);

  function parse(input) {
    var options = arguments.length > 1 ? arguments[1] : {},

        peg$FAILED = {},

        peg$startRuleFunctions = { ruleList: peg$parseruleList },
        peg$startRuleFunction  = peg$parseruleList,

        peg$c0 = [],
        peg$c1 = function(rules) {return rules.join("\n")},
        peg$c2 = peg$FAILED,
        peg$c3 = function(conditions, members) {
            var result = "";
            if(conditions != null && conditions != ""){
               result = conditions + "{" + members.join(";") + ";" + "}";
            }else{
              result = members.join(";") + ";";
            }
            return result;
          },
        peg$c4 = function(first, rest) {
            var result = "";
            var result_start = "if(";
            var result_end = ")";
            if(rest != ""){
              result = result_start + first + " || " + rest.join(" || ") + result_end;
            }else if(first != ""){
              result = result_start + first + result_end;
            }else{
              result = "";
            }
            return result;
          },
        peg$c5 = function(cond) { return cond;},
        peg$c6 = null,
        peg$c7 = function(gt, z, zv, acl, fc) {
            var result = "";
            if(gt == "*"){
              if(zv != null || acl != ""){
                result += "(";
              }
              if(zv != null){
                result += zv;
              }
              if(acl != "" && zv != null){
                result += " && " + acl;
              }else{
                result += acl;
              }
              if(fc != null && (acl != "" || zv != null)){
                result += " && " + fc;
              }else if(fc != null){
                result += fc;
              }
              if(zv != null || acl != ""){
                result += ")";
              }
            }else{
              if(gt != null || zv != null || acl != null){
                result += "(";
              }
              if(gt != null){
                result += "feature.geometry.type == " + "'" + gt + "'";
              }
              if(zv != null && gt != null){
                result += " && " + zv;
              }else if(zv != null && gt == null){
                result += zv;
              }
              if(acl != "" && (zv != null || gt != null)){
                result += " && " + acl;
              }else{
                result += acl;
              }
              if(fc != null && (acl != "" || zv != null || gt != null)){
                result += " && " + fc;
              }else if(fc != null){
                result += fc;
              }
              if(gt != null || zv != null || acl != null){
                result += ")";
              }
            }

            return result;
          },
        peg$c8 = function(name, value) {
              var res = null;
              if(isNaN(value)){
                if(value.indexOf("class") > -1){
                  value = value.replace("class=", "class=\"");
                  value = value.replace(">", "\">")
                }
                res = "style." + name + " = " + "'" + value + "'";
                if(value.indexOf("[") > -1){
                  res = "style." + name + " = " + value;
                }
              }else{
                res = "style." + name + " = " + value;
              }
              return res;
            },
        peg$c9 = /^[a-zA-Z0-9_]/,
        peg$c10 = { type: "class", value: "[a-zA-Z0-9_]", description: "[a-zA-Z0-9_]" },
        peg$c11 = "-",
        peg$c12 = { type: "literal", value: "-", description: "\"-\"" },
        peg$c13 = function(first, second) {
            var res = "";
            if(second.length > 0){
              second[0] = second[0].toUpperCase();
              res = first.join("") + second.join("");
            }else{
              res = first.join("");
            }
            
            return res;
          },
        peg$c14 = function(str) {
            var res = "";
            if(str == "width"){
              res = "strokeWidth";
            }else if(str == "color"){
              res = "strokeColor";
            }else if(str == "dashes"){
              res = "dashArray";
            }else if(str == "linecap"){
              res = "strokeCap";
            }else{
              res = str;
            }
            return res;
          },
        peg$c15 = "z",
        peg$c16 = { type: "literal", value: "z", description: "\"z\"" },
        peg$c17 = function(min, zi, max) {
            var res = "";
            if(zi != null){
              if(min != null && max != null){
                res = "zoom > " + min + " && zoom < " + max;
              }else if(min != null && max == null){
                res = "zoom >= " + min;
              }else if(min == null && max != null){
                res = "zoom <= " + max;
              }
            }else{
              if(min != null){
                res = "zoom == " + min;
              }
            }

            return res;
          },
        peg$c18 = function(atr_conditions) {return atr_conditions.join(" && ");},
        peg$c19 = function(comp) {return comp;},
        peg$c20 = function(first, op, second) {
            var res = "";
            if(isNaN(second)){
              res = "feature.properties." + first + " " + op + " '" + second + "'";
            }else{
              res = "feature.properties." + first + " " + op + " " + second + "";
            }
          return res;
          },
        peg$c21 = function(factor, eq) {
            var res = null;
            if(eq != null){
              res = factor + "=";
            }else{
              res = factor;
            }
            return res;
          },
        peg$c22 = function() { return "<"},
        peg$c23 = function() {return ">"},
        peg$c24 = function() {return "=="},
        peg$c25 = ":",
        peg$c26 = { type: "literal", value: ":", description: "\":\"" },
        peg$c27 = function(str) {return "feature." + str;},
        peg$c28 = "[",
        peg$c29 = { type: "literal", value: "[", description: "\"[\"" },
        peg$c30 = "{",
        peg$c31 = { type: "literal", value: "{", description: "\"{\"" },
        peg$c32 = "]",
        peg$c33 = { type: "literal", value: "]", description: "\"]\"" },
        peg$c34 = "}",
        peg$c35 = { type: "literal", value: "}", description: "\"}\"" },
        peg$c36 = ";",
        peg$c37 = { type: "literal", value: ";", description: "\";\"" },
        peg$c38 = ",",
        peg$c39 = { type: "literal", value: ",", description: "\",\"" },
        peg$c40 = "|",
        peg$c41 = { type: "literal", value: "|", description: "\"|\"" },
        peg$c42 = "<",
        peg$c43 = { type: "literal", value: "<", description: "\"<\"" },
        peg$c44 = ">",
        peg$c45 = { type: "literal", value: ">", description: "\">\"" },
        peg$c46 = "=",
        peg$c47 = { type: "literal", value: "=", description: "\"=\"" },
        peg$c48 = { type: "other", description: "whitespace" },
        peg$c49 = /^[ \t\n\r]/,
        peg$c50 = { type: "class", value: "[ \\t\\n\\r]", description: "[ \\t\\n\\r]" },
        peg$c51 = "false",
        peg$c52 = { type: "literal", value: "false", description: "\"false\"" },
        peg$c53 = function() { return false; },
        peg$c54 = "null",
        peg$c55 = { type: "literal", value: "null", description: "\"null\"" },
        peg$c56 = function() { return null;  },
        peg$c57 = "true",
        peg$c58 = { type: "literal", value: "true", description: "\"true\"" },
        peg$c59 = function() { return true;  },
        peg$c60 = "Point",
        peg$c61 = { type: "literal", value: "Point", description: "\"Point\"" },
        peg$c62 = "MultiPoint",
        peg$c63 = { type: "literal", value: "MultiPoint", description: "\"MultiPoint\"" },
        peg$c64 = "LineString",
        peg$c65 = { type: "literal", value: "LineString", description: "\"LineString\"" },
        peg$c66 = "MultiLineString",
        peg$c67 = { type: "literal", value: "MultiLineString", description: "\"MultiLineString\"" },
        peg$c68 = "Polygon",
        peg$c69 = { type: "literal", value: "Polygon", description: "\"Polygon\"" },
        peg$c70 = "MultiPolygon",
        peg$c71 = { type: "literal", value: "MultiPolygon", description: "\"MultiPolygon\"" },
        peg$c72 = "GeometryCollection",
        peg$c73 = { type: "literal", value: "GeometryCollection", description: "\"GeometryCollection\"" },
        peg$c74 = "*",
        peg$c75 = { type: "literal", value: "*", description: "\"*\"" },
        peg$c76 = { type: "other", description: "number" },
        peg$c77 = function() { return parseFloat(text()); },
        peg$c78 = function(first, rest) {
            var res = "";
            if(rest != ""){
              res = "[" + first + "," + rest.join(",") + "]";
            }else{
              res = first;
            }
            return res;
          },
        peg$c79 = function(n) {return n;},
        peg$c80 = ".",
        peg$c81 = { type: "literal", value: ".", description: "\".\"" },
        peg$c82 = /^[1-9]/,
        peg$c83 = { type: "class", value: "[1-9]", description: "[1-9]" },
        peg$c84 = /^[eE]/,
        peg$c85 = { type: "class", value: "[eE]", description: "[eE]" },
        peg$c86 = "+",
        peg$c87 = { type: "literal", value: "+", description: "\"+\"" },
        peg$c88 = "0",
        peg$c89 = { type: "literal", value: "0", description: "\"0\"" },
        peg$c90 = function(chars) {return chars.join("")},
        peg$c91 = /^[a-zA-Z0-9_\-]/,
        peg$c92 = { type: "class", value: "[a-zA-Z0-9_\\-]", description: "[a-zA-Z0-9_\\-]" },
        peg$c93 = { type: "other", description: "string" },
        peg$c94 = function(chars) { return chars.join(""); },
        peg$c95 = "\"",
        peg$c96 = { type: "literal", value: "\"", description: "\"\\\"\"" },
        peg$c97 = "\\",
        peg$c98 = { type: "literal", value: "\\", description: "\"\\\\\"" },
        peg$c99 = "/",
        peg$c100 = { type: "literal", value: "/", description: "\"/\"" },
        peg$c101 = "b",
        peg$c102 = { type: "literal", value: "b", description: "\"b\"" },
        peg$c103 = function() { return "\b"; },
        peg$c104 = "f",
        peg$c105 = { type: "literal", value: "f", description: "\"f\"" },
        peg$c106 = function() { return "\f"; },
        peg$c107 = "n",
        peg$c108 = { type: "literal", value: "n", description: "\"n\"" },
        peg$c109 = function() { return "\n"; },
        peg$c110 = "r",
        peg$c111 = { type: "literal", value: "r", description: "\"r\"" },
        peg$c112 = function() { return "\r"; },
        peg$c113 = "t",
        peg$c114 = { type: "literal", value: "t", description: "\"t\"" },
        peg$c115 = function() { return "\t"; },
        peg$c116 = "u",
        peg$c117 = { type: "literal", value: "u", description: "\"u\"" },
        peg$c118 = function(digits) {
                  return String.fromCharCode(parseInt(digits, 16));
                },
        peg$c119 = function(sequence) { return sequence; },
        peg$c120 = /^[ -!#-[\]-\u10FFFF]/,
        peg$c121 = { type: "class", value: "[ -!#-[\\]-\\u10FFFF]", description: "[ -!#-[\\]-\\u10FFFF]" },
        peg$c122 = /^[0-9]/,
        peg$c123 = { type: "class", value: "[0-9]", description: "[0-9]" },
        peg$c124 = /^[0-9a-f]/i,
        peg$c125 = { type: "class", value: "[0-9a-f]i", description: "[0-9a-f]i" },

        peg$currPos          = 0,
        peg$reportedPos      = 0,
        peg$cachedPos        = 0,
        peg$cachedPosDetails = { line: 1, column: 1, seenCR: false },
        peg$maxFailPos       = 0,
        peg$maxFailExpected  = [],
        peg$silentFails      = 0,

        peg$result;

    if ("startRule" in options) {
      if (!(options.startRule in peg$startRuleFunctions)) {
        throw new Error("Can't start parsing from rule \"" + options.startRule + "\".");
      }

      peg$startRuleFunction = peg$startRuleFunctions[options.startRule];
    }

    function text() {
      return input.substring(peg$reportedPos, peg$currPos);
    }

    function offset() {
      return peg$reportedPos;
    }

    function line() {
      return peg$computePosDetails(peg$reportedPos).line;
    }

    function column() {
      return peg$computePosDetails(peg$reportedPos).column;
    }

    function expected(description) {
      throw peg$buildException(
        null,
        [{ type: "other", description: description }],
        peg$reportedPos
      );
    }

    function error(message) {
      throw peg$buildException(message, null, peg$reportedPos);
    }

    function peg$computePosDetails(pos) {
      function advance(details, startPos, endPos) {
        var p, ch;

        for (p = startPos; p < endPos; p++) {
          ch = input.charAt(p);
          if (ch === "\n") {
            if (!details.seenCR) { details.line++; }
            details.column = 1;
            details.seenCR = false;
          } else if (ch === "\r" || ch === "\u2028" || ch === "\u2029") {
            details.line++;
            details.column = 1;
            details.seenCR = true;
          } else {
            details.column++;
            details.seenCR = false;
          }
        }
      }

      if (peg$cachedPos !== pos) {
        if (peg$cachedPos > pos) {
          peg$cachedPos = 0;
          peg$cachedPosDetails = { line: 1, column: 1, seenCR: false };
        }
        advance(peg$cachedPosDetails, peg$cachedPos, pos);
        peg$cachedPos = pos;
      }

      return peg$cachedPosDetails;
    }

    function peg$fail(expected) {
      if (peg$currPos < peg$maxFailPos) { return; }

      if (peg$currPos > peg$maxFailPos) {
        peg$maxFailPos = peg$currPos;
        peg$maxFailExpected = [];
      }

      peg$maxFailExpected.push(expected);
    }

    function peg$buildException(message, expected, pos) {
      function cleanupExpected(expected) {
        var i = 1;

        expected.sort(function(a, b) {
          if (a.description < b.description) {
            return -1;
          } else if (a.description > b.description) {
            return 1;
          } else {
            return 0;
          }
        });

        while (i < expected.length) {
          if (expected[i - 1] === expected[i]) {
            expected.splice(i, 1);
          } else {
            i++;
          }
        }
      }

      function buildMessage(expected, found) {
        function stringEscape(s) {
          function hex(ch) { return ch.charCodeAt(0).toString(16).toUpperCase(); }

          return s
            .replace(/\\/g,   '\\\\')
            .replace(/"/g,    '\\"')
            .replace(/\x08/g, '\\b')
            .replace(/\t/g,   '\\t')
            .replace(/\n/g,   '\\n')
            .replace(/\f/g,   '\\f')
            .replace(/\r/g,   '\\r')
            .replace(/[\x00-\x07\x0B\x0E\x0F]/g, function(ch) { return '\\x0' + hex(ch); })
            .replace(/[\x10-\x1F\x80-\xFF]/g,    function(ch) { return '\\x'  + hex(ch); })
            .replace(/[\u0180-\u0FFF]/g,         function(ch) { return '\\u0' + hex(ch); })
            .replace(/[\u1080-\uFFFF]/g,         function(ch) { return '\\u'  + hex(ch); });
        }

        var expectedDescs = new Array(expected.length),
            expectedDesc, foundDesc, i;

        for (i = 0; i < expected.length; i++) {
          expectedDescs[i] = expected[i].description;
        }

        expectedDesc = expected.length > 1
          ? expectedDescs.slice(0, -1).join(", ")
              + " or "
              + expectedDescs[expected.length - 1]
          : expectedDescs[0];

        foundDesc = found ? "\"" + stringEscape(found) + "\"" : "end of input";

        return "Expected " + expectedDesc + " but " + foundDesc + " found.";
      }

      var posDetails = peg$computePosDetails(pos),
          found      = pos < input.length ? input.charAt(pos) : null;

      if (expected !== null) {
        cleanupExpected(expected);
      }

      return new SyntaxError(
        message !== null ? message : buildMessage(expected, found),
        expected,
        found,
        pos,
        posDetails.line,
        posDetails.column
      );
    }

    function peg$parseruleList() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parserule();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parserule();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c1(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parserule() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parsecondition_list();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsebegin_object();
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parsemember();
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            s4 = peg$parsemember();
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseend_object();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c3(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecondition_list() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsecondition();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsecondition_comma();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsecondition_comma();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c4(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecondition_comma() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsecomma_separator();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecondition();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c5(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecondition() {
      var s0, s1, s2, s3, s4, s5;

      s0 = peg$currPos;
      s1 = peg$parsegeometryType();
      if (s1 === peg$FAILED) {
        s1 = peg$c6;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsezoom();
        if (s2 === peg$FAILED) {
          s2 = peg$c6;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsezoom_value();
          if (s3 === peg$FAILED) {
            s3 = peg$c6;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseattribute_condition_list();
            if (s4 === peg$FAILED) {
              s4 = peg$c6;
            }
            if (s4 !== peg$FAILED) {
              s5 = peg$parsefeature_condition();
              if (s5 === peg$FAILED) {
                s5 = peg$c6;
              }
              if (s5 !== peg$FAILED) {
                peg$reportedPos = s0;
                s1 = peg$c7(s1, s2, s3, s4, s5);
                s0 = s1;
              } else {
                peg$currPos = s0;
                s0 = peg$c2;
              }
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsemember() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parsestring_member();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsename_separator();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseoperand();
          if (s3 !== peg$FAILED) {
            s4 = peg$parsevalue_separator();
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c8(s1, s3);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsestring_member() {
      var s0;

      s0 = peg$parsehyphen_member();
      if (s0 === peg$FAILED) {
        s0 = peg$parsecomplex_member();
      }

      return s0;
    }

    function peg$parsehyphen_member() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = [];
      if (peg$c9.test(input.charAt(peg$currPos))) {
        s2 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s2 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c10); }
      }
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        if (peg$c9.test(input.charAt(peg$currPos))) {
          s2 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c10); }
        }
      }
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c11;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          if (peg$c9.test(input.charAt(peg$currPos))) {
            s4 = input.charAt(peg$currPos);
            peg$currPos++;
          } else {
            s4 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c10); }
          }
          while (s4 !== peg$FAILED) {
            s3.push(s4);
            if (peg$c9.test(input.charAt(peg$currPos))) {
              s4 = input.charAt(peg$currPos);
              peg$currPos++;
            } else {
              s4 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c10); }
            }
          }
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c13(s1, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomplex_member() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parsestring_wq();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c14(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsezoom_value() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 122) {
        s1 = peg$c15;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c16); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 === peg$FAILED) {
          s2 = peg$c6;
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsezoom_interval();
          if (s3 === peg$FAILED) {
            s3 = peg$c6;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parsenumber();
            if (s4 === peg$FAILED) {
              s4 = peg$c6;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c17(s2, s3, s4);
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseattribute_condition_list() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parseattribute_condition();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parseattribute_condition();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c18(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parseattribute_condition() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsebegin_array();
      if (s1 !== peg$FAILED) {
        s2 = peg$parsecomparaison();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseend_array();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c19(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomparaison() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parseoperand();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseoperator();
        if (s2 !== peg$FAILED) {
          s3 = peg$parseoperand();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c20(s1, s2, s3);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseoperand() {
      var s0;

      s0 = peg$parsestring();
      if (s0 === peg$FAILED) {
        s0 = peg$parsenumber_array();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring_wq();
          if (s0 === peg$FAILED) {
            s0 = peg$parsenumber();
          }
        }
      }

      return s0;
    }

    function peg$parseoperator() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsefactor();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseequal_than();
        if (s2 === peg$FAILED) {
          s2 = peg$c6;
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c21(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsefactor() {
      var s0, s1;

      s0 = peg$currPos;
      s1 = peg$parseless_than();
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c22();
      }
      s0 = s1;
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsegreater_than();
        if (s1 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c23();
        }
        s0 = s1;
        if (s0 === peg$FAILED) {
          s0 = peg$currPos;
          s1 = peg$parseequal_than();
          if (s1 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c24();
          }
          s0 = s1;
        }
      }

      return s0;
    }

    function peg$parsefeature_condition() {
      var s0, s1, s2;

      s0 = peg$currPos;
      if (input.charCodeAt(peg$currPos) === 58) {
        s1 = peg$c25;
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c26); }
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsestring_wq();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c27(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsebegin_array() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 91) {
          s2 = peg$c28;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c29); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsebegin_object() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 123) {
          s2 = peg$c30;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c31); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseend_array() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 93) {
          s2 = peg$c32;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c33); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseend_object() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 125) {
          s2 = peg$c34;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c35); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsename_separator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c25;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsefeature_condition_separator() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 58) {
          s2 = peg$c25;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c26); }
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsevalue_separator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 59) {
          s2 = peg$c36;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c37); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsecomma_separator() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 44) {
          s2 = peg$c38;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c39); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsezoom() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 124) {
          s2 = peg$c40;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c41); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsezoom_interval() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsews();
      if (s1 !== peg$FAILED) {
        if (input.charCodeAt(peg$currPos) === 45) {
          s2 = peg$c11;
          peg$currPos++;
        } else {
          s2 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c12); }
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsews();
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseless_than() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 60) {
        s0 = peg$c42;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c43); }
      }

      return s0;
    }

    function peg$parsegreater_than() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 62) {
        s0 = peg$c44;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c45); }
      }

      return s0;
    }

    function peg$parseequal_than() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 61) {
        s0 = peg$c46;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c47); }
      }

      return s0;
    }

    function peg$parsews() {
      var s0, s1;

      peg$silentFails++;
      s0 = [];
      if (peg$c49.test(input.charAt(peg$currPos))) {
        s1 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c50); }
      }
      while (s1 !== peg$FAILED) {
        s0.push(s1);
        if (peg$c49.test(input.charAt(peg$currPos))) {
          s1 = input.charAt(peg$currPos);
          peg$currPos++;
        } else {
          s1 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c50); }
        }
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c48); }
      }

      return s0;
    }

    function peg$parsefalse() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 5) === peg$c51) {
        s1 = peg$c51;
        peg$currPos += 5;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c52); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c53();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsenull() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c54) {
        s1 = peg$c54;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c55); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c56();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsetrue() {
      var s0, s1;

      s0 = peg$currPos;
      if (input.substr(peg$currPos, 4) === peg$c57) {
        s1 = peg$c57;
        peg$currPos += 4;
      } else {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c58); }
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c59();
      }
      s0 = s1;

      return s0;
    }

    function peg$parsevalue() {
      var s0;

      s0 = peg$parserule();
      if (s0 === peg$FAILED) {
        s0 = peg$parsenumber();
        if (s0 === peg$FAILED) {
          s0 = peg$parsestring();
        }
      }

      return s0;
    }

    function peg$parsegeometryType() {
      var s0;

      if (input.substr(peg$currPos, 5) === peg$c60) {
        s0 = peg$c60;
        peg$currPos += 5;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c61); }
      }
      if (s0 === peg$FAILED) {
        if (input.substr(peg$currPos, 10) === peg$c62) {
          s0 = peg$c62;
          peg$currPos += 10;
        } else {
          s0 = peg$FAILED;
          if (peg$silentFails === 0) { peg$fail(peg$c63); }
        }
        if (s0 === peg$FAILED) {
          if (input.substr(peg$currPos, 10) === peg$c64) {
            s0 = peg$c64;
            peg$currPos += 10;
          } else {
            s0 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c65); }
          }
          if (s0 === peg$FAILED) {
            if (input.substr(peg$currPos, 15) === peg$c66) {
              s0 = peg$c66;
              peg$currPos += 15;
            } else {
              s0 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c67); }
            }
            if (s0 === peg$FAILED) {
              if (input.substr(peg$currPos, 7) === peg$c68) {
                s0 = peg$c68;
                peg$currPos += 7;
              } else {
                s0 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c69); }
              }
              if (s0 === peg$FAILED) {
                if (input.substr(peg$currPos, 12) === peg$c70) {
                  s0 = peg$c70;
                  peg$currPos += 12;
                } else {
                  s0 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c71); }
                }
                if (s0 === peg$FAILED) {
                  if (input.substr(peg$currPos, 18) === peg$c72) {
                    s0 = peg$c72;
                    peg$currPos += 18;
                  } else {
                    s0 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c73); }
                  }
                  if (s0 === peg$FAILED) {
                    if (input.charCodeAt(peg$currPos) === 42) {
                      s0 = peg$c74;
                      peg$currPos++;
                    } else {
                      s0 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c75); }
                    }
                  }
                }
              }
            }
          }
        }
      }

      return s0;
    }

    function peg$parsenumber() {
      var s0, s1, s2, s3, s4;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parseminus();
      if (s1 === peg$FAILED) {
        s1 = peg$c6;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parseint();
        if (s2 !== peg$FAILED) {
          s3 = peg$parsefrac();
          if (s3 === peg$FAILED) {
            s3 = peg$c6;
          }
          if (s3 !== peg$FAILED) {
            s4 = peg$parseexp();
            if (s4 === peg$FAILED) {
              s4 = peg$c6;
            }
            if (s4 !== peg$FAILED) {
              peg$reportedPos = s0;
              s1 = peg$c77();
              s0 = s1;
            } else {
              peg$currPos = s0;
              s0 = peg$c2;
            }
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c76); }
      }

      return s0;
    }

    function peg$parsenumber_array() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsenumber();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsenumber_separator();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsenumber_separator();
        }
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c78(s1, s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsenumber_separator() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = peg$parsecomma_separator();
      if (s1 === peg$FAILED) {
        s1 = peg$c6;
      }
      if (s1 !== peg$FAILED) {
        s2 = peg$parsenumber();
        if (s2 !== peg$FAILED) {
          peg$reportedPos = s0;
          s1 = peg$c79(s2);
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsedecimal_point() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 46) {
        s0 = peg$c80;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c81); }
      }

      return s0;
    }

    function peg$parsedigit1_9() {
      var s0;

      if (peg$c82.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c83); }
      }

      return s0;
    }

    function peg$parsee() {
      var s0;

      if (peg$c84.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c85); }
      }

      return s0;
    }

    function peg$parseexp() {
      var s0, s1, s2, s3, s4;

      s0 = peg$currPos;
      s1 = peg$parsee();
      if (s1 !== peg$FAILED) {
        s2 = peg$parseminus();
        if (s2 === peg$FAILED) {
          s2 = peg$parseplus();
        }
        if (s2 === peg$FAILED) {
          s2 = peg$c6;
        }
        if (s2 !== peg$FAILED) {
          s3 = [];
          s4 = peg$parseDIGIT();
          if (s4 !== peg$FAILED) {
            while (s4 !== peg$FAILED) {
              s3.push(s4);
              s4 = peg$parseDIGIT();
            }
          } else {
            s3 = peg$c2;
          }
          if (s3 !== peg$FAILED) {
            s1 = [s1, s2, s3];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parsefrac() {
      var s0, s1, s2, s3;

      s0 = peg$currPos;
      s1 = peg$parsedecimal_point();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parseDIGIT();
        if (s3 !== peg$FAILED) {
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDIGIT();
          }
        } else {
          s2 = peg$c2;
        }
        if (s2 !== peg$FAILED) {
          s1 = [s1, s2];
          s0 = s1;
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }

      return s0;
    }

    function peg$parseint() {
      var s0, s1, s2, s3;

      s0 = peg$parsezero();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parsedigit1_9();
        if (s1 !== peg$FAILED) {
          s2 = [];
          s3 = peg$parseDIGIT();
          while (s3 !== peg$FAILED) {
            s2.push(s3);
            s3 = peg$parseDIGIT();
          }
          if (s2 !== peg$FAILED) {
            s1 = [s1, s2];
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseminus() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 45) {
        s0 = peg$c11;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c12); }
      }

      return s0;
    }

    function peg$parseplus() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 43) {
        s0 = peg$c86;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c87); }
      }

      return s0;
    }

    function peg$parsezero() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 48) {
        s0 = peg$c88;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c89); }
      }

      return s0;
    }

    function peg$parsestring_wq() {
      var s0, s1, s2;

      s0 = peg$currPos;
      s1 = [];
      s2 = peg$parsechar_wq();
      while (s2 !== peg$FAILED) {
        s1.push(s2);
        s2 = peg$parsechar_wq();
      }
      if (s1 !== peg$FAILED) {
        peg$reportedPos = s0;
        s1 = peg$c90(s1);
      }
      s0 = s1;

      return s0;
    }

    function peg$parsechar_wq() {
      var s0;

      if (peg$c91.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c92); }
      }

      return s0;
    }

    function peg$parsestring() {
      var s0, s1, s2, s3;

      peg$silentFails++;
      s0 = peg$currPos;
      s1 = peg$parsequotation_mark();
      if (s1 !== peg$FAILED) {
        s2 = [];
        s3 = peg$parsechar();
        while (s3 !== peg$FAILED) {
          s2.push(s3);
          s3 = peg$parsechar();
        }
        if (s2 !== peg$FAILED) {
          s3 = peg$parsequotation_mark();
          if (s3 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c94(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      } else {
        peg$currPos = s0;
        s0 = peg$c2;
      }
      peg$silentFails--;
      if (s0 === peg$FAILED) {
        s1 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c93); }
      }

      return s0;
    }

    function peg$parsechar() {
      var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9;

      s0 = peg$parseunescaped();
      if (s0 === peg$FAILED) {
        s0 = peg$currPos;
        s1 = peg$parseescape();
        if (s1 !== peg$FAILED) {
          if (input.charCodeAt(peg$currPos) === 34) {
            s2 = peg$c95;
            peg$currPos++;
          } else {
            s2 = peg$FAILED;
            if (peg$silentFails === 0) { peg$fail(peg$c96); }
          }
          if (s2 === peg$FAILED) {
            if (input.charCodeAt(peg$currPos) === 92) {
              s2 = peg$c97;
              peg$currPos++;
            } else {
              s2 = peg$FAILED;
              if (peg$silentFails === 0) { peg$fail(peg$c98); }
            }
            if (s2 === peg$FAILED) {
              if (input.charCodeAt(peg$currPos) === 47) {
                s2 = peg$c99;
                peg$currPos++;
              } else {
                s2 = peg$FAILED;
                if (peg$silentFails === 0) { peg$fail(peg$c100); }
              }
              if (s2 === peg$FAILED) {
                s2 = peg$currPos;
                if (input.charCodeAt(peg$currPos) === 98) {
                  s3 = peg$c101;
                  peg$currPos++;
                } else {
                  s3 = peg$FAILED;
                  if (peg$silentFails === 0) { peg$fail(peg$c102); }
                }
                if (s3 !== peg$FAILED) {
                  peg$reportedPos = s2;
                  s3 = peg$c103();
                }
                s2 = s3;
                if (s2 === peg$FAILED) {
                  s2 = peg$currPos;
                  if (input.charCodeAt(peg$currPos) === 102) {
                    s3 = peg$c104;
                    peg$currPos++;
                  } else {
                    s3 = peg$FAILED;
                    if (peg$silentFails === 0) { peg$fail(peg$c105); }
                  }
                  if (s3 !== peg$FAILED) {
                    peg$reportedPos = s2;
                    s3 = peg$c106();
                  }
                  s2 = s3;
                  if (s2 === peg$FAILED) {
                    s2 = peg$currPos;
                    if (input.charCodeAt(peg$currPos) === 110) {
                      s3 = peg$c107;
                      peg$currPos++;
                    } else {
                      s3 = peg$FAILED;
                      if (peg$silentFails === 0) { peg$fail(peg$c108); }
                    }
                    if (s3 !== peg$FAILED) {
                      peg$reportedPos = s2;
                      s3 = peg$c109();
                    }
                    s2 = s3;
                    if (s2 === peg$FAILED) {
                      s2 = peg$currPos;
                      if (input.charCodeAt(peg$currPos) === 114) {
                        s3 = peg$c110;
                        peg$currPos++;
                      } else {
                        s3 = peg$FAILED;
                        if (peg$silentFails === 0) { peg$fail(peg$c111); }
                      }
                      if (s3 !== peg$FAILED) {
                        peg$reportedPos = s2;
                        s3 = peg$c112();
                      }
                      s2 = s3;
                      if (s2 === peg$FAILED) {
                        s2 = peg$currPos;
                        if (input.charCodeAt(peg$currPos) === 116) {
                          s3 = peg$c113;
                          peg$currPos++;
                        } else {
                          s3 = peg$FAILED;
                          if (peg$silentFails === 0) { peg$fail(peg$c114); }
                        }
                        if (s3 !== peg$FAILED) {
                          peg$reportedPos = s2;
                          s3 = peg$c115();
                        }
                        s2 = s3;
                        if (s2 === peg$FAILED) {
                          s2 = peg$currPos;
                          if (input.charCodeAt(peg$currPos) === 117) {
                            s3 = peg$c116;
                            peg$currPos++;
                          } else {
                            s3 = peg$FAILED;
                            if (peg$silentFails === 0) { peg$fail(peg$c117); }
                          }
                          if (s3 !== peg$FAILED) {
                            s4 = peg$currPos;
                            s5 = peg$currPos;
                            s6 = peg$parseHEXDIG();
                            if (s6 !== peg$FAILED) {
                              s7 = peg$parseHEXDIG();
                              if (s7 !== peg$FAILED) {
                                s8 = peg$parseHEXDIG();
                                if (s8 !== peg$FAILED) {
                                  s9 = peg$parseHEXDIG();
                                  if (s9 !== peg$FAILED) {
                                    s6 = [s6, s7, s8, s9];
                                    s5 = s6;
                                  } else {
                                    peg$currPos = s5;
                                    s5 = peg$c2;
                                  }
                                } else {
                                  peg$currPos = s5;
                                  s5 = peg$c2;
                                }
                              } else {
                                peg$currPos = s5;
                                s5 = peg$c2;
                              }
                            } else {
                              peg$currPos = s5;
                              s5 = peg$c2;
                            }
                            if (s5 !== peg$FAILED) {
                              s5 = input.substring(s4, peg$currPos);
                            }
                            s4 = s5;
                            if (s4 !== peg$FAILED) {
                              peg$reportedPos = s2;
                              s3 = peg$c118(s4);
                              s2 = s3;
                            } else {
                              peg$currPos = s2;
                              s2 = peg$c2;
                            }
                          } else {
                            peg$currPos = s2;
                            s2 = peg$c2;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
          if (s2 !== peg$FAILED) {
            peg$reportedPos = s0;
            s1 = peg$c119(s2);
            s0 = s1;
          } else {
            peg$currPos = s0;
            s0 = peg$c2;
          }
        } else {
          peg$currPos = s0;
          s0 = peg$c2;
        }
      }

      return s0;
    }

    function peg$parseescape() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 92) {
        s0 = peg$c97;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c98); }
      }

      return s0;
    }

    function peg$parsequotation_mark() {
      var s0;

      if (input.charCodeAt(peg$currPos) === 34) {
        s0 = peg$c95;
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c96); }
      }

      return s0;
    }

    function peg$parseunescaped() {
      var s0;

      if (peg$c120.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c121); }
      }

      return s0;
    }

    function peg$parseDIGIT() {
      var s0;

      if (peg$c122.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c123); }
      }

      return s0;
    }

    function peg$parseHEXDIG() {
      var s0;

      if (peg$c124.test(input.charAt(peg$currPos))) {
        s0 = input.charAt(peg$currPos);
        peg$currPos++;
      } else {
        s0 = peg$FAILED;
        if (peg$silentFails === 0) { peg$fail(peg$c125); }
      }

      return s0;
    }

    peg$result = peg$startRuleFunction();

    if (peg$result !== peg$FAILED && peg$currPos === input.length) {
      return peg$result;
    } else {
      if (peg$result !== peg$FAILED && peg$currPos < input.length) {
        peg$fail({ type: "end", description: "end of input" });
      }

      throw peg$buildException(null, peg$maxFailExpected, peg$maxFailPos);
    }
  }

  return {
    SyntaxError: SyntaxError,
    parse:       parse
  };
})();

},{}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/Styler.js":[function(require,module,exports){
require("./stylers.js");
/**
 * Global variable that represents PEG library functionality to parser a style string
 * @property {PEG} - PEG variable
 */
var PEG = require("../../../lib/pegjs/lib/peg.js");

/**
 * Global variable that represents mustache library functionality
 * @property {mustache} - mustache variable
 */
var Mustache = require("../../../lib/mustache.js/mustache.js");

/**
 * Base class for feature layers' styles processors.
 *
 * @class
 * @abstract
 * @extends L.Class
 * @param {SMC.layers.stylers.Styler~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.stylers.Styler = L.Class.extend(
    /** @lends SMC.layers.stylers.Styler# */
    {

        _grammar: null,
        _parser_url: null,
        parserInitialized: false,
        /**
         * @typedef {Object} SMC.layers.stylers.Styler~options
         * @property {string} stylesheet=null - The style set to apply
         * @property {string} stylesheetURL=null - The style set url to apply
         */
        options: {
            stylesheet: null,
            stylesheetURL: null
        },

        /**
         * Initialize the object with the params
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
            var scope = this;

            if (!SMC.layers.stylers.PARSER_FUNCTION) {
                $.ajax({
                    url: this._parser_url,
                    type: 'get',
                    success: function(response) {
                        scope._grammar = PEG.buildParser(response);
                        scope._parseStyles();
                    }
                });
            } else {
            	this._grammar = SMC.layers.stylers.PARSER_FUNCTION;
            	scope._parseStyles();
            }
        },

        _parseStyles: function() {
        	var _this = this;
            if (this.options.stylesheetURL) {
                $.ajax({
                    url: this.options.stylesheetURL,
                    type: 'get',
                    success: function(response) {
                        _this.parse(response);
                    }
                });
            } else if (this.options.stylesheet) {
                this.parse(this.options.stylesheet);
            } else {
                // We return default empty styles if we have no config.
                this._createStyles = function() {
                    return {};
                };
            }
        },

        /**
         * Create a style to pass to feature and depends on zoom
         *
         * @abstract
         * @private
         * @param {object} feature - An object that represents the geometry element.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         */
        _createStyles: function(feature, zoom) {
            throw new Error("SMC.layers.stylers.Styler::_createStyles: Error, no _createStyles styles was found, did you specify a parser with a derivate class?");
        },

        /**
         * Loads a stylesheet definition interpreting the rules so it can be applied to features.
         *
         * Must be implemented in derived classes.
         *
         * @abstract
         * @param {string} stylesheet - A string containing the stylesheet or an url to load the stylesheet from.
         */
        parse: function(stylesheet) {
            var stylesFuncBody;
            try {
                stylesFuncBody = this._grammar.parse(stylesheet);
            } catch (e) {
                console.debug(e);
                return;
            }

            this.parserInitialized = true;
            this._createStyles = new Function("feature", "zoom", "var style = {};" + stylesFuncBody + "return style;");
        },

        /**
         * Adds style properties to the received features, so the can be represented as intended by the style for the layer.
         * @param {object} feature - An object that represents the geometry element being styled.
         * @param {string} zoom - Number that represents the level zoom to apply the style.
         * @abstract
         */
        applyStyle: function(feature, zoom) {
            throw new Error("SMC.layers.stylers.Styler::applyStyle: Derivate classes must implement this method.");
        },


        _contentFromTemplate: function(feature, template) {
            var defaultTemplate = false;
            if (!template) {
                defaultTemplate = true;
            }


            var data = {};
            if (this.options.featureId) {
                data.$id = feature[this.options.featureId];
                if (defaultTemplate) {
                    template += "$id: <b>{{$id}}</b><br>";
                }
            }

            for (var propKey in feature.properties) {
                data[propKey] = feature.properties[propKey];
                if (defaultTemplate) {
                    template += propKey + ": <b>{{" + propKey + "}}</b><br>";
                }
            }

            var output = Mustache.render(template, data);
            return output;
        }
    });

},{"../../../lib/mustache.js/mustache.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/mustache.js/mustache.js","../../../lib/pegjs/lib/peg.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/pegjs/lib/peg.js","./stylers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/stylers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/stylers/stylers.js":[function(require,module,exports){
require("../layers.js");

/**
 * Namespace for SMC Viewer's stylesheet processors.
 * @namespace
 * @memberof SMC.layers
 * @author Luis Román (lroman@emergya.com)
 */
SMC.layers.stylers = {};

},{"../layers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/layers/layers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/AtmosphereConnector.js":[function(require,module,exports){
require("./providers.js");
require("../../lib/atmosphere-jquery/jquery.atmosphere.js");


/**
 * Base class for layer data providers capabla of receiving updates to the features
 * retrieved initially from a Real Time source.
 * @class
 * @abstract
 * @extends SMC.providers.RTFeatureProvider
 * @param {SMC.providers.AtmosphereRTFeatureProvider~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.providers.AtmosphereConnector = L.Class.extend(
    /** @lends SMC.providers.AtmosphereRTFeatureProvider# */
    {

        includes: [L.Mixin.Events],

        /**
         * @typedef {Object} SMC.providers.AtmosphereRTFeatureProvider~options
         * @property {string} topic="" - The default topic value.
         */
        options: {
            url: "",
            topic: ""
        },

        /**
         * Socket
         * @property {string} socket - The default socket value.
         * @default null
         */
        socket: null,

        /**
         * Initialize the object with the option parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },

        _createSubscription: function() {
            if (!this.options.url) {
                throw new Error("SMC.providers.AtmosphereConnector::_createSubscription: A valid url field is required to be included in the options argument");
            }

            var request = {
                url: this.options.url + (this.options.topic ? ("/" + this.options.topic) : ""),
                contentType: "application/json",
                logLevel: 'debug',
                transport: 'websocket',
                trackMessageLength: true,
                fallbackTransport: 'long-polling'
            };

            var self = this;
            request.onOpen = function(response) {
                self.fireEvent("socketOpened", self.socket);
            };

            request.onMessage = function(response) {
                self._onMessage(response);
            };

            request.onClose = function(response) {
                self.fireEvent("socketClosed", self.socket);
            };

            request.onError = function(response) {
                console.debug(response);
            };

            this.socket = $.atmosphere.subscribe(request);
        },

        _onMessage: function(response) {
            throw new Error("SMC.providers.AtmosphereConnector::_createSubscription must be implemented in derivate classes.");
        }
    }
);

},{"../../lib/atmosphere-jquery/jquery.atmosphere.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/lib/atmosphere-jquery/jquery.atmosphere.js","./providers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/providers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/AtmosphereRTFeatureProvider.js":[function(require,module,exports){
require("./providers.js");
require("./RTFeatureProvider.js");
require("./AtmosphereConnector.js");


/**
 * Base class for layer data providers capabla of receiving updates to the features
 * retrieved initially from a Real Time source.
 * @class
 * @abstract
 * @extends SMC.providers.RTFeatureProvider
 * @mixes SMC.providers.AtmosphereConnector
 * @param {SMC.providers.AtmosphereRTFeatureProvider~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.providers.AtmosphereRTFeatureProvider = SMC.providers.RTFeatureProvider.extend(
    /** @lends SMC.providers.AtmosphereRTFeatureProvider# */
    {

        /**
         * Initialize the object with the option parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.providers.RTFeatureProvider.prototype.initialize.call(this, options);
            SMC.providers.AtmosphereConnector.prototype.initialize.call(this, options);
            L.Util.setOptions(this, options);
        },

        _onMessage: function(response) {
            var featuresAdded = [];
            var featuresDeleted = [];
            var featuresModified = [];
            for (var i = 0; i < response.messages.length; i++) {
                var message = JSON.parse(response.messages[i]);
                for (var j = 0; j < message.featureCollection.features.length; j++) {
                    var feature = message.featureCollection.features[j];
                    switch (message.action) {
                        case "ADD":
                            featuresAdded.push(feature);
                            break;
                        case "DELETE":
                            featuresDeleted.push(feature);
                            break;
                        case "MODIFY":
                            featuresModified.push(feature);
                            break;
                        default:
                            throw new Error("SMC.providers.AtmosphereRTFeatureProvider::_onMessage: Unsupported action " + message.action);
                    }

                }
            }


            this.onFeaturesLoaded(featuresAdded);
            this.onFeaturesDeleted(featuresDeleted);
            this.onFeaturesModified(featuresModified);
        }
    }, [SMC.providers.AtmosphereConnector]);

},{"./AtmosphereConnector.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/AtmosphereConnector.js","./RTFeatureProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/RTFeatureProvider.js","./providers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/providers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/FeaturesProvider.js":[function(require,module,exports){
require("./providers.js");

/**
 * Base class for layer data providers returning arrays of Features.
 * @class
 * @abstract
 * @extends L.Class
 * @mixes L.Mixin.Events
 * @param {SMC.providers.FeaturesProvider~options} options - The configuration for the class
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.providers.FeaturesProvider = L.Class.extend(
    /** @lends SMC.providers.FeaturesProvider# */
    {

        includes: L.Mixin.Events,

        /**
         * @typedef {Object} SMC.providers.FeaturesProvider~options
         * @property {string} featureId="id" - The default id to the feature
         */
        options: {
            idField: "id"
        },
        /** 
         * Initialize the class 
         * @param {string} options - The default options to the feature
         */
        initialize: function(options) {
            L.setOptions(this, options);
        },

        /**
         * Retrieves the features from its source.
         * @fires SMC.providers.FeaturesProvider#featuresLoaded
         */
        loadFeatures: function() {
            var tis = this;
            this.doFeaturesLoading().then(function(featureCollection) {
                tis.onFeaturesLoaded(featureCollection.features);
                /**
                 * Features loaded event.
                 *
                 * @event SMC.providers.FeaturesProvider#featuresLoaded
                 * @type {object}
                 * @property {object} features - The loaded features.
                 */
                tis.fire("featuresLoaded", featureCollection.features);
            });
        },


        /**
         * Implementations of FeatureProvider must contain an override of this method, so features can be loaded from their source.
         * @abstract
         */
        doFeaturesLoading: function() {
            throw new Error("FeaturesProvider::doFeaturesLoading must be implemented by derivate classes.");
        },

        /**
         * Implementations or users of FeatureProvider must provide an implementation of this class so retrieved features can be used.
         * @abstract
         * @param {object} features - The features retrieved by the provider.
         */
        onFeaturesLoaded: function(features) {
            throw new Error("FeaturesProvider::onFeaturesLoaded must be implemented by derivate classes.");
        }
    });

/**
 * API factory method for ease creation of features providers.
 * @params {Object} options - Options for the provider.
 */
SMC.featuresProvider = function() {
    return new SMC.providers.FeaturesProvider();
};

},{"./providers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/providers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/RTFeatureProvider.js":[function(require,module,exports){
require("./providers.js");
require("./URLFeatureProvider.js");


/**
 * Base class for layer data providers capabla of receiving updates to the features
 * retrieved initially from a Real Time source.

 * @class
 * @abstract
 * @extends SMC.providers.URLFeatureProvider
 *
 * @author Luis Román (lroman@emergya.com)
 */
SMC.providers.RTFeatureProvider = SMC.providers.URLFeatureProvider.extend(
    /** @lends SMC.providers.RTFeatureProvider# */
    {
        
        /**
         * Initialize the object with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.providers.URLFeatureProvider.prototype.initialize.apply(this, arguments);
            L.Util.setOptions(this, options);
        },
        /**
         * Retrieves the features from its source
         * @fires SMC.providers.FeaturesProvider#featuresLoaded
         */
        loadFeatures: function() {
            SMC.providers.URLFeatureProvider.prototype.loadFeatures.call(this);
            this._createSubscription();
        },
        /**
         * Method to create a subcription
         * @abstract
         * @private
         */
        _createSubscription: function() {
            throw new Error("SMC.providers.RTFeatureProvider::_createSubscription: must be implemented in derivate classes.");
        },

        /**
         * Method to execute when a feature have been modified. Implementations of RTFeatureProvider must contain an override of this method
         * @abstract
         * @param {object} features - Features to be modified 
         */
        onFeaturesModified: function(features) {
            throw new Error("SMC.providers.RTFeatureProvider::onFeaturesModified must be implemented by derivate classes.");
        },

        /**
         * Method to execute when a feature have been deleted. Implementations of RTFeatureProvider must contain an override of this method
         * @abstract
         * @param {object} features - Features to be deleted 
         */
        onFeaturesDeleted: function(features) {
            throw new Error("SMC.providers.RTFeatureProvider::onFeaturesDeleted must be implemented by derivate classes.");
        }

    });

},{"./URLFeatureProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/URLFeatureProvider.js","./providers.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/providers.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/SolrHistoryProvider.js":[function(require,module,exports){
require("./URLFeatureProvider.js");


/**
 * Base class to create a Solr provider
 * @class
 * @extends SMC.providers.URLFeatureProvider
 * @mixes L.Mixin.Events
 * @param {SMC.providers.SolrHistoryProvider~options} options - The configuration for the class
 *
 */
SMC.providers.SolrHistoryProvider = SMC.providers.URLFeatureProvider.extend(
    /** @lends SMC.providers.SolrHistoryProvider# */
    {
        _featuresForLayer: {},
        features: [],
       /**
        * @typedef {Object} SMC.providers.SolrHistoryProvider~options
        * @property {SMC.providers.SolrHistoryProvider~requestParams} requestParams - Default solr request parameters
        * @property {string} serverURL=null - The solr server url path parameter
        * @property {string} timeField='time' - The field for define history layers
        * @property {string} geomField='location' - The geometry field 
        * @property {string} time=500 - Time for slider in milliseconds 
        */
        options: {
            /** @typedef {Object} SMC.providers.SolrHistoryProvider~requestParams - Default solr request parameters
             * @property {string} q="*:*" - Main query for the request
             * @property {string} fq=null - Filter query that will be used to restrict the set of documents that will be returned
             * @property {string} sort=null - Order for the returned documents
             * @property {string} fl=null - Parameter for to specify a set of fields to return
             * @property {string} df=null - Parameter that override the default field defined in Solr schema xml
             * @property {string} rows=null - Parameter for specify the maximun number of documents returned
             * @property {string} wt='json' - Default solr output format parameter
             * @property {string} indent=true - Default indenting the response      
             */
            requestParams:{
               q:'*:*',
               fq:null,
               sort: null,
               fl: null,
               df: null,
               rows: null,
               wt: 'json',
               indent: true,
              
              
            },
            serverURL: null,
            timeField: 'time',
            geomField: 'location',
            time: 500
            
            
        },
        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },
        /**
         * Send Solr request to get the group layers
         */
        doFeaturesLoading: function() {
        	
            var self = this;

       
            $.ajax({
                url: this.options.serverURL + "?json.wrf=?&group=true&group.field=" + this.options.timeField,
                data: this.getParamsFromOptions(),
                dataType:'jsonp',
                success: function(result){
                   var numRows = result.grouped[self.options.timeField].matches;
                   var values = [];
                   var groups =result.grouped[self.options.timeField].groups;
                   for(var i in groups){
                        values.push(groups[i].groupValue);
                        //self._aggregatingLayers[groups[i].groupValue] = new SMC.layers.geometry.GeometryLayer(self.options);
                   }

                   self.doLayersGroupLoading(numRows, values);
          
                }
            });
            
        },

        /**
         * Get params from options attributes
         * @returns {object} Object with the Solr params to send
         */
        getParamsFromOptions: function() {
            var params = {};
            for (var option in this.options.requestParams) {
                
                if(this.options[option]){
                     params[option] = this.options[option];
                }
                else if (this.options.requestParams[option] !== null){
                    params[option] = this.options.requestParams[option];
                }
                

            }
            return params;
        },
        /**
         * Send Solr request to get the features
         */
        doLayersGroupLoading:function(rows, values){
            var self = this; 
            this.options.requestParams.rows = rows;
            var allFeatures = [];
             $.ajax({
                url: this.options.serverURL + "?json.wrf=?",
                data: this.getParamsFromOptions(),
                dataType:'jsonp',
                success: function(result){
                   var docs = result.response.docs;
       
                   for(var i in docs){
                        var f = {};

                        f.geometry = JSON.parse(docs[i][self.options.geomField]);
                        f.properties = {};
                        for(var p in docs[i]){
                            if(p == self.options.geomField){
                                continue;
                            }
                            f.properties[p] = docs[i][p];
                        }
                       allFeatures.push(f);

                   }

                   
                   for(var j in values){
                    var features = [];
                        for(var k in allFeatures){
                            if(allFeatures[k].properties[self.options.timeField] == values[j]){
                                features.push(allFeatures[k]);

                            }

                        }

                        self._featuresForLayer[values[j]] = features;
                       
                   }
                   console.log(self._featuresForLayer);
                   //override tree node for layer
                   var node = document.getElementById('node_'+self._leaflet_id);
                   if(node){
                     node.parentNode.appendChild(self.createNodeHTML());
                     node.parentNode.removeChild(node);
                   }
   
                }

            });
          
            
        }

});
/**
 * API factory method for ease creation of Solr features providers.
 * @params {Object} options - Options to initialize the Solr provider
 */
SMC.wfsProvider = function(options) {
    return new SMC.providers.WFSProvider(options);
};

},{"./URLFeatureProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/URLFeatureProvider.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/URLFeatureProvider.js":[function(require,module,exports){
require("./FeaturesProvider.js");

/**
 * Base class to create a feature provider with url
 * @class
 * @extends SMC.providers.FeaturesProvider
 * @param {SMC.providers.URLFeatureProvider~options} options - The configuration for the class
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.providers.URLFeatureProvider = SMC.providers.FeaturesProvider.extend(
    /** @lends SMC.providers.URLFeatureProvider# */
    {

        /**
         * @typedef {Object} SMC.providers.URLFeatureProvider~options
         * @property {string} url=null - The default url to the feature provider
         */
        options: {
            url: null,
            dataType: "jsonp"
        },
        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.providers.FeaturesProvider.prototype.initialize.apply(this, arguments);
            L.Util.setOptions(this, options);
        },

        /**
         * Send request to get the features
         * @returns {object} Deferred object from jQuery
         */
        doFeaturesLoading: function() {
            if (this.options.url) {
                return $.ajax({
                    url: this.options.url,
                    type: "GET",
                    dataType: this.options.dataType
                });
            }
            return $.Deferred();
        }
    }
);

},{"./FeaturesProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/FeaturesProvider.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSProvider.js":[function(require,module,exports){
require("./URLFeatureProvider.js");

/**
 * Base class to create a WFS provider
 * @class
 * @extends SMC.providers.URLFeatureProvider
 * @mixes L.Mixin.Events
 * @param {SMC.providers.WFSProvider~options} options - The configuration for the class
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.providers.WFSProvider = SMC.providers.URLFeatureProvider.extend(
    /** @lends SMC.providers.WFSProvider# */
    {
       /**
        * @typedef {Object} SMC.providers.WFSProvider~options
        * @property {SMC.providers.WFSProvider~requestParams} requestParams - Default wfs request parameters
        * @property {string} serverURL=null - The wfs server url path parameter
        * @property {string} bbox=null - The bbox parameter
        */
        options: {
            /** @typedef {Object} SMC.providers.WFSProvider~requestParams - Default wfs request parameters
             * @property {string} service="wfs" - Default wfs service
             * @property {string} version="1.1.0" - Default wfs version
             * @property {string} request="GetFeature" - Default wfs request
             * @property {string} typeName="namespace:featuretype" - Default wfs typename
             * @property {string} featureID=null - Default wfs feature id
             * @property {string} count=null - Default wfs count parameter
             * @property {string} maxFeatures=null - Default wfs max features parameter
             * @property {string} sortBy=null - Default wfs sort by parameter
             * @property {string} propertyName=null - Default wfs property name parameter
             * @property {string} srsName="EPSG:4326" - Default wfs coordinate reference system parameter
             * @property {string} cqlFilter=null - Default wfs cql filter parameter
             * @property {string} outputFormat="text/javascript" - Default wfs output format parameter
             * @property {string} format_options=null - Default wfs format options parameter
             */
            requestParams:{
                service: "wfs",
                version: "1.1.0",
                request: "GetFeature",
                typeName: "namespace:featuretype",
                featureID: null,
                count: null,
                maxFeatures: null,
                sortBy: null,
                propertyName: null,
                srsName: "EPSG:4326",
                cql_filter: null,
                outputFormat: "text/javascript",
                format_options: null
            },
            serverURL: null,
            bbox: null,
            
        },
        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            L.Util.setOptions(this, options);
        },
        /**
         * Send WFS request to get the features
         * @returns {object} Deferred object from jQuery
         */
        doFeaturesLoading: function(bounds) {
        	var jsonpRandom = this._makeid();
        	this.options.format_options = "callback:" + jsonpRandom;
            
            if (this.options.serverURL !== null) {
                var requestData = {
                    url: this.options.serverURL,
                    data: this.getParamsFromOptions(),
                    jsonpCallback: jsonpRandom,
                    type: "GET",
                    dataType: "jsonp",
                    jsonp: false
                };

               /* if(bounds){
                        this.options.requestParams.cql_filter = requestData.data.cql_filter;
                        if(requestData.data.cql_filter){
                           requestData.data.cql_filter =  this.options.requestParams.cql_filter + ' AND ' + this.options.bbox;
                        }
                        else{
                            requestData.data.cql_filter = this.options.bbox;
                        }

                }*/

                if(bounds){  
                  this.options.bbox = 'bbox('+this.options.fieldGeom +',' 
                                + bounds[1]+ ','
                                + bounds[0]+ ','
                                + bounds[3]+ ','
                                + bounds[2]
                                +')';
                  requestData.data[''] = this.options.bbox;
                }

                return $.ajax(requestData);
                
                
            }
            return $.Deferred();
        },

        /**
         * Get params from options attributes
         * @returns {object} Object with the wfs params to send
         */
        getParamsFromOptions: function() {
            var params = {};
            for (var option in this.options.requestParams) {
                
                if(this.options[option]){
                     params[option] = this.options[option];
                }
                else if (this.options.requestParams[option] !== null && option != 'cql_filter'){
                    params[option] = this.options.requestParams[option];
                }    

            }
            return params;
        },

        /**
         * Method to get an id
         * @private
         */
        _makeid: function(){
        	var text = "";
        	var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
        	for( var i=0; i < 5; i++ )
    	        text += possible.charAt(Math.floor(Math.random() * possible.length));
        	return text;
    	}
    }
);
/**
 * API factory method for ease creation of wfs features providers.
 * @params {Object} options - Options to initialize the WFS provider
 */
SMC.wfsProvider = function(options) {
    return new SMC.providers.WFSProvider(options);
};

},{"./URLFeatureProvider.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/URLFeatureProvider.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSTProvider.js":[function(require,module,exports){
require("./WFSProvider");
/**
 * Base class to create a WFS-T provider
 * @class
 * @extends SMC.providers.WFSProvider
 * @mixes L.Mixin.Events
 * @param {SMC.providers.WFSTProvider~options} options - The configuration for the class
 *
 * @author Moisés Arcos (marcos@emergya.com)
 */
SMC.providers.WFSTProvider = SMC.providers.WFSProvider.extend(
    /** @lends SMC.providers.WFSTProvider# */
    {
        /**
         * @typedef {Object} SMC.providers.WFSTProvider~options
         * @property {string} defaultNewValues=null - The default values  to the fields from feature
         * @property {string} readOnlyFields=null - The default no editable fields from feature
         */
        options: {
            defaultNewValues: {},
            readOnlyFields: []
        },

        /**
         * Initialize the class with options parameter
         * @param {object} options - default options
         */
        initialize: function(options) {
            SMC.providers.WFSProvider.prototype.initialize.call(this, options);
        },

        _getElementsByTagNameNS: function(element, namespace, tagName) {
            var elements = element.getElementsByTagName(tagName);
            if(!elements.length) {
                elements = element.getElementsByTagName(namespace +":"+tagName);
            }

            return elements;
        },

        /**
         * Method to prepare WFS-T request payload to insert a geometry
         * @private
         * @param {object} geometry - element to be added
         */
        _insert: function(geometry) {
            var self = this;
            var geom_type = this._getGeomType(geometry);
            $.ajax({
                type: "GET",
                url: this.options.serverURL + "?request=DescribeFeatureType&version=1.1.0&typename=" +
                    this.options.typeName,
                dataType: "xml",
                contentType: "text/xml",
                success: function(xml, status, object) {
                    var schema = self._getElementsByTagNameNS(xml, "xsd", "schema")[0];
                    var targetNamespace = schema.getAttribute("targetNamespace");
                    var namespace = self.options.typeName.split(":")[0];
                    var typeName = self.options.typeName.split(":")[1];
                    var srsName = self.options.srsName ?
                        self.options.requestParams.srsName :
                        "EPSG:4326";
                    var attributes = self._getElementsByTagNameNS(self._getElementsByTagNameNS(xml, "xsd","sequence")[0],"xsd",'element');
                    var theGeom = 'the_geom';
                    for (var i = 0; i < attributes.length; i++) {
                        if (attributes[i].getAttribute('type') == "gml:GeometryPropertyType") {
                            theGeom = attributes[i].getAttribute('name');
                        }
                    }
                    var postData =
                        '<wfs:Transaction version="1.1.0" service="WFS"\n' +
                        'xmlns:wfs="http://www.opengis.net/wfs"\n' + 'xmlns:' + namespace + '="' +
                        targetNamespace + '">\n' + '   <wfs:Insert>\n' + '       <' + self.options.typeName +
                        ' xmlns:feature="' + self.options.serverURL + '">\n' + '           <' +
                        namespace + ':' + theGeom + '>\n' + '               <gml:' + geom_type +
                        ' xmlns:gml="http://www.opengis.net/gml" srsName="' + srsName + '">\n' +
                        '                   <gml:pos>' + geometry.getLatLng().lng + ' ' + geometry.getLatLng()
                        .lat + '</gml:pos>\n' + '               </gml:' + geom_type + '>\n' +
                        '           </' + namespace + ':' + theGeom + '>\n' + '       </' + self.options
                        .typeName + '>\n' + '   </wfs:Insert>\n' + '</wfs:Transaction>\n';

                   self._sendRequest("POST", self.options.serverURL, postData, function(xml) {
                        var id = self._getElementsByTagNameNS(xml, "ogc", 'FeatureId')[0].getAttribute('fid');
                        self._loadMarker(id);
                        
                    });
                }
            });

        },

        _loadMarker: function(id) {
            var self = this;
            var srsName = this.options.srsName ? self.options.requestParams.srsName : "EPSG:4326";
            var jsonpRandom = this._makeid();
            var formatOptions = "callback:" + jsonpRandom;

            $.ajax({
                type: "GET",
                url: this.options.serverURL + "?service=wfs&version=1.1.0&request=GetFeature&typename=" +
                    this.options.typeName + "&srsName=" + srsName +
                    "&outputFormat=text/javascript&featureId=" + id + "&format_options=" +
                    formatOptions,
                dataType: "jsonp",
                jsonpCallback: jsonpRandom,
                jsonp: false,
                success: function(featureCollection) {
                    var feature = featureCollection.features;  
                    feature = self._setDefaultValues(feature); 
                    feature.geom_type = 'Point';
                    feature.feature = feature;
                    self._update(feature);
                    self.addMarkerFromFeature(feature);
                }
            });

        },

         _setDefaultValues: function(feature){
            var defaultValues = this.options.defaultNewValues;
            var prop = feature[0].properties;
            for(var i in prop){
                if(defaultValues[i]){
                   prop[i] = defaultValues[i];
               }
            }
            return feature[0];
        },
        /**
         * Method to prepare WFS-T request payload to update a geometry
         * @private
         * @param {object} geometry - element to be updated
         */
        _update: function(geometry) {
            var self = this;
            $.ajax({
                type: "GET",
                url: this.options.serverURL + "?request=DescribeFeatureType&version=1.1.0&typename=" +
                    this.options.typeName,
                dataType: "xml",
                contentType: "text/xml",
                success: function(xml, status, object) {
                    var srsName = self.options.srsName ? self.options.requestParams.srsName : "EPSG:4326";
                    var attributes = self._getElementsByTagNameNS(self._getElementsByTagNameNS(xml, "xsd","sequence")[0],"xsd",'element');

                    var wfs_elements = "";
                    if(!geometry.eachLayer){
                        wfs_elements = self._getWFSUpdate(geometry, srsName, attributes);
                    }else{
                        geometry.eachLayer(function(layer) {
                            // Update the edited features
                            wfs_elements += self._getWFSUpdate(layer, srsName, attributes);
                        });
                    }
                    var postData =
                        '<wfs:Transaction\n' + 'version="1.1.0"\n' + 'service="WFS"\n' +
                        'xmlns:wfs="http://www.opengis.net/wfs">\n' + wfs_elements +
                        '</wfs:Transaction>\n';

                    self._sendRequest("POST", self.options.serverURL, postData);

                }

            });

        },



        /**
         * Method to prepare WFS-T request payload to delete a geometry
         * @private
         * @param {object} geometry - element to be removed
         */
        _delete: function(geometry) {
            var self = this;
            var typeName = self.options.typeName.split(":")[1];
            var wfs_elements = "";
            geometry.eachLayer(function(layer) {
                // Update the edited features
                wfs_elements += self._getWFSDelete(typeName, layer.feature.id);
            });

            var postData =
                '<wfs:Transaction\n' + 'version="1.1.0"\n' + 'service="WFS"\n' +
                'xmlns:wfs="http://www.opengis.net/wfs">\n' + wfs_elements + '</wfs:Transaction>\n';

            this._sendRequest("POST", this.options.serverURL, postData);
        },
        /**
         * Method to send WFS-T request
         * @private
         * @param {string} url - url server where send request
         * @param {string} data - request payload
         */
        _sendRequest: function(type, url, data, method) {
            $.ajax({
                type: type,
                url: url,
                dataType: "xml",
                contentType: "text/xml",
                data: data,
                success: method
            }).fail(function(xhr, status, error) {
                console.debug(error);
            });
        },
        /**
         * Method to get the geometry type
         * @private
         * @param {Object} geometry - Geometry to get type
         * @returns {string} geometry type
         */
        _getGeomType: function(geometry) {
            var geom_type = null;
            if (geometry instanceof L.Marker || geometry instanceof L.Point) {
                geom_type = "Point";
            }
            if(geometry.geom_type){
                geom_type = geometry.geom_type;
            }
            return geom_type;
        },
        /**
         * Method to get the wfs delete request
         * @private
         * @param {Object} typeName - type name layer
         * @param {string} featureId - id from the element to remove
         * @returns {string} request filter to remove elements
         */
        _getWFSDelete: function(typeName, featureId) {
            var res =
                '   <wfs:Delete typeName="feature:' + typeName + '" xmlns:feature="http://opengeo.org">\n' +
                '       <ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">\n' +
                '           <ogc:FeatureId fid="' + featureId + '"/>\n' + '       </ogc:Filter>\n' +
                '   </wfs:Delete>\n';
            return res;
        },
        /**
         * Method to get the wfs update request
         * @private
         * @param {Object} geometry - type name layer
         * @param {string} srsName - layer srs
         * @returns {string} request filter to update elements
         */
        _getWFSUpdate: function(geometry, srsName, attributes) {
            var geom_type = this._getGeomType(geometry);
            var lat, lng;
            if(geometry.getLatLng){
                lat = geometry.getLatLng().lat;
                lng = geometry.getLatLng().lng;
            }
            else{
                lat = geometry.geometry.coordinates[1];
                lng = geometry.geometry.coordinates[0];
            }
            var typeName = this.options.typeName.split(":")[1];
            var res = ' <wfs:Update typeName="feature:' + typeName + '" xmlns:feature="http://opengeo.org">\n';
            for (var i = 0; i < attributes.length; i++) {
                var name = attributes[i].getAttribute('name');
                res += '       <wfs:Property>\n'

                + '           <wfs:Name>' + name + '</wfs:Name>\n'

                + '           <wfs:Value>\n';
                if (attributes[i].getAttribute('type') == 'gml:GeometryPropertyType' || attributes[i].getAttribute('type') == 'gml:PointPropertyType') {
                    res += '               <gml:' + geom_type +
                        ' xmlns:gml="http://www.opengis.net/gml" srsName="' + srsName + '">\n' +
                        '                   <gml:pos>' + lng + ' ' + lat +
                        '</gml:pos>\n' + '               </gml:' + geom_type + '>\n';
                } else if (geometry.feature.properties[name] != null) {
                    res += geometry.feature.properties[name];
                }
                res += '           </wfs:Value>\n'

                + '       </wfs:Property>\n';
            }
            res += '       <ogc:Filter xmlns:ogc="http://www.opengis.net/ogc">\n' +
                '           <ogc:FeatureId fid="' + geometry.feature.id + '"/>\n' + '       </ogc:Filter>\n' +
                '   </wfs:Update>\n';
            return res;
        },
    }, [SMC.providers.WFSProvider]);
/**
 * API factory method for ease creation of wfs features providers.
 * @params {Object} options - Options to initialize the WFS provider
 */
SMC.wfstProvider = function(options) {
    return new SMC.providers.WFSTProvider(options);
};

},{"./WFSProvider":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/WFSProvider.js"}],"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/providers/providers.js":[function(require,module,exports){
require("../SMC.js");

/**
 * Namespace of SMC.Viewer's data providers for use by layers.
 * @namespace
 * @memberof SMC
 * @author Luis Román (lroman@emergya.com)
 */
SMC.providers = {};
},{"../SMC.js":"/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/src/SMC.js"}]},{},["/home/lroman/Proyectos/smartcity/projects/SMCMapViewer/build/api-deps.js"])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy93YXRjaGlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1wYWNrL19wcmVsdWRlLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2J1aWxkL2FwaS1kZXBzLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9MZWFmbGV0SHRtbEljb24uanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvbGliL2F0bW9zcGhlcmUtanF1ZXJ5L2pxdWVyeS5hdG1vc3BoZXJlLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9jYW52YXNMYXllci9sZWFmbGV0X2NhbnZhc19sYXllci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvbGVhZmxldC5kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvbGVhZmxldC9sZWFmbGV0LXNyYy5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvbXVzdGFjaGUuanMvbXVzdGFjaGUuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvbGliL3BhcGVyL2Rpc3QvcGFwZXItZnVsbC5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvcGVnanMvbGliL2NvbXBpbGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9wZWdqcy9saWIvY29tcGlsZXIvb3Bjb2Rlcy5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvcGVnanMvbGliL2NvbXBpbGVyL3Bhc3Nlcy9nZW5lcmF0ZS1ieXRlY29kZS5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvcGVnanMvbGliL2NvbXBpbGVyL3Bhc3Nlcy9nZW5lcmF0ZS1qYXZhc2NyaXB0LmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9wZWdqcy9saWIvY29tcGlsZXIvcGFzc2VzL3JlbW92ZS1wcm94eS1ydWxlcy5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9saWIvcGVnanMvbGliL2NvbXBpbGVyL3Bhc3Nlcy9yZXBvcnQtbGVmdC1yZWN1cnNpb24uanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvbGliL3BlZ2pzL2xpYi9jb21waWxlci9wYXNzZXMvcmVwb3J0LW1pc3NpbmctcnVsZXMuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvbGliL3BlZ2pzL2xpYi9ncmFtbWFyLWVycm9yLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9wZWdqcy9saWIvcGFyc2VyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9wZWdqcy9saWIvcGVnLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL2xpYi9wZWdqcy9saWIvdXRpbHMuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvbGliL3JidXNoLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9MYXllckxvYWRlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvTWFwLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9TTUMuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL1V0aWwuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2NvbnRyb2xzL0lzb2Nocm9uZUNvbnRyb2wuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2NvbnRyb2xzL2NvbnRyb2xzLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9jb250cm9scy9sYXllclRyZWUvTGF5ZXJUcmVlQ29udHJvbC5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvY29udHJvbHMvbGF5ZXJUcmVlL0xheWVyVHJlZUZvbGRlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvY29udHJvbHMvbGF5ZXJUcmVlL0xheWVyVHJlZUxlYWYuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2NvbnRyb2xzL2xheWVyVHJlZS9MYXllclRyZWVOb2RlLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9jb250cm9scy9sYXllclRyZWUvbGF5ZXJUcmVlLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvRWRpdGFibGVMYXllci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL0ZvbGRlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL0lzb2Nocm9uZUxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvTGF5ZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9TaW5nbGVMYXllci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL1RpbGVMYXllci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL1dNU0xheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvYWdncmVnYXRpb24vQWdncmVnYXRpbmdMYXllci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL2FnZ3JlZ2F0aW9uL011bHRpTW9kZUxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvYWdncmVnYXRpb24vYWdncmVnYXRpb24uanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9nZW9tZXRyeS9DYW52YXNSZW5kZXJlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL2dlb21ldHJ5L0dlb21ldHJ5TGF5ZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9nZW9tZXRyeS9Tb2xyR2VvbWV0cnlIaXN0b3J5TGF5ZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9nZW9tZXRyeS9UaWxlZEdlb21ldHJ5TGF5ZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9nZW9tZXRyeS9XRlNHZW9tZXRyeUxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvZ2VvbWV0cnkvV0ZTVGlsZWRHZW9tZXRyeUxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvZ2VvbWV0cnkvZ2VvbWV0cnkuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9oaXN0b3J5L0FnZ3JlZ2F0aW5nSGlzdG9yeUxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvaGlzdG9yeS9EYXRhSGlzdG9yeUxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvaGlzdG9yeS9oaXN0b3J5LmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvbGF5ZXJzLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvbWFya2Vycy9BdG1vc3BoZXJlUlRNYXJrZXJMYXllci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL21hcmtlcnMvTWFya2VyTGF5ZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9tYXJrZXJzL1dGU01hcmtlckxheWVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvbWFya2Vycy9XRlNUTWFya2VyTGF5ZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9tYXJrZXJzL21hcmtlcnMuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9yZWxvYWRlcnMvQXRtb3NwaGVyZVJUUmVsb2FkVHJpZ2dlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL3JlbG9hZGVycy9MYXllclJlbG9hZGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvcmVsb2FkZXJzL1JlbG9hZFRyaWdnZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9yZWxvYWRlcnMvVGltZXJSZWxvYWRUcmlnZ2VyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvcmVsb2FkZXJzL3JlbG9hZGVycy5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvbGF5ZXJzL3N0eWxlcnMvTWFwQ3NzU3R5bGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvc3R5bGVycy9NYXJrZXJDc3NTdHlsZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9zdHlsZXJzL1BhcnNlckZ1bmN0aW9uLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9sYXllcnMvc3R5bGVycy9TdHlsZXIuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL2xheWVycy9zdHlsZXJzL3N0eWxlcnMuanMiLCIvaG9tZS9scm9tYW4vUHJveWVjdG9zL3NtYXJ0Y2l0eS9wcm9qZWN0cy9TTUNNYXBWaWV3ZXIvc3JjL3Byb3ZpZGVycy9BdG1vc3BoZXJlQ29ubmVjdG9yLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9wcm92aWRlcnMvQXRtb3NwaGVyZVJURmVhdHVyZVByb3ZpZGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9wcm92aWRlcnMvRmVhdHVyZXNQcm92aWRlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvcHJvdmlkZXJzL1JURmVhdHVyZVByb3ZpZGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9wcm92aWRlcnMvU29sckhpc3RvcnlQcm92aWRlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvcHJvdmlkZXJzL1VSTEZlYXR1cmVQcm92aWRlci5qcyIsIi9ob21lL2xyb21hbi9Qcm95ZWN0b3Mvc21hcnRjaXR5L3Byb2plY3RzL1NNQ01hcFZpZXdlci9zcmMvcHJvdmlkZXJzL1dGU1Byb3ZpZGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9wcm92aWRlcnMvV0ZTVFByb3ZpZGVyLmpzIiwiL2hvbWUvbHJvbWFuL1Byb3llY3Rvcy9zbWFydGNpdHkvcHJvamVjdHMvU01DTWFwVmlld2VyL3NyYy9wcm92aWRlcnMvcHJvdmlkZXJzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdtR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25vR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5akVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0L1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNybVpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeDlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3dUZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdGhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ByQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeFNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6T0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BwRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIlxucmVxdWlyZShcIi4uL3NyYy9VdGlsLmpzXCIpO1xuXG5cblxucmVxdWlyZShcIi4uL3NyYy9sYXllcnMvV01TTGF5ZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9UaWxlTGF5ZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9tYXJrZXJzL01hcmtlckxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uL3NyYy9sYXllcnMvZ2VvbWV0cnkvR2VvbWV0cnlMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL2dlb21ldHJ5L1RpbGVkR2VvbWV0cnlMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL0ZvbGRlci5qc1wiKTtcblxucmVxdWlyZShcIi4uL3NyYy9wcm92aWRlcnMvV0ZTUHJvdmlkZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9tYXJrZXJzL1dGU01hcmtlckxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uL3NyYy9sYXllcnMvZ2VvbWV0cnkvV0ZTR2VvbWV0cnlMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL2dlb21ldHJ5L1dGU1RpbGVkR2VvbWV0cnlMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL21hcmtlcnMvQXRtb3NwaGVyZVJUTWFya2VyTGF5ZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9tYXJrZXJzL0F0bW9zcGhlcmVSVE1hcmtlckxheWVyLmpzXCIpO1xuXG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9hZ2dyZWdhdGlvbi9BZ2dyZWdhdGluZ0xheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uL3NyYy9sYXllcnMvaGlzdG9yeS9BZ2dyZWdhdGluZ0hpc3RvcnlMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL2hpc3RvcnkvRGF0YUhpc3RvcnlMYXllci5qc1wiKTtcblxucmVxdWlyZShcIi4uL3NyYy9sYXllcnMvYWdncmVnYXRpb24vTXVsdGlNb2RlTGF5ZXIuanNcIik7XG5cbnJlcXVpcmUoXCIuLi9zcmMvcHJvdmlkZXJzL1dGU1RQcm92aWRlci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL0VkaXRhYmxlTGF5ZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9tYXJrZXJzL1dGU1RNYXJrZXJMYXllci5qc1wiKTtcblxucmVxdWlyZShcIi4uL3NyYy9sYXllcnMvcmVsb2FkZXJzL1RpbWVyUmVsb2FkVHJpZ2dlci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL3JlbG9hZGVycy9BdG1vc3BoZXJlUlRSZWxvYWRUcmlnZ2VyLmpzXCIpO1xuXG5yZXF1aXJlKFwiLi4vc3JjL2xheWVycy9Jc29jaHJvbmVMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvY29udHJvbHMvSXNvY2hyb25lQ29udHJvbC5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL3N0eWxlcnMvUGFyc2VyRnVuY3Rpb24uanNcIik7XG5cbi8vcmVxdWlyZShcIi4uL3NyYy9wcm92aWRlcnMvU29sckhpc3RvcnlQcm92aWRlci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9zcmMvbGF5ZXJzL2dlb21ldHJ5L1NvbHJHZW9tZXRyeUhpc3RvcnlMYXllci5qc1wiKTsiLCIvKipcbiAqIFBsdWdpbiBmb3IgYWRkaW5nIGFyYml0cmFyeSBIVE1MIG1hcmtlcnMgdG8gYSBMZWFmbGV0IG1hcFxuICogaHR0cHM6Ly9naXRodWIuY29tL2R3bm9ibGUvTGVhZmxldEh0bWxJY29uXG4gKiBcbiAqIFB1YmxpYyBkb21haW5cbiAqIFxuICovXG5cbkwuSHRtbEljb24gPSBMLkljb24uZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdC8qXG5cdFx0aHRtbDogKFN0cmluZykgKHJlcXVpcmVkKVxuXHRcdGljb25BbmNob3I6IChQb2ludClcblx0XHRwb3B1cEFuY2hvcjogKFBvaW50KVxuXHRcdCovXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGRpdi5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuaHRtbDtcblx0XHRyZXR1cm4gZGl2O1xuXHR9LFxuXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG59KTtcblxuIiwiLypcbiAqIENvcHlyaWdodCAyMDE0IEplYW5mcmFuY29pcyBBcmNhbmRcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBBdG1vc3BoZXJlLmpzXG4gKiBodHRwczovL2dpdGh1Yi5jb20vQXRtb3NwaGVyZS9hdG1vc3BoZXJlLWphdmFzY3JpcHRcbiAqIFxuICogUmVxdWlyZXMgXG4gKiAtIGpRdWVyeSAyLjAuMyBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqIFxuICogQVBJIHJlZmVyZW5jZVxuICogaHR0cHM6Ly9naXRodWIuY29tL0F0bW9zcGhlcmUvYXRtb3NwaGVyZS93aWtpL2pRdWVyeS5hdG1vc3BoZXJlLmpzLUFQSVxuICogXG4gKiBIaWdobHkgaW5zcGlyZWQgYnkgXG4gKiAtIFBvcnRhbCBieSBEb25naHdhbiBLaW0gaHR0cDovL2Zsb3dlcnNpbnRoZXNhbmQuZ2l0aHViLmlvL3BvcnRhbC9cbiAqL1xuKGZ1bmN0aW9uKGZhY3RvcnkpIHtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIC8vIEFNRFxuICAgICAgICBkZWZpbmUoWydqcXVlcnknXSwgZmFjdG9yeSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQnJvd3NlciBnbG9iYWxzLCBXaW5kb3dcbiAgICAgICAgZmFjdG9yeShqUXVlcnkpO1xuICAgIH1cbn0oZnVuY3Rpb24oalF1ZXJ5KSB7XG5cbiAgICBqUXVlcnkod2luZG93KS5iaW5kKFwidW5sb2FkLmF0bW9zcGhlcmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuXG4gICAgalF1ZXJ5KHdpbmRvdykuYmluZChcIm9mZmxpbmVcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS51bnN1YnNjcmliZSgpO1xuICAgIH0pO1xuXG4gICAgLy8gUHJldmVudCBFU0MgdG8ga2lsbCB0aGUgY29ubmVjdGlvbiBmcm9tIEZpcmVmb3guXG4gICAgalF1ZXJ5KHdpbmRvdykua2V5cHJlc3MoZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHBhcnNlSGVhZGVycyA9IGZ1bmN0aW9uIChoZWFkZXJTdHJpbmcpIHtcbiAgICAgICAgdmFyIG1hdGNoLCByaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKVxccj8kL21nLCBoZWFkZXJzID0ge307XG4gICAgICAgIHdoaWxlIChtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoaGVhZGVyU3RyaW5nKSkge1xuICAgICAgICAgICAgaGVhZGVyc1ttYXRjaFsxXV0gPSBtYXRjaFsyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9O1xuXG4gICAgalF1ZXJ5LmF0bW9zcGhlcmUgPSB7XG4gICAgICAgIHZlcnNpb246IFwiMi4yLjEtanF1ZXJ5XCIsXG4gICAgICAgIHV1aWQgOiAwLFxuICAgICAgICByZXF1ZXN0czogW10sXG4gICAgICAgIGNhbGxiYWNrczogW10sXG5cbiAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB9LFxuICAgICAgICBvbk9wZW46IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB9LFxuICAgICAgICBvbk1lc3NhZ2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB9LFxuICAgICAgICBvblJlY29ubmVjdDogZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTWVzc2FnZVB1Ymxpc2hlZDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVHJhbnNwb3J0RmFpbHVyZTogZnVuY3Rpb24gKGVycm9yTWVzc2FnZSwgX3JlcXVlc3QpIHtcbiAgICAgICAgfSxcbiAgICAgICAgb25Mb2NhbE1lc3NhZ2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICB9LFxuICAgICAgICBvbkNsaWVudFRpbWVvdXQ6IGZ1bmN0aW9uKHJlcXVlc3Qpe1xuICAgICAgICB9LFxuICAgICAgICBvbkZhaWx1cmVUb1JlY29ubmVjdDogZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGJhc2VkIG9uIGFuIGF0bW9zcGhlcmUgc3Vic2NyaXB0aW9uIHRoYXQgZXhwb3NlcyBmdW5jdGlvbnMgZGVmaW5lZCBieSB0aGUgV2Vic29ja2V0IGludGVyZmFjZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQGNsYXNzIFdlYnNvY2tldEFwaUFkYXB0ZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3QgdGhlIHJlcXVlc3Qgb2JqZWN0IHRvIGJ1aWxkIHRoZSB1bmRlcmx5aW5nIHN1YnNjcmlwdGlvblxuICAgICAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgICAgICovXG4gICAgICAgIFdlYnNvY2tldEFwaUFkYXB0ZXI6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICB2YXIgX3NvY2tldCwgX2FkYXB0ZXI7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogT3ZlcnJpZGVzIHRoZSBvbk1lc3NhZ2UgY2FsbGJhY2sgaW4gZ2l2ZW4gcmVxdWVzdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAbWV0aG9kIG9uTWVzc2FnZVxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGUgdGhlIGV2ZW50IG9iamVjdFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXF1ZXN0Lm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgX2FkYXB0ZXIub25tZXNzYWdlKHtkYXRhOiBlLnJlc3BvbnNlQm9keX0pO1xuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE92ZXJyaWRlcyB0aGUgb25PcGVuIGNhbGxiYWNrIGluIGdpdmVuIHJlcXVlc3QgdG8gcHJveHkgdGhlIGV2ZW50IHRvIHRoZSBhZGFwdGVyLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBtZXRob2Qgb25PcGVuXG4gICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZSB0aGUgZXZlbnQgb2JqZWN0XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlcXVlc3Qub25PcGVuID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICBfYWRhcHRlci5vbm9wZW4oZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBfYWRhcHRlciA9IHtcbiAgICAgICAgICAgICAgICBzZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBfc29ja2V0LnB1c2goZGF0YSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIG9ubWVzc2FnZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBvbm9wZW46IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb25jbG9zZTogZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgb25lcnJvcjogZnVuY3Rpb24gKGUpIHtcblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBfc29ja2V0ID0gbmV3ICQuYXRtb3NwaGVyZS5zdWJzY3JpYmUocmVxdWVzdCk7XG5cbiAgICAgICAgICAgIHJldHVybiBfYWRhcHRlcjtcbiAgICAgICAgfSxcblxuICAgICAgICBBdG1vc3BoZXJlUmVxdWVzdDogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB7T2JqZWN0fSBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIF9yZXF1ZXN0ID0ge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDMwMDAwMCxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHt9LFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiAnJyxcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICB1cmw6ICcnLFxuICAgICAgICAgICAgICAgIGRhdGE6ICcnLFxuICAgICAgICAgICAgICAgIHN1c3BlbmQ6IHRydWUsXG4gICAgICAgICAgICAgICAgbWF4UmVxdWVzdDogLTEsXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIG1heFN0cmVhbWluZ0xlbmd0aDogMTAwMDAwMDAsXG4gICAgICAgICAgICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgICAgICAgICAgIGxvZ0xldmVsOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgcmVxdWVzdENvdW50OiAwLFxuICAgICAgICAgICAgICAgIGZhbGxiYWNrTWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBmYWxsYmFja1RyYW5zcG9ydDogJ3N0cmVhbWluZycsXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0OiAnbG9uZy1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICB3ZWJTb2NrZXRJbXBsOiBudWxsLFxuICAgICAgICAgICAgICAgIHdlYlNvY2tldEJpbmFyeVR5cGU6IG51bGwsXG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hVcmw6IG51bGwsXG4gICAgICAgICAgICAgICAgd2ViU29ja2V0UGF0aERlbGltaXRlcjogXCJAQFwiLFxuICAgICAgICAgICAgICAgIGVuYWJsZVhEUjogZmFsc2UsXG4gICAgICAgICAgICAgICAgcmV3cml0ZVVSTDogZmFsc2UsXG4gICAgICAgICAgICAgICAgYXR0YWNoSGVhZGVyc0FzUXVlcnlTdHJpbmc6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhlY3V0ZUNhbGxiYWNrQmVmb3JlUmVjb25uZWN0OiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZWFkeVN0YXRlOiAwLFxuICAgICAgICAgICAgICAgIGxhc3RUaW1lc3RhbXA6IDAsXG4gICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB0cmFja01lc3NhZ2VMZW5ndGg6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG1lc3NhZ2VEZWxpbWl0ZXI6ICd8JyxcbiAgICAgICAgICAgICAgICBjb25uZWN0VGltZW91dDogLTEsXG4gICAgICAgICAgICAgICAgcmVjb25uZWN0SW50ZXJ2YWw6IDAsXG4gICAgICAgICAgICAgICAgZHJvcEhlYWRlcnM6IHRydWUsXG4gICAgICAgICAgICAgICAgdXVpZDogMCxcbiAgICAgICAgICAgICAgICBzaGFyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJlYWRSZXNwb25zZXNIZWFkZXJzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBtYXhSZWNvbm5lY3RPbkNsb3NlOiA1LFxuICAgICAgICAgICAgICAgIGVuYWJsZVByb3RvY29sOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvbGxpbmdJbnRlcnZhbCA6IDAsXG4gICAgICAgICAgICAgICAgaGVhcnRiZWF0OiB7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgc2VydmVyOiBudWxsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhY2tJbnRlcnZhbDogMCxcbiAgICAgICAgICAgICAgICBvbkVycm9yOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xvc2U6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25PcGVuOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uTWVzc2FnZTogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblJlb3BlbjogZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvblJlY29ubmVjdDogZnVuY3Rpb24gKHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbk1lc3NhZ2VQdWJsaXNoZWQ6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25UcmFuc3BvcnRGYWlsdXJlOiBmdW5jdGlvbiAocmVhc29uLCByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBvbkxvY2FsTWVzc2FnZTogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uRmFpbHVyZVRvUmVjb25uZWN0OiBmdW5jdGlvbiAocmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG9uQ2xpZW50VGltZW91dDogZnVuY3Rpb24ocmVxdWVzdCl7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB7T2JqZWN0fSBSZXF1ZXN0J3MgbGFzdCByZXNwb25zZS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3Jlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgIHN0YXR1czogMjAwLFxuICAgICAgICAgICAgICAgIHJlYXNvblBocmFzZTogXCJPS1wiLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlQm9keTogJycsXG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IFtdLFxuICAgICAgICAgICAgICAgIHN0YXRlOiBcIm1lc3NhZ2VSZWNlaXZlZFwiLFxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogXCJwb2xsaW5nXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogbnVsbCxcbiAgICAgICAgICAgICAgICBwYXJ0aWFsTWVzc2FnZTogXCJcIixcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZWQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNsb3NlZEJ5Q2xpZW50VGltZW91dDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZmZUcnlpbmdSZWNvbm5lY3QgOiBmYWxzZVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB7d2Vic29ja2V0fSBPcGVuZWQgd2ViIHNvY2tldC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3dlYnNvY2tldCA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICoge1NTRX0gT3BlbmVkIFNTRS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3NzZSA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICoge1hNTEh0dHBSZXF1ZXN0LCBBY3RpdmVYT2JqZWN0fSBPcGVuZWQgYWpheCByZXF1ZXN0IChpbiBjYXNlIG9mIGh0dHAtc3RyZWFtaW5nIG9yIGxvbmctcG9sbGluZylcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX2FjdGl2ZVJlcXVlc3QgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHtPYmplY3R9IE9iamVjdCB1c2UgZm9yIHN0cmVhbWluZyB3aXRoIElFLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHZhciBfaWVTdHJlYW0gPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHtPYmplY3R9IE9iamVjdCB1c2UgZm9yIGpzb25wIHRyYW5zcG9ydC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX2pxeGhyID0gbnVsbDtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiB7Ym9vbGVhbn0gSWYgcmVxdWVzdCBoYXMgYmVlbiBzdWJzY3JpYmVkIG9yIG5vdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3N1YnNjcmliZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHtudW1iZXJ9IE51bWJlciBvZiB0ZXN0IHJlY29ubmVjdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3JlcXVlc3RDb3VudCA9IDA7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICoge2Jvb2xlYW59IElmIHJlcXVlc3QgaXMgY3VycmVudGx5IGFib3JkZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIF9hYm9yZGluZ0Nvbm5lY3Rpb24gPSBmYWxzZTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBBIGxvY2FsIFwiY2hhbm5lbCcgb2YgY29tbXVuaWNhdGlvbi5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX2xvY2FsU29ja2V0RiA9IG51bGw7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVGhlIHN0b3JhZ2UgdXNlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX3N0b3JhZ2VTZXJ2aWNlO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvY2FsIGNvbW11bmljYXRpb25cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB2YXIgX2xvY2FsU3RvcmFnZVNlcnZpY2UgPSBudWxsO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEEgVW5pcXVlIElEXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgdmFyIGd1aWQgPSBqUXVlcnkubm93KCk7XG5cbiAgICAgICAgICAgIC8qKiBUcmFjZSB0aW1lICovXG4gICAgICAgICAgICB2YXIgX3RyYWNlVGltZXI7XG5cbiAgICAgICAgICAgIC8qKiBLZXkgZm9yIGNvbm5lY3Rpb24gc2hhcmluZyAqL1xuICAgICAgICAgICAgdmFyIF9zaGFyaW5nS2V5O1xuXG4gICAgICAgICAgICAvLyBBdXRvbWF0aWMgY2FsbCB0byBzdWJzY3JpYmVcbiAgICAgICAgICAgIF9zdWJzY3JpYmUob3B0aW9ucyk7XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW5pdGlhbGl6ZSBhdG1vc3BoZXJlIHJlcXVlc3Qgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbml0KCkge1xuICAgICAgICAgICAgICAgIF9zdWJzY3JpYmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBfYWJvcmRpbmdDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3JlcXVlc3RDb3VudCA9IDA7XG5cbiAgICAgICAgICAgICAgICBfd2Vic29ja2V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfc3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICBfYWN0aXZlUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgX2llU3RyZWFtID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZS1pbml0aWFsaXplIGF0bW9zcGhlcmUgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWluaXQoKSB7XG4gICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBfaW5pdCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFN1YnNjcmliZSByZXF1ZXN0IHVzaW5nIHJlcXVlc3QgdHJhbnNwb3J0LiA8YnI+XG4gICAgICAgICAgICAgKiBJZiByZXF1ZXN0IGlzIGN1cnJlbnRseSBvcGVuZWQsIHRoaXMgb25lIHdpbGwgYmUgY2xvc2VkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfc3Vic2NyaWJlKG9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBfcmVpbml0KCk7XG5cbiAgICAgICAgICAgICAgICBfcmVxdWVzdCA9IGpRdWVyeS5leHRlbmQoX3JlcXVlc3QsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIC8vIEFsbG93IGF0IGxlYXN0IDEgcmVxdWVzdFxuICAgICAgICAgICAgICAgIF9yZXF1ZXN0Lm1yZXF1ZXN0ID0gX3JlcXVlc3QucmVjb25uZWN0O1xuICAgICAgICAgICAgICAgIGlmICghX3JlcXVlc3QucmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LnJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIENoZWNrIGlmIHdlYiBzb2NrZXQgaXMgc3VwcG9ydGVkIChjaGVjayBmb3IgY3VzdG9tIGltcGxlbWVudGF0aW9uIHByb3ZpZGVkIGJ5IHJlcXVlc3Qgb2JqZWN0IG9yIGJyb3dzZXIgaW1wbGVtZW50YXRpb24pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHdlYiBzb2NrZXQgaXMgc3VwcG9ydGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfc3VwcG9ydFdlYnNvY2tldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlcXVlc3Qud2ViU29ja2V0SW1wbCAhPSBudWxsIHx8IHdpbmRvdy5XZWJTb2NrZXQgfHwgd2luZG93Lk1veldlYlNvY2tldDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDaGVjayBpZiBzZXJ2ZXIgc2lkZSBldmVudHMgKFNTRSkgaXMgc3VwcG9ydGVkIChjaGVjayBmb3IgY3VzdG9tIGltcGxlbWVudGF0aW9uIHByb3ZpZGVkIGJ5IHJlcXVlc3Qgb2JqZWN0IG9yIGJyb3dzZXIgaW1wbGVtZW50YXRpb24pLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHdlYiBzb2NrZXQgaXMgc3VwcG9ydGVkLCBmYWxzZSBvdGhlcndpc2UuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfc3VwcG9ydFNTRSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LkV2ZW50U291cmNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9wZW4gcmVxdWVzdCB1c2luZyByZXF1ZXN0IHRyYW5zcG9ydC4gPGJyPlxuICAgICAgICAgICAgICogSWYgcmVxdWVzdCB0cmFuc3BvcnQgaXMgJ3dlYnNvY2tldCcgYnV0IHdlYnNvY2tldCBjYW4ndCBiZSBvcGVuZWQsIHJlcXVlc3Qgd2lsbCBhdXRvbWF0aWNhbGx5IHJlY29ubmVjdCB1c2luZyBmYWxsYmFjayB0cmFuc3BvcnQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2V4ZWN1dGUoKSB7XG4gICAgICAgICAgICAgICAgLy8gU2hhcmVkIGFjcm9zcyBtdWx0aXBsZSB0YWJzL3dpbmRvd3MuXG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LnNoYXJlZCkge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxTdG9yYWdlU2VydmljZSA9IF9sb2NhbChfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfbG9jYWxTdG9yYWdlU2VydmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QubG9nTGV2ZWwgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5kZWJ1ZyhcIlN0b3JhZ2Ugc2VydmljZSBhdmFpbGFibGUuIEFsbCBjb21tdW5pY2F0aW9uIHdpbGwgYmUgbG9jYWxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfbG9jYWxTdG9yYWdlU2VydmljZS5vcGVuKF9yZXF1ZXN0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIExvY2FsIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5kZWJ1ZyhcIk5vIFN0b3JhZ2Ugc2VydmljZSBhdmFpbGFibGUuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFdhc24ndCBsb2NhbCBvciBhbiBlcnJvciBvY2N1cnJlZFxuICAgICAgICAgICAgICAgICAgICBfbG9jYWxTdG9yYWdlU2VydmljZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gUHJvdG9jb2xcbiAgICAgICAgICAgICAgICBfcmVxdWVzdC5maXJzdE1lc3NhZ2UgPSBqUXVlcnkuYXRtb3NwaGVyZS51dWlkID09IDAgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICAgICAgX3JlcXVlc3QuaXNPcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3JlcXVlc3QuY3RpbWUgPSBqUXVlcnkubm93KCk7XG5cbiAgICAgICAgICAgICAgICAvLyBXZSBjYXJyeSBhbnkgVVVJRCBzZXQgYnkgdGhlIHVzZXIgb3IgZnJvbSBhIHByZXZpb3VzIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LnV1aWQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3QudXVpZCA9IGpRdWVyeS5hdG1vc3BoZXJlLnV1aWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF9yZXF1ZXN0LmNsb3NlZEJ5Q2xpZW50VGltZW91dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LnRyYW5zcG9ydCAhPT0gJ3dlYnNvY2tldCcgJiYgX3JlcXVlc3QudHJhbnNwb3J0ICE9PSAnc3NlJykge1xuICAgICAgICAgICAgICAgICAgICBfZXhlY3V0ZVJlcXVlc3QoX3JlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfcmVxdWVzdC50cmFuc3BvcnQgPT09ICd3ZWJzb2NrZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghX3N1cHBvcnRXZWJzb2NrZXQoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlY29ubmVjdFdpdGhGYWxsYmFja1RyYW5zcG9ydChcIldlYnNvY2tldCBpcyBub3Qgc3VwcG9ydGVkLCB1c2luZyByZXF1ZXN0LmZhbGxiYWNrVHJhbnNwb3J0IChcIiArIF9yZXF1ZXN0LmZhbGxiYWNrVHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXhlY3V0ZVdlYlNvY2tldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9yZXF1ZXN0LnRyYW5zcG9ydCA9PT0gJ3NzZScpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfc3VwcG9ydFNTRSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0V2l0aEZhbGxiYWNrVHJhbnNwb3J0KFwiU2VydmVyIFNpZGUgRXZlbnRzKFNTRSkgaXMgbm90IHN1cHBvcnRlZCwgdXNpbmcgcmVxdWVzdC5mYWxsYmFja1RyYW5zcG9ydCAoXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICArIF9yZXF1ZXN0LmZhbGxiYWNrVHJhbnNwb3J0ICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V4ZWN1dGVTU0UoZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBfbG9jYWwocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIHZhciB0cmFjZSwgY29ubmVjdG9yLCBvcnBoYW4sIG5hbWUgPSBcImF0bW9zcGhlcmUtXCIgKyByZXF1ZXN0LnVybCwgY29ubmVjdG9ycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFqUXVlcnkuYXRtb3NwaGVyZS5zdXBwb3J0U3RvcmFnZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2UsIGdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4galF1ZXJ5LnBhcnNlSlNPTihzdG9yYWdlLmdldEl0ZW0obmFtZSArIFwiLVwiICsga2V5KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCBzZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShuYW1lICsgXCItXCIgKyBrZXksIGpRdWVyeS5zdHJpbmdpZnlKU09OKHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0KFwiY2hpbGRyZW5cIiwgZ2V0KFwiY2hpbGRyZW5cIikuY29uY2F0KFtndWlkXSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkod2luZG93KS5vbihcInN0b3JhZ2Uuc29ja2V0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gbmFtZSAmJiBldmVudC5uZXdWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyKGV2ZW50Lm5ld1ZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXQoXCJvcGVuZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0SXRlbShuYW1lLCBqUXVlcnkuc3RyaW5naWZ5SlNPTih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwicFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGluZGV4LCBjaGlsZHJlbiA9IGdldChcImNoaWxkcmVuXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeSh3aW5kb3cpLm9mZihcInN0b3JhZ2Uuc29ja2V0XCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0galF1ZXJ5LmluQXJyYXkocmVxdWVzdC5pZCwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldChcImNoaWxkcmVuXCIsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd3JlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHdpbiA9IHdpbmRvdy5vcGVuKFwiXCIsIG5hbWUucmVwbGFjZSgvXFxXL2csIFwiXCIpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4gfHwgd2luLmNsb3NlZCB8fCAhd2luLmNhbGxiYWNrcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5jYWxsYmFja3MucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbi5jaGlsZHJlbi5wdXNoKGd1aWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd2luLm9wZW5lZDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3aW4uY2xvc2VkICYmIHdpbi5maXJlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4uZmlyZShqUXVlcnkuc3RyaW5naWZ5SlNPTih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBcInBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaW5kZXggPSBqUXVlcnkuaW5BcnJheShlLCBhcnJheSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5kZXggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFycmF5LnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmVzIHRyYWNlcyBvbmx5IGlmIHRoZSBwYXJlbnQgaXMgYWxpdmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFvcnBoYW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSh3aW4uY2FsbGJhY2tzLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUod2luLmNoaWxkcmVuLCBndWlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAvLyBSZWNlaXZlcyBvcGVuLCBjbG9zZSBhbmQgbWVzc2FnZSBjb21tYW5kIGZyb20gdGhlIHBhcmVudFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxpc3RlbmVyKHN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29tbWFuZCA9IGpRdWVyeS5wYXJzZUpTT04oc3RyaW5nKSwgZGF0YSA9IGNvbW1hbmQuZGF0YTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC50YXJnZXQgPT09IFwiY1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNvbW1hbmQudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcGVuKFwib3BlbmluZ1wiLCAnbG9jYWwnLCBfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbG9zZVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW9ycGhhbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JwaGFuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnJlYXNvbiA9PT0gXCJhYm9ydGVkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gR2l2ZXMgdGhlIGhlaXIgc29tZSB0aW1lIHRvIHJlY29ubmVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmhlaXIgPT09IGd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2V4ZWN1dGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVwYXJlQ2FsbGJhY2soZGF0YSwgXCJtZXNzYWdlUmVjZWl2ZWRcIiwgMjAwLCByZXF1ZXN0LnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJsb2NhbE1lc3NhZ2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2xvY2FsTWVzc2FnZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBmaW5kVHJhY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaGVyID0gbmV3IFJlZ0V4cChcIig/Ol58OyApKFwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgXCIpPShbXjtdKilcIikuZXhlYyhkb2N1bWVudC5jb29raWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5wYXJzZUpTT04oZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoZXJbMl0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIEZpbmRzIGFuZCB2YWxpZGF0ZXMgdGhlIHBhcmVudCBzb2NrZXQncyB0cmFjZSBmcm9tIHRoZSBjb29raWVcbiAgICAgICAgICAgICAgICB0cmFjZSA9IGZpbmRUcmFjZSgpO1xuICAgICAgICAgICAgICAgIGlmICghdHJhY2UgfHwgalF1ZXJ5Lm5vdygpIC0gdHJhY2UudHMgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBDaG9vc2VzIGEgY29ubmVjdG9yXG4gICAgICAgICAgICAgICAgY29ubmVjdG9yID0gY29ubmVjdG9ycy5zdG9yYWdlKCkgfHwgY29ubmVjdG9ycy53aW5kb3dyZWYoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWNvbm5lY3Rvcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE9wZW5lZDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2tzIHRoZSBzaGFyZWQgb25lIGlzIGFsaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBfdHJhY2VUaW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgb2xkVHJhY2UgPSB0cmFjZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFjZSA9IGZpbmRUcmFjZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdHJhY2UgfHwgb2xkVHJhY2UudHMgPT09IHRyYWNlLnRzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNpbXVsYXRlcyBhIGNsb3NlIHNpZ25hbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcihqUXVlcnkuc3RyaW5naWZ5SlNPTih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXQ6IFwiY1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJjbG9zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogXCJlcnJvclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaXI6IG9sZFRyYWNlLmhlaXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRPcGVuZWQgPSBjb25uZWN0b3IuaW5pdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudE9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmluZyB0aGUgb3BlbiBldmVudCB3aXRob3V0IGRlbGF5IHJvYnMgdGhlIHVzZXIgb2YgdGhlIG9wcG9ydHVuaXR5IHRvIGJpbmQgY29ubmVjdGluZyBldmVudCBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3BlbihcIm9wZW5pbmdcIiwgJ2xvY2FsJywgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcmVudE9wZW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgc2VuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc2lnbmFsKFwic2VuZFwiLCBldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsU2VuZDogZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3Iuc2lnbmFsKFwibG9jYWxTZW5kXCIsIGpRdWVyeS5zdHJpbmdpZnlKU09OKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogZ3VpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCBzaWduYWwgdGhlIHBhcmVudCBpZiB0aGlzIG1ldGhvZCBpcyBleGVjdXRlZCBieSB0aGUgdW5sb2FkIGV2ZW50IGhhbmRsZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghX2Fib3JkaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoX3RyYWNlVGltZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rvci5zaWduYWwoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0b3IuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIHNoYXJlKCkge1xuICAgICAgICAgICAgICAgIHZhciBzdG9yYWdlU2VydmljZSwgbmFtZSA9IFwiYXRtb3NwaGVyZS1cIiArIF9yZXF1ZXN0LnVybCwgc2VydmVycyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUG93ZXJlZCBieSB0aGUgc3RvcmFnZSBldmVudCBhbmQgdGhlIGxvY2FsU3RvcmFnZVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vd3d3LnczLm9yZy9UUi93ZWJzdG9yYWdlLyNldmVudC1zdG9yYWdlXG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LmF0bW9zcGhlcmUuc3VwcG9ydFN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHN0b3JhZ2UgPSB3aW5kb3cubG9jYWxTdG9yYWdlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlcyB0aGUgc3RvcmFnZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkod2luZG93KS5vbihcInN0b3JhZ2Uuc29ja2V0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQgPSBldmVudC5vcmlnaW5hbEV2ZW50O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2hlbiBhIGRlbGV0aW9uLCBuZXdWYWx1ZSBpbml0aWFsaXplZCB0byBudWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnQua2V5ID09PSBuYW1lICYmIGV2ZW50Lm5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXIoZXZlbnQubmV3VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpZ25hbDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKG5hbWUsIGpRdWVyeS5zdHJpbmdpZnlKU09OKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZGF0YVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGpRdWVyeS5wYXJzZUpTT04oc3RvcmFnZS5nZXRJdGVtKG5hbWUgKyBcIi1cIiArIGtleSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlLnNldEl0ZW0obmFtZSArIFwiLVwiICsga2V5LCBqUXVlcnkuc3RyaW5naWZ5SlNPTih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5KHdpbmRvdykub2ZmKFwic3RvcmFnZS5zb2NrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5yZW1vdmVJdGVtKG5hbWUgKyBcIi1vcGVuZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShuYW1lICsgXCItY2hpbGRyZW5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAvLyBQb3dlcmVkIGJ5IHRoZSB3aW5kb3cub3BlbiBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5vcGVuXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvd3JlZjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgcmFpc2VzIGFuIGludmFsaWQgYXJndW1lbnQgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoZW4gY2FsbGluZyB0aGUgd2luZG93Lm9wZW4gbWV0aG9kIHdpdGggdGhlIG5hbWUgY29udGFpbmluZyBub24td29yZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbmVpbSA9IG5hbWUucmVwbGFjZSgvXFxXL2csIFwiXCIpLCB3aW4gPSAoalF1ZXJ5KCdpZnJhbWVbbmFtZT1cIicgKyBuZWltICsgJ1wiXScpWzBdIHx8IGpRdWVyeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnPGlmcmFtZSBuYW1lPVwiJyArIG5laW0gKyAnXCIgLz4nKS5oaWRlKCkuYXBwZW5kVG8oXCJib2R5XCIpWzBdKS5jb250ZW50V2luZG93O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbGJhY2tzIGZyb20gZGlmZmVyZW50IHdpbmRvd3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luLmNhbGxiYWNrcyA9IFtsaXN0ZW5lcl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluIElFIDggYW5kIGxlc3MsIG9ubHkgc3RyaW5nIGFyZ3VtZW50IGNhbiBiZSBzYWZlbHkgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBpbiBvdGhlciB3aW5kb3dcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luLmZpcmUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHdpbi5jYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW4uY2FsbGJhY2tzW2ldKHN0cmluZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGZ1bmN0aW9uICh0eXBlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luLmNsb3NlZCAmJiB3aW4uZmlyZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luLmZpcmUoalF1ZXJ5LnN0cmluZ2lmeUpTT04oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogXCJjXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gIXdpbi5jbG9zZWQgPyB3aW5ba2V5XSA6IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIChrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghd2luLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2luW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFJlY2VpdmVzIHNlbmQgYW5kIGNsb3NlIGNvbW1hbmQgZnJvbSB0aGUgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBsaXN0ZW5lcihzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbW1hbmQgPSBqUXVlcnkucGFyc2VKU09OKHN0cmluZyksIGRhdGEgPSBjb21tYW5kLmRhdGE7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvbW1hbmQudGFyZ2V0ID09PSBcInBcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb21tYW5kLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwic2VuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHVzaChkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImxvY2FsU2VuZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfbG9jYWxNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiY2xvc2VcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2Nsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX2xvY2FsU29ja2V0RiA9IGZ1bmN0aW9uIHByb3BhZ2F0ZU1lc3NhZ2VFdmVudChjb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2VTZXJ2aWNlLnNpZ25hbChcIm1lc3NhZ2VcIiwgY29udGV4dCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGxlYXZlVHJhY2UoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IF9zaGFyaW5nS2V5ICsgXCI9XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT3BlcmEncyBKU09OIGltcGxlbWVudGF0aW9uIGlnbm9yZXMgYSBudW1iZXIgd2hvc2UgYSBsYXN0IGRpZ2l0IG9mIDAgc3RyYW5nZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBidXQgaGFzIG5vIHByb2JsZW0gd2l0aCBhIG51bWJlciB3aG9zZSBhIGxhc3QgZGlnaXQgb2YgOSArIDFcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChqUXVlcnkuc3RyaW5naWZ5SlNPTih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHM6IGpRdWVyeS5ub3coKSArIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVpcjogKHN0b3JhZ2VTZXJ2aWNlLmdldChcImNoaWxkcmVuXCIpIHx8IFtdKVswXVxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpICsgXCI7IHBhdGg9L1wiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIENob29zZXMgYSBzdG9yYWdlU2VydmljZVxuICAgICAgICAgICAgICAgIHN0b3JhZ2VTZXJ2aWNlID0gc2VydmVycy5zdG9yYWdlKCkgfHwgc2VydmVycy53aW5kb3dyZWYoKTtcbiAgICAgICAgICAgICAgICBzdG9yYWdlU2VydmljZS5pbml0KCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QubG9nTGV2ZWwgPT09ICdkZWJ1ZycpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZGVidWcoXCJJbnN0YWxsZWQgU3RvcmFnZVNlcnZpY2UgXCIgKyBzdG9yYWdlU2VydmljZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gTGlzdCBvZiBjaGlsZHJlbiBzb2NrZXRzXG4gICAgICAgICAgICAgICAgc3RvcmFnZVNlcnZpY2Uuc2V0KFwiY2hpbGRyZW5cIiwgW10pO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0b3JhZ2VTZXJ2aWNlLmdldChcIm9wZW5lZFwiKSAhPSBudWxsICYmICFzdG9yYWdlU2VydmljZS5nZXQoXCJvcGVuZWRcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRmxhZyBpbmRpY2F0aW5nIHRoZSBwYXJlbnQgc29ja2V0IGlzIG9wZW5lZFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlU2VydmljZS5zZXQoXCJvcGVuZWRcIiwgZmFsc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBMZWF2ZXMgdHJhY2VzXG4gICAgICAgICAgICAgICAgX3NoYXJpbmdLZXkgPSBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICAgICAgICAgICAgbGVhdmVUcmFjZSgpO1xuICAgICAgICAgICAgICAgIF90cmFjZVRpbWVyID0gc2V0SW50ZXJ2YWwobGVhdmVUcmFjZSwgMTAwMCk7XG5cbiAgICAgICAgICAgICAgICBfc3RvcmFnZVNlcnZpY2UgPSBzdG9yYWdlU2VydmljZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfb3BlbihzdGF0ZSwgdHJhbnNwb3J0LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LnNoYXJlZCAmJiB0cmFuc3BvcnQgIT09ICdsb2NhbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hhcmUoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3N0b3JhZ2VTZXJ2aWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3N0b3JhZ2VTZXJ2aWNlLnNldChcIm9wZW5lZFwiLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXF1ZXN0LmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0Q291bnQgPiAwICYmIHN0YXRlID09PSAncmUtY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5pc1Jlb3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF90cnlpbmdUb1JlY29ubmVjdChfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3Jlc3BvbnNlLmVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlcXVlc3QgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJldlN0YXRlID0gX3Jlc3BvbnNlLnN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdGUgPSBzdGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByZXZUcmFuc3BvcnQgPSBfcmVzcG9uc2UudHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBfYm9keSA9IF9yZXNwb25zZS5yZXNwb25zZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIF9pbnZva2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gX2JvZHk7XG5cbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXRlID0gcHJldlN0YXRlO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UudHJhbnNwb3J0ID0gcHJldlRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXhlY3V0ZSByZXF1ZXN0IHVzaW5nIGpzb25wIHRyYW5zcG9ydC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCB7T2JqZWN0fSByZXF1ZXN0IFJlcXVlc3QgcGFyYW1ldGVycywgaWYgdW5kZWZpbmVkIF9yZXF1ZXN0IG9iamVjdCB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfanNvbnAocmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIC8vIFdoZW4gQ09SUyBpcyBlbmFibGVkLCBtYWtlIHN1cmUgd2UgZm9yY2UgdGhlIHByb3BlciB0cmFuc3BvcnQuXG4gICAgICAgICAgICAgICAgcmVxdWVzdC50cmFuc3BvcnQgPSBcImpzb25wXCI7XG5cbiAgICAgICAgICAgICAgICB2YXIgcnEgPSBfcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAoKHJlcXVlc3QgIT0gbnVsbCkgJiYgKHR5cGVvZiAocmVxdWVzdCkgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBycSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHJxLnVybDtcbiAgICAgICAgICAgICAgICBpZiAocnEuZGlzcGF0Y2hVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gcnEuZGlzcGF0Y2hVcmw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBycS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChycS5hdHRhY2hIZWFkZXJzQXNRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBfYXR0YWNoSGVhZGVycyhycSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJlgtQXRtb3NwaGVyZS1Qb3N0LUJvZHk9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9qcXhociA9IGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IHJxLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvbnBcIixcbiAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGZ1bmN0aW9uIChqcVhIUiwgdGV4dFN0YXR1cywgZXJyb3JUaHJvd24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5lcnJvciA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5vcGVuSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocnEub3BlbklkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJxLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLnJlY29ubmVjdCAmJiBfcmVxdWVzdENvdW50KysgPCBycS5tYXhSZWNvbm5lY3RPbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29wZW4oJ3JlLWNvbm5lY3RpbmcnLCBycS50cmFuc3BvcnQsIHJxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0KF9qcXhociwgcnEsIHJxLnJlY29ubmVjdEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBycS5vcGVuSWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdHJpZ2dlck9wZW4ocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJxLnJlY29ubmVjdEludGVydmFsICsgMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vbkVycm9yKGpxWEhSLnN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBqc29ucDogXCJqc29ucFRyYW5zcG9ydFwiLFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5tYXhSZXF1ZXN0ID09PSAtMSB8fCBycS5yZXF1ZXN0Q291bnQrKyA8IHJxLm1heFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlYWRIZWFkZXJzKF9qcXhociwgcnEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcnEuZXhlY3V0ZUNhbGxiYWNrQmVmb3JlUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0KF9qcXhociwgcnEsIHJxLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0ganNvbi5tZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobXNnICE9IG51bGwgJiYgdHlwZW9mIG1zZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnID0galF1ZXJ5LnN0cmluZ2lmeUpTT04obXNnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBtZXNzYWdlIHdhcyBwYXJ0aWFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcENhbGxiYWNrSW52b2NhdGlvbiA9IF90cmFja01lc3NhZ2VTaXplKG1zZywgcnEsIF9yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhbGxiYWNrSW52b2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ByZXBhcmVDYWxsYmFjayhfcmVzcG9uc2UucmVzcG9uc2VCb2R5LCBcIm1lc3NhZ2VSZWNlaXZlZFwiLCAyMDAsIHJxLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnEuZXhlY3V0ZUNhbGxiYWNrQmVmb3JlUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0KF9qcXhociwgcnEsIHJxLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5sb2coX3JlcXVlc3QubG9nTGV2ZWwsIFtcIkpTT05QIHJlY29ubmVjdCBtYXhpbXVtIHRyeSByZWFjaGVkIFwiICsgX3JlcXVlc3QucmVxdWVzdENvdW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vbkVycm9yKDAsIFwibWF4UmVxdWVzdCByZWFjaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogcnEuZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZG9SZXF1ZXN0KGpxWEhSLCBycSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRXhlY3V0ZSByZXF1ZXN0IHVzaW5nIGFqYXggdHJhbnNwb3J0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSByZXF1ZXN0IHtPYmplY3R9IHJlcXVlc3QgUmVxdWVzdCBwYXJhbWV0ZXJzLCBpZiB1bmRlZmluZWQgX3JlcXVlc3Qgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9hamF4KHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnEgPSBfcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAoKHJlcXVlc3QgIT0gbnVsbCkgJiYgKHR5cGVvZiAocmVxdWVzdCkgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBycSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHVybCA9IHJxLnVybDtcbiAgICAgICAgICAgICAgICBpZiAocnEuZGlzcGF0Y2hVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gcnEuZGlzcGF0Y2hVcmw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGRhdGEgPSBycS5kYXRhO1xuICAgICAgICAgICAgICAgIGlmIChycS5hdHRhY2hIZWFkZXJzQXNRdWVyeVN0cmluZykge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSBfYXR0YWNoSGVhZGVycyhycSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhICE9PSAnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJlgtQXRtb3NwaGVyZS1Qb3N0LUJvZHk9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZGF0YSA9ICcnO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBhc3luYyA9IHR5cGVvZiAocnEuYXN5bmMpICE9PSAndW5kZWZpbmVkJyA/IHJxLmFzeW5jIDogdHJ1ZTtcbiAgICAgICAgICAgICAgICBfanF4aHIgPSBqUXVlcnkuYWpheCh7XG4gICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBycS5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBmdW5jdGlvbiAoanFYSFIsIHRleHRTdGF0dXMsIGVycm9yVGhyb3duKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UuZXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGpxWEhSLnN0YXR1cyA8IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWNvbm5lY3QoX2pxeGhyLCBycSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vbkVycm9yKGpxWEhSLnN0YXR1cywgZXJyb3JUaHJvd24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbiAoZGF0YSwgdGV4dFN0YXR1cywganFYSFIpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLnJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5tYXhSZXF1ZXN0ID09PSAtMSB8fCBycS5yZXF1ZXN0Q291bnQrKyA8IHJxLm1heFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFycS5leGVjdXRlQ2FsbGJhY2tCZWZvcmVSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWNvbm5lY3QoX2pxeGhyLCBycSwgcnEucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcENhbGxiYWNrSW52b2NhdGlvbiA9IF90cmFja01lc3NhZ2VTaXplKGRhdGEsIHJxLCBfcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBDYWxsYmFja0ludm9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVwYXJlQ2FsbGJhY2soX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSwgXCJtZXNzYWdlUmVjZWl2ZWRcIiwgMjAwLCBycS50cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmV4ZWN1dGVDYWxsYmFja0JlZm9yZVJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlY29ubmVjdChfanF4aHIsIHJxLCBycS5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKF9yZXF1ZXN0LmxvZ0xldmVsLCBbXCJBSkFYIHJlY29ubmVjdCBtYXhpbXVtIHRyeSByZWFjaGVkIFwiICsgX3JlcXVlc3QucmVxdWVzdENvdW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vbkVycm9yKDAsIFwibWF4UmVxdWVzdCByZWFjaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgYmVmb3JlU2VuZDogZnVuY3Rpb24gKGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZG9SZXF1ZXN0KGpxWEhSLCBycSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBjcm9zc0RvbWFpbjogcnEuZW5hYmxlWERSLFxuICAgICAgICAgICAgICAgICAgICBhc3luYzogYXN5bmNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCdWlsZCB3ZWJzb2NrZXQgb2JqZWN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBsb2NhdGlvbiB7c3RyaW5nfSBXZWIgc29ja2V0IHVybC5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt3ZWJzb2NrZXR9IFdlYiBzb2NrZXQgb2JqZWN0LlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2dldFdlYlNvY2tldChsb2NhdGlvbikge1xuICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC53ZWJTb2NrZXRJbXBsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9yZXF1ZXN0LndlYlNvY2tldEltcGw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHdpbmRvdy5XZWJTb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgV2ViU29ja2V0KGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTW96V2ViU29ja2V0KGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCdWlsZCB3ZWIgc29ja2V0IHVybCBmcm9tIHJlcXVlc3QgdXJsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gV2ViIHNvY2tldCB1cmwgKHN0YXJ0IHdpdGggXCJ3c1wiIG9yIFwid3NzXCIgZm9yIHNlY3VyZSB3ZWIgc29ja2V0KS5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9idWlsZFdlYlNvY2tldFVybCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gX2F0dGFjaEhlYWRlcnMoX3JlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSShqUXVlcnkoJzxhIGhyZWY9XCInICsgdXJsICsgJ1wiLz4nKVswXS5ocmVmLnJlcGxhY2UoL15odHRwLywgXCJ3c1wiKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQnVpbGQgU1NFIHVybCBmcm9tIHJlcXVlc3QgdXJsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm4gYSB1cmwgd2l0aCBBdG1vc3BoZXJlJ3MgaGVhZGVyc1xuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2J1aWxkU1NFVXJsKCkge1xuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBfYXR0YWNoSGVhZGVycyhfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBPcGVuIFNTRS4gPGJyPlxuICAgICAgICAgICAgICogQXV0b21hdGljYWxseSB1c2UgZmFsbGJhY2sgdHJhbnNwb3J0IGlmIFNTRSBjYW4ndCBiZSBvcGVuZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2V4ZWN1dGVTU0Uoc3NlT3BlbmVkKSB7XG5cbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UudHJhbnNwb3J0ID0gXCJzc2VcIjtcblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IF9idWlsZFNTRVVybChfcmVxdWVzdC51cmwpO1xuXG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmRlYnVnKFwiSW52b2tpbmcgZXhlY3V0ZVNTRVwiKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZGVidWcoXCJVc2luZyBVUkw6IFwiICsgbG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5lbmFibGVQcm90b2NvbCAmJiBzc2VPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRpbWUgPSBqUXVlcnkubm93KCkgLSBfcmVxdWVzdC5jdGltZTtcbiAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3QubGFzdFRpbWVzdGFtcCA9IE51bWJlcihfcmVxdWVzdC5zdGltZSkgKyBOdW1iZXIodGltZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHNzZU9wZW5lZCAmJiAhX3JlcXVlc3QucmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfc3NlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIF9zc2UgPSBuZXcgRXZlbnRTb3VyY2UobG9jYXRpb24sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdpdGhDcmVkZW50aWFsczogX3JlcXVlc3Qud2l0aENyZWRlbnRpYWxzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgX29uRXJyb3IoMCwgZSk7XG4gICAgICAgICAgICAgICAgICAgIF9yZWNvbm5lY3RXaXRoRmFsbGJhY2tUcmFuc3BvcnQoXCJTU0UgZmFpbGVkLiBEb3duZ3JhZGluZyB0byBmYWxsYmFjayB0cmFuc3BvcnQgYW5kIHJlc2VuZGluZ1wiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5jb25uZWN0VGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3QuaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc3NlT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgX3JlcXVlc3QuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9zc2Uub25vcGVuID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aW1lb3V0KF9yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5kZWJ1ZyhcIlNTRSBzdWNjZXNzZnVsbHkgb3BlbmVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFfcmVxdWVzdC5lbmFibGVQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzc2VPcGVuZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3Blbignb3BlbmluZycsIFwic3NlXCIsIF9yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29wZW4oJ3JlLW9wZW5pbmcnLCBcInNzZVwiLCBfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3JlcXVlc3QuaXNSZW9wZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LmlzUmVvcGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfb3BlbigncmUtb3BlbmluZycsIF9yZXF1ZXN0LnRyYW5zcG9ydCwgX3JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNzZU9wZW5lZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdGUgPSBcIm1lc3NhZ2VSZWNlaXZlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3NzZS5zZW5kKF9yZXF1ZXN0LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIF9zc2Uub25tZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RpbWVvdXQoX3JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV9yZXF1ZXN0LmVuYWJsZVhEUiAmJiBtZXNzYWdlLm9yaWdpbiAhPT0gd2luZG93LmxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgd2luZG93LmxvY2F0aW9uLmhvc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmxvZyhfcmVxdWVzdC5sb2dMZXZlbCwgW1wiT3JpZ2luIHdhcyBub3QgXCIgKyB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyB3aW5kb3cubG9jYXRpb24uaG9zdF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXRlID0gJ21lc3NhZ2VSZWNlaXZlZCc7XG4gICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0dXMgPSAyMDA7XG5cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNraXBDYWxsYmFja0ludm9jYXRpb24gPSBfdHJhY2tNZXNzYWdlU2l6ZShtZXNzYWdlLCBfcmVxdWVzdCwgX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwQ2FsbGJhY2tJbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5yZXNwb25zZUJvZHkgPSAnJztcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5tZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIF9zc2Uub25lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfcmVxdWVzdC5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3JlcXVlc3QuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXNwb25zZS5jbG9zZWRCeUNsaWVudFRpbWVvdXQpIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2xvc2Uoc3NlT3BlbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Fib3JkaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKF9yZXF1ZXN0LmxvZ0xldmVsLCBbXCJTU0UgY2xvc2VkIG5vcm1hbGx5XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghc3NlT3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0V2l0aEZhbGxiYWNrVHJhbnNwb3J0KFwiU1NFIGZhaWxlZC4gRG93bmdyYWRpbmcgdG8gZmFsbGJhY2sgdHJhbnNwb3J0IGFuZCByZXNlbmRpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX3JlcXVlc3QucmVjb25uZWN0ICYmIChfcmVzcG9uc2UudHJhbnNwb3J0ID09PSAnc3NlJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdENvdW50KysgPCBfcmVxdWVzdC5tYXhSZWNvbm5lY3RPbkNsb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29wZW4oJ3JlLWNvbm5lY3RpbmcnLCBfcmVxdWVzdC50cmFuc3BvcnQsIF9yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QucmVjb25uZWN0SW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LnJlY29ubmVjdElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXhlY3V0ZVNTRSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgX3JlcXVlc3QucmVjb25uZWN0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leGVjdXRlU1NFKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKF9yZXF1ZXN0LmxvZ0xldmVsLCBbXCJTU0UgcmVjb25uZWN0IG1heGltdW0gdHJ5IHJlYWNoZWQgXCIgKyBfcmVxdWVzdENvdW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29uRXJyb3IoMCwgXCJtYXhSZWNvbm5lY3RPbkNsb3NlIHJlYWNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIE9wZW4gd2ViIHNvY2tldC4gPGJyPlxuICAgICAgICAgICAgICogQXV0b21hdGljYWxseSB1c2UgZmFsbGJhY2sgdHJhbnNwb3J0IGlmIHdlYiBzb2NrZXQgY2FuJ3QgYmUgb3BlbmVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9leGVjdXRlV2ViU29ja2V0KHdlYlNvY2tldE9wZW5lZCkge1xuXG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnRyYW5zcG9ydCA9IFwid2Vic29ja2V0XCI7XG5cbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QuZW5hYmxlUHJvdG9jb2wgJiYgd2ViU29ja2V0T3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aW1lID0galF1ZXJ5Lm5vdygpIC0gX3JlcXVlc3QuY3RpbWU7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0Lmxhc3RUaW1lc3RhbXAgPSBOdW1iZXIoX3JlcXVlc3Quc3RpbWUpICsgTnVtYmVyKHRpbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvbiA9IF9idWlsZFdlYlNvY2tldFVybChfcmVxdWVzdC51cmwpO1xuICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5sb2dMZXZlbCA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5kZWJ1ZyhcIkludm9raW5nIGV4ZWN1dGVXZWJTb2NrZXRcIik7XG4gICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmRlYnVnKFwiVXNpbmcgVVJMOiBcIiArIGxvY2F0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAod2ViU29ja2V0T3BlbmVkICYmICFfcmVxdWVzdC5yZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKF93ZWJzb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3dlYnNvY2tldCA9IF9nZXRXZWJTb2NrZXQobG9jYXRpb24pO1xuICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC53ZWJTb2NrZXRCaW5hcnlUeXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3dlYnNvY2tldC5iaW5hcnlUeXBlID0gX3JlcXVlc3Qud2ViU29ja2V0QmluYXJ5VHlwZTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QuY29ubmVjdFRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LmlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdlYlNvY2tldE9wZW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBfbWVzc2FnZSA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZTogMTAwMixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNDbGVhbjogZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF93ZWJzb2NrZXQub25jbG9zZShfbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xvc2UgaXQgYW55d2F5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9LCBfcmVxdWVzdC5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgX3dlYnNvY2tldC5vbm9wZW4gPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGltZW91dChfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5sb2dMZXZlbCA9PT0gJ2RlYnVnJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZGVidWcoXCJXZWJzb2NrZXQgc3VjY2Vzc2Z1bGx5IG9wZW5lZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZW9wZW5pbmcgPSB3ZWJTb2NrZXRPcGVuZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYoX3dlYnNvY2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfd2Vic29ja2V0LmNhblNlbmRNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICghX3JlcXVlc3QuZW5hYmxlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdlYlNvY2tldE9wZW5lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVvcGVuaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29wZW4oJ3JlLW9wZW5pbmcnLCBcIndlYnNvY2tldFwiLCBfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcGVuKCdvcGVuaW5nJywgXCJ3ZWJzb2NrZXRcIiwgX3JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF93ZWJzb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXRlID0gXCJtZXNzYWdlUmVjZWl2ZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfd2Vic29ja2V0LnNlbmQoX3JlcXVlc3QuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgX3dlYnNvY2tldC5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGltZW91dChfcmVxdWVzdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2Ugb25seSBjb25zaWRlciBpdCBvcGVuZWQgaWYgd2UgZ2V0IHRoZSBoYW5kc2hha2UgZGF0YVxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vQXRtb3NwaGVyZS9hdG1vc3BoZXJlLWphdmFzY3JpcHQvaXNzdWVzLzc0XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5lbmFibGVQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2ViU29ja2V0T3BlbmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0ZSA9ICdtZXNzYWdlUmVjZWl2ZWQnO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdHVzID0gMjAwO1xuXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpc1N0cmluZyA9IHR5cGVvZiAobWVzc2FnZSkgPT09ICdzdHJpbmcnO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwQ2FsbGJhY2tJbnZvY2F0aW9uID0gX3RyYWNrTWVzc2FnZVNpemUobWVzc2FnZSwgX3JlcXVlc3QsIF9yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBDYWxsYmFja0ludm9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gJyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLm1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2hhbmRsZVByb3RvY29sKF9yZXF1ZXN0LCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlID09PSBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5yZXNwb25zZUJvZHkgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIF93ZWJzb2NrZXQub25lcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChfcmVxdWVzdC5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3JlcXVlc3QuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIF93ZWJzb2NrZXQub25jbG9zZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVzcG9uc2Uuc3RhdGUgPT09ICdjbG9zZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3JlcXVlc3QuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciByZWFzb24gPSBtZXNzYWdlLnJlYXNvbjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlYXNvbiA9PT0gXCJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiTm9ybWFsIGNsb3N1cmU7IHRoZSBjb25uZWN0aW9uIHN1Y2Nlc3NmdWxseSBjb21wbGV0ZWQgd2hhdGV2ZXIgcHVycG9zZSBmb3Igd2hpY2ggXCIgKyBcIml0IHdhcyBjcmVhdGVkLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiVGhlIGVuZHBvaW50IGlzIGdvaW5nIGF3YXksIGVpdGhlciBiZWNhdXNlIG9mIGEgc2VydmVyIGZhaWx1cmUgb3IgYmVjYXVzZSB0aGUgXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgXCJicm93c2VyIGlzIG5hdmlnYXRpbmcgYXdheSBmcm9tIHRoZSBwYWdlIHRoYXQgb3BlbmVkIHRoZSBjb25uZWN0aW9uLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiVGhlIGVuZHBvaW50IGlzIHRlcm1pbmF0aW5nIHRoZSBjb25uZWN0aW9uIGR1ZSB0byBhIHByb3RvY29sIGVycm9yLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiVGhlIGNvbm5lY3Rpb24gaXMgYmVpbmcgdGVybWluYXRlZCBiZWNhdXNlIHRoZSBlbmRwb2ludCByZWNlaXZlZCBkYXRhIG9mIGEgdHlwZSBpdCBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcImNhbm5vdCBhY2NlcHQgKGZvciBleGFtcGxlLCBhIHRleHQtb25seSBlbmRwb2ludCByZWNlaXZlZCBiaW5hcnkgZGF0YSkuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTAwNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJUaGUgZW5kcG9pbnQgaXMgdGVybWluYXRpbmcgdGhlIGNvbm5lY3Rpb24gYmVjYXVzZSBhIGRhdGEgZnJhbWUgd2FzIHJlY2VpdmVkIHRoYXQgXCIgKyBcImlzIHRvbyBsYXJnZS5cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxMDA1OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24gPSBcIlVua25vd246IG5vIHN0YXR1cyBjb2RlIHdhcyBwcm92aWRlZCBldmVuIHRob3VnaCBvbmUgd2FzIGV4cGVjdGVkLlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDEwMDY6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbiA9IFwiQ29ubmVjdGlvbiB3YXMgY2xvc2VkIGFibm9ybWFsbHkgKHRoYXQgaXMsIHdpdGggbm8gY2xvc2UgZnJhbWUgYmVpbmcgc2VudCkuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLndhcm4oXCJXZWJzb2NrZXQgY2xvc2VkLCByZWFzb246IFwiICsgcmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLndhcm4oXCJXZWJzb2NrZXQgY2xvc2VkLCB3YXNDbGVhbjogXCIgKyBtZXNzYWdlLndhc0NsZWFuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVzcG9uc2UuY2xvc2VkQnlDbGllbnRUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2xvc2Uod2ViU29ja2V0T3BlbmVkKTtcblxuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdGUgPSAnY2xvc2VkJztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2Fib3JkaW5nQ29ubmVjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKF9yZXF1ZXN0LmxvZ0xldmVsLCBbXCJXZWJzb2NrZXQgY2xvc2VkIG5vcm1hbGx5XCJdKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghd2ViU29ja2V0T3BlbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0V2l0aEZhbGxiYWNrVHJhbnNwb3J0KFwiV2Vic29ja2V0IGZhaWxlZC4gRG93bmdyYWRpbmcgdG8gQ29tZXQgYW5kIHJlc2VuZGluZ1wiKTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9yZXF1ZXN0LnJlY29ubmVjdCAmJiBfcmVzcG9uc2UudHJhbnNwb3J0ID09PSAnd2Vic29ja2V0JyAmJiBtZXNzYWdlLmNvZGUgIT09IDEwMDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3RDb3VudCsrIDwgX3JlcXVlc3QubWF4UmVjb25uZWN0T25DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcGVuKCdyZS1jb25uZWN0aW5nJywgX3JlcXVlc3QudHJhbnNwb3J0LCBfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LnJlY29ubmVjdEludGVydmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVxdWVzdC5yZWNvbm5lY3RJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leGVjdXRlV2ViU29ja2V0KHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBfcmVxdWVzdC5yZWNvbm5lY3RJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5tZXNzYWdlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfZXhlY3V0ZVdlYlNvY2tldCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmxvZyhfcmVxdWVzdC5sb2dMZXZlbCwgW1wiV2Vic29ja2V0IHJlY29ubmVjdCBtYXhpbXVtIHRyeSByZWFjaGVkIFwiICsgX3JlcXVlc3QucmVxdWVzdENvdW50XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnd2FybicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUud2FybihcIldlYnNvY2tldCBlcnJvciwgcmVhc29uOiBcIiArIG1lc3NhZ2UucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29uRXJyb3IoMCwgXCJtYXhSZWNvbm5lY3RPbkNsb3NlIHJlYWNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIHZhciBpc0FuZHJvaWQgPSB1YS5pbmRleE9mKFwiYW5kcm9pZFwiKSA+IC0xO1xuICAgICAgICAgICAgICAgIGlmIChpc0FuZHJvaWQgJiYgX3dlYnNvY2tldC51cmwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBBbmRyb2lkIDQuMSBkb2VzIG5vdCByZWFsbHkgc3VwcG9ydCB3ZWJzb2NrZXRzIGFuZCBmYWlscyBzaWxlbnRseVxuICAgICAgICAgICAgICAgICAgICBfd2Vic29ja2V0Lm9uY2xvc2Uoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkFuZHJvaWQgNC4xIGRvZXMgbm90IHN1cHBvcnQgd2Vic29ja2V0cy5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHdhc0NsZWFuOiBmYWxzZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9oYW5kbGVQcm90b2NvbChyZXF1ZXN0LCBtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5NZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgICAgICAgICBpZiAocmVxdWVzdC50cmFuc3BvcnQgPT09ICdwb2xsaW5nJykgcmV0dXJuIG5NZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS50cmltKG1lc3NhZ2UpLmxlbmd0aCAhPT0gMCAmJiByZXF1ZXN0LmVuYWJsZVByb3RvY29sICYmIHJlcXVlc3QuZmlyc3RNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3MgPSByZXF1ZXN0LnRyYWNrTWVzc2FnZUxlbmd0aCA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBtZXNzYWdlLnNwbGl0KHJlcXVlc3QubWVzc2FnZURlbGltaXRlcik7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA8PSBwb3MgKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBTb21ldGhpbmcgd2VudCB3cm9uZywgbm9ybWFsbHkgd2l0aCBJRSBvciB3aGVuIGEgbWVzc2FnZSBpcyB3cml0dGVuIGJlZm9yZSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRzaGFrZSBoYXMgYmVlbiByZWNlaXZlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuZmlyc3RNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3QudXVpZCA9IGpRdWVyeS50cmltKG1lc3NhZ2VzW3Bvc10pO1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnN0aW1lID0galF1ZXJ5LnRyaW0obWVzc2FnZXNbcG9zICsgMV0pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPD0gcG9zICsgMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKCdlcnJvcicsIFtcIlByb3RvY29sIGRhdGEgbm90IHNlbnQgYnkgdGhlIHNlcnZlci4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSWYgeW91IGVuYWJsZSBwcm90b2NvbCBvbiBjbGllbnQgc2lkZSwgYmUgc3VyZSB0byBpbnN0YWxsIEphdmFzY3JpcHRQcm90b2NvbCBpbnRlcmNlcHRvciBvbiBzZXJ2ZXIgc2lkZS5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJBbHNvIG5vdGUgdGhhdCBhdG1vc3BoZXJlLXJ1bnRpbWUgMi4yKyBzaG91bGQgYmUgdXNlZC5cIl0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVydmFsID0gcGFyc2VJbnQoalF1ZXJ5LnRyaW0obWVzc2FnZXNbcG9zICsgMl0pLCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwYWRkaW5nRGF0YSA9IG1lc3NhZ2VzW3BvcyArIDNdO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNOYU4oaW50ZXJ2YWwpICYmIGludGVydmFsID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9wdXNoSGVhcnRiZWF0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wdXNoKHBhZGRpbmdEYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmhlYXJ0YmVhdFRpbWVyID0gc2V0VGltZW91dChfcHVzaEhlYXJ0YmVhdCwgaW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QuaGVhcnRiZWF0VGltZXIgPSBzZXRUaW1lb3V0KF9wdXNoSGVhcnRiZWF0LCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBiID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRyYW5zcG9ydCAhPT0gJ2xvbmctcG9sbGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90cmlnZ2VyT3BlbihyZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS51dWlkID0gcmVxdWVzdC51dWlkO1xuICAgICAgICAgICAgICAgICAgICBuTWVzc2FnZSA9IFwiXCI7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgaGF2ZSB0cmFpbGluZyBtZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSByZXF1ZXN0LnRyYWNrTWVzc2FnZUxlbmd0aCA/IDUgOiA0O1xuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID4gcG9zICsgMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IHBvczsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbk1lc3NhZ2UgKz0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGkgKyAxICE9PSBtZXNzYWdlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbk1lc3NhZ2UgKz0gcmVxdWVzdC5tZXNzYWdlRGVsaW1pdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LmFja0ludGVydmFsICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHVzaChcIi4uLkFDSy4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJlcXVlc3QuYWNrSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZXF1ZXN0LmVuYWJsZVByb3RvY29sICYmIHJlcXVlc3QuZmlyc3RNZXNzYWdlICYmIGpRdWVyeS5icm93c2VyLm1zaWUgJiYgK2pRdWVyeS5icm93c2VyLnZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gY2FzZSB3ZSBhcmUgZ2V0dGluZyBzb21lIGp1bmsgZnJvbSBJRVxuICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5sb2coX3JlcXVlc3QubG9nTGV2ZWwsIFtcIlJlY2VpdmluZyB1bmV4cGVjdGVkIGRhdGEgZnJvbSBJRVwiXSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RyaWdnZXJPcGVuKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbk1lc3NhZ2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90aW1lb3V0KF9yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9yZXF1ZXN0LmlkKTtcbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QudGltZW91dCA+IDAgJiYgX3JlcXVlc3QudHJhbnNwb3J0ICE9PSAncG9sbGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3QuaWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9vbkNsaWVudFRpbWVvdXQoX3JlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sIF9yZXF1ZXN0LnRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX29uQ2xpZW50VGltZW91dChfcmVxdWVzdCkge1xuICAgICAgICAgICAgICAgIF9yZXNwb25zZS5jbG9zZWRCeUNsaWVudFRpbWVvdXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0ZSA9ICdjbG9zZWRCeUNsaWVudCc7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXR1cyA9IDQwODtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX29uRXJyb3IoY29kZSwgcmVhc29uKSB7XG4gICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3JlcXVlc3QuaWQpO1xuICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0ZSA9ICdlcnJvcic7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlYXNvblBocmFzZSA9IHJlYXNvbjtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdHVzID0gY29kZTtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUcmFjayByZWNlaXZlZCBtZXNzYWdlIGFuZCBtYWtlIHN1cmUgY2FsbGJhY2tzL2Z1bmN0aW9ucyBhcmUgb25seSBpbnZva2VkIHdoZW4gdGhlIGNvbXBsZXRlIG1lc3NhZ2UgaGFzIGJlZW4gcmVjZWl2ZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG1lc3NhZ2VcbiAgICAgICAgICAgICAqIEBwYXJhbSByZXF1ZXN0XG4gICAgICAgICAgICAgKiBAcGFyYW0gcmVzcG9uc2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX3RyYWNrTWVzc2FnZVNpemUobWVzc2FnZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlID0gX2hhbmRsZVByb3RvY29sKHJlcXVlc3QsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmxlbmd0aCA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgICAgICByZXNwb25zZS5yZXNwb25zZUJvZHkgPSBtZXNzYWdlO1xuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudHJhY2tNZXNzYWdlTGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHByZXBlbmQgcGFydGlhbE1lc3NhZ2UgaWYgYW55XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UgPSByZXNwb25zZS5wYXJ0aWFsTWVzc2FnZSArIG1lc3NhZ2U7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlU3RhcnQgPSBtZXNzYWdlLmluZGV4T2YocmVxdWVzdC5tZXNzYWdlRGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgd2hpbGUgKG1lc3NhZ2VTdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdHIgPSBtZXNzYWdlLnN1YnN0cmluZygwLCBtZXNzYWdlU3RhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VMZW5ndGggPSBwYXJzZUludChzdHIsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc05hTihtZXNzYWdlTGVuZ3RoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyAnbWVzc2FnZSBsZW5ndGggXCInICsgc3RyICsgJ1wiIGlzIG5vdCBhIG51bWJlcic7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlU3RhcnQgKz0gcmVxdWVzdC5tZXNzYWdlRGVsaW1pdGVyLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlU3RhcnQgKyBtZXNzYWdlTGVuZ3RoID4gbWVzc2FnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIG5vdCBjb21wbGV0ZSwgc28gdGhlcmUgaXMgbm8gdHJhaWxpbmcgbWVzc2FnZURlbGltaXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VTdGFydCA9IC0xO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBtZXNzYWdlIGNvbXBsZXRlLCBzbyBhZGQgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlcy5wdXNoKG1lc3NhZ2Uuc3Vic3RyaW5nKG1lc3NhZ2VTdGFydCwgbWVzc2FnZVN0YXJ0ICsgbWVzc2FnZUxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBjb25zdW1lZCBjaGFyYWN0ZXJzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZSA9IG1lc3NhZ2Uuc3Vic3RyaW5nKG1lc3NhZ2VTdGFydCArIG1lc3NhZ2VMZW5ndGgsIG1lc3NhZ2UubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlU3RhcnQgPSBtZXNzYWdlLmluZGV4T2YocmVxdWVzdC5tZXNzYWdlRGVsaW1pdGVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8qIGtlZXAgYW55IHJlbWFpbmluZyBkYXRhICovXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnBhcnRpYWxNZXNzYWdlID0gbWVzc2FnZTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5yZXNwb25zZUJvZHkgPSBtZXNzYWdlcy5qb2luKHJlcXVlc3QubWVzc2FnZURlbGltaXRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZS5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLm1lc3NhZ2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlLnJlc3BvbnNlQm9keSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWNvbm5lY3QgcmVxdWVzdCB3aXRoIGZhbGxiYWNrIHRyYW5zcG9ydC4gPGJyPlxuICAgICAgICAgICAgICogVXNlZCBpbiBjYXNlIHdlYnNvY2tldCBjYW4ndCBiZSBvcGVuZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX3JlY29ubmVjdFdpdGhGYWxsYmFja1RyYW5zcG9ydChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5sb2coX3JlcXVlc3QubG9nTGV2ZWwsIFtlcnJvck1lc3NhZ2VdKTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKF9yZXF1ZXN0Lm9uVHJhbnNwb3J0RmFpbHVyZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0Lm9uVHJhbnNwb3J0RmFpbHVyZShlcnJvck1lc3NhZ2UsIF9yZXF1ZXN0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiAoalF1ZXJ5LmF0bW9zcGhlcmUub25UcmFuc3BvcnRGYWlsdXJlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUub25UcmFuc3BvcnRGYWlsdXJlKGVycm9yTWVzc2FnZSwgX3JlcXVlc3QpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9yZXF1ZXN0LnRyYW5zcG9ydCA9IF9yZXF1ZXN0LmZhbGxiYWNrVHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgIHZhciByZWNvbm5lY3RJbnRlcnZhbCA9IF9yZXF1ZXN0LmNvbm5lY3RUaW1lb3V0ID09PSAtMSA/IDAgOiBfcmVxdWVzdC5jb25uZWN0VGltZW91dDtcbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QucmVjb25uZWN0ICYmIF9yZXF1ZXN0LnRyYW5zcG9ydCAhPT0gJ25vbmUnIHx8IF9yZXF1ZXN0LnRyYW5zcG9ydCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0Lm1ldGhvZCA9IF9yZXF1ZXN0LmZhbGxiYWNrTWV0aG9kO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UudHJhbnNwb3J0ID0gX3JlcXVlc3QuZmFsbGJhY2tUcmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LmZhbGxiYWNrVHJhbnNwb3J0ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVjb25uZWN0SW50ZXJ2YWwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVxdWVzdC5yZWNvbm5lY3RJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9leGVjdXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCByZWNvbm5lY3RJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZXhlY3V0ZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX29uRXJyb3IoNTAwLCBcIlVuYWJsZSB0byByZWNvbm5lY3Qgd2l0aCBmYWxsYmFjayB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB1cmwgZnJvbSByZXF1ZXN0IGFuZCBhdHRhY2ggaGVhZGVycyB0byBpdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCB7T2JqZWN0fSByZXF1ZXN0IFJlcXVlc3QgcGFyYW1ldGVycywgaWYgdW5kZWZpbmVkIF9yZXF1ZXN0IG9iamVjdCB3aWxsIGJlIHVzZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybnMge09iamVjdH0gUmVxdWVzdCBvYmplY3QsIGlmIHVuZGVmaW5lZCwgX3JlcXVlc3Qgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9hdHRhY2hIZWFkZXJzKHJlcXVlc3QsIHVybCkge1xuICAgICAgICAgICAgICAgIHZhciBycSA9IF9yZXF1ZXN0O1xuICAgICAgICAgICAgICAgIGlmICgocmVxdWVzdCAhPSBudWxsKSAmJiAodHlwZW9mIChyZXF1ZXN0KSAhPT0gJ3VuZGVmaW5lZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJxID0gcmVxdWVzdDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodXJsID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsID0gcnEudXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIElmIG5vdCBlbmFibGVkXG4gICAgICAgICAgICAgICAgaWYgKCFycS5hdHRhY2hIZWFkZXJzQXNRdWVyeVN0cmluZylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybDtcblxuICAgICAgICAgICAgICAgIC8vIElmIGFscmVhZHkgYWRkZWRcbiAgICAgICAgICAgICAgICBpZiAodXJsLmluZGV4T2YoXCJYLUF0bW9zcGhlcmUtRnJhbWV3b3JrXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSAhPT0gLTEpID8gJyYnIDogJz8nO1xuICAgICAgICAgICAgICAgIHVybCArPSBcIlgtQXRtb3NwaGVyZS10cmFja2luZy1pZD1cIiArIHJxLnV1aWQ7XG4gICAgICAgICAgICAgICAgdXJsICs9IFwiJlgtQXRtb3NwaGVyZS1GcmFtZXdvcms9XCIgKyBqUXVlcnkuYXRtb3NwaGVyZS52ZXJzaW9uO1xuICAgICAgICAgICAgICAgIHVybCArPSBcIiZYLUF0bW9zcGhlcmUtVHJhbnNwb3J0PVwiICsgcnEudHJhbnNwb3J0O1xuXG4gICAgICAgICAgICAgICAgaWYgKHJxLnRyYWNrTWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImWC1BdG1vc3BoZXJlLVRyYWNrTWVzc2FnZVNpemU9XCIgKyBcInRydWVcIjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocnEubGFzdFRpbWVzdGFtcCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZYLUNhY2hlLURhdGU9XCIgKyBycS5sYXN0VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZYLUNhY2hlLURhdGU9XCIgKyAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChycS5oZWFydGJlYXQgIT09IG51bGwgJiYgcnEuaGVhcnRiZWF0LnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgKz0gXCImWC1IZWFydGJlYXQtU2VydmVyPVwiICsgcnEuaGVhcnRiZWF0LnNlcnZlcjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAocnEuY29udGVudFR5cGUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZDb250ZW50LVR5cGU9XCIgKyAocnEudHJhbnNwb3J0ID09PSAnd2Vic29ja2V0JyA/IHJxLmNvbnRlbnRUeXBlIDogZW5jb2RlVVJJQ29tcG9uZW50KHJxLmNvbnRlbnRUeXBlKSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJxLmVuYWJsZVByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSBcIiZYLWF0bW8tcHJvdG9jb2w9dHJ1ZVwiO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKHJxLmhlYWRlcnMsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodGhpcywgcnEsIHJlcXVlc3QsIF9yZXNwb25zZSkgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJlwiICsgZW5jb2RlVVJJQ29tcG9uZW50KG5hbWUpICsgXCI9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoaCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF90cmlnZ2VyT3BlbihycSkge1xuICAgICAgICAgICAgICAgIGlmICghcnEuaXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJxLmlzT3BlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIF9vcGVuKCdvcGVuaW5nJywgcnEudHJhbnNwb3J0LCBycSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChycS5pc1Jlb3Blbikge1xuICAgICAgICAgICAgICAgICAgICBycS5pc1Jlb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfb3BlbigncmUtb3BlbmluZycsIHJxLnRyYW5zcG9ydCwgcnEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBFeGVjdXRlIGFqYXggcmVxdWVzdC4gPGJyPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSByZXF1ZXN0IHtPYmplY3R9IHJlcXVlc3QgUmVxdWVzdCBwYXJhbWV0ZXJzLCBpZiB1bmRlZmluZWQgX3JlcXVlc3Qgb2JqZWN0IHdpbGwgYmUgdXNlZC5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9leGVjdXRlUmVxdWVzdChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJxID0gX3JlcXVlc3Q7XG4gICAgICAgICAgICAgICAgaWYgKChyZXF1ZXN0ICE9IG51bGwpIHx8ICh0eXBlb2YgKHJlcXVlc3QpICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcnEgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJxLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgcnEucmVhZHlTdGF0ZSA9IDA7XG5cbiAgICAgICAgICAgICAgICAvLyBDT1JTIGZha2UgdXNpbmcgSlNPTlBcbiAgICAgICAgICAgICAgICBpZiAoKHJxLnRyYW5zcG9ydCA9PT0gJ2pzb25wJykgfHwgKChycS5lbmFibGVYRFIpICYmIChqUXVlcnkuYXRtb3NwaGVyZS5jaGVja0NPUlNTdXBwb3J0KCkpKSkge1xuICAgICAgICAgICAgICAgICAgICBfanNvbnAocnEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJxLnRyYW5zcG9ydCA9PT0gJ2FqYXgnKSB7XG4gICAgICAgICAgICAgICAgICAgIF9hamF4KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGpRdWVyeS5icm93c2VyLm1zaWUgJiYgK2pRdWVyeS5icm93c2VyLnZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgMTApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKChycS50cmFuc3BvcnQgPT09ICdzdHJlYW1pbmcnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmVuYWJsZVhEUiAmJiB3aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWVYRFIocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWVTdHJlYW1pbmcocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKChycS5lbmFibGVYRFIpICYmICh3aW5kb3cuWERvbWFpblJlcXVlc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaWVYRFIocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHJlY29ubmVjdEYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJxLmxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChycS5yZWNvbm5lY3QgJiYgX3JlcXVlc3RDb3VudCsrIDwgcnEubWF4UmVjb25uZWN0T25DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX29wZW4oJ3JlLWNvbm5lY3RpbmcnLCByZXF1ZXN0LnRyYW5zcG9ydCwgcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfcmVjb25uZWN0KGFqYXhSZXF1ZXN0LCBycSwgcmVxdWVzdC5yZWNvbm5lY3RJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfb25FcnJvcigwLCBcIm1heFJlY29ubmVjdE9uQ2xvc2UgcmVhY2hlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICB2YXIgZGlzY29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcmV2ZW50IG9uZXJyb3IgY2FsbGJhY2sgdG8gYmUgY2FsbGVkXG4gICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5lcnJvckhhbmRsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBfY2xlYXJTdGF0ZSgpO1xuICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3RGKCk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChycS5yZWNvbm5lY3QgJiYgKHJxLm1heFJlcXVlc3QgPT09IC0xIHx8IHJxLnJlcXVlc3RDb3VudCsrIDwgcnEubWF4UmVxdWVzdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFqYXhSZXF1ZXN0ID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcbiAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3QuaGFzRGF0YSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgIF9kb1JlcXVlc3QoYWpheFJlcXVlc3QsIHJxLCB0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocnEuc3VzcGVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2FjdGl2ZVJlcXVlc3QgPSBhamF4UmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChycS50cmFuc3BvcnQgIT09ICdwb2xsaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnRyYW5zcG9ydCA9IHJxLnRyYW5zcG9ydDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Qub25hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2xvc2UodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhamF4UmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5lcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLmZmVHJ5aW5nUmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdHVzID0gWE1MSHR0cFJlcXVlc3Quc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXR1cyA9IDUwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9yZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXR1cyA9IDUwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFfcmVzcG9uc2UuZXJyb3JIYW5kbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdEYoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9hYm9yZGluZ0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcENhbGxiYWNrSW52b2NhdGlvbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwZGF0ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnEudHJhbnNwb3J0ID09PSAnc3RyZWFtaW5nJyAmJiBycS5yZWFkeVN0YXRlID4gMiAmJiBhamF4UmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWNvbm5lY3RGKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBycS5yZWFkeVN0YXRlID0gYWpheFJlcXVlc3QucmVhZHlTdGF0ZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLnRyYW5zcG9ydCA9PT0gJ3N0cmVhbWluZycgJiYgYWpheFJlcXVlc3QucmVhZHlTdGF0ZSA+PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAocnEudHJhbnNwb3J0ID09PSAnbG9uZy1wb2xsaW5nJyAmJiBhamF4UmVxdWVzdC5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aW1lb3V0KF9yZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLnRyYW5zcG9ydCAhPT0gJ3BvbGxpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTVNJRSA5IGFuZCBsb3dlciBzdGF0dXMgY2FuIGJlIGhpZ2hlciB0aGFuIDEwMDAsIENocm9tZSBjYW4gYmUgMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXhSZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gYWpheFJlcXVlc3Quc3RhdHVzID4gMTAwMCA/IDAgOiBhamF4UmVxdWVzdC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyA+PSAzMDAgfHwgc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcmVmb3ggaW5jb3JyZWN0bHkgc2VuZCBzdGF0ZWNoYW5nZSAwLT4yIHdoZW4gYSByZWNvbm5lY3QgYXR0ZW1wdCBmYWlscy4gVGhlIGFib3ZlIGNoZWNrcyBlbnN1cmUgdGhhdCBvbm9wZW4gaXMgbm90IGNhbGxlZCBmb3IgdGhlc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoKCFycS5lbmFibGVQcm90b2NvbCB8fCAhcmVxdWVzdC5maXJzdE1lc3NhZ2UpICYmIGFqYXhSZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlyZWZveCBpbmNvcnJlY3RseSBzZW5kIHN0YXRlY2hhbmdlIDAtPjIgd2hlbiBhIHJlY29ubmVjdCBhdHRlbXB0IGZhaWxzLiBUaGUgYWJvdmUgY2hlY2tzIGVuc3VyZSB0aGF0IG9ub3BlbiBpcyBub3QgY2FsbGVkIGZvciB0aGVzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIGFqYXhSZXF1ZXN0Lm9uZXJyb3Igd2lsbCBiZSBjYWxsZWQganVzdCBhZnRlciBvbnJlYWR5c3RhdGVjaGFuZ2UgaXMgY2FsbGVkLCBzbyB3ZSBkZWxheSB0aGUgdHJpZ2dlciB1bnRpbGwgd2UgYXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdhcmFudGVlIHRoZSBjb25uZWN0aW9uIGlzIHdlbGwgZXN0YWJsaXNoZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuYnJvd3Nlci5tb3ppbGxhICYmIF9yZXNwb25zZS5mZlRyeWluZ1JlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLmZmVHJ5aW5nUmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIV9yZXNwb25zZS5mZlRyeWluZ1JlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90cmlnZ2VyT3BlbihycSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCA1MDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RyaWdnZXJPcGVuKHJxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFqYXhSZXF1ZXN0LnJlYWR5U3RhdGUgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlVGV4dCA9IGFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkudHJpbShyZXNwb25zZVRleHQpLmxlbmd0aCA9PT0gMCAmJiBycS50cmFuc3BvcnQgPT09ICdsb25nLXBvbGxpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciBicm93c2VyIHRoYXQgYXJlbid0IHN1cHBvcnQgb25hYm9ydFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFqYXhSZXF1ZXN0Lmhhc0RhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3QuaGFzRGF0YSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3QuaGFzRGF0YSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVhZEhlYWRlcnMoYWpheFJlcXVlc3QsIF9yZXF1ZXN0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS50cmFuc3BvcnQgPT09ICdzdHJlYW1pbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5LmJyb3dzZXIub3BlcmEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gcmVzcG9uc2VUZXh0LnN1YnN0cmluZyhycS5sYXN0SW5kZXgsIHJlc3BvbnNlVGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcENhbGxiYWNrSW52b2NhdGlvbiA9IF90cmFja01lc3NhZ2VTaXplKG1lc3NhZ2UsIHJxLCBfcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycS5sYXN0SW5kZXggPSByZXNwb25zZVRleHQubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBDYWxsYmFja0ludm9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5pdGVyYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc3BvbnNlLnN0YXR1cyAhPT0gNTAwICYmIGFqYXhSZXF1ZXN0LnJlc3BvbnNlVGV4dC5sZW5ndGggPiBycS5sYXN0SW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0dXMgPSBhamF4UmVxdWVzdC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UuaGVhZGVycyA9IHBhcnNlSGVhZGVycyhhamF4UmVxdWVzdC5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWFkSGVhZGVycyhhamF4UmVxdWVzdCwgX3JlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0dXMgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RpbWVvdXQoX3JlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0ZSA9IFwibWVzc2FnZVJlY2VpdmVkXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0LnN1YnN0cmluZyhycS5sYXN0SW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycS5sYXN0SW5kZXggPSBhamF4UmVxdWVzdC5yZXNwb25zZVRleHQubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBDYWxsYmFja0ludm9jYXRpb24gPSBfdHJhY2tNZXNzYWdlU2l6ZShtZXNzYWdlLCBycSwgX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFza2lwQ2FsbGJhY2tJbnZvY2F0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdmVyaWZ5U3RyZWFtaW5nTGVuZ3RoKGFqYXhSZXF1ZXN0LCBycSkpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlY29ubmVjdE9uTWF4U3RyZWFtaW5nTGVuZ3RoKGFqYXhSZXF1ZXN0LCBycSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9yZXNwb25zZS5zdGF0dXMgPiA0MDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gUHJldmVudCByZXBsYXlpbmcgdGhlIGxhc3QgbWVzc2FnZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnEubGFzdEluZGV4ID0gYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcENhbGxiYWNrSW52b2NhdGlvbiA9IF90cmFja01lc3NhZ2VTaXplKHJlc3BvbnNlVGV4dCwgcnEsIF9yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjbG9zZVN0cmVhbSA9IF92ZXJpZnlTdHJlYW1pbmdMZW5ndGgoYWpheFJlcXVlc3QsIHJxKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0dXMgPSBhamF4UmVxdWVzdC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5oZWFkZXJzID0gcGFyc2VIZWFkZXJzKGFqYXhSZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVhZEhlYWRlcnMoYWpheFJlcXVlc3QsIHJxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0dXMgPSA0MDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLnN1c3BlbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXRlID0gX3Jlc3BvbnNlLnN0YXR1cyA9PT0gMCA/IFwiY2xvc2VkXCIgOiBcIm1lc3NhZ2VSZWNlaXZlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0ZSA9IFwibWVzc2FnZVB1Ymxpc2hlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpc0FsbG93ZWRUb1JlY29ubmVjdCA9ICFjbG9zZVN0cmVhbSAmJiByZXF1ZXN0LnRyYW5zcG9ydCAhPT0gJ3N0cmVhbWluZycgJiYgcmVxdWVzdC50cmFuc3BvcnQgIT09ICdwb2xsaW5nJzs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQWxsb3dlZFRvUmVjb25uZWN0ICYmICFycS5leGVjdXRlQ2FsbGJhY2tCZWZvcmVSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlY29ubmVjdChhamF4UmVxdWVzdCwgcnEsIHJxLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXNwb25zZS5yZXNwb25zZUJvZHkubGVuZ3RoICE9PSAwICYmICFza2lwQ2FsbGJhY2tJbnZvY2F0aW9uKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChpc0FsbG93ZWRUb1JlY29ubmVjdCAmJiBycS5leGVjdXRlQ2FsbGJhY2tCZWZvcmVSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlY29ubmVjdChhamF4UmVxdWVzdCwgcnEsIHJxLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsb3NlU3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZWNvbm5lY3RPbk1heFN0cmVhbWluZ0xlbmd0aChhamF4UmVxdWVzdCwgcnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBhamF4UmVxdWVzdC5zZW5kKHJxLmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICBfc3Vic2NyaWJlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5sb2cocnEubG9nTGV2ZWwsIFtcIk1heCByZS1jb25uZWN0aW9uIHJlYWNoZWQuXCJdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfb25FcnJvcigwLCBcIm1heFJlcXVlc3QgcmVhY2hlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWNvbm5lY3RPbk1heFN0cmVhbWluZ0xlbmd0aChhamF4UmVxdWVzdCwgcnEpIHtcbiAgICAgICAgICAgICAgICBfY2xvc2UoKTtcbiAgICAgICAgICAgICAgICBfYWJvcmRpbmdDb25uZWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgX3JlY29ubmVjdChhamF4UmVxdWVzdCwgcnEsIDUwMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRG8gYWpheCByZXF1ZXN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBhamF4UmVxdWVzdCBBamF4IHJlcXVlc3QuXG4gICAgICAgICAgICAgKiBAcGFyYW0gcmVxdWVzdCBSZXF1ZXN0IHBhcmFtZXRlcnMuXG4gICAgICAgICAgICAgKiBAcGFyYW0gY3JlYXRlIElmIGFqYXggcmVxdWVzdCBoYXMgdG8gYmUgb3Blbi5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2RvUmVxdWVzdChhamF4UmVxdWVzdCwgcmVxdWVzdCwgY3JlYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCBBbmRyb2lkIHRvIGNhY2hlIHJlcXVlc3RcbiAgICAgICAgICAgICAgICB2YXIgdXJsID0gcmVxdWVzdC51cmw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuZGlzcGF0Y2hVcmwgIT0gbnVsbCAmJiByZXF1ZXN0Lm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCArPSByZXF1ZXN0LmRpc3BhdGNoVXJsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cmwgPSBfYXR0YWNoSGVhZGVycyhyZXF1ZXN0LCB1cmwpO1xuICAgICAgICAgICAgICAgIHVybCA9IGpRdWVyeS5hdG1vc3BoZXJlLnByZXBhcmVVUkwodXJsKTtcblxuICAgICAgICAgICAgICAgIGlmIChjcmVhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Qub3BlbihyZXF1ZXN0Lm1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY29ubmVjdFRpbWVvdXQgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QucmVxdWVzdENvdW50ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVwYXJlQ2FsbGJhY2soXCJDb25uZWN0IHRpbWVvdXRcIiwgXCJjbG9zZWRcIiwgMjAwLCByZXF1ZXN0LnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVxdWVzdC5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3Qud2l0aENyZWRlbnRpYWxzICYmIF9yZXF1ZXN0LnRyYW5zcG9ydCAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKFwid2l0aENyZWRlbnRpYWxzXCIgaW4gYWpheFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFqYXhSZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIV9yZXF1ZXN0LmRyb3BIZWFkZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFqYXhSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJYLUF0bW9zcGhlcmUtRnJhbWV3b3JrXCIsIGpRdWVyeS5hdG1vc3BoZXJlLnZlcnNpb24pO1xuICAgICAgICAgICAgICAgICAgICBhamF4UmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BdG1vc3BoZXJlLVRyYW5zcG9ydFwiLCByZXF1ZXN0LnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0Lmxhc3RUaW1lc3RhbXAgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIlgtQ2FjaGUtRGF0ZVwiLCByZXF1ZXN0Lmxhc3RUaW1lc3RhbXApO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIlgtQ2FjaGUtRGF0ZVwiLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhamF4UmVxdWVzdC5oZWFydGJlYXQgIT09IG51bGwgJiYgYWpheFJlcXVlc3QuaGVhcnRiZWF0LnNlcnZlciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIlgtSGVhcnRiZWF0LVNlcnZlclwiLCBhamF4UmVxdWVzdC5oZWFydGJlYXQuc2VydmVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnRyYWNrTWVzc2FnZUxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihcIlgtQXRtb3NwaGVyZS1UcmFja01lc3NhZ2VTaXplXCIsIFwidHJ1ZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhamF4UmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKFwiWC1BdG1vc3BoZXJlLXRyYWNraW5nLWlkXCIsIHJlcXVlc3QudXVpZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2gocmVxdWVzdC5oZWFkZXJzLCBmdW5jdGlvbiAobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoID0galF1ZXJ5LmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbCh0aGlzLCBhamF4UmVxdWVzdCwgcmVxdWVzdCwgY3JlYXRlLCBfcmVzcG9uc2UpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWpheFJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihuYW1lLCBoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QuY29udGVudFR5cGUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFqYXhSZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoXCJDb250ZW50LVR5cGVcIiwgcmVxdWVzdC5jb250ZW50VHlwZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBfcmVjb25uZWN0KGFqYXhSZXF1ZXN0LCByZXF1ZXN0LCByZWNvbm5lY3RJbnRlcnZhbCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlY29ubmVjdCB8fCAocmVxdWVzdC5zdXNwZW5kICYmIF9zdWJzY3JpYmVkKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFqYXhSZXF1ZXN0LnJlYWR5U3RhdGUgPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBhamF4UmVxdWVzdC5zdGF0dXMgPiAxMDAwID8gMCA6IGFqYXhSZXF1ZXN0LnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdHVzID0gc3RhdHVzID09PSAwID8gMjA0IDogc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVhc29uID0gc3RhdHVzID09PSAwID8gXCJTZXJ2ZXIgcmVzdW1lZCB0aGUgY29ubmVjdGlvbiBvciBkb3duLlwiIDogXCJPS1wiO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlY29ubmVjdCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC5pZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXF1ZXN0LnJlY29ubmVjdElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocmVxdWVzdC5yZWNvbm5lY3RJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcmVxdWVzdC5yZWNvbm5lY3RJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZWNvbm5lY3RJbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LnJlY29ubmVjdElkID0gX2V4ZWN1dGVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgcmVjb25uZWN0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgX2V4ZWN1dGVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBfdHJ5aW5nVG9SZWNvbm5lY3QocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS5zdGF0ZSA9ICdyZS1jb25uZWN0aW5nJztcbiAgICAgICAgICAgICAgICBfaW52b2tlRnVuY3Rpb24ocmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGcm9tIGpxdWVyeS1zdHJlYW0sIHdoaWNoIGlzIEFQTDIgbGljZW5zZWQgYXMgd2VsbC5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pZVhEUihyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QudHJhbnNwb3J0ICE9PSBcInBvbGxpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBfaWVTdHJlYW0gPSBfY29uZmlndXJlWERSKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICBfaWVTdHJlYW0ub3BlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9jb25maWd1cmVYRFIocmVxdWVzdCkub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2NvbmZpZ3VyZVhEUihyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJxID0gX3JlcXVlc3Q7XG4gICAgICAgICAgICAgICAgaWYgKChyZXF1ZXN0ICE9IG51bGwpICYmICh0eXBlb2YgKHJlcXVlc3QpICE9PSAndW5kZWZpbmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcnEgPSByZXF1ZXN0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHZhciB0cmFuc3BvcnQgPSBycS50cmFuc3BvcnQ7XG4gICAgICAgICAgICAgICAgdmFyIGxhc3RJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIHhkciA9IG5ldyB3aW5kb3cuWERvbWFpblJlcXVlc3QoKTtcblxuICAgICAgICAgICAgICAgIHZhciByZWNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChycS50cmFuc3BvcnQgPT09IFwibG9uZy1wb2xsaW5nXCIgJiYgKHJxLnJlY29ubmVjdCAmJiAocnEubWF4UmVxdWVzdCA9PT0gLTEgfHwgcnEucmVxdWVzdENvdW50KysgPCBycS5tYXhSZXF1ZXN0KSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhkci5zdGF0dXMgPSAyMDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBfaWVYRFIocnEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciByZXdyaXRlVVJMID0gcnEucmV3cml0ZVVSTCB8fCBmdW5jdGlvbiAodXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1haW50YWluaW5nIHNlc3Npb24gYnkgcmV3cml0aW5nIFVSTFxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzY0NTM3NzkvbWFpbnRhaW5pbmctc2Vzc2lvbi1ieS1yZXdyaXRpbmctdXJsXG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IC8oPzpefDtcXHMqKShKU0VTU0lPTklEfFBIUFNFU1NJRCk9KFteO10qKS8uZXhlYyhkb2N1bWVudC5jb29raWUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAobWF0Y2ggJiYgbWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJKU0VTU0lPTklEXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVybC5yZXBsYWNlKC87anNlc3Npb25pZD1bXlxcP10qfChcXD8pfCQvLCBcIjtqc2Vzc2lvbmlkPVwiICsgbWF0Y2hbMl0gKyBcIiQxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIlBIUFNFU1NJRFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmwucmVwbGFjZSgvXFw/UEhQU0VTU0lEPVteJl0qJj98XFw/fCQvLCBcIj9QSFBTRVNTSUQ9XCIgKyBtYXRjaFsyXSArIFwiJlwiKS5yZXBsYWNlKC8mJC8sIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXMgb3BlbiBhbmQgbWVzc2FnZSBldmVudFxuICAgICAgICAgICAgICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGUoeGRyKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEhhbmRsZXMgZXJyb3IgZXZlbnRcbiAgICAgICAgICAgICAgICB4ZHIub25lcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIHNlcnZlciBkb2Vzbid0IHNlbmQgYW55dGhpbmcgYmFjayB0byBYRFIgd2lsbCBmYWlsIHdpdGggcG9sbGluZ1xuICAgICAgICAgICAgICAgICAgICBpZiAocnEudHJhbnNwb3J0ICE9PSAncG9sbGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3RDb3VudCsrIDwgcnEubWF4UmVjb25uZWN0T25DbG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5yZWNvbm5lY3RJbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnEucmVjb25uZWN0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcGVuKCdyZS1jb25uZWN0aW5nJywgcmVxdWVzdC50cmFuc3BvcnQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2llWERSKHJxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgcnEucmVjb25uZWN0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vcGVuKCdyZS1jb25uZWN0aW5nJywgcmVxdWVzdC50cmFuc3BvcnQsIHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWVYRFIocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX29uRXJyb3IoMCwgXCJtYXhSZWNvbm5lY3RPbkNsb3NlIHJlYWNoZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlcyBjbG9zZSBldmVudFxuICAgICAgICAgICAgICAgIHhkci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHZhciBoYW5kbGUgPSBmdW5jdGlvbiAoeGRyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChycS5pZCk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0geGRyLnJlc3BvbnNlVGV4dDtcblxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgICAgICAgICAgICAgICAgbGFzdEluZGV4ICs9IG1lc3NhZ2UubGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQgIT09ICdwb2xsaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RpbWVvdXQocnEpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2tpcENhbGxiYWNrSW52b2NhdGlvbiA9IF90cmFja01lc3NhZ2VTaXplKG1lc3NhZ2UsIHJxLCBfcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSAnbG9uZy1wb2xsaW5nJyAmJiBqUXVlcnkudHJpbShtZXNzYWdlKS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnEuZXhlY3V0ZUNhbGxiYWNrQmVmb3JlUmVjb25uZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghc2tpcENhbGxiYWNrSW52b2NhdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcmVwYXJlQ2FsbGJhY2soX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSwgXCJtZXNzYWdlUmVjZWl2ZWRcIiwgMjAwLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJxLmV4ZWN1dGVDYWxsYmFja0JlZm9yZVJlY29ubmVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB1cmwgPSBycS51cmw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocnEuZGlzcGF0Y2hVcmwgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCArPSBycS5kaXNwYXRjaFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IF9hdHRhY2hIZWFkZXJzKHJxLCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgeGRyLm9wZW4ocnEubWV0aG9kLCByZXdyaXRlVVJMKHVybCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLm1ldGhvZCA9PT0gJ0dFVCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZHIuc2VuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ZHIuc2VuZChycS5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmNvbm5lY3RUaW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJxLmlkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5yZXF1ZXN0Q291bnQgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jbGVhclN0YXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcHJlcGFyZUNhbGxiYWNrKFwiQ29ubmVjdCB0aW1lb3V0XCIsIFwiY2xvc2VkXCIsIDIwMCwgcnEudHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJxLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHhkci5hYm9ydCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2llU3RyZWFtaW5nKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBfaWVTdHJlYW0gPSBfY29uZmlndXJlSUUocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgX2llU3RyZWFtLm9wZW4oKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2NvbmZpZ3VyZUlFKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnEgPSBfcmVxdWVzdDtcbiAgICAgICAgICAgICAgICBpZiAoKHJlcXVlc3QgIT0gbnVsbCkgJiYgKHR5cGVvZiAocmVxdWVzdCkgIT09ICd1bmRlZmluZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICBycSA9IHJlcXVlc3Q7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIHN0b3A7XG4gICAgICAgICAgICAgICAgdmFyIGRvYyA9IG5ldyB3aW5kb3cuQWN0aXZlWE9iamVjdChcImh0bWxmaWxlXCIpO1xuXG4gICAgICAgICAgICAgICAgZG9jLm9wZW4oKTtcbiAgICAgICAgICAgICAgICBkb2MuY2xvc2UoKTtcblxuICAgICAgICAgICAgICAgIHZhciB1cmwgPSBycS51cmw7XG4gICAgICAgICAgICAgICAgaWYgKHJxLmRpc3BhdGNoVXJsICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdXJsICs9IHJxLmRpc3BhdGNoVXJsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChycS50cmFuc3BvcnQgIT09ICdwb2xsaW5nJykge1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UudHJhbnNwb3J0ID0gcnEudHJhbnNwb3J0O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG9wZW46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudChcImlmcmFtZVwiKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gX2F0dGFjaEhlYWRlcnMocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmRhdGEgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsICs9IFwiJlgtQXRtb3NwaGVyZS1Qb3N0LUJvZHk9XCIgKyBlbmNvZGVVUklDb21wb25lbnQocnEuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpbmFsbHkgYXR0YWNoIGEgdGltZXN0YW1wIHRvIHByZXZlbnQgQW5kcm9pZCBhbmQgSUUgY2FjaGluZy5cbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IGpRdWVyeS5hdG1vc3BoZXJlLnByZXBhcmVVUkwodXJsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnNyYyA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZvciB0aGUgc2VydmVyIHRvIHJlc3BvbmQgaW4gYSBjb25zaXN0ZW50IGZvcm1hdCByZWdhcmRsZXNzIG9mIHVzZXIgYWdlbnQsIHdlIHBvbGxzIHJlc3BvbnNlIHRleHRcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjZG9jID0gaWZyYW1lLmNvbnRlbnREb2N1bWVudCB8fCBpZnJhbWUuY29udGVudFdpbmRvdy5kb2N1bWVudDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCA9IGpRdWVyeS5hdG1vc3BoZXJlLml0ZXJhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2RvYy5maXJzdENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBEZXRlY3RzIGNvbm5lY3Rpb24gZmFpbHVyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2RvYy5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5Lm5vb3AoY2RvYy5maWxlU2l6ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ByZXBhcmVDYWxsYmFjayhcIkNvbm5lY3Rpb24gRmFpbHVyZVwiLCBcImVycm9yXCIsIDUwMCwgcnEudHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gY2RvYy5ib2R5ID8gY2RvYy5ib2R5Lmxhc3RDaGlsZCA6IGNkb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZWFkUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBDbG9uZXMgdGhlIGVsZW1lbnQgbm90IHRvIGRpc3R1cmIgdGhlIG9yaWdpbmFsIG9uZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb25lID0gcmVzLmNsb25lTm9kZSh0cnVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgdGhlIGxhc3QgY2hhcmFjdGVyIGlzIGEgY2FycmlhZ2UgcmV0dXJuIG9yIGEgbGluZSBmZWVkLCBJRSBpZ25vcmVzIGl0IGluIHRoZSBpbm5lclRleHQgcHJvcGVydHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlZm9yZSwgd2UgYWRkIGFub3RoZXIgbm9uLW5ld2xpbmUgY2hhcmFjdGVyIHRvIHByZXNlcnZlIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9uZS5hcHBlbmRDaGlsZChjZG9jLmNyZWF0ZVRleHROb2RlKFwiLlwiKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gY2xvbmUuaW5uZXJUZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zdWJzdHJpbmcoMCwgdGV4dC5sZW5ndGggLSAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG8gc3VwcG9ydCB0ZXh0L2h0bWwgY29udGVudCB0eXBlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghalF1ZXJ5Lm5vZGVOYW1lKHJlcywgXCJwcmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEluamVjdHMgYSBwbGFpbnRleHQgZWxlbWVudCB3aGljaCByZW5kZXJzIHRleHQgd2l0aG91dCBpbnRlcnByZXRpbmcgdGhlIEhUTUwgYW5kIGNhbm5vdCBiZSBzdG9wcGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBkZXByZWNhdGVkIGluIEhUTUw1LCBidXQgc3RpbGwgd29ya3NcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBoZWFkID0gY2RvYy5oZWFkIHx8IGNkb2MuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdIHx8IGNkb2MuZG9jdW1lbnRFbGVtZW50IHx8IGNkb2M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2NyaXB0ID0gY2RvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHQudGV4dCA9IFwiZG9jdW1lbnQud3JpdGUoJzxwbGFpbnRleHQ+JylcIjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcGxhaW50ZXh0IGVsZW1lbnQgd2lsbCBiZSB0aGUgcmVzcG9uc2UgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXMgPSBjZG9jLmJvZHkubGFzdENoaWxkO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnEuaXNSZW9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlcyBtZXNzYWdlIGFuZCBjbG9zZSBldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9wID0galF1ZXJ5LmF0bW9zcGhlcmUuaXRlcmF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHJlYWRSZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gcnEubGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RpbWVvdXQoX3JlcXVlc3QpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXR1cyA9IDIwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UuZXJyb3IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRW1wdGllcyByZXNwb25zZSBldmVyeSB0aW1lIHRoYXQgaXQgaXMgaGFuZGxlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5pbm5lclRleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBza2lwQ2FsbGJhY2tJbnZvY2F0aW9uID0gX3RyYWNrTWVzc2FnZVNpemUodGV4dCwgcnEsIF9yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBDYWxsYmFja0ludm9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ByZXBhcmVDYWxsYmFjayhfcmVzcG9uc2UucmVzcG9uc2VCb2R5LCBcIm1lc3NhZ2VSZWNlaXZlZFwiLCAyMDAsIHJxLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJxLmxhc3RJbmRleCA9IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZG9jLnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pbnZva2VDbG9zZSh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfb3BlbigncmUtY29ubmVjdGluZycsIHJxLnRyYW5zcG9ydCwgcnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5yZWNvbm5lY3RJbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcnEucmVjb25uZWN0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9pZVN0cmVhbWluZyhycSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJxLnJlY29ubmVjdEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWVTdHJlYW1pbmcocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIG51bGwpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLmVycm9yID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX29wZW4oJ3JlLWNvbm5lY3RpbmcnLCBycS50cmFuc3BvcnQsIHJxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0Q291bnQrKyA8IHJxLm1heFJlY29ubmVjdE9uQ2xvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5yZWNvbm5lY3RJbnRlcnZhbCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBycS5yZWNvbm5lY3RJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfaWVTdHJlYW1pbmcocnEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIHJxLnJlY29ubmVjdEludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2llU3RyZWFtaW5nKHJxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9vbkVycm9yKDAsIFwibWF4UmVjb25uZWN0T25DbG9zZSByZWFjaGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5leGVjQ29tbWFuZChcIlN0b3BcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRvYy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICAgICAgY2xvc2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkb2MuZXhlY0NvbW1hbmQoXCJTdG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX2ludm9rZUNsb3NlKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZW5kIG1lc3NhZ2UuIDxicj5cbiAgICAgICAgICAgICAqIFdpbGwgYmUgYXV0b21hdGljYWxseSBkaXNwYXRjaCB0byBvdGhlciBjb25uZWN0ZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3QsIHN0cmluZ30gTWVzc2FnZSB0byBzZW5kLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX3B1c2gobWVzc2FnZSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKF9sb2NhbFN0b3JhZ2VTZXJ2aWNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3B1c2hMb2NhbChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF9hY3RpdmVSZXF1ZXN0ICE9IG51bGwgfHwgX3NzZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9wdXNoQWpheE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfaWVTdHJlYW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfcHVzaElFKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoX2pxeGhyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3B1c2hKc29ucChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKF93ZWJzb2NrZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfcHVzaFdlYlNvY2tldChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfb25FcnJvcigwLCBcIk5vIHN1c3BlbmRlZCBjb25uZWN0aW9uIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZXJyb3IoXCJObyBzdXNwZW5kZWQgY29ubmVjdGlvbiBhdmFpbGFibGUuIE1ha2Ugc3VyZSBhdG1vc3BoZXJlLnN1YnNjcmliZSBoYXMgYmVlbiBjYWxsZWQgYW5kIHJlcXVlc3Qub25PcGVuIGludm9rZWQgYmVmb3JlIGludm9raW5nIHRoaXMgbWV0aG9kXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX3B1c2hPbkNsb3NlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgcnEgPSBfZ2V0UHVzaFJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcnEudHJhbnNwb3J0ID0gXCJhamF4XCI7XG4gICAgICAgICAgICAgICAgcnEubWV0aG9kID0gXCJHRVRcIjtcbiAgICAgICAgICAgICAgICBycS5hc3luYyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHJxLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9leGVjdXRlUmVxdWVzdChycSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9wdXNoTG9jYWwobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIF9sb2NhbFN0b3JhZ2VTZXJ2aWNlLnNlbmQobWVzc2FnZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbnRyYVB1c2gobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIC8vIElFIDkgd2lsbCBjcmFzaCBpZiBub3QuXG4gICAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoX2xvY2FsU3RvcmFnZVNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2NhbFN0b3JhZ2VTZXJ2aWNlLmxvY2FsU2VuZChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChfc3RvcmFnZVNlcnZpY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdG9yYWdlU2VydmljZS5zaWduYWwoXCJsb2NhbE1lc3NhZ2VcIiwgalF1ZXJ5LnN0cmluZ2lmeUpTT04oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBndWlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50OiBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogU2VuZCBhIG1lc3NhZ2UgdXNpbmcgY3VycmVudGx5IG9wZW5lZCBhamF4IHJlcXVlc3QgKHVzaW5nIGh0dHAtc3RyZWFtaW5nIG9yIGxvbmctcG9sbGluZykuIDxicj5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZywgT2JqZWN0fSBNZXNzYWdlIHRvIHNlbmQuIFRoaXMgaXMgYW4gb2JqZWN0LCBzdHJpbmcgbWVzc2FnZSBpcyBzYXZlZCBpbiBkYXRhIG1lbWJlci5cbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9wdXNoQWpheE1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBycSA9IF9nZXRQdXNoUmVxdWVzdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBfZXhlY3V0ZVJlcXVlc3QocnEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlbmQgYSBtZXNzYWdlIHVzaW5nIGN1cnJlbnRseSBvcGVuZWQgaWUgc3RyZWFtaW5nICh1c2luZyBodHRwLXN0cmVhbWluZyBvciBsb25nLXBvbGxpbmcpLiA8YnI+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmcsIE9iamVjdH0gTWVzc2FnZSB0byBzZW5kLiBUaGlzIGlzIGFuIG9iamVjdCwgc3RyaW5nIG1lc3NhZ2UgaXMgc2F2ZWQgaW4gZGF0YSBtZW1iZXIuXG4gICAgICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfcHVzaElFKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QuZW5hYmxlWERSICYmIGpRdWVyeS5hdG1vc3BoZXJlLmNoZWNrQ09SU1N1cHBvcnQoKSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcnEgPSBfZ2V0UHVzaFJlcXVlc3QobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIERvIG5vdCByZWNvbm5lY3Qgc2luY2Ugd2UgYXJlIHB1c2hpbmcuXG4gICAgICAgICAgICAgICAgICAgIHJxLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBfanNvbnAocnEpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9wdXNoQWpheE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlbmQgYSBtZXNzYWdlIHVzaW5nIGpzb25wIHRyYW5zcG9ydC4gPGJyPlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nLCBPYmplY3R9IE1lc3NhZ2UgdG8gc2VuZC4gVGhpcyBpcyBhbiBvYmplY3QsIHN0cmluZyBtZXNzYWdlIGlzIHNhdmVkIGluIGRhdGEgbWVtYmVyLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX3B1c2hKc29ucChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgX3B1c2hBamF4TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2dldFN0cmluZ01lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKG1zZykgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1zZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBCdWlsZCByZXF1ZXN0IHVzZSB0byBwdXNoIG1lc3NhZ2UgdXNpbmcgbWV0aG9kICdQT1NUJyA8YnI+LiBUcmFuc3BvcnQgaXMgZGVmaW5lZCBhcyAncG9sbGluZycgYW5kICdzdXNwZW5kJyBpcyBzZXQgdG8gZmFsc2UuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBSZXF1ZXN0IG9iamVjdCB1c2UgdG8gcHVzaCBtZXNzYWdlLlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2dldFB1c2hSZXF1ZXN0KG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gX2dldFN0cmluZ01lc3NhZ2UobWVzc2FnZSk7XG5cbiAgICAgICAgICAgICAgICB2YXIgcnEgPSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3RlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHRpbWVvdXQ6IDYwMDAwLFxuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBfcmVxdWVzdC51cmwsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBfcmVxdWVzdC5jb250ZW50VHlwZSxcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyczogX3JlcXVlc3QuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgICAgcmVjb25uZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGF0YTogbXNnLFxuICAgICAgICAgICAgICAgICAgICBzdXNwZW5kOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgbWF4UmVxdWVzdDogLTEsXG4gICAgICAgICAgICAgICAgICAgIGxvZ0xldmVsOiAnaW5mbycsXG4gICAgICAgICAgICAgICAgICAgIHJlcXVlc3RDb3VudDogMCxcbiAgICAgICAgICAgICAgICAgICAgd2l0aENyZWRlbnRpYWxzOiBfcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydDogJ3BvbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICBpc09wZW46IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGF0dGFjaEhlYWRlcnNBc1F1ZXJ5U3RyaW5nOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVYRFI6IF9yZXF1ZXN0LmVuYWJsZVhEUixcbiAgICAgICAgICAgICAgICAgICAgdXVpZDogX3JlcXVlc3QudXVpZCxcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2hVcmw6IF9yZXF1ZXN0LmRpc3BhdGNoVXJsLFxuICAgICAgICAgICAgICAgICAgICBlbmFibGVQcm90b2NvbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VEZWxpbWl0ZXI6ICd8JyxcbiAgICAgICAgICAgICAgICAgICAgdHJhY2tNZXNzYWdlTGVuZ3RoOiBfcmVxdWVzdC50cmFja01lc3NhZ2VMZW5ndGgsXG4gICAgICAgICAgICAgICAgICAgIG1heFJlY29ubmVjdE9uQ2xvc2U6IF9yZXF1ZXN0Lm1heFJlY29ubmVjdE9uQ2xvc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYXJ0YmVhdFRpbWVyOiBfcmVxdWVzdC5oZWFydGJlYXRUaW1lcixcbiAgICAgICAgICAgICAgICAgICAgaGVhcnRiZWF0OiBfcmVxdWVzdC5oZWFydGJlYXRcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJxID0galF1ZXJ5LmV4dGVuZChycSwgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNlbmQgYSBtZXNzYWdlIHVzaW5nIGN1cnJlbnRseSBvcGVuZWQgd2Vic29ja2V0LiA8YnI+XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBfcHVzaFdlYlNvY2tldChtZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IGpRdWVyeS5hdG1vc3BoZXJlLmlzQmluYXJ5KG1lc3NhZ2UpID8gbWVzc2FnZSA6IF9nZXRTdHJpbmdNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHZhciBkYXRhO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5kaXNwYXRjaFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gX3JlcXVlc3Qud2ViU29ja2V0UGF0aERlbGltaXRlciArIF9yZXF1ZXN0LmRpc3BhdGNoVXJsICsgX3JlcXVlc3Qud2ViU29ja2V0UGF0aERlbGltaXRlciArIG1zZztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBtc2c7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoIV93ZWJzb2NrZXQuY2FuU2VuZE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmVycm9yKFwiV2ViU29ja2V0IG5vdCBjb25uZWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgX3dlYnNvY2tldC5zZW5kKGRhdGEpO1xuXG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBfd2Vic29ja2V0Lm9uY2xvc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBfY2xlYXJTdGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgICAgIF9yZWNvbm5lY3RXaXRoRmFsbGJhY2tUcmFuc3BvcnQoXCJXZWJzb2NrZXQgZmFpbGVkLiBEb3duZ3JhZGluZyB0byBDb21ldCBhbmQgcmVzZW5kaW5nIFwiICsgbWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIF9wdXNoQWpheE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBfbG9jYWxNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICB2YXIgbSA9IGpRdWVyeS5wYXJzZUpTT04obWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgaWYgKG0uaWQgIT09IGd1aWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoX3JlcXVlc3Qub25Mb2NhbE1lc3NhZ2UpICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3Qub25Mb2NhbE1lc3NhZ2UobS5ldmVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIChqUXVlcnkuYXRtb3NwaGVyZS5vbkxvY2FsTWVzc2FnZSkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5vbkxvY2FsTWVzc2FnZShtLmV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX3ByZXBhcmVDYWxsYmFjayhtZXNzYWdlQm9keSwgc3RhdGUsIGVycm9yQ29kZSwgdHJhbnNwb3J0KSB7XG5cbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gbWVzc2FnZUJvZHk7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdHVzID0gZXJyb3JDb2RlO1xuICAgICAgICAgICAgICAgIF9yZXNwb25zZS5zdGF0ZSA9IHN0YXRlO1xuXG4gICAgICAgICAgICAgICAgX2ludm9rZUNhbGxiYWNrKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9yZWFkSGVhZGVycyh4ZHIsIHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlcXVlc3QucmVhZFJlc3BvbnNlc0hlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXF1ZXN0LmVuYWJsZVByb3RvY29sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0Lmxhc3RUaW1lc3RhbXAgPSBqUXVlcnkubm93KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LnV1aWQgPSBqUXVlcnkuYXRtb3NwaGVyZS5ndWlkKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGVtcERhdGUgPSB4ZHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ1gtQ2FjaGUtRGF0ZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRlbXBEYXRlICYmIHRlbXBEYXRlICE9IG51bGwgJiYgdGVtcERhdGUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3QubGFzdFRpbWVzdGFtcCA9IHRlbXBEYXRlLnNwbGl0KFwiIFwiKS5wb3AoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRlbXBVVUlEID0geGRyLmdldFJlc3BvbnNlSGVhZGVyKCdYLUF0bW9zcGhlcmUtdHJhY2tpbmctaWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0ZW1wVVVJRCAmJiB0ZW1wVVVJRCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC51dWlkID0gdGVtcFVVSUQuc3BsaXQoXCIgXCIpLnBvcCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbnZva2VGdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIF9mKHJlc3BvbnNlLCBfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgLy8gR2xvYmFsXG4gICAgICAgICAgICAgICAgX2YocmVzcG9uc2UsIGpRdWVyeS5hdG1vc3BoZXJlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2YocmVzcG9uc2UsIGYpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlUmVjZWl2ZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0Q291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZi5vbk1lc3NhZ2UpICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9uTWVzc2FnZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChmLm9uRXJyb3IpICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9uRXJyb3IocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJvcGVuaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3JlcXVlc3QuY2xvc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZi5vbk9wZW4pICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9uT3BlbihyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcIm1lc3NhZ2VQdWJsaXNoZWRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGYub25NZXNzYWdlUHVibGlzaGVkKSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5vbk1lc3NhZ2VQdWJsaXNoZWQocmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJyZS1jb25uZWN0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChmLm9uUmVjb25uZWN0KSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5vblJlY29ubmVjdChfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJjbG9zZWRCeUNsaWVudFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZi5vbkNsaWVudFRpbWVvdXQpICE9PSAndW5kZWZpbmVkJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmLm9uQ2xpZW50VGltZW91dChfcmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcInJlLW9wZW5pbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBfcmVxdWVzdC5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChmLm9uUmVvcGVuKSAhPT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5vblJlb3BlbihfcmVxdWVzdCwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmYWlsLXRvLXJlY29ubmVjdFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZi5vbkZhaWx1cmVUb1JlY29ubmVjdCkgIT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYub25GYWlsdXJlVG9SZWNvbm5lY3QoX3JlcXVlc3QsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwidW5zdWJzY3JpYmVcIjpcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlZFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNsb3NlZCA9IHR5cGVvZiAoX3JlcXVlc3QuY2xvc2VkKSAhPT0gJ3VuZGVmaW5lZCcgPyBfcmVxdWVzdC5jbG9zZWQgOiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2xvc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAoZi5vbkNsb3NlKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5vbkNsb3NlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LmNsb3NlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbnZva2VDbG9zZSh3YXNPcGVuKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9yZXNwb25zZS5zdGF0ZSAhPT0gJ2Nsb3NlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXRlID0gJ2Nsb3NlZCc7XG4gICAgICAgICAgICAgICAgICAgIF9yZXNwb25zZS5yZXNwb25zZUJvZHkgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBfcmVzcG9uc2UubWVzc2FnZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXR1cyA9ICF3YXNPcGVuID8gNTAxIDogMjAwO1xuICAgICAgICAgICAgICAgICAgICBfaW52b2tlQ2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogSW52b2tlIHJlcXVlc3QgY2FsbGJhY2tzLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9pbnZva2VDYWxsYmFjaygpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2FsbCA9IGZ1bmN0aW9uIChpbmRleCwgZnVuYykge1xuICAgICAgICAgICAgICAgICAgICBmdW5jKF9yZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGlmIChfbG9jYWxTdG9yYWdlU2VydmljZSA9PSBudWxsICYmIF9sb2NhbFNvY2tldEYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfbG9jYWxTb2NrZXRGKF9yZXNwb25zZS5yZXNwb25zZUJvZHkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9yZXF1ZXN0LnJlY29ubmVjdCA9IF9yZXF1ZXN0Lm1yZXF1ZXN0O1xuXG4gICAgICAgICAgICAgICAgdmFyIGlzU3RyaW5nID0gdHlwZW9mIChfcmVzcG9uc2UucmVzcG9uc2VCb2R5KSA9PT0gJ3N0cmluZyc7XG4gICAgICAgICAgICAgICAgdmFyIG1lc3NhZ2VzID0gKGlzU3RyaW5nICYmIF9yZXF1ZXN0LnRyYWNrTWVzc2FnZUxlbmd0aCkgPyAoX3Jlc3BvbnNlLm1lc3NhZ2VzLmxlbmd0aCA+IDAgPyBfcmVzcG9uc2UubWVzc2FnZXMgOiBbJyddKSA6IG5ldyBBcnJheShcbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPiAxICYmIG1lc3NhZ2VzW2ldLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSA9IChpc1N0cmluZykgPyBqUXVlcnkudHJpbShtZXNzYWdlc1tpXSkgOiBtZXNzYWdlc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoX2xvY2FsU3RvcmFnZVNlcnZpY2UgPT0gbnVsbCAmJiBfbG9jYWxTb2NrZXRGICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9sb2NhbFNvY2tldEYoX3Jlc3BvbnNlLnJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAoX3Jlc3BvbnNlLnJlc3BvbnNlQm9keS5sZW5ndGggPT09IDAgJiYgX3Jlc3BvbnNlLnN0YXRlID09PSBcIm1lc3NhZ2VSZWNlaXZlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIF9pbnZva2VGdW5jdGlvbihfcmVzcG9uc2UpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSBnbG9iYWwgY2FsbGJhY2tzXG4gICAgICAgICAgICAgICAgICAgIGlmIChqUXVlcnkuYXRtb3NwaGVyZS5jYWxsYmFja3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZGVidWcoXCJJbnZva2luZyBcIiArIGpRdWVyeS5hdG1vc3BoZXJlLmNhbGxiYWNrcy5sZW5ndGggKyBcIiBnbG9iYWwgY2FsbGJhY2tzOiBcIiArIF9yZXNwb25zZS5zdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5lYWNoKGpRdWVyeS5hdG1vc3BoZXJlLmNhbGxiYWNrcywgY2FsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKF9yZXF1ZXN0LmxvZ0xldmVsLCBbXCJDYWxsYmFjayBleGNlcHRpb25cIiArIGVdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEludm9rZSByZXF1ZXN0IGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKF9yZXF1ZXN0LmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmxvZ0xldmVsID09PSAnZGVidWcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuZGVidWcoXCJJbnZva2luZyByZXF1ZXN0IGNhbGxiYWNrc1wiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3JlcXVlc3QuY2FsbGJhY2soX3Jlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5sb2coX3JlcXVlc3QubG9nTGV2ZWwsIFtcIkNhbGxiYWNrIGV4Y2VwdGlvblwiICsgZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF92ZXJpZnlTdHJlYW1pbmdMZW5ndGgoYWpheFJlcXVlc3QsIHJxKSB7XG4gICAgICAgICAgICAgICAgLy8gV2FpdCB0byBiZSBzdXJlIHdlIGhhdmUgdGhlIGZ1bGwgbWVzc2FnZSBiZWZvcmUgY2xvc2luZy5cbiAgICAgICAgICAgICAgICBpZiAoX3Jlc3BvbnNlLnBhcnRpYWxNZXNzYWdlID09PSBcIlwiICYmIChycS50cmFuc3BvcnQgPT09ICdzdHJlYW1pbmcnKSAmJiAoYWpheFJlcXVlc3QucmVzcG9uc2VUZXh0Lmxlbmd0aCA+IHJxLm1heFN0cmVhbWluZ0xlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEaXNjb25uZWN0XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gX2Rpc2Nvbm5lY3QoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9yZXF1ZXN0LmVuYWJsZVByb3RvY29sICYmICFfcmVxdWVzdC5maXJzdE1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHF1ZXJ5ID0gXCJYLUF0bW9zcGhlcmUtVHJhbnNwb3J0PWNsb3NlJlgtQXRtb3NwaGVyZS10cmFja2luZy1pZD1cIiArIF9yZXF1ZXN0LnV1aWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgalF1ZXJ5LmVhY2goX3JlcXVlc3QuaGVhZGVycywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IGpRdWVyeS5pc0Z1bmN0aW9uKHZhbHVlKSA/IHZhbHVlLmNhbGwodGhpcywgX3JlcXVlc3QsIF9yZXF1ZXN0LCBfcmVzcG9uc2UpIDogdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVlcnkgKz0gXCImXCIgKyBlbmNvZGVVUklDb21wb25lbnQobmFtZSkgKyBcIj1cIiArIGVuY29kZVVSSUNvbXBvbmVudChoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHVybCA9IF9yZXF1ZXN0LnVybC5yZXBsYWNlKC8oWz8mXSlfPVteJl0qLywgcXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAodXJsID09PSBfcmVxdWVzdC51cmwgPyAoL1xcPy8udGVzdChfcmVxdWVzdC51cmwpID8gXCImXCIgOiBcIj9cIikgKyBxdWVyeSA6IFwiXCIpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5jb25uZWN0VGltZW91dCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dDogX3JlcXVlc3QuY29ubmVjdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpRdWVyeS5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDbG9zZSByZXF1ZXN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9jbG9zZSgpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QucmVjb25uZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9yZXF1ZXN0LnJlY29ubmVjdElkKTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIF9yZXF1ZXN0LnJlY29ubmVjdElkO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChfcmVxdWVzdC5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoX3JlcXVlc3QuaGVhcnRiZWF0VGltZXIpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIF9yZXF1ZXN0LnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIF9hYm9yZGluZ0Nvbm5lY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgICAgIF9yZXNwb25zZS5yZXF1ZXN0ID0gX3JlcXVlc3Q7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnN0YXRlID0gJ3Vuc3Vic2NyaWJlJztcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2UucmVzcG9uc2VCb2R5ID0gXCJcIjtcbiAgICAgICAgICAgICAgICBfcmVzcG9uc2Uuc3RhdHVzID0gNDA4O1xuICAgICAgICAgICAgICAgIF9pbnZva2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgIF9kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgX2NsZWFyU3RhdGUoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gX2NsZWFyU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgX3Jlc3BvbnNlLnBhcnRpYWxNZXNzYWdlID0gXCJcIjtcbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9yZXF1ZXN0LmlkKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX3JlcXVlc3QuaGVhcnRiZWF0VGltZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9yZXF1ZXN0LmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoX2llU3RyZWFtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2llU3RyZWFtLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIF9pZVN0cmVhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfanF4aHIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBfanF4aHIuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2pxeGhyID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKF9hY3RpdmVSZXF1ZXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX2FjdGl2ZVJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgX2FjdGl2ZVJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoX3dlYnNvY2tldCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfd2Vic29ja2V0LmNhblNlbmRNZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX3dlYnNvY2tldCA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfc3NlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgX3NzZS5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICBfc3NlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBfY2xlYXJTdG9yYWdlKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIF9jbGVhclN0b3JhZ2UoKSB7XG4gICAgICAgICAgICAgICAgLy8gU3RvcCBzaGFyaW5nIGEgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgIGlmIChfc3RvcmFnZVNlcnZpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBDbGVhcnMgdHJhY2UgdGltZXJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChfdHJhY2VUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZXMgdGhlIHRyYWNlXG4gICAgICAgICAgICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IF9zaGFyaW5nS2V5ICsgXCI9OyBleHBpcmVzPVRodSwgMDEgSmFuIDE5NzAgMDA6MDA6MDAgR01UOyBwYXRoPS9cIjtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGhlaXIgaXMgdGhlIHBhcmVudCB1bmxlc3MgdW5sb2FkaW5nXG4gICAgICAgICAgICAgICAgICAgIF9zdG9yYWdlU2VydmljZS5zaWduYWwoXCJjbG9zZVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlyOiAhX2Fib3JkaW5nQ29ubmVjdGlvbiA/IGd1aWQgOiAoX3N0b3JhZ2VTZXJ2aWNlLmdldChcImNoaWxkcmVuXCIpIHx8IFtdKVswXVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgX3N0b3JhZ2VTZXJ2aWNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChfbG9jYWxTdG9yYWdlU2VydmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIF9sb2NhbFN0b3JhZ2VTZXJ2aWNlLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgICAgICAgICAgX3N1YnNjcmliZShvcHRpb25zKTtcbiAgICAgICAgICAgICAgICBfZXhlY3V0ZSgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF9leGVjdXRlKCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmludm9rZUNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF9pbnZva2VDYWxsYmFjaygpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfY2xvc2UoKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRVcmwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9yZXF1ZXN0LnVybDtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMucHVzaCA9IGZ1bmN0aW9uIChtZXNzYWdlLCBkaXNwYXRjaFVybCkge1xuICAgICAgICAgICAgICAgIGlmIChkaXNwYXRjaFVybCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvcmlnaW5hbERpc3BhdGNoVXJsID0gX3JlcXVlc3QuZGlzcGF0Y2hVcmw7XG4gICAgICAgICAgICAgICAgICAgIF9yZXF1ZXN0LmRpc3BhdGNoVXJsID0gZGlzcGF0Y2hVcmw7XG4gICAgICAgICAgICAgICAgICAgIF9wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBfcmVxdWVzdC5kaXNwYXRjaFVybCA9IG9yaWdpbmFsRGlzcGF0Y2hVcmw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3B1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5nZXRVVUlEID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfcmVxdWVzdC51dWlkO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgdGhpcy5wdXNoTG9jYWwgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgICAgIF9pbnRyYVB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmVuYWJsZVByb3RvY29sID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3JlcXVlc3QuZW5hYmxlUHJvdG9jb2w7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLnJlcXVlc3QgPSBfcmVxdWVzdDtcbiAgICAgICAgICAgIHRoaXMucmVzcG9uc2UgPSBfcmVzcG9uc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3Vic2NyaWJlOiBmdW5jdGlvbiAodXJsLCBjYWxsYmFjaywgcmVxdWVzdCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2FsbGJhY2spID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuYWRkQ2FsbGJhY2soY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodHlwZW9mICh1cmwpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdCA9IHVybDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdC51cmwgPSB1cmw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9BdG1vc3BoZXJlL2F0bW9zcGhlcmUtamF2YXNjcmlwdC9pc3N1ZXMvNThcbiAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLnV1aWQgPSAoKHR5cGVvZiAocmVxdWVzdCkgIT09ICd1bmRlZmluZWQnKSAmJiB0eXBlb2YgKHJlcXVlc3QudXVpZCkgIT09ICd1bmRlZmluZWQnKSA/IHJlcXVlc3QudXVpZCA6IDA7XG5cbiAgICAgICAgICAgIHZhciBycSA9IG5ldyBqUXVlcnkuYXRtb3NwaGVyZS5BdG1vc3BoZXJlUmVxdWVzdChyZXF1ZXN0KTtcbiAgICAgICAgICAgIHJxLmV4ZWN1dGUoKTtcblxuICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUucmVxdWVzdHNbalF1ZXJ5LmF0bW9zcGhlcmUucmVxdWVzdHMubGVuZ3RoXSA9IHJxO1xuICAgICAgICAgICAgcmV0dXJuIHJxO1xuICAgICAgICB9LFxuXG4gICAgICAgIGFkZENhbGxiYWNrOiBmdW5jdGlvbiAoZnVuYykge1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5pbkFycmF5KGZ1bmMsIGpRdWVyeS5hdG1vc3BoZXJlLmNhbGxiYWNrcykgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUuY2FsbGJhY2tzLnB1c2goZnVuYyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlQ2FsbGJhY2s6IGZ1bmN0aW9uIChmdW5jKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBqUXVlcnkuaW5BcnJheShmdW5jLCBqUXVlcnkuYXRtb3NwaGVyZS5jYWxsYmFja3MpO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHVuc3Vic2NyaWJlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoalF1ZXJ5LmF0bW9zcGhlcmUucmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciByZXF1ZXN0c0Nsb25lID0gW10uY29uY2F0KGpRdWVyeS5hdG1vc3BoZXJlLnJlcXVlc3RzKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlcXVlc3RzQ2xvbmUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJxID0gcmVxdWVzdHNDbG9uZVtpXTtcbiAgICAgICAgICAgICAgICAgICAgcnEuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJxLnJlc3BvbnNlLnJlcXVlc3QuaWQpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChycS5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHJxLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLnJlcXVlc3RzID0gW107XG4gICAgICAgICAgICBqUXVlcnkuYXRtb3NwaGVyZS5jYWxsYmFja3MgPSBbXTtcbiAgICAgICAgfSxcblxuICAgICAgICB1bnN1YnNjcmliZVVybDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgdmFyIGlkeCA9IC0xO1xuICAgICAgICAgICAgaWYgKGpRdWVyeS5hdG1vc3BoZXJlLnJlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGpRdWVyeS5hdG1vc3BoZXJlLnJlcXVlc3RzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBycSA9IGpRdWVyeS5hdG1vc3BoZXJlLnJlcXVlc3RzW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFN1cHBvc2UgeW91IGNhbiBzdWJzY3JpYmUgb25jZSB0byBhbiB1cmxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJxLmdldFVybCgpID09PSB1cmwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJxLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQocnEucmVzcG9uc2UucmVxdWVzdC5pZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChycS5oZWFydGJlYXRUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dChycS5oZWFydGJlYXRUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlkeCA9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpZHggPj0gMCkge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLnJlcXVlc3RzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHB1Ymxpc2g6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChyZXF1ZXN0LmNhbGxiYWNrKSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmFkZENhbGxiYWNrKHJlcXVlc3QuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVxdWVzdC50cmFuc3BvcnQgPSBcInBvbGxpbmdcIjtcblxuICAgICAgICAgICAgdmFyIHJxID0gbmV3IGpRdWVyeS5hdG1vc3BoZXJlLkF0bW9zcGhlcmVSZXF1ZXN0KHJlcXVlc3QpO1xuICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUucmVxdWVzdHNbalF1ZXJ5LmF0bW9zcGhlcmUucmVxdWVzdHMubGVuZ3RoXSA9IHJxO1xuICAgICAgICAgICAgcmV0dXJuIHJxO1xuICAgICAgICB9LFxuXG4gICAgICAgIGNoZWNrQ09SU1N1cHBvcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChqUXVlcnkuYnJvd3Nlci5tc2llICYmICF3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgK2pRdWVyeS5icm93c2VyLnZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgMTEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoalF1ZXJ5LmJyb3dzZXIub3BlcmEgJiYgK2pRdWVyeS5icm93c2VyLnZlcnNpb24uc3BsaXQoXCIuXCIpWzBdIDwgMTIuMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBLcmVhVFYgNC4xIC0+IDQuNFxuICAgICAgICAgICAgZWxzZSBpZiAoalF1ZXJ5LnRyaW0obmF2aWdhdG9yLnVzZXJBZ2VudCkuc2xpY2UoMCwgMTYpID09PSBcIktyZWFUVldlYktpdC81MzFcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gS3JlYVRWIDMuOFxuICAgICAgICAgICAgZWxzZSBpZiAoalF1ZXJ5LnRyaW0obmF2aWdhdG9yLnVzZXJBZ2VudCkuc2xpY2UoLTcpLnRvTG93ZXJDYXNlKCkgPT09IFwia3JlYXRlbFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZvcmNlIEFuZHJvaWQgdG8gdXNlIENPUlMgYXMgc29tZSB2ZXJzaW9uIGxpa2UgMi4yLjMgZmFpbCBvdGhlcndpc2VcbiAgICAgICAgICAgIHZhciB1YSA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIHZhciBpc0FuZHJvaWQgPSB1YS5pbmRleE9mKFwiYW5kcm9pZFwiKSA+IC0xO1xuICAgICAgICAgICAgaWYgKGlzQW5kcm9pZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9LFxuXG4gICAgICAgIFM0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gKCgoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkgfCAwKS50b1N0cmluZygxNikuc3Vic3RyaW5nKDEpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGd1aWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiAoalF1ZXJ5LmF0bW9zcGhlcmUuUzQoKSArIGpRdWVyeS5hdG1vc3BoZXJlLlM0KCkgKyBcIi1cIiArIGpRdWVyeS5hdG1vc3BoZXJlLlM0KCkgKyBcIi1cIiArIGpRdWVyeS5hdG1vc3BoZXJlLlM0KCkgKyBcIi1cIlxuICAgICAgICAgICAgICAgICsgalF1ZXJ5LmF0bW9zcGhlcmUuUzQoKSArIFwiLVwiICsgalF1ZXJ5LmF0bW9zcGhlcmUuUzQoKSArIGpRdWVyeS5hdG1vc3BoZXJlLlM0KCkgKyBqUXVlcnkuYXRtb3NwaGVyZS5TNCgpKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBGcm9tIGpRdWVyeS1TdHJlYW1cbiAgICAgICAgcHJlcGFyZVVSTDogZnVuY3Rpb24gKHVybCkge1xuICAgICAgICAgICAgLy8gQXR0YWNoZXMgYSB0aW1lIHN0YW1wIHRvIHByZXZlbnQgY2FjaGluZ1xuICAgICAgICAgICAgdmFyIHRzID0galF1ZXJ5Lm5vdygpO1xuICAgICAgICAgICAgdmFyIHJldCA9IHVybC5yZXBsYWNlKC8oWz8mXSlfPVteJl0qLywgXCIkMV89XCIgKyB0cyk7XG5cbiAgICAgICAgICAgIHJldHVybiByZXQgKyAocmV0ID09PSB1cmwgPyAoL1xcPy8udGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIikgKyBcIl89XCIgKyB0cyA6IFwiXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIEZyb20galF1ZXJ5LVN0cmVhbVxuICAgICAgICBwYXJhbTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBqUXVlcnkucGFyYW0oZGF0YSwgalF1ZXJ5LmFqYXhTZXR0aW5ncy50cmFkaXRpb25hbCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3VwcG9ydFN0b3JhZ2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBzdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZTtcbiAgICAgICAgICAgIGlmIChzdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgc3RvcmFnZS5zZXRJdGVtKFwidFwiLCBcInRcIik7XG4gICAgICAgICAgICAgICAgICAgIHN0b3JhZ2UucmVtb3ZlSXRlbShcInRcIik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZSBzdG9yYWdlIGV2ZW50IG9mIEludGVybmV0IEV4cGxvcmVyIGFuZCBGaXJlZm94IDMgd29ya3Mgc3RyYW5nZWx5XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cuU3RvcmFnZUV2ZW50ICYmICFqUXVlcnkuYnJvd3Nlci5tc2llICYmICEoalF1ZXJ5LmJyb3dzZXIubW96aWxsYSAmJiBqUXVlcnkuYnJvd3Nlci52ZXJzaW9uLnNwbGl0KFwiLlwiKVswXSA9PT0gXCIxXCIpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBpdGVyYXRlOiBmdW5jdGlvbiAoZm4sIGludGVydmFsKSB7XG4gICAgICAgICAgICB2YXIgdGltZW91dElkO1xuXG4gICAgICAgICAgICAvLyBUaG91Z2ggdGhlIGludGVydmFsIGlzIDAgZm9yIHJlYWwtdGltZSBhcHBsaWNhdGlvbiwgdGhlcmUgaXMgYSBkZWxheSBiZXR3ZWVuIHNldFRpbWVvdXQgY2FsbHNcbiAgICAgICAgICAgIC8vIEZvciBkZXRhaWwsIHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi93aW5kb3cuc2V0VGltZW91dCNNaW5pbXVtX2RlbGF5X2FuZF90aW1lb3V0X25lc3RpbmdcbiAgICAgICAgICAgIGludGVydmFsID0gaW50ZXJ2YWwgfHwgMDtcblxuICAgICAgICAgICAgKGZ1bmN0aW9uIGxvb3AoKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmbigpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgbG9vcCgpO1xuICAgICAgICAgICAgICAgIH0sIGludGVydmFsKTtcbiAgICAgICAgICAgIH0pKCk7XG5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIGxvZzogZnVuY3Rpb24gKGxldmVsLCBhcmdzKSB7XG4gICAgICAgICAgICBpZiAod2luZG93LmNvbnNvbGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbG9nZ2VyID0gd2luZG93LmNvbnNvbGVbbGV2ZWxdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbG9nZ2VyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci5hcHBseSh3aW5kb3cuY29uc29sZSwgYXJncyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIHdhcm46IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmxvZygnd2FybicsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaW5mbzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKCdpbmZvJywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICBkZWJ1ZzogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgalF1ZXJ5LmF0bW9zcGhlcmUubG9nKCdkZWJ1ZycsIGFyZ3VtZW50cyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZXJyb3I6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGpRdWVyeS5hdG1vc3BoZXJlLmxvZygnZXJyb3InLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFRPRE8gZXh0cmFjdCB0byB1dGlscyBvciBzb21ldGhpbmdcbiAgICAgICAgaXNCaW5hcnk6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAvLyBUcnVlIGlmIGRhdGEgaXMgYW4gaW5zdGFuY2Ugb2YgQmxvYiwgQXJyYXlCdWZmZXIgb3IgQXJyYXlCdWZmZXJWaWV3IFxuICAgICAgICAgICAgcmV0dXJuIC9eXFxbb2JqZWN0XFxzKD86QmxvYnxBcnJheUJ1ZmZlcnwuK0FycmF5KVxcXSQvLnRlc3QoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGRhdGEpKTtcbiAgICAgICAgfVxuICAgIH07XG5cblxuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTY0NTgwMy93aGF0cy10aGUtcmVwbGFjZW1lbnQtZm9yLWJyb3dzZXJcbiAgICAvLyBMaW1pdCBzY29wZSBwb2xsdXRpb24gZnJvbSBhbnkgZGVwcmVjYXRlZCBBUElcbiAgICAoZnVuY3Rpb24gKCkge1xuXHRcbiAgICAgICAgdmFyIG1hdGNoZWQsIGJyb3dzZXI7XG5cdFxuICAgICAgICAvLyBVc2Ugb2YgalF1ZXJ5LmJyb3dzZXIgaXMgZnJvd25lZCB1cG9uLlxuICAgICAgICAvLyBNb3JlIGRldGFpbHM6IGh0dHA6Ly9hcGkuanF1ZXJ5LmNvbS9qUXVlcnkuYnJvd3NlclxuICAgICAgICAvLyBqUXVlcnkudWFNYXRjaCBtYWludGFpbmVkIGZvciBiYWNrLWNvbXBhdFxuICAgICAgICBqUXVlcnkudWFNYXRjaCA9IGZ1bmN0aW9uICh1YSkge1xuICAgICAgICAgICAgdWEgPSB1YS50b0xvd2VyQ2FzZSgpO1xuXHRcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IC8oY2hyb21lKVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHwgXG4gICAgICAgICAgICAgICAgICAgIC8od2Via2l0KVsgXFwvXShbXFx3Ll0rKS8uZXhlYyh1YSkgfHwgXG4gICAgICAgICAgICAgICAgICAgIC8ob3BlcmEpKD86Lip2ZXJzaW9ufClbIFxcL10oW1xcdy5dKykvLmV4ZWModWEpIHx8IFxuICAgICAgICAgICAgICAgICAgICAvKG1zaWUpIChbXFx3Ll0rKS8uZXhlYyh1YSkgfHwgXG4gICAgICAgICAgICAgICAgICAgIC8odHJpZGVudCkoPzouKj8gcnY6KFtcXHcuXSspfCkvLmV4ZWModWEpIHx8XG4gICAgICAgICAgICAgICAgICAgIHVhLmluZGV4T2YoXCJjb21wYXRpYmxlXCIpIDwgMCAmJiAvKG1vemlsbGEpKD86Lio/IHJ2OihbXFx3Ll0rKXwpLy5leGVjKHVhKSB8fCBcbiAgICAgICAgICAgICAgICAgICAgW107XG5cdFxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBicm93c2VyOiBtYXRjaFsxXSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHZlcnNpb246IG1hdGNoWzJdIHx8IFwiMFwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9O1xuXHRcbiAgICAgICAgbWF0Y2hlZCA9IGpRdWVyeS51YU1hdGNoKG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgICBicm93c2VyID0ge307XG5cdFxuICAgICAgICBpZiAobWF0Y2hlZC5icm93c2VyKSB7XG4gICAgICAgICAgICBicm93c2VyW21hdGNoZWQuYnJvd3Nlcl0gPSB0cnVlO1xuICAgICAgICAgICAgYnJvd3Nlci52ZXJzaW9uID0gbWF0Y2hlZC52ZXJzaW9uO1xuICAgICAgICB9XG5cdFxuICAgICAgICAvLyBDaHJvbWUgaXMgV2Via2l0LCBidXQgV2Via2l0IGlzIGFsc28gU2FmYXJpLlxuICAgICAgICBpZiAoYnJvd3Nlci5jaHJvbWUpIHtcbiAgICAgICAgICAgIGJyb3dzZXIud2Via2l0ID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIGlmIChicm93c2VyLndlYmtpdCkge1xuICAgICAgICAgICAgYnJvd3Nlci5zYWZhcmkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBUcmlkZW50IGlzIHRoZSBsYXlvdXQgZW5naW5lIG9mIHRoZSBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgICAvLyBJRSAxMSBoYXMgbm8gXCJNU0lFOiAxMS4wXCIgdG9rZW5cbiAgICAgICAgaWYgKGJyb3dzZXIudHJpZGVudCkge1xuICAgICAgICAgICAgYnJvd3Nlci5tc2llID0gdHJ1ZTtcbiAgICAgICAgfVxuXHRcbiAgICAgICAgalF1ZXJ5LmJyb3dzZXIgPSBicm93c2VyO1xuXHRcbiAgICAgICAgalF1ZXJ5LnN1YiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGpRdWVyeVN1YihzZWxlY3RvciwgY29udGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgalF1ZXJ5U3ViLmZuLmluaXQoc2VsZWN0b3IsIGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuXHRcbiAgICAgICAgICAgIGpRdWVyeS5leHRlbmQodHJ1ZSwgalF1ZXJ5U3ViLCB0aGlzKTtcbiAgICAgICAgICAgIGpRdWVyeVN1Yi5zdXBlcmNsYXNzID0gdGhpcztcbiAgICAgICAgICAgIGpRdWVyeVN1Yi5mbiA9IGpRdWVyeVN1Yi5wcm90b3R5cGUgPSB0aGlzKCk7XG4gICAgICAgICAgICBqUXVlcnlTdWIuZm4uY29uc3RydWN0b3IgPSBqUXVlcnlTdWI7XG4gICAgICAgICAgICBqUXVlcnlTdWIuc3ViID0gdGhpcy5zdWI7XG4gICAgICAgICAgICBqUXVlcnlTdWIuZm4uaW5pdCA9IGZ1bmN0aW9uIGluaXQoc2VsZWN0b3IsIGNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29udGV4dCAmJiBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ICYmICEoY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeVN1YikpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dCA9IGpRdWVyeVN1Yihjb250ZXh0KTtcbiAgICAgICAgICAgICAgICB9XG5cdFxuICAgICAgICAgICAgICAgIHJldHVybiBqUXVlcnkuZm4uaW5pdC5jYWxsKHRoaXMsIHNlbGVjdG9yLCBjb250ZXh0LCByb290alF1ZXJ5U3ViKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBqUXVlcnlTdWIuZm4uaW5pdC5wcm90b3R5cGUgPSBqUXVlcnlTdWIuZm47XG4gICAgICAgICAgICB2YXIgcm9vdGpRdWVyeVN1YiA9IGpRdWVyeVN1Yihkb2N1bWVudCk7XG4gICAgICAgICAgICByZXR1cm4galF1ZXJ5U3ViO1xuICAgICAgICB9O1xuXHRcbiAgICB9KSgpO1xuXHRcbiAgICAvKlxuICAgICAqIGpRdWVyeSBzdHJpbmdpZnlKU09OXG4gICAgICogaHR0cDovL2dpdGh1Yi5jb20vZmxvd2Vyc2ludGhlc2FuZC9qcXVlcnktc3RyaW5naWZ5SlNPTlxuICAgICAqXG4gICAgICogQ29weXJpZ2h0IDIwMTEsIERvbmdod2FuIEtpbVxuICAgICAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjBcbiAgICAgKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAgICAgKi9cbiAgICAvLyBUaGlzIHBsdWdpbiBpcyBoZWF2aWx5IGJhc2VkIG9uIERvdWdsYXMgQ3JvY2tmb3JkJ3MgcmVmZXJlbmNlIGltcGxlbWVudGF0aW9uXG4gICAgKGZ1bmN0aW9uIChqUXVlcnkpIHtcblx0XG4gICAgICAgIHZhciBlc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLCBtZXRhID0ge1xuICAgICAgICAgICAgJ1xcYic6ICdcXFxcYicsXG4gICAgICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAgICAgJ1xcZic6ICdcXFxcZicsXG4gICAgICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgICAgICdcIic6ICdcXFxcXCInLFxuICAgICAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgICAgIH07XG5cdFxuICAgICAgICBmdW5jdGlvbiBxdW90ZShzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiAnXCInICsgc3RyaW5nLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICAgICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09IFwic3RyaW5nXCIgPyBjIDogXCJcXFxcdVwiICsgKFwiMDAwMFwiICsgYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpO1xuICAgICAgICAgICAgfSkgKyAnXCInO1xuICAgICAgICB9XG5cdFxuICAgICAgICBmdW5jdGlvbiBmKG4pIHtcbiAgICAgICAgICAgIHJldHVybiBuIDwgMTAgPyBcIjBcIiArIG4gOiBuO1xuICAgICAgICB9XG5cdFxuICAgICAgICBmdW5jdGlvbiBzdHIoa2V5LCBob2xkZXIpIHtcbiAgICAgICAgICAgIHZhciBpLCB2LCBsZW4sIHBhcnRpYWwsIHZhbHVlID0gaG9sZGVyW2tleV0sIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdFxuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgdmFsdWUudG9KU09OID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG4gICAgICAgICAgICB9XG5cdFxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiBcIm51bGxcIjtcbiAgICAgICAgICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBcIm51bGxcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuXHRcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW29iamVjdCBEYXRlXVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZS52YWx1ZU9mKCkpID8gJ1wiJyArIHZhbHVlLmdldFVUQ0Z1bGxZZWFyKCkgKyBcIi1cIiArIGYodmFsdWUuZ2V0VVRDTW9udGgoKSArIDEpICsgXCItXCIgKyBmKHZhbHVlLmdldFVUQ0RhdGUoKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBcIlRcIiArIGYodmFsdWUuZ2V0VVRDSG91cnMoKSkgKyBcIjpcIiArIGYodmFsdWUuZ2V0VVRDTWludXRlcygpKSArIFwiOlwiICsgZih2YWx1ZS5nZXRVVENTZWNvbmRzKCkpICsgXCJaXCIgKyAnXCInIDogXCJudWxsXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiW29iamVjdCBBcnJheV1cIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbCA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2goc3RyKGksIHZhbHVlKSB8fCBcIm51bGxcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJbXCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJdXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaSkgKyBcIjpcIiArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJ7XCIgKyBwYXJ0aWFsLmpvaW4oXCIsXCIpICsgXCJ9XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXHRcbiAgICAgICAgalF1ZXJ5LnN0cmluZ2lmeUpTT04gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSlNPTiAmJiB3aW5kb3cuSlNPTi5zdHJpbmdpZnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2luZG93LkpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIH1cblx0XG4gICAgICAgICAgICByZXR1cm4gc3RyKFwiXCIsIHtcbiAgICAgICAgICAgICAgICBcIlwiOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG5cdFxuICAgIH0oalF1ZXJ5KSk7XG59KSk7XG4vKiBqc2hpbnQgbm9hcmc6dHJ1ZSwgbm9lbXB0eTp0cnVlLCBlcWVxZXE6dHJ1ZSwgZXZpbDp0cnVlLCBsYXhicmVhazp0cnVlLCB1bmRlZjp0cnVlLCBicm93c2VyOnRydWUsIGpxdWVyeTp0cnVlLCBpbmRlbnQ6ZmFsc2UsIG1heGVycjo1MCwgZXFudWxsOnRydWUgKi9cbiIsImlmICh0eXBlb2YoTCkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLyoqXG4gICAgICogZnVsbCBjYW52YXMgbGF5ZXIgaW1wbGVtZW50YXRpb24gZm9yIExlYWZsZXRcbiAgICAgKi9cblxuICAgIEwuQ2FudmFzTGF5ZXIgPSBMLkNsYXNzLmV4dGVuZCh7XG5cbiAgICAgICAgaW5jbHVkZXM6IFtMLk1peGluLkV2ZW50cywgTC5NaXhpbi5UaWxlTG9hZGVyXSxcblxuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBtaW5ab29tOiAwLFxuICAgICAgICAgICAgbWF4Wm9vbTogMjgsXG4gICAgICAgICAgICB0aWxlU2l6ZTogMjU2LFxuICAgICAgICAgICAgc3ViZG9tYWluczogJ2FiYycsXG4gICAgICAgICAgICBlcnJvclRpbGVVcmw6ICcnLFxuICAgICAgICAgICAgYXR0cmlidXRpb246ICcnLFxuICAgICAgICAgICAgem9vbU9mZnNldDogMCxcbiAgICAgICAgICAgIG9wYWNpdHk6IDEsXG4gICAgICAgICAgICB1bmxvYWRJbnZpc2libGVUaWxlczogTC5Ccm93c2VyLm1vYmlsZSxcbiAgICAgICAgICAgIHVwZGF0ZVdoZW5JZGxlOiBMLkJyb3dzZXIubW9iaWxlLFxuICAgICAgICAgICAgdGlsZUxvYWRlcjogZmFsc2UgLy8gaW5zdGFsbHMgdGlsZSBsb2FkaW5nIGV2ZW50c1xuICAgICAgICB9LFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICAgICAgLy90aGlzLnByb2plY3QgPSB0aGlzLl9wcm9qZWN0LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlciA9IHRoaXMucmVuZGVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcyA9IHRoaXMuX2NyZWF0ZUNhbnZhcygpO1xuICAgICAgICAgICAgLy8gYmFja0NhbnZhcyBmb3Igem9vbSBhbmltYXRpb25cbiAgICAgICAgICAgIHRoaXMuX2JhY2tDYW52YXMgPSB0aGlzLl9jcmVhdGVDYW52YXMoKTtcbiAgICAgICAgICAgIHRoaXMuX2N0eCA9IHRoaXMuX2NhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSAtMTtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubW96UmVxdWVzdEFuaW1hdGlvbkZyYW1lIHx8XG4gICAgICAgICAgICAgICAgd2luZG93LndlYmtpdFJlcXVlc3RBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHwgZnVuY3Rpb24oY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHdpbmRvdy5zZXRUaW1lb3V0KGNhbGxiYWNrLCAxMDAwIC8gNjApO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gd2luZG93LmNhbmNlbEFuaW1hdGlvbkZyYW1lIHx8IHdpbmRvdy5tb3pDYW5jZWxBbmltYXRpb25GcmFtZSB8fFxuICAgICAgICAgICAgICAgIHdpbmRvdy53ZWJraXRDYW5jZWxBbmltYXRpb25GcmFtZSB8fCB3aW5kb3cubXNDYW5jZWxBbmltYXRpb25GcmFtZSB8fCBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZUNhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2FudmFzO1xuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLnRvcCA9IDA7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUubGVmdCA9IDA7XG4gICAgICAgICAgICBjYW52YXMuc3R5bGUucG9pbnRlckV2ZW50cyA9IFwibm9uZVwiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXggfHwgMDtcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC10aWxlLWNvbnRhaW5lciBsZWFmbGV0LXpvb20tYW5pbWF0ZWQnO1xuICAgICAgICAgICAgY2FudmFzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc05hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICAgICAgfSxcblxuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgICAgIC8vIGFkZCBjb250YWluZXIgd2l0aCB0aGUgY2FudmFzIHRvIHRoZSB0aWxlIHBhbmVcbiAgICAgICAgICAgIC8vIHRoZSBjb250YWluZXIgaXMgbW92ZWQgaW4gdGhlIG9wb3NpdGUgZGlyZWN0aW9uIG9mIHRoZSBcbiAgICAgICAgICAgIC8vIG1hcCBwYW5lIHRvIGtlZXAgdGhlIGNhbnZhcyBhbHdheXMgaW4gKDAsIDApXG4gICAgICAgICAgICB2YXIgdGlsZVBhbmUgPSB0aGlzLl9tYXAuX3BhbmVzLnRpbGVQYW5lO1xuICAgICAgICAgICAgdmFyIF9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1sYXllcicpO1xuICAgICAgICAgICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuICAgICAgICAgICAgX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9iYWNrQ2FudmFzKTtcbiAgICAgICAgICAgIHRoaXMuX2JhY2tDYW52YXMuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIHRpbGVQYW5lLmFwcGVuZENoaWxkKF9jb250YWluZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBfY29udGFpbmVyO1xuXG4gICAgICAgICAgICAvLyBoYWNrOiBsaXN0ZW4gdG8gcHJlZHJhZyBldmVudCBsYXVuY2hlZCBieSBkcmFnZ2luZyB0b1xuICAgICAgICAgICAgLy8gc2V0IGNvbnRhaW5lciBpbiBwb3NpdGlvbiAoMCwgMCkgaW4gc2NyZWVuIGNvb3JkaW5hdGVzXG4gICAgICAgICAgICBtYXAuZHJhZ2dpbmcuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gbWFwLmRyYWdnaW5nLl9kcmFnZ2FibGU7XG4gICAgICAgICAgICAgICAgTC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NhbnZhcywge1xuICAgICAgICAgICAgICAgICAgICB4OiAtZC5fbmV3UG9zLngsXG4gICAgICAgICAgICAgICAgICAgIHk6IC1kLl9uZXdQb3MueVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIG1hcC5vbih7XG4gICAgICAgICAgICAgICAgJ3ZpZXdyZXNldCc6IHRoaXMuX3Jlc2V0XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vbignbW92ZScsIHRoaXMucmVuZGVyLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vbigncmVzaXplJywgdGhpcy5fcmVzZXQsIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9uKHtcbiAgICAgICAgICAgICAgICAnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlWm9vbSxcbiAgICAgICAgICAgICAgICAnem9vbWVuZCc6IHRoaXMuX2VuZFpvb21BbmltXG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aWxlTG9hZGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdFRpbGVMb2FkZXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYW5pbWF0ZVpvb206IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYWNrID0gdGhpcy5fYmFja0NhbnZhcztcblxuICAgICAgICAgICAgYmFjay53aWR0aCA9IHRoaXMuX2NhbnZhcy53aWR0aDtcbiAgICAgICAgICAgIGJhY2suaGVpZ2h0ID0gdGhpcy5fY2FudmFzLmhlaWdodDtcblxuICAgICAgICAgICAgLy8gcGFpbnQgY3VycmVudCBjYW52YXMgaW4gYmFjayBjYW52YXMgd2l0aCB0cmFzbmZvcm1hdGlvblxuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuX2NhbnZhcy5fbGVhZmxldF9wb3MgfHwge1xuICAgICAgICAgICAgICAgIHg6IDAsXG4gICAgICAgICAgICAgICAgeTogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGJhY2suZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UodGhpcy5fY2FudmFzLCAwLCAwKTtcblxuICAgICAgICAgICAgLy8gaGlkZSBvcmlnaW5hbFxuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICBiYWNrLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICAgICAgICAgICAgdmFyIG1hcCA9IHRoaXMuX21hcDtcbiAgICAgICAgICAgIHZhciBzY2FsZSA9IG1hcC5nZXRab29tU2NhbGUoZS56b29tKTtcbiAgICAgICAgICAgIHZhciBuZXdDZW50ZXIgPSBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludChtYXAuZ2V0Q2VudGVyKCksIGUuem9vbSwgZS5jZW50ZXIpO1xuICAgICAgICAgICAgdmFyIG9sZENlbnRlciA9IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KGUuY2VudGVyLCBlLnpvb20sIGUuY2VudGVyKTtcblxuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHtcbiAgICAgICAgICAgICAgICB4OiBuZXdDZW50ZXIueCAtIG9sZENlbnRlci54LFxuICAgICAgICAgICAgICAgIHk6IG5ld0NlbnRlci55IC0gb2xkQ2VudGVyLnlcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBiZyA9IGJhY2s7XG4gICAgICAgICAgICB2YXIgdHJhbnNmb3JtID0gTC5Eb21VdGlsLlRSQU5TRk9STTtcbiAgICAgICAgICAgIGJnLnN0eWxlW3RyYW5zZm9ybV0gPSBMLkRvbVV0aWwuZ2V0VHJhbnNsYXRlU3RyaW5nKG9yaWdpbikgKyAnIHNjYWxlKCcgKyBlLnNjYWxlICsgJykgJztcbiAgICAgICAgfSxcblxuICAgICAgICBfZW5kWm9vbUFuaW06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0aGlzLl9iYWNrQ2FudmFzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jYW52YXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgZ2V0QXR0cmlidXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5hdHRyaWJ1dGlvbjtcbiAgICAgICAgfSxcblxuICAgICAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZXNldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG1hcC5vZmYoe1xuICAgICAgICAgICAgICAgICd2aWV3cmVzZXQnOiB0aGlzLl9yZXNldCxcbiAgICAgICAgICAgICAgICAnbW92ZSc6IHRoaXMuX3JlbmRlcixcbiAgICAgICAgICAgICAgICAncmVzaXplJzogdGhpcy5fcmVzZXQsXG4gICAgICAgICAgICAgICAgJ3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXG4gICAgICAgICAgICAgICAgJ3pvb21lbmQnOiB0aGlzLl9lbmRab29tQW5pbVxuICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYWRkVG86IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgbWFwLmFkZExheWVyKHRoaXMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0T3BhY2l0eTogZnVuY3Rpb24ob3BhY2l0eSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc2V0WkluZGV4OiBmdW5jdGlvbih6SW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS56SW5kZXggPSB6SW5kZXg7XG4gICAgICAgIH0sXG5cbiAgICAgICAgYnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIGJyaW5nVG9CYWNrOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2l6ZSA9IHRoaXMuX21hcC5nZXRTaXplKCk7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSBzaXplLng7XG4gICAgICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gc2l6ZS55O1xuICAgICAgICAgICAgdGhpcy5vblJlc2l6ZSgpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLypcbiAgICAgICAgX3Byb2plY3Q6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KG5ldyBMLkxhdExuZyh4WzFdLCB4WzBdKSk7XG4gICAgICAgICAgcmV0dXJuIFtwb2ludC54LCBwb2ludC55XTtcbiAgICAgICAgfSxcbiAgICAgICAgKi9cblxuICAgICAgICBfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICBfcmVuZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRBbmltYXRpb25GcmFtZSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWxBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jdXJyZW50QW5pbWF0aW9uRnJhbWUgPSB0aGlzLnJlcXVlc3RBbmltYXRpb25GcmFtZS5jYWxsKHdpbmRvdywgdGhpcy5yZW5kZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHVzZSBkaXJlY3Q6IHRydWUgaWYgeW91IGFyZSBpbnNpZGUgYW4gYW5pbWF0aW9uIGZyYW1lIGNhbGxcbiAgICAgICAgcmVkcmF3OiBmdW5jdGlvbihkaXJlY3QpIHtcbiAgICAgICAgICAgIGlmIChkaXJlY3QpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvblJlc2l6ZTogZnVuY3Rpb24oKSB7fSxcblxuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW5kZXIgZnVuY3Rpb24gc2hvdWxkIGJlIGltcGxlbWVudGVkJyk7XG4gICAgICAgIH1cblxuICAgIH0pO1xuXG59IC8vTCBkZWZpbmVkIiwiLypcblx0TGVhZmxldC5kcmF3LCBhIHBsdWdpbiB0aGF0IGFkZHMgZHJhd2luZyBhbmQgZWRpdGluZyB0b29scyB0byBMZWFmbGV0IHBvd2VyZWQgbWFwcy5cblx0KGMpIDIwMTItMjAxMywgSmFjb2IgVG95ZSwgU21hcnRyYWtcblxuXHRodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0LmRyYXdcblx0aHR0cDovL2xlYWZsZXRqcy5jb21cblx0aHR0cHM6Ly9naXRodWIuY29tL2phY29idG95ZVxuKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7LypcbiAqIExlYWZsZXQuZHJhdyBhc3N1bWVzIHRoYXQgeW91IGhhdmUgYWxyZWFkeSBpbmNsdWRlZCB0aGUgTGVhZmxldCBsaWJyYXJ5LlxuICovXG5cbkwuZHJhd1ZlcnNpb24gPSAnMC4yLjMnO1xuXG5MLmRyYXdMb2NhbCA9IHtcblx0ZHJhdzoge1xuXHRcdHRvb2xiYXI6IHtcblx0XHRcdGFjdGlvbnM6IHtcblx0XHRcdFx0dGl0bGU6ICdDYW5jZWwgZHJhd2luZycsXG5cdFx0XHRcdHRleHQ6ICdDYW5jZWwnXG5cdFx0XHR9LFxuXHRcdFx0YWN0aW9uc0lzbzoge1xuXHRcdFx0XHRcdG9wdGlvbjoge1xuXHRcdFx0XHRcdFx0dGl0bGU6ICdTZXQgb3B0aW9ucy4nLFxuXHRcdFx0XHRcdFx0dGV4dDogJ09wdGlvbnMnXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRjYW5jZWw6IHtcblx0XHRcdFx0XHRcdHRpdGxlOiAnQ2FuY2VsLicsXG5cdFx0XHRcdFx0XHR0ZXh0OiAnQ2FuY2VsJ1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblx0XHRcdHVuZG86IHtcblx0XHRcdFx0dGl0bGU6ICdEZWxldGUgbGFzdCBwb2ludCBkcmF3bicsXG5cdFx0XHRcdHRleHQ6ICdEZWxldGUgbGFzdCBwb2ludCdcblx0XHRcdH0sXG5cdFx0XHRidXR0b25zOiB7XG5cdFx0XHRcdHBvbHlsaW5lOiAnRHJhdyBhIHBvbHlsaW5lJyxcblx0XHRcdFx0cG9seWdvbjogJ0RyYXcgYSBwb2x5Z29uJyxcblx0XHRcdFx0cmVjdGFuZ2xlOiAnRHJhdyBhIHJlY3RhbmdsZScsXG5cdFx0XHRcdGNpcmNsZTogJ0RyYXcgYSBjaXJjbGUnLFxuXHRcdFx0XHRtYXJrZXI6ICdEcmF3IGEgbWFya2VyJyxcblx0XHRcdFx0aXNvY2hyb25lOiAnRHJhdyBhIGlzb2Nocm9uZScsXG5cdFx0XHRcdGlzb2Nocm9uZURpc2FibGVkOiAnJ1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0aGFuZGxlcnM6IHtcblx0XHRcdGNpcmNsZToge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c3RhcnQ6ICdDbGljayBhbmQgZHJhZyB0byBkcmF3IGNpcmNsZS4nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRtYXJrZXI6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgbWFwIHRvIHBsYWNlIG1hcmtlci4nXG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRwb2x5Z29uOiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHRzdGFydDogJ0NsaWNrIHRvIHN0YXJ0IGRyYXdpbmcgc2hhcGUuJyxcblx0XHRcdFx0XHRjb250OiAnQ2xpY2sgdG8gY29udGludWUgZHJhd2luZyBzaGFwZS4nLFxuXHRcdFx0XHRcdGVuZDogJ0NsaWNrIGZpcnN0IHBvaW50IHRvIGNsb3NlIHRoaXMgc2hhcGUuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cG9seWxpbmU6IHtcblx0XHRcdFx0ZXJyb3I6ICc8c3Ryb25nPkVycm9yOjwvc3Ryb25nPiBzaGFwZSBlZGdlcyBjYW5ub3QgY3Jvc3MhJyxcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHN0YXJ0OiAnQ2xpY2sgdG8gc3RhcnQgZHJhd2luZyBsaW5lLicsXG5cdFx0XHRcdFx0Y29udDogJ0NsaWNrIHRvIGNvbnRpbnVlIGRyYXdpbmcgbGluZS4nLFxuXHRcdFx0XHRcdGVuZDogJ0NsaWNrIGxhc3QgcG9pbnQgdG8gZmluaXNoIGxpbmUuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVjdGFuZ2xlOiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHRzdGFydDogJ0NsaWNrIGFuZCBkcmFnIHRvIGRyYXcgcmVjdGFuZ2xlLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdHNpbXBsZXNoYXBlOiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHRlbmQ6ICdSZWxlYXNlIG1vdXNlIHRvIGZpbmlzaCBkcmF3aW5nLidcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGlzb2Nocm9uZToge1xuXHRcdFx0XHR0b29sdGlwOiB7XG5cdFx0XHRcdFx0c3RhcnQ6ICdDbGljayBtYXAgdG8gcGxhY2Ugc3RhcnQgcG9pbnQuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXHRlZGl0OiB7XG5cdFx0dG9vbGJhcjoge1xuXHRcdFx0YWN0aW9uczoge1xuXHRcdFx0XHRzYXZlOiB7XG5cdFx0XHRcdFx0dGl0bGU6ICdTYXZlIGNoYW5nZXMuJyxcblx0XHRcdFx0XHR0ZXh0OiAnU2F2ZSdcblx0XHRcdFx0fSxcblx0XHRcdFx0Y2FuY2VsOiB7XG5cdFx0XHRcdFx0dGl0bGU6ICdDYW5jZWwgZWRpdGluZywgZGlzY2FyZHMgYWxsIGNoYW5nZXMuJyxcblx0XHRcdFx0XHR0ZXh0OiAnQ2FuY2VsJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0YnV0dG9uczoge1xuXHRcdFx0XHRlZGl0OiAnRWRpdCBnZW9tZXRyeSBsYXllcnMuJyxcblx0XHRcdFx0ZWRpdERpc2FibGVkOiAnTm8gbGF5ZXJzIHRvIGVkaXQuJyxcblx0XHRcdFx0ZWRpdERhdGE6ICdFZGl0IGF0dHJpYnV0ZXMgbGF5ZXJzLicsXG5cdFx0XHRcdGVkaXREYXRhRGlzYWJsZWQ6ICdObyBsYXllcnMgdG8gZWRpdCBhdHRyaWJ1dGVzLicsXG5cdFx0XHRcdHJlbW92ZTogJ0RlbGV0ZSBsYXllcnMuJyxcblx0XHRcdFx0cmVtb3ZlRGlzYWJsZWQ6ICdObyBsYXllcnMgdG8gZGVsZXRlLidcblx0XHRcdH1cblx0XHR9LFxuXHRcdGhhbmRsZXJzOiB7XG5cdFx0XHRlZGl0OiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHR0ZXh0OiAnRHJhZyBoYW5kbGVzLCBvciBtYXJrZXIgdG8gZWRpdCBmZWF0dXJlLicsXG5cdFx0XHRcdFx0c3VidGV4dDogJ0NsaWNrIGNhbmNlbCB0byB1bmRvIGNoYW5nZXMuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZWRpdERhdGE6IHtcblx0XHRcdFx0dG9vbHRpcDoge1xuXHRcdFx0XHRcdHRleHQ6ICdDbGljayBvbiBhIGZlYXR1cmUgdG8gZWRpdCBhdHRyaWJ1dGVzLicsXG5cdFx0XHRcdFx0c3VidGV4dDogJ0NsaWNrIGNhbmNlbCB0byB1bmRvIGNoYW5nZXMuJ1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0cmVtb3ZlOiB7XG5cdFx0XHRcdHRvb2x0aXA6IHtcblx0XHRcdFx0XHR0ZXh0OiAnQ2xpY2sgb24gYSBmZWF0dXJlIHRvIHJlbW92ZSdcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXHRcbn07XG5cblxuTC5EcmF3ID0ge307XG5cbkwuRHJhdy5GZWF0dXJlID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5fbWFwID0gbWFwO1xuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5fY29udGFpbmVyO1xuXHRcdHRoaXMuX292ZXJsYXlQYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcblx0XHR0aGlzLl9wb3B1cFBhbmUgPSBtYXAuX3BhbmVzLnBvcHVwUGFuZTtcblxuXHRcdC8vIE1lcmdlIGRlZmF1bHQgc2hhcGVPcHRpb25zIG9wdGlvbnMgd2l0aCBjdXN0b20gc2hhcGVPcHRpb25zXG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zaGFwZU9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMuc2hhcGVPcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucywgb3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXHRcdH1cblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLmZpcmUoJ2VuYWJsZWQnLCB7IGhhbmRsZXI6IHRoaXMudHlwZSB9KTtcblxuXHRcdHRoaXMuX21hcC5maXJlKCdkcmF3OmRyYXdzdGFydCcsIHsgbGF5ZXJUeXBlOiB0aGlzLnR5cGUgfSk7XG5cblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XG5cblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmRpc2FibGUuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX21hcC5maXJlKCdkcmF3OmRyYXdzdG9wJywgeyBsYXllclR5cGU6IHRoaXMudHlwZSB9KTtcblxuXHRcdHRoaXMuZmlyZSgnZGlzYWJsZWQnLCB7IGhhbmRsZXI6IHRoaXMudHlwZSB9KTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcblxuXHRcdFx0bWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBuZXcgTC5Ub29sdGlwKHRoaXMuX21hcCk7XG5cblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAna2V5dXAnLCB0aGlzLl9jYW5jZWxEcmF3aW5nLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHRMLkRvbVV0aWwuZW5hYmxlVGV4dFNlbGVjdGlvbigpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdrZXl1cCcsIHRoaXMuX2NhbmNlbERyYXdpbmcsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRzZXRPcHRpb25zOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHRfZmlyZUNyZWF0ZWRFdmVudDogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2RyYXc6Y3JlYXRlZCcsIHsgbGF5ZXI6IGxheWVyLCBsYXllclR5cGU6IHRoaXMudHlwZSB9KTtcblx0fSxcblxuXHQvLyBDYW5jZWwgZHJhd2luZyB3aGVuIHRoZSBlc2NhcGUga2V5IGlzIHByZXNzZWRcblx0X2NhbmNlbERyYXdpbmc6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcblx0XHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuRHJhdy5Qb2x5bGluZSA9IEwuRHJhdy5GZWF0dXJlLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAncG9seWxpbmUnXG5cdH0sXG5cblx0UG9seTogTC5Qb2x5bGluZSxcblxuXHRvcHRpb25zOiB7XG5cdFx0YWxsb3dJbnRlcnNlY3Rpb246IHRydWUsXG5cdFx0cmVwZWF0TW9kZTogZmFsc2UsXG5cdFx0ZHJhd0Vycm9yOiB7XG5cdFx0XHRjb2xvcjogJyNiMDBiMDAnLFxuXHRcdFx0dGltZW91dDogMjUwMFxuXHRcdH0sXG5cdFx0aWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOCksXG5cdFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uJ1xuXHRcdH0pLFxuXHRcdGd1aWRlbGluZURpc3RhbmNlOiAyMCxcblx0XHRtYXhHdWlkZUxpbmVMZW5ndGg6IDQwMDAsXG5cdFx0c2hhcGVPcHRpb25zOiB7XG5cdFx0XHRzdHJva2U6IHRydWUsXG5cdFx0XHRjb2xvcjogJyNmMDZlYWEnLFxuXHRcdFx0d2VpZ2h0OiA0LFxuXHRcdFx0b3BhY2l0eTogMC41LFxuXHRcdFx0ZmlsbDogZmFsc2UsXG5cdFx0XHRjbGlja2FibGU6IHRydWVcblx0XHR9LFxuXHRcdG1ldHJpYzogdHJ1ZSwgLy8gV2hldGhlciB0byB1c2UgdGhlIG1ldHJpYyBtZWF1cmVtZW50IHN5c3RlbSBvciBpbXBlcmlhbFxuXHRcdHNob3dMZW5ndGg6IHRydWUsIC8vIFdoZXRoZXIgdG8gZGlzcGxheSBkaXN0YW5jZSBpbiB0aGUgdG9vbHRpcFxuXHRcdHpJbmRleE9mZnNldDogMjAwMCAvLyBUaGlzIHNob3VsZCBiZSA+IHRoYW4gdGhlIGhpZ2hlc3Qgei1pbmRleCBhbnkgbWFwIGxheWVyc1xuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHQvLyBOZWVkIHRvIHNldCB0aGlzIGhlcmUgdG8gZW5zdXJlIHRoZSBjb3JyZWN0IG1lc3NhZ2UgaXMgdXNlZC5cblx0XHR0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLm1lc3NhZ2UgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLmVycm9yO1xuXG5cdFx0Ly8gTWVyZ2UgZGVmYXVsdCBkcmF3RXJyb3Igb3B0aW9ucyB3aXRoIGN1c3RvbSBvcHRpb25zXG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kcmF3RXJyb3IpIHtcblx0XHRcdG9wdGlvbnMuZHJhd0Vycm9yID0gTC5VdGlsLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmRyYXdFcnJvciwgb3B0aW9ucy5kcmF3RXJyb3IpO1xuXHRcdH1cblxuXHRcdC8vIFNhdmUgdGhlIHR5cGUgc28gc3VwZXIgY2FuIGZpcmUsIG5lZWQgdG8gZG8gdGhpcyBhcyBjYW5ub3QgZG8gdGhpcy5UWVBFIDooXG5cdFx0dGhpcy50eXBlID0gTC5EcmF3LlBvbHlsaW5lLlRZUEU7XG5cblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuYWRkSG9va3MuY2FsbCh0aGlzKTtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzID0gW107XG5cblx0XHRcdHRoaXMuX21hcmtlckdyb3VwID0gbmV3IEwuTGF5ZXJHcm91cCgpO1xuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblxuXHRcdFx0dGhpcy5fcG9seSA9IG5ldyBMLlBvbHlsaW5lKFtdLCB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHRoaXMuX2dldFRvb2x0aXBUZXh0KCkpO1xuXG5cdFx0XHQvLyBNYWtlIGEgdHJhbnNwYXJlbnQgbWFya2VyIHRoYXQgd2lsbCB1c2VkIHRvIGNhdGNoIGNsaWNrIGV2ZW50cy4gVGhlc2UgY2xpY2tcblx0XHRcdC8vIGV2ZW50cyB3aWxsIGNyZWF0ZSB0aGUgdmVydGljZXMuIFdlIG5lZWQgdG8gZG8gdGhpcyBzbyB3ZSBjYW4gZW5zdXJlIHRoYXRcblx0XHRcdC8vIHdlIGNhbiBjcmVhdGUgdmVydGljZXMgb3ZlciBvdGhlciBtYXAgbGF5ZXJzIChtYXJrZXJzLCB2ZWN0b3IgbGF5ZXJzKS4gV2Vcblx0XHRcdC8vIGFsc28gZG8gbm90IHdhbnQgdG8gdHJpZ2dlciBhbnkgY2xpY2sgaGFuZGxlcnMgb2Ygb2JqZWN0cyB3ZSBhcmUgY2xpY2tpbmcgb25cblx0XHRcdC8vIHdoaWxlIGRyYXdpbmcuXG5cdFx0XHRpZiAoIXRoaXMuX21vdXNlTWFya2VyKSB7XG5cdFx0XHRcdHRoaXMuX21vdXNlTWFya2VyID0gTC5tYXJrZXIodGhpcy5fbWFwLmdldENlbnRlcigpLCB7XG5cdFx0XHRcdFx0aWNvbjogTC5kaXZJY29uKHtcblx0XHRcdFx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtbW91c2UtbWFya2VyJyxcblx0XHRcdFx0XHRcdGljb25BbmNob3I6IFsyMCwgMjBdLFxuXHRcdFx0XHRcdFx0aWNvblNpemU6IFs0MCwgNDBdXG5cdFx0XHRcdFx0fSksXG5cdFx0XHRcdFx0b3BhY2l0eTogMCxcblx0XHRcdFx0XHR6SW5kZXhPZmZzZXQ6IHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXRcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlTWFya2VyXG5cdFx0XHRcdC5vbignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5hZGRUbyh0aGlzLl9tYXApO1xuXG5cdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0Lm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcylcblx0XHRcdFx0Lm9uKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKVxuXHRcdFx0XHQub24oJ3pvb21lbmQnLCB0aGlzLl9vblpvb21FbmQsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5yZW1vdmVIb29rcy5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fY2xlYXJIaWRlRXJyb3JUaW1lb3V0KCk7XG5cblx0XHR0aGlzLl9jbGVhblVwU2hhcGUoKTtcblxuXHRcdC8vIHJlbW92ZSBtYXJrZXJzIGZyb20gbWFwXG5cdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHRkZWxldGUgdGhpcy5fbWFya2VyR3JvdXA7XG5cdFx0ZGVsZXRlIHRoaXMuX21hcmtlcnM7XG5cblx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fcG9seSk7XG5cdFx0ZGVsZXRlIHRoaXMuX3BvbHk7XG5cblx0XHR0aGlzLl9tb3VzZU1hcmtlclxuXHRcdFx0Lm9mZignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHQub2ZmKCdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKTtcblx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbW91c2VNYXJrZXIpO1xuXHRcdGRlbGV0ZSB0aGlzLl9tb3VzZU1hcmtlcjtcblxuXHRcdC8vIGNsZWFuIHVwIERPTVxuXHRcdHRoaXMuX2NsZWFyR3VpZGVzKCk7XG5cblx0XHR0aGlzLl9tYXBcblx0XHRcdC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxuXHRcdFx0Lm9mZignem9vbWVuZCcsIHRoaXMuX29uWm9vbUVuZCwgdGhpcyk7XG5cdH0sXG5cblx0ZGVsZXRlTGFzdFZlcnRleDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA8PSAxKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxhc3RNYXJrZXIgPSB0aGlzLl9tYXJrZXJzLnBvcCgpLFxuXHRcdFx0cG9seSA9IHRoaXMuX3BvbHksXG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9wb2x5LnNwbGljZUxhdExuZ3MocG9seS5nZXRMYXRMbmdzKCkubGVuZ3RoIC0gMSwgMSlbMF07XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihsYXN0TWFya2VyKTtcblxuXHRcdGlmIChwb2x5LmdldExhdExuZ3MoKS5sZW5ndGggPCAyKSB7XG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIocG9seSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdmVydGV4Q2hhbmdlZChsYXRsbmcsIGZhbHNlKTtcblx0fSxcblxuXHRhZGRWZXJ0ZXg6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgbWFya2Vyc0xlbmd0aCA9IHRoaXMuX21hcmtlcnMubGVuZ3RoO1xuXG5cdFx0aWYgKG1hcmtlcnNMZW5ndGggPiAwICYmICF0aGlzLm9wdGlvbnMuYWxsb3dJbnRlcnNlY3Rpb24gJiYgdGhpcy5fcG9seS5uZXdMYXRMbmdJbnRlcnNlY3RzKGxhdGxuZykpIHtcblx0XHRcdHRoaXMuX3Nob3dFcnJvclRvb2x0aXAoKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0ZWxzZSBpZiAodGhpcy5fZXJyb3JTaG93bikge1xuXHRcdFx0dGhpcy5faGlkZUVycm9yVG9vbHRpcCgpO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcmtlcnMucHVzaCh0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nKSk7XG5cblx0XHR0aGlzLl9wb2x5LmFkZExhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKHRoaXMuX3BvbHkuZ2V0TGF0TG5ncygpLmxlbmd0aCA9PT0gMikge1xuXHRcdFx0dGhpcy5fbWFwLmFkZExheWVyKHRoaXMuX3BvbHkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3ZlcnRleENoYW5nZWQobGF0bG5nLCB0cnVlKTtcblx0fSxcblxuXHRfZmluaXNoU2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgaW50ZXJzZWN0cyA9IHRoaXMuX3BvbHkubmV3TGF0TG5nSW50ZXJzZWN0cyh0aGlzLl9wb2x5LmdldExhdExuZ3MoKVswXSwgdHJ1ZSk7XG5cblx0XHRpZiAoKCF0aGlzLm9wdGlvbnMuYWxsb3dJbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0cykgfHwgIXRoaXMuX3NoYXBlSXNWYWxpZCgpKSB7XG5cdFx0XHR0aGlzLl9zaG93RXJyb3JUb29sdGlwKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmlyZUNyZWF0ZWRFdmVudCgpO1xuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdGlmICh0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSkge1xuXHRcdFx0dGhpcy5lbmFibGUoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly9DYWxsZWQgdG8gdmVyaWZ5IHRoZSBzaGFwZSBpcyB2YWxpZCB3aGVuIHRoZSB1c2VyIHRyaWVzIHRvIGZpbmlzaCBpdFxuXHQvL1JldHVybiBmYWxzZSBpZiB0aGUgc2hhcGUgaXMgbm90IHZhbGlkXG5cdF9zaGFwZUlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfb25ab29tRW5kOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fdXBkYXRlR3VpZGUoKTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG5ld1BvcyA9IGUubGF5ZXJQb2ludCxcblx0XHRcdGxhdGxuZyA9IGUubGF0bG5nO1xuXG5cdFx0Ly8gU2F2ZSBsYXRsbmdcblx0XHQvLyBzaG91bGQgdGhpcyBiZSBtb3ZlZCB0byBfdXBkYXRlR3VpZGUoKSA/XG5cdFx0dGhpcy5fY3VycmVudExhdExuZyA9IGxhdGxuZztcblxuXHRcdHRoaXMuX3VwZGF0ZVRvb2x0aXAobGF0bG5nKTtcblxuXHRcdC8vIFVwZGF0ZSB0aGUgZ3VpZGUgbGluZVxuXHRcdHRoaXMuX3VwZGF0ZUd1aWRlKG5ld1Bvcyk7XG5cblx0XHQvLyBVcGRhdGUgdGhlIG1vdXNlIG1hcmtlciBwb3NpdGlvblxuXHRcdHRoaXMuX21vdXNlTWFya2VyLnNldExhdExuZyhsYXRsbmcpO1xuXG5cdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlLm9yaWdpbmFsRXZlbnQpO1xuXHR9LFxuXG5cdF92ZXJ0ZXhDaGFuZ2VkOiBmdW5jdGlvbiAobGF0bG5nLCBhZGRlZCkge1xuXHRcdHRoaXMuX3VwZGF0ZUZpbmlzaEhhbmRsZXIoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVJ1bm5pbmdNZWFzdXJlKGxhdGxuZywgYWRkZWQpO1xuXG5cdFx0dGhpcy5fY2xlYXJHdWlkZXMoKTtcblxuXHRcdHRoaXMuX3VwZGF0ZVRvb2x0aXAoKTtcblx0fSxcblxuXHRfb25Nb3VzZURvd246IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG5cdFx0dGhpcy5fbW91c2VEb3duT3JpZ2luID0gTC5wb2ludChvcmlnaW5hbEV2ZW50LmNsaWVudFgsIG9yaWdpbmFsRXZlbnQuY2xpZW50WSk7XG5cdH0sXG5cblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcblx0XHRpZiAodGhpcy5fbW91c2VEb3duT3JpZ2luKSB7XG5cdFx0XHQvLyBXZSBkZXRlY3QgY2xpY2tzIHdpdGhpbiBhIGNlcnRhaW4gdG9sZXJhbmNlLCBvdGhlcndpc2UgbGV0IGl0XG5cdFx0XHQvLyBiZSBpbnRlcnByZXRlZCBhcyBhIGRyYWcgYnkgdGhlIG1hcFxuXHRcdFx0dmFyIGRpc3RhbmNlID0gTC5wb2ludChlLm9yaWdpbmFsRXZlbnQuY2xpZW50WCwgZS5vcmlnaW5hbEV2ZW50LmNsaWVudFkpXG5cdFx0XHRcdC5kaXN0YW5jZVRvKHRoaXMuX21vdXNlRG93bk9yaWdpbik7XG5cdFx0XHRpZiAoTWF0aC5hYnMoZGlzdGFuY2UpIDwgOSAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSkge1xuXHRcdFx0XHR0aGlzLmFkZFZlcnRleChlLmxhdGxuZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX21vdXNlRG93bk9yaWdpbiA9IG51bGw7XG5cdH0sXG5cblx0X3VwZGF0ZUZpbmlzaEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyQ291bnQgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aDtcblx0XHQvLyBUaGUgbGFzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYSBjbGljayBoYW5kbGVyIHRvIGNsb3NlIHRoZSBwb2x5bGluZVxuXHRcdGlmIChtYXJrZXJDb3VudCA+IDEpIHtcblx0XHRcdHRoaXMuX21hcmtlcnNbbWFya2VyQ291bnQgLSAxXS5vbignY2xpY2snLCB0aGlzLl9maW5pc2hTaGFwZSwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBvbGQgbWFya2VyIGNsaWNrIGhhbmRsZXIgKGFzIG9ubHkgdGhlIGxhc3QgcG9pbnQgc2hvdWxkIGNsb3NlIHRoZSBwb2x5bGluZSlcblx0XHRpZiAobWFya2VyQ291bnQgPiAyKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMl0ub2ZmKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRpY29uOiB0aGlzLm9wdGlvbnMuaWNvbixcblx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldCAqIDJcblx0XHR9KTtcblxuXHRcdHRoaXMuX21hcmtlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cblx0XHRyZXR1cm4gbWFya2VyO1xuXHR9LFxuXG5cdF91cGRhdGVHdWlkZTogZnVuY3Rpb24gKG5ld1Bvcykge1xuXHRcdHZhciBtYXJrZXJDb3VudCA9IHRoaXMuX21hcmtlcnMubGVuZ3RoO1xuXG5cdFx0aWYgKG1hcmtlckNvdW50ID4gMCkge1xuXHRcdFx0bmV3UG9zID0gbmV3UG9zIHx8IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fY3VycmVudExhdExuZyk7XG5cblx0XHRcdC8vIGRyYXcgdGhlIGd1aWRlIGxpbmVcblx0XHRcdHRoaXMuX2NsZWFyR3VpZGVzKCk7XG5cdFx0XHR0aGlzLl9kcmF3R3VpZGUoXG5cdFx0XHRcdHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbWFya2Vyc1ttYXJrZXJDb3VudCAtIDFdLmdldExhdExuZygpKSxcblx0XHRcdFx0bmV3UG9zXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlVG9vbHRpcDogZnVuY3Rpb24gKGxhdExuZykge1xuXHRcdHZhciB0ZXh0ID0gdGhpcy5fZ2V0VG9vbHRpcFRleHQoKTtcblxuXHRcdGlmIChsYXRMbmcpIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24obGF0TG5nKTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX2Vycm9yU2hvd24pIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh0ZXh0KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXdHdWlkZTogZnVuY3Rpb24gKHBvaW50QSwgcG9pbnRCKSB7XG5cdFx0dmFyIGxlbmd0aCA9IE1hdGguZmxvb3IoTWF0aC5zcXJ0KE1hdGgucG93KChwb2ludEIueCAtIHBvaW50QS54KSwgMikgKyBNYXRoLnBvdygocG9pbnRCLnkgLSBwb2ludEEueSksIDIpKSksXG5cdFx0XHRndWlkZWxpbmVEaXN0YW5jZSA9IHRoaXMub3B0aW9ucy5ndWlkZWxpbmVEaXN0YW5jZSxcblx0XHRcdG1heEd1aWRlTGluZUxlbmd0aCA9IHRoaXMub3B0aW9ucy5tYXhHdWlkZUxpbmVMZW5ndGgsXG5cdFx0XHQvLyBPbmx5IGRyYXcgYSBndWlkZWxpbmUgd2l0aCBhIG1heCBsZW5ndGhcblx0XHRcdGkgPSBsZW5ndGggPiBtYXhHdWlkZUxpbmVMZW5ndGggPyBsZW5ndGggLSBtYXhHdWlkZUxpbmVMZW5ndGggOiBndWlkZWxpbmVEaXN0YW5jZSxcblx0XHRcdGZyYWN0aW9uLFxuXHRcdFx0ZGFzaFBvaW50LFxuXHRcdFx0ZGFzaDtcblxuXHRcdC8vY3JlYXRlIHRoZSBndWlkZXMgY29udGFpbmVyIGlmIHdlIGhhdmVuJ3QgeWV0XG5cdFx0aWYgKCF0aGlzLl9ndWlkZXNDb250YWluZXIpIHtcblx0XHRcdHRoaXMuX2d1aWRlc0NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWRyYXctZ3VpZGVzJywgdGhpcy5fb3ZlcmxheVBhbmUpO1xuXHRcdH1cblxuXHRcdC8vZHJhdyBhIGRhc2ggZXZlcnkgR3VpbGRlTGluZURpc3RhbmNlXG5cdFx0Zm9yICg7IGkgPCBsZW5ndGg7IGkgKz0gdGhpcy5vcHRpb25zLmd1aWRlbGluZURpc3RhbmNlKSB7XG5cdFx0XHQvL3dvcmsgb3V0IGZyYWN0aW9uIGFsb25nIGxpbmUgd2UgYXJlXG5cdFx0XHRmcmFjdGlvbiA9IGkgLyBsZW5ndGg7XG5cblx0XHRcdC8vY2FsY3VsYXRlIG5ldyB4LHkgcG9pbnRcblx0XHRcdGRhc2hQb2ludCA9IHtcblx0XHRcdFx0eDogTWF0aC5mbG9vcigocG9pbnRBLnggKiAoMSAtIGZyYWN0aW9uKSkgKyAoZnJhY3Rpb24gKiBwb2ludEIueCkpLFxuXHRcdFx0XHR5OiBNYXRoLmZsb29yKChwb2ludEEueSAqICgxIC0gZnJhY3Rpb24pKSArIChmcmFjdGlvbiAqIHBvaW50Qi55KSlcblx0XHRcdH07XG5cblx0XHRcdC8vYWRkIGd1aWRlIGRhc2ggdG8gZ3VpZGUgY29udGFpbmVyXG5cdFx0XHRkYXNoID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy1ndWlkZS1kYXNoJywgdGhpcy5fZ3VpZGVzQ29udGFpbmVyKTtcblx0XHRcdGRhc2guc3R5bGUuYmFja2dyb3VuZENvbG9yID1cblx0XHRcdFx0IXRoaXMuX2Vycm9yU2hvd24gPyB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zLmNvbG9yIDogdGhpcy5vcHRpb25zLmRyYXdFcnJvci5jb2xvcjtcblxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKGRhc2gsIGRhc2hQb2ludCk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGVHdWlkZUNvbG9yOiBmdW5jdGlvbiAoY29sb3IpIHtcblx0XHRpZiAodGhpcy5fZ3VpZGVzQ29udGFpbmVyKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2d1aWRlc0NvbnRhaW5lci5jaGlsZE5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0aGlzLl9ndWlkZXNDb250YWluZXIuY2hpbGROb2Rlc1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBjb2xvcjtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gcmVtb3ZlcyBhbGwgY2hpbGQgZWxlbWVudHMgKGd1aWRlIGRhc2hlcykgZnJvbSB0aGUgZ3VpZGVzIGNvbnRhaW5lclxuXHRfY2xlYXJHdWlkZXM6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZ3VpZGVzQ29udGFpbmVyKSB7XG5cdFx0XHR3aGlsZSAodGhpcy5fZ3VpZGVzQ29udGFpbmVyLmZpcnN0Q2hpbGQpIHtcblx0XHRcdFx0dGhpcy5fZ3VpZGVzQ29udGFpbmVyLnJlbW92ZUNoaWxkKHRoaXMuX2d1aWRlc0NvbnRhaW5lci5maXJzdENoaWxkKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRvb2x0aXBUZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNob3dMZW5ndGggPSB0aGlzLm9wdGlvbnMuc2hvd0xlbmd0aCxcblx0XHRcdGxhYmVsVGV4dCwgZGlzdGFuY2VTdHI7XG5cblx0XHRpZiAodGhpcy5fbWFya2Vycy5sZW5ndGggPT09IDApIHtcblx0XHRcdGxhYmVsVGV4dCA9IHtcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLnN0YXJ0XG5cdFx0XHR9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXN0YW5jZVN0ciA9IHNob3dMZW5ndGggPyB0aGlzLl9nZXRNZWFzdXJlbWVudFN0cmluZygpIDogJyc7XG5cblx0XHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0XHRsYWJlbFRleHQgPSB7XG5cdFx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5wb2x5bGluZS50b29sdGlwLmNvbnQsXG5cdFx0XHRcdFx0c3VidGV4dDogZGlzdGFuY2VTdHJcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGxhYmVsVGV4dCA9IHtcblx0XHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlsaW5lLnRvb2x0aXAuZW5kLFxuXHRcdFx0XHRcdHN1YnRleHQ6IGRpc3RhbmNlU3RyXG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBsYWJlbFRleHQ7XG5cdH0sXG5cblx0X3VwZGF0ZVJ1bm5pbmdNZWFzdXJlOiBmdW5jdGlvbiAobGF0bG5nLCBhZGRlZCkge1xuXHRcdHZhciBtYXJrZXJzTGVuZ3RoID0gdGhpcy5fbWFya2Vycy5sZW5ndGgsXG5cdFx0XHRwcmV2aW91c01hcmtlckluZGV4LCBkaXN0YW5jZTtcblxuXHRcdGlmICh0aGlzLl9tYXJrZXJzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fbWVhc3VyZW1lbnRSdW5uaW5nVG90YWwgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcmV2aW91c01hcmtlckluZGV4ID0gbWFya2Vyc0xlbmd0aCAtIChhZGRlZCA/IDIgOiAxKTtcblx0XHRcdGRpc3RhbmNlID0gbGF0bG5nLmRpc3RhbmNlVG8odGhpcy5fbWFya2Vyc1twcmV2aW91c01hcmtlckluZGV4XS5nZXRMYXRMbmcoKSk7XG5cblx0XHRcdHRoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsICs9IGRpc3RhbmNlICogKGFkZGVkID8gMSA6IC0xKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldE1lYXN1cmVtZW50U3RyaW5nOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGN1cnJlbnRMYXRMbmcgPSB0aGlzLl9jdXJyZW50TGF0TG5nLFxuXHRcdFx0cHJldmlvdXNMYXRMbmcgPSB0aGlzLl9tYXJrZXJzW3RoaXMuX21hcmtlcnMubGVuZ3RoIC0gMV0uZ2V0TGF0TG5nKCksXG5cdFx0XHRkaXN0YW5jZTtcblxuXHRcdC8vIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgZnJvbSB0aGUgbGFzdCBmaXhlZCBwb2ludCB0byB0aGUgbW91c2UgcG9zaXRpb25cblx0XHRkaXN0YW5jZSA9IHRoaXMuX21lYXN1cmVtZW50UnVubmluZ1RvdGFsICsgY3VycmVudExhdExuZy5kaXN0YW5jZVRvKHByZXZpb3VzTGF0TG5nKTtcblxuXHRcdHJldHVybiBMLkdlb21ldHJ5VXRpbC5yZWFkYWJsZURpc3RhbmNlKGRpc3RhbmNlLCB0aGlzLm9wdGlvbnMubWV0cmljKTtcblx0fSxcblxuXHRfc2hvd0Vycm9yVG9vbHRpcDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2Vycm9yU2hvd24gPSB0cnVlO1xuXG5cdFx0Ly8gVXBkYXRlIHRvb2x0aXBcblx0XHR0aGlzLl90b29sdGlwXG5cdFx0XHQuc2hvd0FzRXJyb3IoKVxuXHRcdFx0LnVwZGF0ZUNvbnRlbnQoeyB0ZXh0OiB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLm1lc3NhZ2UgfSk7XG5cblx0XHQvLyBVcGRhdGUgc2hhcGVcblx0XHR0aGlzLl91cGRhdGVHdWlkZUNvbG9yKHRoaXMub3B0aW9ucy5kcmF3RXJyb3IuY29sb3IpO1xuXHRcdHRoaXMuX3BvbHkuc2V0U3R5bGUoeyBjb2xvcjogdGhpcy5vcHRpb25zLmRyYXdFcnJvci5jb2xvciB9KTtcblxuXHRcdC8vIEhpZGUgdGhlIGVycm9yIGFmdGVyIDIgc2Vjb25kc1xuXHRcdHRoaXMuX2NsZWFySGlkZUVycm9yVGltZW91dCgpO1xuXHRcdHRoaXMuX2hpZGVFcnJvclRpbWVvdXQgPSBzZXRUaW1lb3V0KEwuVXRpbC5iaW5kKHRoaXMuX2hpZGVFcnJvclRvb2x0aXAsIHRoaXMpLCB0aGlzLm9wdGlvbnMuZHJhd0Vycm9yLnRpbWVvdXQpO1xuXHR9LFxuXG5cdF9oaWRlRXJyb3JUb29sdGlwOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fZXJyb3JTaG93biA9IGZhbHNlO1xuXG5cdFx0dGhpcy5fY2xlYXJIaWRlRXJyb3JUaW1lb3V0KCk7XG5cblx0XHQvLyBSZXZlcnQgdG9vbHRpcFxuXHRcdHRoaXMuX3Rvb2x0aXBcblx0XHRcdC5yZW1vdmVFcnJvcigpXG5cdFx0XHQudXBkYXRlQ29udGVudCh0aGlzLl9nZXRUb29sdGlwVGV4dCgpKTtcblxuXHRcdC8vIFJldmVydCBzaGFwZVxuXHRcdHRoaXMuX3VwZGF0ZUd1aWRlQ29sb3IodGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucy5jb2xvcik7XG5cdFx0dGhpcy5fcG9seS5zZXRTdHlsZSh7IGNvbG9yOiB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zLmNvbG9yIH0pO1xuXHR9LFxuXG5cdF9jbGVhckhpZGVFcnJvclRpbWVvdXQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faGlkZUVycm9yVGltZW91dCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hpZGVFcnJvclRpbWVvdXQpO1xuXHRcdFx0dGhpcy5faGlkZUVycm9yVGltZW91dCA9IG51bGw7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbGVhblVwU2hhcGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFya2Vycy5sZW5ndGggPiAxKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzW3RoaXMuX21hcmtlcnMubGVuZ3RoIC0gMV0ub2ZmKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9seSA9IG5ldyB0aGlzLlBvbHkodGhpcy5fcG9seS5nZXRMYXRMbmdzKCksIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5fZmlyZUNyZWF0ZWRFdmVudC5jYWxsKHRoaXMsIHBvbHkpO1xuXHR9XG59KTtcblxuXG5MLkRyYXcuUG9seWdvbiA9IEwuRHJhdy5Qb2x5bGluZS5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ3BvbHlnb24nXG5cdH0sXG5cblx0UG9seTogTC5Qb2x5Z29uLFxuXG5cdG9wdGlvbnM6IHtcblx0XHRzaG93QXJlYTogZmFsc2UsXG5cdFx0c2hhcGVPcHRpb25zOiB7XG5cdFx0XHRzdHJva2U6IHRydWUsXG5cdFx0XHRjb2xvcjogJyNmMDZlYWEnLFxuXHRcdFx0d2VpZ2h0OiA0LFxuXHRcdFx0b3BhY2l0eTogMC41LFxuXHRcdFx0ZmlsbDogdHJ1ZSxcblx0XHRcdGZpbGxDb2xvcjogbnVsbCwgLy9zYW1lIGFzIGNvbG9yIGJ5IGRlZmF1bHRcblx0XHRcdGZpbGxPcGFjaXR5OiAwLjIsXG5cdFx0XHRjbGlja2FibGU6IHRydWVcblx0XHR9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCwgb3B0aW9ucykge1xuXHRcdEwuRHJhdy5Qb2x5bGluZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRHJhdy5Qb2x5Z29uLlRZUEU7XG5cdH0sXG5cblx0X3VwZGF0ZUZpbmlzaEhhbmRsZXI6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyQ291bnQgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aDtcblxuXHRcdC8vIFRoZSBmaXJzdCBtYXJrZXIgc2hvdWxkIGhhdmUgYSBjbGljayBoYW5kbGVyIHRvIGNsb3NlIHRoZSBwb2x5Z29uXG5cdFx0aWYgKG1hcmtlckNvdW50ID09PSAxKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzWzBdLm9uKCdjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHR9XG5cblx0XHQvLyBBZGQgYW5kIHVwZGF0ZSB0aGUgZG91YmxlIGNsaWNrIGhhbmRsZXJcblx0XHRpZiAobWFya2VyQ291bnQgPiAyKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMV0ub24oJ2RibGNsaWNrJywgdGhpcy5fZmluaXNoU2hhcGUsIHRoaXMpO1xuXHRcdFx0Ly8gT25seSBuZWVkIHRvIHJlbW92ZSBoYW5kbGVyIGlmIGhhcyBiZWVuIGFkZGVkIGJlZm9yZVxuXHRcdFx0aWYgKG1hcmtlckNvdW50ID4gMykge1xuXHRcdFx0XHR0aGlzLl9tYXJrZXJzW21hcmtlckNvdW50IC0gMl0ub2ZmKCdkYmxjbGljaycsIHRoaXMuX2ZpbmlzaFNoYXBlLCB0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2dldFRvb2x0aXBUZXh0OiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHRleHQsIHN1YnRleHQ7XG5cblx0XHRpZiAodGhpcy5fbWFya2Vycy5sZW5ndGggPT09IDApIHtcblx0XHRcdHRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5zdGFydDtcblx0XHR9IGVsc2UgaWYgKHRoaXMuX21hcmtlcnMubGVuZ3RoIDwgMykge1xuXHRcdFx0dGV4dCA9IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMucG9seWdvbi50b29sdGlwLmNvbnQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnBvbHlnb24udG9vbHRpcC5lbmQ7XG5cdFx0XHRzdWJ0ZXh0ID0gdGhpcy5fZ2V0TWVhc3VyZW1lbnRTdHJpbmcoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0dGV4dDogdGV4dCxcblx0XHRcdHN1YnRleHQ6IHN1YnRleHRcblx0XHR9O1xuXHR9LFxuXG5cdF9nZXRNZWFzdXJlbWVudFN0cmluZzogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBhcmVhID0gdGhpcy5fYXJlYTtcblxuXHRcdGlmICghYXJlYSkge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEwuR2VvbWV0cnlVdGlsLnJlYWRhYmxlQXJlYShhcmVhLCB0aGlzLm9wdGlvbnMubWV0cmljKTtcblx0fSxcblxuXHRfc2hhcGVJc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hcmtlcnMubGVuZ3RoID49IDM7XG5cdH0sXG5cblx0X3ZlcnRleEFkZGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIHNob3VsZCBzaG93IHRoZSBhcmVhXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hbGxvd0ludGVyc2VjdGlvbiB8fCAhdGhpcy5vcHRpb25zLnNob3dBcmVhKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGxhdExuZ3MgPSB0aGlzLl9wb2x5LmdldExhdExuZ3MoKTtcblxuXHRcdHRoaXMuX2FyZWEgPSBMLkdlb21ldHJ5VXRpbC5nZW9kZXNpY0FyZWEobGF0TG5ncyk7XG5cdH0sXG5cblx0X2NsZWFuVXBTaGFwZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXJrZXJDb3VudCA9IHRoaXMuX21hcmtlcnMubGVuZ3RoO1xuXG5cdFx0aWYgKG1hcmtlckNvdW50ID4gMCkge1xuXHRcdFx0dGhpcy5fbWFya2Vyc1swXS5vZmYoJ2NsaWNrJywgdGhpcy5fZmluaXNoU2hhcGUsIHRoaXMpO1xuXG5cdFx0XHRpZiAobWFya2VyQ291bnQgPiAyKSB7XG5cdFx0XHRcdHRoaXMuX21hcmtlcnNbbWFya2VyQ291bnQgLSAxXS5vZmYoJ2RibGNsaWNrJywgdGhpcy5fZmluaXNoU2hhcGUsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cblxuTC5TaW1wbGVTaGFwZSA9IHt9O1xuXG5MLkRyYXcuU2ltcGxlU2hhcGUgPSBMLkRyYXcuRmVhdHVyZS5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0cmVwZWF0TW9kZTogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0dGhpcy5fZW5kTGFiZWxUZXh0ID0gTC5kcmF3TG9jYWwuZHJhdy5oYW5kbGVycy5zaW1wbGVzaGFwZS50b29sdGlwLmVuZDtcblxuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwLCBvcHRpb25zKTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5hZGRIb29rcy5jYWxsKHRoaXMpO1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcERyYWdnYWJsZSA9IHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGVkKCk7XG5cblx0XHRcdGlmICh0aGlzLl9tYXBEcmFnZ2FibGUpIHtcblx0XHRcdFx0dGhpcy5fbWFwLmRyYWdnaW5nLmRpc2FibGUoKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9UT0RPIHJlZmFjdG9yOiBtb3ZlIGN1cnNvciB0byBzdHlsZXNcblx0XHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5jdXJzb3IgPSAnY3Jvc3NoYWlyJztcblxuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHsgdGV4dDogdGhpcy5faW5pdGlhbExhYmVsVGV4dCB9KTtcblxuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5yZW1vdmVIb29rcy5jYWxsKHRoaXMpO1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdGlmICh0aGlzLl9tYXBEcmFnZ2FibGUpIHtcblx0XHRcdFx0dGhpcy5fbWFwLmRyYWdnaW5nLmVuYWJsZSgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1RPRE8gcmVmYWN0b3I6IG1vdmUgY3Vyc29yIHRvIHN0eWxlc1xuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICcnO1xuXG5cdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0Lm9mZignbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpXG5cdFx0XHRcdC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblxuXHRcdFx0TC5Eb21FdmVudC5vZmYoZG9jdW1lbnQsICdtb3VzZXVwJywgdGhpcy5fb25Nb3VzZVVwLCB0aGlzKTtcblxuXHRcdFx0Ly8gSWYgdGhlIGJveCBlbGVtZW50IGRvZXNuJ3QgZXhpc3QgdGhleSBtdXN0IG5vdCBoYXZlIG1vdmVkIHRoZSBtb3VzZSwgc28gZG9uJ3QgbmVlZCB0byBkZXN0cm95L3JldHVyblxuXHRcdFx0aWYgKHRoaXMuX3NoYXBlKSB7XG5cdFx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9zaGFwZSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9zaGFwZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faXNEcmF3aW5nID0gZmFsc2U7XG5cdH0sXG5cblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xuXHRcdHRoaXMuX2lzRHJhd2luZyA9IHRydWU7XG5cdFx0dGhpcy5fc3RhcnRMYXRMbmcgPSBlLmxhdGxuZztcblxuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIHRoaXMpXG5cdFx0XHQucHJldmVudERlZmF1bHQoZS5vcmlnaW5hbEV2ZW50KTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nO1xuXG5cdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihsYXRsbmcpO1xuXHRcdGlmICh0aGlzLl9pc0RyYXdpbmcpIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh7IHRleHQ6IHRoaXMuX2VuZExhYmVsVGV4dCB9KTtcblx0XHRcdHRoaXMuX2RyYXdTaGFwZShsYXRsbmcpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZVVwOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3NoYXBlKSB7XG5cdFx0XHR0aGlzLl9maXJlQ3JlYXRlZEV2ZW50KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5kaXNhYmxlKCk7XG5cdFx0aWYgKHRoaXMub3B0aW9ucy5yZXBlYXRNb2RlKSB7XG5cdFx0XHR0aGlzLmVuYWJsZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbkwuRHJhdy5SZWN0YW5nbGUgPSBMLkRyYXcuU2ltcGxlU2hhcGUuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdyZWN0YW5nbGUnXG5cdH0sXG5cblx0b3B0aW9uczoge1xuXHRcdHNoYXBlT3B0aW9uczoge1xuXHRcdFx0c3Ryb2tlOiB0cnVlLFxuXHRcdFx0Y29sb3I6ICcjZjA2ZWFhJyxcblx0XHRcdHdlaWdodDogNCxcblx0XHRcdG9wYWNpdHk6IDAuNSxcblx0XHRcdGZpbGw6IHRydWUsXG5cdFx0XHRmaWxsQ29sb3I6IG51bGwsIC8vc2FtZSBhcyBjb2xvciBieSBkZWZhdWx0XG5cdFx0XHRmaWxsT3BhY2l0eTogMC4yLFxuXHRcdFx0Y2xpY2thYmxlOiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRHJhdy5SZWN0YW5nbGUuVFlQRTtcblxuXHRcdHRoaXMuX2luaXRpYWxMYWJlbFRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLnJlY3RhbmdsZS50b29sdGlwLnN0YXJ0O1xuXG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwLCBvcHRpb25zKTtcblx0fSxcblxuXHRfZHJhd1NoYXBlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0aWYgKCF0aGlzLl9zaGFwZSkge1xuXHRcdFx0dGhpcy5fc2hhcGUgPSBuZXcgTC5SZWN0YW5nbGUobmV3IEwuTGF0TG5nQm91bmRzKHRoaXMuX3N0YXJ0TGF0TG5nLCBsYXRsbmcpLCB0aGlzLm9wdGlvbnMuc2hhcGVPcHRpb25zKTtcblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9zaGFwZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3NoYXBlLnNldEJvdW5kcyhuZXcgTC5MYXRMbmdCb3VuZHModGhpcy5fc3RhcnRMYXRMbmcsIGxhdGxuZykpO1xuXHRcdH1cblx0fSxcblxuXHRfZmlyZUNyZWF0ZWRFdmVudDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciByZWN0YW5nbGUgPSBuZXcgTC5SZWN0YW5nbGUodGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCksIHRoaXMub3B0aW9ucy5zaGFwZU9wdGlvbnMpO1xuXHRcdEwuRHJhdy5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCByZWN0YW5nbGUpO1xuXHR9XG59KTtcblxuXG5MLkRyYXcuQ2lyY2xlID0gTC5EcmF3LlNpbXBsZVNoYXBlLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnY2lyY2xlJ1xuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblx0XHRzaGFwZU9wdGlvbnM6IHtcblx0XHRcdHN0cm9rZTogdHJ1ZSxcblx0XHRcdGNvbG9yOiAnI2YwNmVhYScsXG5cdFx0XHR3ZWlnaHQ6IDQsXG5cdFx0XHRvcGFjaXR5OiAwLjUsXG5cdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0ZmlsbENvbG9yOiBudWxsLCAvL3NhbWUgYXMgY29sb3IgYnkgZGVmYXVsdFxuXHRcdFx0ZmlsbE9wYWNpdHk6IDAuMixcblx0XHRcdGNsaWNrYWJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0c2hvd1JhZGl1czogdHJ1ZSxcblx0XHRtZXRyaWM6IHRydWUgLy8gV2hldGhlciB0byB1c2UgdGhlIG1ldHJpYyBtZWF1cmVtZW50IHN5c3RlbSBvciBpbXBlcmlhbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRHJhdy5DaXJjbGUuVFlQRTtcblxuXHRcdHRoaXMuX2luaXRpYWxMYWJlbFRleHQgPSBMLmRyYXdMb2NhbC5kcmF3LmhhbmRsZXJzLmNpcmNsZS50b29sdGlwLnN0YXJ0O1xuXG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwLCBvcHRpb25zKTtcblx0fSxcblxuXHRfZHJhd1NoYXBlOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0aWYgKCF0aGlzLl9zaGFwZSkge1xuXHRcdFx0dGhpcy5fc2hhcGUgPSBuZXcgTC5DaXJjbGUodGhpcy5fc3RhcnRMYXRMbmcsIHRoaXMuX3N0YXJ0TGF0TG5nLmRpc3RhbmNlVG8obGF0bG5nKSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIodGhpcy5fc2hhcGUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9zaGFwZS5zZXRSYWRpdXModGhpcy5fc3RhcnRMYXRMbmcuZGlzdGFuY2VUbyhsYXRsbmcpKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgY2lyY2xlID0gbmV3IEwuQ2lyY2xlKHRoaXMuX3N0YXJ0TGF0TG5nLCB0aGlzLl9zaGFwZS5nZXRSYWRpdXMoKSwgdGhpcy5vcHRpb25zLnNoYXBlT3B0aW9ucyk7XG5cdFx0TC5EcmF3LlNpbXBsZVNoYXBlLnByb3RvdHlwZS5fZmlyZUNyZWF0ZWRFdmVudC5jYWxsKHRoaXMsIGNpcmNsZSk7XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZyxcblx0XHRcdHNob3dSYWRpdXMgPSB0aGlzLm9wdGlvbnMuc2hvd1JhZGl1cyxcblx0XHRcdHVzZU1ldHJpYyA9IHRoaXMub3B0aW9ucy5tZXRyaWMsXG5cdFx0XHRyYWRpdXM7XG5cblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGxhdGxuZyk7XG5cdFx0aWYgKHRoaXMuX2lzRHJhd2luZykge1xuXHRcdFx0dGhpcy5fZHJhd1NoYXBlKGxhdGxuZyk7XG5cblx0XHRcdC8vIEdldCB0aGUgbmV3IHJhZGl1cyAocm91bmRlZCB0byAxIGRwKVxuXHRcdFx0cmFkaXVzID0gdGhpcy5fc2hhcGUuZ2V0UmFkaXVzKCkudG9GaXhlZCgxKTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHtcblx0XHRcdFx0dGV4dDogdGhpcy5fZW5kTGFiZWxUZXh0LFxuXHRcdFx0XHRzdWJ0ZXh0OiBzaG93UmFkaXVzID8gJ1JhZGl1czogJyArIEwuR2VvbWV0cnlVdGlsLnJlYWRhYmxlRGlzdGFuY2UocmFkaXVzLCB1c2VNZXRyaWMpIDogJydcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxufSk7XG5cblxuTC5EcmF3Lk1hcmtlciA9IEwuRHJhdy5GZWF0dXJlLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAnbWFya2VyJ1xuXHR9LFxuXG5cdG9wdGlvbnM6IHtcblx0XHRpY29uOiBuZXcgTC5JY29uLkRlZmF1bHQoKSxcblx0XHRyZXBlYXRNb2RlOiBmYWxzZSxcblx0XHR6SW5kZXhPZmZzZXQ6IDIwMDAgLy8gVGhpcyBzaG91bGQgYmUgPiB0aGFuIHRoZSBoaWdoZXN0IHotaW5kZXggYW55IG1hcmtlcnNcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkRyYXcuTWFya2VyLlRZUEU7XG5cblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG1hcCwgb3B0aW9ucyk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuYWRkSG9va3MuY2FsbCh0aGlzKTtcblxuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh7IHRleHQ6IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMubWFya2VyLnRvb2x0aXAuc3RhcnQgfSk7XG5cblx0XHRcdC8vIFNhbWUgbW91c2VNYXJrZXIgYXMgaW4gRHJhdy5Qb2x5bGluZVxuXHRcdFx0aWYgKCF0aGlzLl9tb3VzZU1hcmtlcikge1xuXHRcdFx0XHR0aGlzLl9tb3VzZU1hcmtlciA9IEwubWFya2VyKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwge1xuXHRcdFx0XHRcdGljb246IEwuZGl2SWNvbih7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LW1vdXNlLW1hcmtlcicsXG5cdFx0XHRcdFx0XHRpY29uQW5jaG9yOiBbMjAsIDIwXSxcblx0XHRcdFx0XHRcdGljb25TaXplOiBbNDAsIDQwXVxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRcdFx0ekluZGV4T2Zmc2V0OiB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZU1hcmtlclxuXHRcdFx0XHQub24oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcylcblx0XHRcdFx0LmFkZFRvKHRoaXMuX21hcCk7XG5cblx0XHRcdHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5yZW1vdmVIb29rcy5jYWxsKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0aWYgKHRoaXMuX21hcmtlcikge1xuXHRcdFx0XHR0aGlzLl9tYXJrZXIub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0XHQub2ZmKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpXG5cdFx0XHRcdFx0LnJlbW92ZUxheWVyKHRoaXMuX21hcmtlcik7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXI7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuX21vdXNlTWFya2VyLm9mZignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKTtcblx0XHRcdHRoaXMuX21hcC5yZW1vdmVMYXllcih0aGlzLl9tb3VzZU1hcmtlcik7XG5cdFx0XHRkZWxldGUgdGhpcy5fbW91c2VNYXJrZXI7XG5cblx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXRsbmcgPSBlLmxhdGxuZztcblxuXHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlUG9zaXRpb24obGF0bG5nKTtcblx0XHR0aGlzLl9tb3VzZU1hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblxuXHRcdGlmICghdGhpcy5fbWFya2VyKSB7XG5cdFx0XHR0aGlzLl9tYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRcdGljb246IHRoaXMub3B0aW9ucy5pY29uLFxuXHRcdFx0XHR6SW5kZXhPZmZzZXQ6IHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXRcblx0XHRcdH0pO1xuXHRcdFx0Ly8gQmluZCB0byBib3RoIG1hcmtlciBhbmQgbWFwIHRvIG1ha2Ugc3VyZSB3ZSBnZXQgdGhlIGNsaWNrIGV2ZW50LlxuXHRcdFx0dGhpcy5fbWFya2VyLm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpO1xuXHRcdFx0dGhpcy5fbWFwXG5cdFx0XHRcdC5vbignY2xpY2snLCB0aGlzLl9vbkNsaWNrLCB0aGlzKVxuXHRcdFx0XHQvLy5hZGRMYXllcih0aGlzLl9tYXJrZXIpOyAvL21hcmtlciBtb3VzZSBcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0XHRsYXRsbmcgPSB0aGlzLl9tb3VzZU1hcmtlci5nZXRMYXRMbmcoKTtcblx0XHRcdHRoaXMuX21hcmtlci5zZXRMYXRMbmcobGF0bG5nKTtcblx0XHR9XG5cdH0sXG5cblx0X29uQ2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9maXJlQ3JlYXRlZEV2ZW50KCk7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2FkZElzbycpO1xuXHRcdHRoaXMuZGlzYWJsZSgpO1xuXHRcdGlmICh0aGlzLm9wdGlvbnMucmVwZWF0TW9kZSkge1xuXHRcdFx0dGhpcy5lbmFibGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2ZpcmVDcmVhdGVkRXZlbnQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFya2VyID0gbmV3IEwuTWFya2VyKHRoaXMuX21hcmtlci5nZXRMYXRMbmcoKSwgeyBpY29uOiB0aGlzLm9wdGlvbnMuaWNvbiB9KTtcblx0XHRMLkRyYXcuRmVhdHVyZS5wcm90b3R5cGUuX2ZpcmVDcmVhdGVkRXZlbnQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuXHR9XG59KTtcblxuTC5EcmF3Lklzb2Nocm9uZSA9IEwuRHJhdy5NYXJrZXIuZXh0ZW5kKHtcblx0c3RhdGljczoge1xuXHRcdFRZUEU6ICdpc29jaHJvbmUnXG5cdH0sXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKG1hcCwgb3B0aW9ucyl7XG5cdFx0dGhpcy50eXBlID0gTC5EcmF3Lklzb2Nocm9uZS5UWVBFO1xuXG5cdFx0TC5EcmF3LkZlYXR1cmUucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXAsIG9wdGlvbnMpO1xuXHR9LFxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdFxuXHRcdEwuRHJhdy5GZWF0dXJlLnByb3RvdHlwZS5hZGRIb29rcy5jYWxsKHRoaXMpO1xuXHRcdFxuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh7IHRleHQ6IEwuZHJhd0xvY2FsLmRyYXcuaGFuZGxlcnMuaXNvY2hyb25lLnRvb2x0aXAuc3RhcnQgfSk7XG5cblx0XHRcdC8vIFNhbWUgbW91c2VNYXJrZXIgYXMgaW4gRHJhdy5Qb2x5bGluZVxuXHRcdFx0aWYgKCF0aGlzLl9tb3VzZU1hcmtlcikge1xuXHRcdFx0XHR0aGlzLl9tb3VzZU1hcmtlciA9IEwubWFya2VyKHRoaXMuX21hcC5nZXRDZW50ZXIoKSwge1xuXHRcdFx0XHRcdGljb246IEwuZGl2SWNvbih7XG5cdFx0XHRcdFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LW1vdXNlLW1hcmtlcicsXG5cdFx0XHRcdFx0XHRpY29uQW5jaG9yOiBbMjAsIDIwXSxcblx0XHRcdFx0XHRcdGljb25TaXplOiBbNDAsIDQwXVxuXHRcdFx0XHRcdH0pLFxuXHRcdFx0XHRcdG9wYWNpdHk6IDAsXG5cdFx0XHRcdFx0ekluZGV4T2Zmc2V0OiB0aGlzLm9wdGlvbnMuekluZGV4T2Zmc2V0XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9tb3VzZU1hcmtlclxuXHRcdFx0XHQub24oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcylcblx0XHRcdFx0LmFkZFRvKHRoaXMuX21hcCk7XG5cblx0XHRcdHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxhdGxuZyA9IGUubGF0bG5nO1xuXG5cdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihsYXRsbmcpO1xuXHRcdHRoaXMuX21vdXNlTWFya2VyLnNldExhdExuZyhsYXRsbmcpO1xuXG5cdFx0aWYgKCF0aGlzLl9tYXJrZXIpIHtcblx0XHRcdHRoaXMuX21hcmtlciA9IG5ldyBMLk1hcmtlcihsYXRsbmcsIHtcblx0XHRcdFx0aWNvbjogdGhpcy5vcHRpb25zLmljb24sXG5cdFx0XHRcdHpJbmRleE9mZnNldDogdGhpcy5vcHRpb25zLnpJbmRleE9mZnNldFxuXHRcdFx0fSk7XG5cdFx0XHQvLyBCaW5kIHRvIGJvdGggbWFya2VyIGFuZCBtYXAgdG8gbWFrZSBzdXJlIHdlIGdldCB0aGUgY2xpY2sgZXZlbnQuXG5cdFx0XHR0aGlzLl9tYXJrZXIub24oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXBcblx0XHRcdFx0Lm9uKCdjbGljaycsIHRoaXMuX29uQ2xpY2ssIHRoaXMpXG5cdFx0XHRcdC5hZGRMYXllcih0aGlzLl9tYXJrZXIpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHRcdGxhdGxuZyA9IHRoaXMuX21vdXNlTWFya2VyLmdldExhdExuZygpO1xuXHRcdFx0dGhpcy5fbWFya2VyLnNldExhdExuZyhsYXRsbmcpO1xuXHRcdH1cblx0fSxcblxuXHRmb3JtT3B0aW9uczogZnVuY3Rpb24odG9vbGJhcil7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2RyYXc6c3RhcnRJc28nLHt0b29sYmFyOiB0b29sYmFyfSk7XG5cdH1cbn0pLFxuXG5MLkVkaXQgPSBMLkVkaXQgfHwge307XG5cbi8qXG4gKiBMLkVkaXQuUG9seSBpcyBhbiBlZGl0aW5nIGhhbmRsZXIgZm9yIHBvbHlsaW5lcyBhbmQgcG9seWdvbnMuXG4gKi9cblxuTC5FZGl0LlBvbHkgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdGljb246IG5ldyBMLkRpdkljb24oe1xuXHRcdFx0aWNvblNpemU6IG5ldyBMLlBvaW50KDgsIDgpLFxuXHRcdFx0Y2xhc3NOYW1lOiAnbGVhZmxldC1kaXYtaWNvbiBsZWFmbGV0LWVkaXRpbmctaWNvbidcblx0XHR9KVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChwb2x5LCBvcHRpb25zKSB7XG5cdFx0dGhpcy5fcG9seSA9IHBvbHk7XG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3BvbHkuX21hcCkge1xuXHRcdFx0aWYgKCF0aGlzLl9tYXJrZXJHcm91cCkge1xuXHRcdFx0XHR0aGlzLl9pbml0TWFya2VycygpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fcG9seS5fbWFwLmFkZExheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fcG9seS5fbWFwKSB7XG5cdFx0XHR0aGlzLl9wb2x5Ll9tYXAucmVtb3ZlTGF5ZXIodGhpcy5fbWFya2VyR3JvdXApO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX21hcmtlckdyb3VwO1xuXHRcdFx0ZGVsZXRlIHRoaXMuX21hcmtlcnM7XG5cdFx0fVxuXHR9LFxuXG5cdHVwZGF0ZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpO1xuXHRcdHRoaXMuX2luaXRNYXJrZXJzKCk7XG5cdH0sXG5cblx0X2luaXRNYXJrZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXJrZXJHcm91cCkge1xuXHRcdFx0dGhpcy5fbWFya2VyR3JvdXAgPSBuZXcgTC5MYXllckdyb3VwKCk7XG5cdFx0fVxuXHRcdHRoaXMuX21hcmtlcnMgPSBbXTtcblxuXHRcdHZhciBsYXRsbmdzID0gdGhpcy5fcG9seS5fbGF0bG5ncyxcblx0XHRcdGksIGosIGxlbiwgbWFya2VyO1xuXG5cdFx0Ly8gVE9ETyByZWZhY3RvciBob2xlcyBpbXBsZW1lbnRhdGlvbiBpbiBQb2x5Z29uIHRvIHN1cHBvcnQgaXQgaGVyZVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG5cdFx0XHRtYXJrZXIgPSB0aGlzLl9jcmVhdGVNYXJrZXIobGF0bG5nc1tpXSwgaSk7XG5cdFx0XHRtYXJrZXIub24oJ2NsaWNrJywgdGhpcy5fb25NYXJrZXJDbGljaywgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXJrZXJzLnB1c2gobWFya2VyKTtcblx0XHR9XG5cblx0XHR2YXIgbWFya2VyTGVmdCwgbWFya2VyUmlnaHQ7XG5cblx0XHRmb3IgKGkgPSAwLCBqID0gbGVuIC0gMTsgaSA8IGxlbjsgaiA9IGkrKykge1xuXHRcdFx0aWYgKGkgPT09IDAgJiYgIShMLlBvbHlnb24gJiYgKHRoaXMuX3BvbHkgaW5zdGFuY2VvZiBMLlBvbHlnb24pKSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bWFya2VyTGVmdCA9IHRoaXMuX21hcmtlcnNbal07XG5cdFx0XHRtYXJrZXJSaWdodCA9IHRoaXMuX21hcmtlcnNbaV07XG5cblx0XHRcdHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihtYXJrZXJMZWZ0LCBtYXJrZXJSaWdodCk7XG5cdFx0XHR0aGlzLl91cGRhdGVQcmV2TmV4dChtYXJrZXJMZWZ0LCBtYXJrZXJSaWdodCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jcmVhdGVNYXJrZXI6IGZ1bmN0aW9uIChsYXRsbmcsIGluZGV4KSB7XG5cdFx0dmFyIG1hcmtlciA9IG5ldyBMLk1hcmtlcihsYXRsbmcsIHtcblx0XHRcdGRyYWdnYWJsZTogdHJ1ZSxcblx0XHRcdGljb246IHRoaXMub3B0aW9ucy5pY29uXG5cdFx0fSk7XG5cblx0XHRtYXJrZXIuX29yaWdMYXRMbmcgPSBsYXRsbmc7XG5cdFx0bWFya2VyLl9pbmRleCA9IGluZGV4O1xuXG5cdFx0bWFya2VyLm9uKCdkcmFnJywgdGhpcy5fb25NYXJrZXJEcmFnLCB0aGlzKTtcblx0XHRtYXJrZXIub24oJ2RyYWdlbmQnLCB0aGlzLl9maXJlRWRpdCwgdGhpcyk7XG5cblx0XHR0aGlzLl9tYXJrZXJHcm91cC5hZGRMYXllcihtYXJrZXIpO1xuXG5cdFx0cmV0dXJuIG1hcmtlcjtcblx0fSxcblxuXHRfcmVtb3ZlTWFya2VyOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dmFyIGkgPSBtYXJrZXIuX2luZGV4O1xuXG5cdFx0dGhpcy5fbWFya2VyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyKTtcblx0XHR0aGlzLl9tYXJrZXJzLnNwbGljZShpLCAxKTtcblx0XHR0aGlzLl9wb2x5LnNwbGljZUxhdExuZ3MoaSwgMSk7XG5cdFx0dGhpcy5fdXBkYXRlSW5kZXhlcyhpLCAtMSk7XG5cblx0XHRtYXJrZXJcblx0XHRcdC5vZmYoJ2RyYWcnLCB0aGlzLl9vbk1hcmtlckRyYWcsIHRoaXMpXG5cdFx0XHQub2ZmKCdkcmFnZW5kJywgdGhpcy5fZmlyZUVkaXQsIHRoaXMpXG5cdFx0XHQub2ZmKCdjbGljaycsIHRoaXMuX29uTWFya2VyQ2xpY2ssIHRoaXMpO1xuXHR9LFxuXG5cdF9maXJlRWRpdDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX3BvbHkuZWRpdGVkID0gdHJ1ZTtcblx0XHR0aGlzLl9wb2x5LmZpcmUoJ2VkaXQnKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldDtcblxuXHRcdEwuZXh0ZW5kKG1hcmtlci5fb3JpZ0xhdExuZywgbWFya2VyLl9sYXRsbmcpO1xuXG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlTGVmdCkge1xuXHRcdFx0bWFya2VyLl9taWRkbGVMZWZ0LnNldExhdExuZyh0aGlzLl9nZXRNaWRkbGVMYXRMbmcobWFya2VyLl9wcmV2LCBtYXJrZXIpKTtcblx0XHR9XG5cdFx0aWYgKG1hcmtlci5fbWlkZGxlUmlnaHQpIHtcblx0XHRcdG1hcmtlci5fbWlkZGxlUmlnaHQuc2V0TGF0TG5nKHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIsIG1hcmtlci5fbmV4dCkpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3BvbHkucmVkcmF3KCk7XG5cdH0sXG5cblx0X29uTWFya2VyQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1pblBvaW50cyA9IEwuUG9seWdvbiAmJiAodGhpcy5fcG9seSBpbnN0YW5jZW9mIEwuUG9seWdvbikgPyA0IDogMyxcblx0XHRcdG1hcmtlciA9IGUudGFyZ2V0O1xuXG5cdFx0Ly8gSWYgcmVtb3ZpbmcgdGhpcyBwb2ludCB3b3VsZCBjcmVhdGUgYW4gaW52YWxpZCBwb2x5bGluZS9wb2x5Z29uIGRvbid0IHJlbW92ZVxuXHRcdGlmICh0aGlzLl9wb2x5Ll9sYXRsbmdzLmxlbmd0aCA8IG1pblBvaW50cykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIHJlbW92ZSB0aGUgbWFya2VyXG5cdFx0dGhpcy5fcmVtb3ZlTWFya2VyKG1hcmtlcik7XG5cblx0XHQvLyB1cGRhdGUgcHJldi9uZXh0IGxpbmtzIG9mIGFkamFjZW50IG1hcmtlcnNcblx0XHR0aGlzLl91cGRhdGVQcmV2TmV4dChtYXJrZXIuX3ByZXYsIG1hcmtlci5fbmV4dCk7XG5cblx0XHQvLyByZW1vdmUgZ2hvc3QgbWFya2VycyBuZWFyIHRoZSByZW1vdmVkIG1hcmtlclxuXHRcdGlmIChtYXJrZXIuX21pZGRsZUxlZnQpIHtcblx0XHRcdHRoaXMuX21hcmtlckdyb3VwLnJlbW92ZUxheWVyKG1hcmtlci5fbWlkZGxlTGVmdCk7XG5cdFx0fVxuXHRcdGlmIChtYXJrZXIuX21pZGRsZVJpZ2h0KSB7XG5cdFx0XHR0aGlzLl9tYXJrZXJHcm91cC5yZW1vdmVMYXllcihtYXJrZXIuX21pZGRsZVJpZ2h0KTtcblx0XHR9XG5cblx0XHQvLyBjcmVhdGUgYSBnaG9zdCBtYXJrZXIgaW4gcGxhY2Ugb2YgdGhlIHJlbW92ZWQgb25lXG5cdFx0aWYgKG1hcmtlci5fcHJldiAmJiBtYXJrZXIuX25leHQpIHtcblx0XHRcdHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihtYXJrZXIuX3ByZXYsIG1hcmtlci5fbmV4dCk7XG5cblx0XHR9IGVsc2UgaWYgKCFtYXJrZXIuX3ByZXYpIHtcblx0XHRcdG1hcmtlci5fbmV4dC5fbWlkZGxlTGVmdCA9IG51bGw7XG5cblx0XHR9IGVsc2UgaWYgKCFtYXJrZXIuX25leHQpIHtcblx0XHRcdG1hcmtlci5fcHJldi5fbWlkZGxlUmlnaHQgPSBudWxsO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZpcmVFZGl0KCk7XG5cdH0sXG5cblx0X3VwZGF0ZUluZGV4ZXM6IGZ1bmN0aW9uIChpbmRleCwgZGVsdGEpIHtcblx0XHR0aGlzLl9tYXJrZXJHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdFx0aWYgKG1hcmtlci5faW5kZXggPiBpbmRleCkge1xuXHRcdFx0XHRtYXJrZXIuX2luZGV4ICs9IGRlbHRhO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHR9LFxuXG5cdF9jcmVhdGVNaWRkbGVNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIxLCBtYXJrZXIyKSB7XG5cdFx0dmFyIGxhdGxuZyA9IHRoaXMuX2dldE1pZGRsZUxhdExuZyhtYXJrZXIxLCBtYXJrZXIyKSxcblx0XHQgICAgbWFya2VyID0gdGhpcy5fY3JlYXRlTWFya2VyKGxhdGxuZyksXG5cdFx0ICAgIG9uQ2xpY2ssXG5cdFx0ICAgIG9uRHJhZ1N0YXJ0LFxuXHRcdCAgICBvbkRyYWdFbmQ7XG5cblx0XHRtYXJrZXIuc2V0T3BhY2l0eSgwLjYpO1xuXG5cdFx0bWFya2VyMS5fbWlkZGxlUmlnaHQgPSBtYXJrZXIyLl9taWRkbGVMZWZ0ID0gbWFya2VyO1xuXG5cdFx0b25EcmFnU3RhcnQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHR2YXIgaSA9IG1hcmtlcjIuX2luZGV4O1xuXG5cdFx0XHRtYXJrZXIuX2luZGV4ID0gaTtcblxuXHRcdFx0bWFya2VyXG5cdFx0XHQgICAgLm9mZignY2xpY2snLCBvbkNsaWNrLCB0aGlzKVxuXHRcdFx0ICAgIC5vbignY2xpY2snLCB0aGlzLl9vbk1hcmtlckNsaWNrLCB0aGlzKTtcblxuXHRcdFx0bGF0bG5nLmxhdCA9IG1hcmtlci5nZXRMYXRMbmcoKS5sYXQ7XG5cdFx0XHRsYXRsbmcubG5nID0gbWFya2VyLmdldExhdExuZygpLmxuZztcblx0XHRcdHRoaXMuX3BvbHkuc3BsaWNlTGF0TG5ncyhpLCAwLCBsYXRsbmcpO1xuXHRcdFx0dGhpcy5fbWFya2Vycy5zcGxpY2UoaSwgMCwgbWFya2VyKTtcblxuXHRcdFx0bWFya2VyLnNldE9wYWNpdHkoMSk7XG5cblx0XHRcdHRoaXMuX3VwZGF0ZUluZGV4ZXMoaSwgMSk7XG5cdFx0XHRtYXJrZXIyLl9pbmRleCsrO1xuXHRcdFx0dGhpcy5fdXBkYXRlUHJldk5leHQobWFya2VyMSwgbWFya2VyKTtcblx0XHRcdHRoaXMuX3VwZGF0ZVByZXZOZXh0KG1hcmtlciwgbWFya2VyMik7XG5cblx0XHRcdHRoaXMuX3BvbHkuZmlyZSgnZWRpdHN0YXJ0Jyk7XG5cdFx0fTtcblxuXHRcdG9uRHJhZ0VuZCA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdG1hcmtlci5vZmYoJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0LCB0aGlzKTtcblx0XHRcdG1hcmtlci5vZmYoJ2RyYWdlbmQnLCBvbkRyYWdFbmQsIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl9jcmVhdGVNaWRkbGVNYXJrZXIobWFya2VyMSwgbWFya2VyKTtcblx0XHRcdHRoaXMuX2NyZWF0ZU1pZGRsZU1hcmtlcihtYXJrZXIsIG1hcmtlcjIpO1xuXHRcdH07XG5cblx0XHRvbkNsaWNrID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0b25EcmFnU3RhcnQuY2FsbCh0aGlzKTtcblx0XHRcdG9uRHJhZ0VuZC5jYWxsKHRoaXMpO1xuXHRcdFx0dGhpcy5fZmlyZUVkaXQoKTtcblx0XHR9O1xuXG5cdFx0bWFya2VyXG5cdFx0ICAgIC5vbignY2xpY2snLCBvbkNsaWNrLCB0aGlzKVxuXHRcdCAgICAub24oJ2RyYWdzdGFydCcsIG9uRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdCAgICAub24oJ2RyYWdlbmQnLCBvbkRyYWdFbmQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFya2VyR3JvdXAuYWRkTGF5ZXIobWFya2VyKTtcblx0fSxcblxuXHRfdXBkYXRlUHJldk5leHQ6IGZ1bmN0aW9uIChtYXJrZXIxLCBtYXJrZXIyKSB7XG5cdFx0aWYgKG1hcmtlcjEpIHtcblx0XHRcdG1hcmtlcjEuX25leHQgPSBtYXJrZXIyO1xuXHRcdH1cblx0XHRpZiAobWFya2VyMikge1xuXHRcdFx0bWFya2VyMi5fcHJldiA9IG1hcmtlcjE7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRNaWRkbGVMYXRMbmc6IGZ1bmN0aW9uIChtYXJrZXIxLCBtYXJrZXIyKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX3BvbHkuX21hcCxcblx0XHQgICAgcDEgPSBtYXAucHJvamVjdChtYXJrZXIxLmdldExhdExuZygpKSxcblx0XHQgICAgcDIgPSBtYXAucHJvamVjdChtYXJrZXIyLmdldExhdExuZygpKTtcblxuXHRcdHJldHVybiBtYXAudW5wcm9qZWN0KHAxLl9hZGQocDIpLl9kaXZpZGVCeSgyKSk7XG5cdH1cbn0pO1xuXG5MLlBvbHlsaW5lLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblxuXHQvLyBDaGVjayB0byBzZWUgaWYgaGFuZGxlciBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLiBUaGlzIGlzIHRvIHN1cHBvcnQgdmVyc2lvbnMgb2YgTGVhZmxldCB0aGF0IHN0aWxsIGhhdmUgTC5IYW5kbGVyLlBvbHlFZGl0XG5cdGlmICh0aGlzLmVkaXRpbmcpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpZiAoTC5FZGl0LlBvbHkpIHtcblx0XHR0aGlzLmVkaXRpbmcgPSBuZXcgTC5FZGl0LlBvbHkodGhpcyk7XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmVkaXRhYmxlKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcuZW5hYmxlKCk7XG5cdFx0fVxuXHR9XG5cblx0dGhpcy5vbignYWRkJywgZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmVkaXRpbmcgJiYgdGhpcy5lZGl0aW5nLmVuYWJsZWQoKSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmFkZEhvb2tzKCk7XG5cdFx0fVxuXHR9KTtcblxuXHR0aGlzLm9uKCdyZW1vdmUnLCBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuZWRpdGluZyAmJiB0aGlzLmVkaXRpbmcuZW5hYmxlZCgpKSB7XG5cdFx0XHR0aGlzLmVkaXRpbmcucmVtb3ZlSG9va3MoKTtcblx0XHR9XG5cdH0pO1xufSk7XG5cblxuTC5FZGl0ID0gTC5FZGl0IHx8IHt9O1xuXG5MLkVkaXQuU2ltcGxlU2hhcGUgPSBMLkhhbmRsZXIuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdG1vdmVJY29uOiBuZXcgTC5EaXZJY29uKHtcblx0XHRcdGljb25TaXplOiBuZXcgTC5Qb2ludCg4LCA4KSxcblx0XHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24gbGVhZmxldC1lZGl0aW5nLWljb24gbGVhZmxldC1lZGl0LW1vdmUnXG5cdFx0fSksXG5cdFx0cmVzaXplSWNvbjogbmV3IEwuRGl2SWNvbih7XG5cdFx0XHRpY29uU2l6ZTogbmV3IEwuUG9pbnQoOCwgOCksXG5cdFx0XHRjbGFzc05hbWU6ICdsZWFmbGV0LWRpdi1pY29uIGxlYWZsZXQtZWRpdGluZy1pY29uIGxlYWZsZXQtZWRpdC1yZXNpemUnXG5cdFx0fSlcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoc2hhcGUsIG9wdGlvbnMpIHtcblx0XHR0aGlzLl9zaGFwZSA9IHNoYXBlO1xuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3NoYXBlLl9tYXApIHtcblx0XHRcdHRoaXMuX21hcCA9IHRoaXMuX3NoYXBlLl9tYXA7XG5cblx0XHRcdGlmICghdGhpcy5fbWFya2VyR3JvdXApIHtcblx0XHRcdFx0dGhpcy5faW5pdE1hcmtlcnMoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21hcC5hZGRMYXllcih0aGlzLl9tYXJrZXJHcm91cCk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3NoYXBlLl9tYXApIHtcblx0XHRcdHRoaXMuX3VuYmluZE1hcmtlcih0aGlzLl9tb3ZlTWFya2VyKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR0aGlzLl91bmJpbmRNYXJrZXIodGhpcy5fcmVzaXplTWFya2Vyc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9yZXNpemVNYXJrZXJzID0gbnVsbDtcblxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX21hcmtlckdyb3VwKTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9tYXJrZXJHcm91cDtcblx0XHR9XG5cblx0XHR0aGlzLl9tYXAgPSBudWxsO1xuXHR9LFxuXG5cdHVwZGF0ZU1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXJrZXJHcm91cC5jbGVhckxheWVycygpO1xuXHRcdHRoaXMuX2luaXRNYXJrZXJzKCk7XG5cdH0sXG5cblx0X2luaXRNYXJrZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9tYXJrZXJHcm91cCkge1xuXHRcdFx0dGhpcy5fbWFya2VyR3JvdXAgPSBuZXcgTC5MYXllckdyb3VwKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ3JlYXRlIGNlbnRlciBtYXJrZXJcblx0XHR0aGlzLl9jcmVhdGVNb3ZlTWFya2VyKCk7XG5cblx0XHQvLyBDcmVhdGUgZWRnZSBtYXJrZXJcblx0XHR0aGlzLl9jcmVhdGVSZXNpemVNYXJrZXIoKTtcblx0fSxcblxuXHRfY3JlYXRlTW92ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIENoaWxkcmVuIG92ZXJyaWRlXG5cdH0sXG5cblx0X2NyZWF0ZVJlc2l6ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vIENoaWxkcmVuIG92ZXJyaWRlXG5cdH0sXG5cblx0X2NyZWF0ZU1hcmtlcjogZnVuY3Rpb24gKGxhdGxuZywgaWNvbikge1xuXHRcdHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobGF0bG5nLCB7XG5cdFx0XHRkcmFnZ2FibGU6IHRydWUsXG5cdFx0XHRpY29uOiBpY29uLFxuXHRcdFx0ekluZGV4T2Zmc2V0OiAxMFxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fYmluZE1hcmtlcihtYXJrZXIpO1xuXG5cdFx0dGhpcy5fbWFya2VyR3JvdXAuYWRkTGF5ZXIobWFya2VyKTtcblxuXHRcdHJldHVybiBtYXJrZXI7XG5cdH0sXG5cblx0X2JpbmRNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHRtYXJrZXJcblx0XHRcdC5vbignZHJhZ3N0YXJ0JywgdGhpcy5fb25NYXJrZXJEcmFnU3RhcnQsIHRoaXMpXG5cdFx0XHQub24oJ2RyYWcnLCB0aGlzLl9vbk1hcmtlckRyYWcsIHRoaXMpXG5cdFx0XHQub24oJ2RyYWdlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpO1xuXHR9LFxuXG5cdF91bmJpbmRNYXJrZXI6IGZ1bmN0aW9uIChtYXJrZXIpIHtcblx0XHRtYXJrZXJcblx0XHRcdC5vZmYoJ2RyYWdzdGFydCcsIHRoaXMuX29uTWFya2VyRHJhZ1N0YXJ0LCB0aGlzKVxuXHRcdFx0Lm9mZignZHJhZycsIHRoaXMuX29uTWFya2VyRHJhZywgdGhpcylcblx0XHRcdC5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9vbk1hcmtlckRyYWdFbmQsIHRoaXMpO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdTdGFydDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gZS50YXJnZXQ7XG5cdFx0bWFya2VyLnNldE9wYWNpdHkoMCk7XG5cblx0XHR0aGlzLl9zaGFwZS5maXJlKCdlZGl0c3RhcnQnKTtcblx0fSxcblxuXHRfZmlyZUVkaXQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9zaGFwZS5lZGl0ZWQgPSB0cnVlO1xuXHRcdHRoaXMuX3NoYXBlLmZpcmUoJ2VkaXQnKTtcblx0fSxcblxuXHRfb25NYXJrZXJEcmFnOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBtYXJrZXIgPSBlLnRhcmdldCxcblx0XHRcdGxhdGxuZyA9IG1hcmtlci5nZXRMYXRMbmcoKTtcblxuXHRcdGlmIChtYXJrZXIgPT09IHRoaXMuX21vdmVNYXJrZXIpIHtcblx0XHRcdHRoaXMuX21vdmUobGF0bG5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcmVzaXplKGxhdGxuZyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fc2hhcGUucmVkcmF3KCk7XG5cdH0sXG5cblx0X29uTWFya2VyRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFya2VyID0gZS50YXJnZXQ7XG5cdFx0bWFya2VyLnNldE9wYWNpdHkoMSk7XG5cblx0XHR0aGlzLl9maXJlRWRpdCgpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fSxcblxuXHRfcmVzaXplOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gQ2hpbGRyZW4gb3ZlcnJpZGVcblx0fVxufSk7XG5cblxuTC5FZGl0ID0gTC5FZGl0IHx8IHt9O1xuXG5MLkVkaXQuUmVjdGFuZ2xlID0gTC5FZGl0LlNpbXBsZVNoYXBlLmV4dGVuZCh7XG5cdF9jcmVhdGVNb3ZlTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3NoYXBlLmdldEJvdW5kcygpLFxuXHRcdFx0Y2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuXG5cdFx0dGhpcy5fbW92ZU1hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihjZW50ZXIsIHRoaXMub3B0aW9ucy5tb3ZlSWNvbik7XG5cdH0sXG5cblx0X2NyZWF0ZVJlc2l6ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpO1xuXG5cdFx0dGhpcy5fcmVzaXplTWFya2VycyA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb3JuZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fcmVzaXplTWFya2Vycy5wdXNoKHRoaXMuX2NyZWF0ZU1hcmtlcihjb3JuZXJzW2ldLCB0aGlzLm9wdGlvbnMucmVzaXplSWNvbikpO1xuXHRcdFx0Ly8gTW9ua2V5IGluIHRoZSBjb3JuZXIgaW5kZXggYXMgd2Ugd2lsbCBuZWVkIHRvIGtub3cgdGhpcyBmb3IgZHJhZ2dpbmdcblx0XHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnNbaV0uX2Nvcm5lckluZGV4ID0gaTtcblx0XHR9XG5cdH0sXG5cblx0X29uTWFya2VyRHJhZ1N0YXJ0OiBmdW5jdGlvbiAoZSkge1xuXHRcdEwuRWRpdC5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX29uTWFya2VyRHJhZ1N0YXJ0LmNhbGwodGhpcywgZSk7XG5cblx0XHQvLyBTYXZlIGEgcmVmZXJlbmNlIHRvIHRoZSBvcHBvc2l0ZSBwb2ludFxuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpLFxuXHRcdFx0bWFya2VyID0gZS50YXJnZXQsXG5cdFx0XHRjdXJyZW50Q29ybmVySW5kZXggPSBtYXJrZXIuX2Nvcm5lckluZGV4O1xuXG5cdFx0dGhpcy5fb3Bwb3NpdGVDb3JuZXIgPSBjb3JuZXJzWyhjdXJyZW50Q29ybmVySW5kZXggKyAyKSAlIDRdO1xuXG5cdFx0dGhpcy5fdG9nZ2xlQ29ybmVyTWFya2VycygwLCBjdXJyZW50Q29ybmVySW5kZXgpO1xuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcmtlciA9IGUudGFyZ2V0LFxuXHRcdFx0Ym91bmRzLCBjZW50ZXI7XG5cblx0XHQvLyBSZXNldCBtb3ZlIG1hcmtlciBwb3NpdGlvbiB0byB0aGUgY2VudGVyXG5cdFx0aWYgKG1hcmtlciA9PT0gdGhpcy5fbW92ZU1hcmtlcikge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5fc2hhcGUuZ2V0Qm91bmRzKCk7XG5cdFx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cblx0XHRcdG1hcmtlci5zZXRMYXRMbmcoY2VudGVyKTtcblx0XHR9XG5cblx0XHR0aGlzLl90b2dnbGVDb3JuZXJNYXJrZXJzKDEpO1xuXG5cdFx0dGhpcy5fcmVwb3NpdGlvbkNvcm5lck1hcmtlcnMoKTtcblxuXHRcdEwuRWRpdC5TaW1wbGVTaGFwZS5wcm90b3R5cGUuX29uTWFya2VyRHJhZ0VuZC5jYWxsKHRoaXMsIGUpO1xuXHR9LFxuXG5cdF9tb3ZlOiBmdW5jdGlvbiAobmV3Q2VudGVyKSB7XG5cdFx0dmFyIGxhdGxuZ3MgPSB0aGlzLl9zaGFwZS5nZXRMYXRMbmdzKCksXG5cdFx0XHRib3VuZHMgPSB0aGlzLl9zaGFwZS5nZXRCb3VuZHMoKSxcblx0XHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKSxcblx0XHRcdG9mZnNldCwgbmV3TGF0TG5ncyA9IFtdO1xuXG5cdFx0Ly8gT2Zmc2V0IHRoZSBsYXRsbmdzIHRvIHRoZSBuZXcgY2VudGVyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0b2Zmc2V0ID0gW2xhdGxuZ3NbaV0ubGF0IC0gY2VudGVyLmxhdCwgbGF0bG5nc1tpXS5sbmcgLSBjZW50ZXIubG5nXTtcblx0XHRcdG5ld0xhdExuZ3MucHVzaChbbmV3Q2VudGVyLmxhdCArIG9mZnNldFswXSwgbmV3Q2VudGVyLmxuZyArIG9mZnNldFsxXV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuX3NoYXBlLnNldExhdExuZ3MobmV3TGF0TG5ncyk7XG5cblx0XHQvLyBSZXBvc2l0aW9uIHRoZSByZXNpemUgbWFya2Vyc1xuXHRcdHRoaXMuX3JlcG9zaXRpb25Db3JuZXJNYXJrZXJzKCk7XG5cdH0sXG5cblx0X3Jlc2l6ZTogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdHZhciBib3VuZHM7XG5cblx0XHQvLyBVcGRhdGUgdGhlIHNoYXBlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHBvc2l0aW9uIG9mIHRoaXMgY29ybmVyIGFuZCB0aGUgb3Bwb3NpdGUgcG9pbnRcblx0XHR0aGlzLl9zaGFwZS5zZXRCb3VuZHMoTC5sYXRMbmdCb3VuZHMobGF0bG5nLCB0aGlzLl9vcHBvc2l0ZUNvcm5lcikpO1xuXG5cdFx0Ly8gUmVwb3NpdGlvbiB0aGUgbW92ZSBtYXJrZXJcblx0XHRib3VuZHMgPSB0aGlzLl9zaGFwZS5nZXRCb3VuZHMoKTtcblx0XHR0aGlzLl9tb3ZlTWFya2VyLnNldExhdExuZyhib3VuZHMuZ2V0Q2VudGVyKCkpO1xuXHR9LFxuXG5cdF9nZXRDb3JuZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX3NoYXBlLmdldEJvdW5kcygpLFxuXHRcdFx0bncgPSBib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXG5cdFx0XHRuZSA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcblx0XHRcdHNlID0gYm91bmRzLmdldFNvdXRoRWFzdCgpLFxuXHRcdFx0c3cgPSBib3VuZHMuZ2V0U291dGhXZXN0KCk7XG5cblx0XHRyZXR1cm4gW253LCBuZSwgc2UsIHN3XTtcblx0fSxcblxuXHRfdG9nZ2xlQ29ybmVyTWFya2VyczogZnVuY3Rpb24gKG9wYWNpdHkpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3Jlc2l6ZU1hcmtlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR0aGlzLl9yZXNpemVNYXJrZXJzW2ldLnNldE9wYWNpdHkob3BhY2l0eSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZXBvc2l0aW9uQ29ybmVyTWFya2VyczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjb3JuZXJzID0gdGhpcy5fZ2V0Q29ybmVycygpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9yZXNpemVNYXJrZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fcmVzaXplTWFya2Vyc1tpXS5zZXRMYXRMbmcoY29ybmVyc1tpXSk7XG5cdFx0fVxuXHR9XG59KTtcblxuTC5SZWN0YW5nbGUuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRpZiAoTC5FZGl0LlJlY3RhbmdsZSkge1xuXHRcdHRoaXMuZWRpdGluZyA9IG5ldyBMLkVkaXQuUmVjdGFuZ2xlKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmVuYWJsZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cblxuTC5FZGl0ID0gTC5FZGl0IHx8IHt9O1xuXG5MLkVkaXQuQ2lyY2xlID0gTC5FZGl0LlNpbXBsZVNoYXBlLmV4dGVuZCh7XG5cdF9jcmVhdGVNb3ZlTWFya2VyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNlbnRlciA9IHRoaXMuX3NoYXBlLmdldExhdExuZygpO1xuXG5cdFx0dGhpcy5fbW92ZU1hcmtlciA9IHRoaXMuX2NyZWF0ZU1hcmtlcihjZW50ZXIsIHRoaXMub3B0aW9ucy5tb3ZlSWNvbik7XG5cdH0sXG5cblx0X2NyZWF0ZVJlc2l6ZU1hcmtlcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjZW50ZXIgPSB0aGlzLl9zaGFwZS5nZXRMYXRMbmcoKSxcblx0XHRcdHJlc2l6ZW1hcmtlclBvaW50ID0gdGhpcy5fZ2V0UmVzaXplTWFya2VyUG9pbnQoY2VudGVyKTtcblxuXHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnMgPSBbXTtcblx0XHR0aGlzLl9yZXNpemVNYXJrZXJzLnB1c2godGhpcy5fY3JlYXRlTWFya2VyKHJlc2l6ZW1hcmtlclBvaW50LCB0aGlzLm9wdGlvbnMucmVzaXplSWNvbikpO1xuXHR9LFxuXG5cdF9nZXRSZXNpemVNYXJrZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykge1xuXHRcdC8vIEZyb20gTC5zaGFwZS5nZXRCb3VuZHMoKVxuXHRcdHZhciBkZWx0YSA9IHRoaXMuX3NoYXBlLl9yYWRpdXMgKiBNYXRoLmNvcyhNYXRoLlBJIC8gNCksXG5cdFx0XHRwb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxhdGxuZyk7XG5cdFx0cmV0dXJuIHRoaXMuX21hcC51bnByb2plY3QoW3BvaW50LnggKyBkZWx0YSwgcG9pbnQueSAtIGRlbHRhXSk7XG5cdH0sXG5cblx0X21vdmU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgcmVzaXplbWFya2VyUG9pbnQgPSB0aGlzLl9nZXRSZXNpemVNYXJrZXJQb2ludChsYXRsbmcpO1xuXG5cdFx0Ly8gTW92ZSB0aGUgcmVzaXplIG1hcmtlclxuXHRcdHRoaXMuX3Jlc2l6ZU1hcmtlcnNbMF0uc2V0TGF0TG5nKHJlc2l6ZW1hcmtlclBvaW50KTtcblxuXHRcdC8vIE1vdmUgdGhlIGNpcmNsZVxuXHRcdHRoaXMuX3NoYXBlLnNldExhdExuZyhsYXRsbmcpO1xuXHR9LFxuXG5cdF9yZXNpemU6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHR2YXIgbW92ZUxhdExuZyA9IHRoaXMuX21vdmVNYXJrZXIuZ2V0TGF0TG5nKCksXG5cdFx0XHRyYWRpdXMgPSBtb3ZlTGF0TG5nLmRpc3RhbmNlVG8obGF0bG5nKTtcblxuXHRcdHRoaXMuX3NoYXBlLnNldFJhZGl1cyhyYWRpdXMpO1xuXHR9XG59KTtcblxuTC5DaXJjbGUuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xuXHRpZiAoTC5FZGl0LkNpcmNsZSkge1xuXHRcdHRoaXMuZWRpdGluZyA9IG5ldyBMLkVkaXQuQ2lyY2xlKHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0YWJsZSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLmVuYWJsZSgpO1xuXHRcdH1cblx0fVxuXG5cdHRoaXMub24oJ2FkZCcsIGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5lZGl0aW5nICYmIHRoaXMuZWRpdGluZy5lbmFibGVkKCkpIHtcblx0XHRcdHRoaXMuZWRpdGluZy5hZGRIb29rcygpO1xuXHRcdH1cblx0fSk7XG5cblx0dGhpcy5vbigncmVtb3ZlJywgZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLmVkaXRpbmcgJiYgdGhpcy5lZGl0aW5nLmVuYWJsZWQoKSkge1xuXHRcdFx0dGhpcy5lZGl0aW5nLnJlbW92ZUhvb2tzKCk7XG5cdFx0fVxuXHR9KTtcbn0pO1xuXG4vKlxuICogTC5MYXRMbmdVdGlsIGNvbnRhaW5zIGRpZmZlcmVudCB1dGlsaXR5IGZ1bmN0aW9ucyBmb3IgTGF0TG5ncy5cbiAqL1xuXG5MLkxhdExuZ1V0aWwgPSB7XG5cdC8vIENsb25lcyBhIExhdExuZ3NbXSwgcmV0dXJucyBbXVtdXG5cdGNsb25lTGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcblx0XHR2YXIgY2xvbmUgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxhdGxuZ3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjbG9uZS5wdXNoKHRoaXMuY2xvbmVMYXRMbmcobGF0bG5nc1tpXSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xvbmVMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcblx0XHRyZXR1cm4gTC5sYXRMbmcobGF0bG5nLmxhdCwgbGF0bG5nLmxuZyk7XG5cdH1cbn07XG5cbkwuR2VvbWV0cnlVdGlsID0gTC5leHRlbmQoTC5HZW9tZXRyeVV0aWwgfHwge30sIHtcblx0Ly8gUG9ydGVkIGZyb20gdGhlIE9wZW5MYXllcnMgaW1wbGVtZW50YXRpb24uIFNlZSBodHRwczovL2dpdGh1Yi5jb20vb3BlbmxheWVycy9vcGVubGF5ZXJzL2Jsb2IvbWFzdGVyL2xpYi9PcGVuTGF5ZXJzL0dlb21ldHJ5L0xpbmVhclJpbmcuanMjTDI3MFxuXHRnZW9kZXNpY0FyZWE6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XG5cdFx0dmFyIHBvaW50c0NvdW50ID0gbGF0TG5ncy5sZW5ndGgsXG5cdFx0XHRhcmVhID0gMC4wLFxuXHRcdFx0ZDJyID0gTC5MYXRMbmcuREVHX1RPX1JBRCxcblx0XHRcdHAxLCBwMjtcblxuXHRcdGlmIChwb2ludHNDb3VudCA+IDIpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzQ291bnQ7IGkrKykge1xuXHRcdFx0XHRwMSA9IGxhdExuZ3NbaV07XG5cdFx0XHRcdHAyID0gbGF0TG5nc1soaSArIDEpICUgcG9pbnRzQ291bnRdO1xuXHRcdFx0XHRhcmVhICs9ICgocDIubG5nIC0gcDEubG5nKSAqIGQycikgKlxuXHRcdFx0XHRcdFx0KDIgKyBNYXRoLnNpbihwMS5sYXQgKiBkMnIpICsgTWF0aC5zaW4ocDIubGF0ICogZDJyKSk7XG5cdFx0XHR9XG5cdFx0XHRhcmVhID0gYXJlYSAqIDYzNzgxMzcuMCAqIDYzNzgxMzcuMCAvIDIuMDtcblx0XHR9XG5cblx0XHRyZXR1cm4gTWF0aC5hYnMoYXJlYSk7XG5cdH0sXG5cblx0cmVhZGFibGVBcmVhOiBmdW5jdGlvbiAoYXJlYSwgaXNNZXRyaWMpIHtcblx0XHR2YXIgYXJlYVN0cjtcblxuXHRcdGlmIChpc01ldHJpYykge1xuXHRcdFx0aWYgKGFyZWEgPj0gMTAwMDApIHtcblx0XHRcdFx0YXJlYVN0ciA9IChhcmVhICogMC4wMDAxKS50b0ZpeGVkKDIpICsgJyBoYSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhcmVhU3RyID0gYXJlYS50b0ZpeGVkKDIpICsgJyBtJnN1cDI7Jztcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0YXJlYSAqPSAwLjgzNjEyNzsgLy8gU3F1YXJlIHlhcmRzIGluIDEgbWV0ZXJcblxuXHRcdFx0aWYgKGFyZWEgPj0gMzA5NzYwMCkgeyAvLzMwOTc2MDAgc3F1YXJlIHlhcmRzIGluIDEgc3F1YXJlIG1pbGVcblx0XHRcdFx0YXJlYVN0ciA9IChhcmVhIC8gMzA5NzYwMCkudG9GaXhlZCgyKSArICcgbWkmc3VwMjsnO1xuXHRcdFx0fSBlbHNlIGlmIChhcmVhID49IDQ4NDApIHsvLzQ4MDQwIHNxdWFyZSB5YXJkcyBpbiAxIGFjcmVcblx0XHRcdFx0YXJlYVN0ciA9IChhcmVhIC8gNDg0MCkudG9GaXhlZCgyKSArICcgYWNyZXMnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXJlYVN0ciA9IE1hdGguY2VpbChhcmVhKSArICcgeWQmc3VwMjsnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBhcmVhU3RyO1xuXHR9LFxuXG5cdHJlYWRhYmxlRGlzdGFuY2U6IGZ1bmN0aW9uIChkaXN0YW5jZSwgaXNNZXRyaWMpIHtcblx0XHR2YXIgZGlzdGFuY2VTdHI7XG5cblx0XHRpZiAoaXNNZXRyaWMpIHtcblx0XHRcdC8vIHNob3cgbWV0cmVzIHdoZW4gZGlzdGFuY2UgaXMgPCAxa20sIHRoZW4gc2hvdyBrbVxuXHRcdFx0aWYgKGRpc3RhbmNlID4gMTAwMCkge1xuXHRcdFx0XHRkaXN0YW5jZVN0ciA9IChkaXN0YW5jZSAgLyAxMDAwKS50b0ZpeGVkKDIpICsgJyBrbSc7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkaXN0YW5jZVN0ciA9IE1hdGguY2VpbChkaXN0YW5jZSkgKyAnIG0nO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRkaXN0YW5jZSAqPSAxLjA5MzYxO1xuXG5cdFx0XHRpZiAoZGlzdGFuY2UgPiAxNzYwKSB7XG5cdFx0XHRcdGRpc3RhbmNlU3RyID0gKGRpc3RhbmNlIC8gMTc2MCkudG9GaXhlZCgyKSArICcgbWlsZXMnO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGlzdGFuY2VTdHIgPSBNYXRoLmNlaWwoZGlzdGFuY2UpICsgJyB5ZCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRpc3RhbmNlU3RyO1xuXHR9XG59KTtcblxuTC5VdGlsLmV4dGVuZChMLkxpbmVVdGlsLCB7XG5cdC8vIENoZWNrcyB0byBzZWUgaWYgdHdvIGxpbmUgc2VnbWVudHMgaW50ZXJzZWN0LiBEb2VzIG5vdCBoYW5kbGUgZGVnZW5lcmF0ZSBjYXNlcy5cblx0Ly8gaHR0cDovL2NvbXBnZW9tLmNzLnVpdWMuZWR1L35qZWZmZS90ZWFjaGluZy8zNzMvbm90ZXMveDA2LXN3ZWVwbGluZS5wZGZcblx0c2VnbWVudHNJbnRlcnNlY3Q6IGZ1bmN0aW9uICgvKlBvaW50Ki8gcCwgLypQb2ludCovIHAxLCAvKlBvaW50Ki8gcDIsIC8qUG9pbnQqLyBwMykge1xuXHRcdHJldHVyblx0dGhpcy5fY2hlY2tDb3VudGVyY2xvY2t3aXNlKHAsIHAyLCBwMykgIT09XG5cdFx0XHRcdHRoaXMuX2NoZWNrQ291bnRlcmNsb2Nrd2lzZShwMSwgcDIsIHAzKSAmJlxuXHRcdFx0XHR0aGlzLl9jaGVja0NvdW50ZXJjbG9ja3dpc2UocCwgcDEsIHAyKSAhPT1cblx0XHRcdFx0dGhpcy5fY2hlY2tDb3VudGVyY2xvY2t3aXNlKHAsIHAxLCBwMyk7XG5cdH0sXG5cblx0Ly8gY2hlY2sgdG8gc2VlIGlmIHBvaW50cyBhcmUgaW4gY291bnRlcmNsb2Nrd2lzZSBvcmRlclxuXHRfY2hlY2tDb3VudGVyY2xvY2t3aXNlOiBmdW5jdGlvbiAoLypQb2ludCovIHAsIC8qUG9pbnQqLyBwMSwgLypQb2ludCovIHAyKSB7XG5cdFx0cmV0dXJuIChwMi55IC0gcC55KSAqIChwMS54IC0gcC54KSA+IChwMS55IC0gcC55KSAqIChwMi54IC0gcC54KTtcblx0fVxufSk7XG5cbkwuUG9seWxpbmUuaW5jbHVkZSh7XG5cdC8vIENoZWNrIHRvIHNlZSBpZiB0aGlzIHBvbHlsaW5lIGhhcyBhbnkgbGluZXNlZ21lbnRzIHRoYXQgaW50ZXJzZWN0LlxuXHQvLyBOT1RFOiBkb2VzIG5vdCBzdXBwb3J0IGRldGVjdGluZyBpbnRlcnNlY3Rpb24gZm9yIGRlZ2VuZXJhdGUgY2FzZXMuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXG5cdFx0XHRsZW4gPSBwb2ludHMgPyBwb2ludHMubGVuZ3RoIDogMCxcblx0XHRcdGksIHAsIHAxO1xuXG5cdFx0aWYgKHRoaXMuX3Rvb0Zld1BvaW50c0ZvckludGVyc2VjdGlvbigpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gbGVuIC0gMTsgaSA+PSAzOyBpLS0pIHtcblx0XHRcdHAgPSBwb2ludHNbaSAtIDFdO1xuXHRcdFx0cDEgPSBwb2ludHNbaV07XG5cblxuXHRcdFx0aWYgKHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShwLCBwMSwgaSAtIDIpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHQvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIGlmIG5ldyBsYXRsbmcgd2FzIGFkZGVkIHRvIHRoaXMgcG9seWxpbmUuXG5cdC8vIE5PVEU6IGRvZXMgbm90IHN1cHBvcnQgZGV0ZWN0aW5nIGludGVyc2VjdGlvbiBmb3IgZGVnZW5lcmF0ZSBjYXNlcy5cblx0bmV3TGF0TG5nSW50ZXJzZWN0czogZnVuY3Rpb24gKGxhdGxuZywgc2tpcEZpcnN0KSB7XG5cdFx0Ly8gQ2Fubm90IGNoZWNrIGEgcG9seWxpbmUgZm9yIGludGVyc2VjdGluZyBsYXRzL2xuZ3Mgd2hlbiBub3QgYWRkZWQgdG8gdGhlIG1hcFxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMubmV3UG9pbnRJbnRlcnNlY3RzKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKSwgc2tpcEZpcnN0KTtcblx0fSxcblxuXHQvLyBDaGVjayBmb3IgaW50ZXJzZWN0aW9uIGlmIG5ldyBwb2ludCB3YXMgYWRkZWQgdG8gdGhpcyBwb2x5bGluZS5cblx0Ly8gbmV3UG9pbnQgbXVzdCBiZSBhIGxheWVyIHBvaW50LlxuXHQvLyBOT1RFOiBkb2VzIG5vdCBzdXBwb3J0IGRldGVjdGluZyBpbnRlcnNlY3Rpb24gZm9yIGRlZ2VuZXJhdGUgY2FzZXMuXG5cdG5ld1BvaW50SW50ZXJzZWN0czogZnVuY3Rpb24gKG5ld1BvaW50LCBza2lwRmlyc3QpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXG5cdFx0XHRsZW4gPSBwb2ludHMgPyBwb2ludHMubGVuZ3RoIDogMCxcblx0XHRcdGxhc3RQb2ludCA9IHBvaW50cyA/IHBvaW50c1tsZW4gLSAxXSA6IG51bGwsXG5cdFx0XHQvLyBUaGUgcHJldmlvdXMgcHJldmlvdXMgbGluZSBzZWdtZW50LiBQcmV2aW91cyBsaW5lIHNlZ21lbnQgZG9lc24ndCBuZWVkIHRlc3RpbmcuXG5cdFx0XHRtYXhJbmRleCA9IGxlbiAtIDI7XG5cblx0XHRpZiAodGhpcy5fdG9vRmV3UG9pbnRzRm9ySW50ZXJzZWN0aW9uKDEpKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuX2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZShsYXN0UG9pbnQsIG5ld1BvaW50LCBtYXhJbmRleCwgc2tpcEZpcnN0ID8gMSA6IDApO1xuXHR9LFxuXG5cdC8vIFBvbHlsaW5lcyB3aXRoIDIgc2lkZXMgY2FuIG9ubHkgaW50ZXJzZWN0IGluIGNhc2VzIHdoZXJlIHBvaW50cyBhcmUgY29sbGluZWFyICh3ZSBkb24ndCBzdXBwb3J0IGRldGVjdGluZyB0aGVzZSkuXG5cdC8vIENhbm5vdCBoYXZlIGludGVyc2VjdGlvbiB3aGVuIDwgMyBsaW5lIHNlZ21lbnRzICg8IDQgcG9pbnRzKVxuXHRfdG9vRmV3UG9pbnRzRm9ySW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoZXh0cmFQb2ludHMpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXG5cdFx0XHRsZW4gPSBwb2ludHMgPyBwb2ludHMubGVuZ3RoIDogMDtcblx0XHQvLyBJbmNyZW1lbnQgbGVuZ3RoIGJ5IGV4dHJhUG9pbnRzIGlmIHByZXNlbnRcblx0XHRsZW4gKz0gZXh0cmFQb2ludHMgfHwgMDtcblxuXHRcdHJldHVybiAhdGhpcy5fb3JpZ2luYWxQb2ludHMgfHwgbGVuIDw9IDM7XG5cdH0sXG5cblx0Ly8gQ2hlY2tzIGEgbGluZSBzZWdtZW50IGludGVyc2VjdGlvbnMgd2l0aCBhbnkgbGluZSBzZWdtZW50cyBiZWZvcmUgaXRzIHByZWRlY2Vzc29yLlxuXHQvLyBEb24ndCBuZWVkIHRvIGNoZWNrIHRoZSBwcmVkZWNlc3NvciBhcyB3aWxsIG5ldmVyIGludGVyc2VjdC5cblx0X2xpbmVTZWdtZW50c0ludGVyc2VjdHNSYW5nZTogZnVuY3Rpb24gKHAsIHAxLCBtYXhJbmRleCwgbWluSW5kZXgpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5fb3JpZ2luYWxQb2ludHMsXG5cdFx0XHRwMiwgcDM7XG5cblx0XHRtaW5JbmRleCA9IG1pbkluZGV4IHx8IDA7XG5cblx0XHQvLyBDaGVjayBhbGwgcHJldmlvdXMgbGluZSBzZWdtZW50cyAoYmVzaWRlIHRoZSBpbW1lZGlhdGVseSBwcmV2aW91cykgZm9yIGludGVyc2VjdGlvbnNcblx0XHRmb3IgKHZhciBqID0gbWF4SW5kZXg7IGogPiBtaW5JbmRleDsgai0tKSB7XG5cdFx0XHRwMiA9IHBvaW50c1tqIC0gMV07XG5cdFx0XHRwMyA9IHBvaW50c1tqXTtcblxuXHRcdFx0aWYgKEwuTGluZVV0aWwuc2VnbWVudHNJbnRlcnNlY3QocCwgcDEsIHAyLCBwMykpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59KTtcblxuXG5MLlBvbHlnb24uaW5jbHVkZSh7XG5cdC8vIENoZWNrcyBhIHBvbHlnb24gZm9yIGFueSBpbnRlcnNlY3RpbmcgbGluZSBzZWdtZW50cy4gSWdub3JlcyBob2xlcy5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBwb2x5bGluZUludGVyc2VjdHMsXG5cdFx0XHRwb2ludHMgPSB0aGlzLl9vcmlnaW5hbFBvaW50cyxcblx0XHRcdGxlbiwgZmlyc3RQb2ludCwgbGFzdFBvaW50LCBtYXhJbmRleDtcblxuXHRcdGlmICh0aGlzLl90b29GZXdQb2ludHNGb3JJbnRlcnNlY3Rpb24oKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHBvbHlsaW5lSW50ZXJzZWN0cyA9IEwuUG9seWxpbmUucHJvdG90eXBlLmludGVyc2VjdHMuY2FsbCh0aGlzKTtcblxuXHRcdC8vIElmIGFscmVhZHkgZm91bmQgYW4gaW50ZXJzZWN0aW9uIGRvbid0IG5lZWQgdG8gY2hlY2sgZm9yIGFueSBtb3JlLlxuXHRcdGlmIChwb2x5bGluZUludGVyc2VjdHMpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxlbiA9IHBvaW50cy5sZW5ndGg7XG5cdFx0Zmlyc3RQb2ludCA9IHBvaW50c1swXTtcblx0XHRsYXN0UG9pbnQgPSBwb2ludHNbbGVuIC0gMV07XG5cdFx0bWF4SW5kZXggPSBsZW4gLSAyO1xuXG5cdFx0Ly8gQ2hlY2sgdGhlIGxpbmUgc2VnbWVudCBiZXR3ZWVuIGxhc3QgYW5kIGZpcnN0IHBvaW50LiBEb24ndCBuZWVkIHRvIGNoZWNrIHRoZSBmaXJzdCBsaW5lIHNlZ21lbnQgKG1pbkluZGV4ID0gMSlcblx0XHRyZXR1cm4gdGhpcy5fbGluZVNlZ21lbnRzSW50ZXJzZWN0c1JhbmdlKGxhc3RQb2ludCwgZmlyc3RQb2ludCwgbWF4SW5kZXgsIDEpO1xuXHR9XG59KTtcblxuTC5Db250cm9sLkRyYXcgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0Jyxcblx0XHRkcmF3OiB7fSxcblx0XHRlZGl0OiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0aWYgKEwudmVyc2lvbiA8ICcwLjcnKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0xlYWZsZXQuZHJhdyAwLjIuMysgcmVxdWlyZXMgTGVhZmxldCAwLjcuMCsuIERvd25sb2FkIGxhdGVzdCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvJyk7XG5cdFx0fVxuXG5cdFx0TC5Db250cm9sLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cblx0XHR2YXIgaWQsIHRvb2xiYXI7XG5cblx0XHR0aGlzLl90b29sYmFycyA9IHt9O1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0b29sYmFyc1xuXHRcdGlmIChMLkRyYXdUb29sYmFyICYmIHRoaXMub3B0aW9ucy5kcmF3KSB7XG5cdFx0XHR0b29sYmFyID0gbmV3IEwuRHJhd1Rvb2xiYXIodGhpcy5vcHRpb25zLmRyYXcpO1xuXHRcdFx0aWQgPSBMLnN0YW1wKHRvb2xiYXIpO1xuXHRcdFx0dGhpcy5fdG9vbGJhcnNbaWRdID0gdG9vbGJhcjtcblxuXHRcdFx0Ly8gTGlzdGVuIGZvciB3aGVuIHRvb2xiYXIgaXMgZW5hYmxlZFxuXHRcdFx0dGhpcy5fdG9vbGJhcnNbaWRdLm9uKCdlbmFibGUnLCB0aGlzLl90b29sYmFyRW5hYmxlZCwgdGhpcyk7XG5cdFx0fVxuXG5cdFx0aWYgKEwuRWRpdFRvb2xiYXIgJiYgdGhpcy5vcHRpb25zLmVkaXQpIHtcblx0XHRcdHRvb2xiYXIgPSBuZXcgTC5FZGl0VG9vbGJhcih0aGlzLm9wdGlvbnMuZWRpdCk7XG5cdFx0XHRpZCA9IEwuc3RhbXAodG9vbGJhcik7XG5cdFx0XHR0aGlzLl90b29sYmFyc1tpZF0gPSB0b29sYmFyO1xuXG5cdFx0XHQvLyBMaXN0ZW4gZm9yIHdoZW4gdG9vbGJhciBpcyBlbmFibGVkXG5cdFx0XHR0aGlzLl90b29sYmFyc1tpZF0ub24oJ2VuYWJsZScsIHRoaXMuX3Rvb2xiYXJFbmFibGVkLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdycpLFxuXHRcdFx0YWRkZWRUb3BDbGFzcyA9IGZhbHNlLFxuXHRcdFx0dG9wQ2xhc3NOYW1lID0gJ2xlYWZsZXQtZHJhdy10b29sYmFyLXRvcCcsXG5cdFx0XHR0b29sYmFyQ29udGFpbmVyO1xuXG5cdFx0Zm9yICh2YXIgdG9vbGJhcklkIGluIHRoaXMuX3Rvb2xiYXJzKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbGJhcnMuaGFzT3duUHJvcGVydHkodG9vbGJhcklkKSkge1xuXHRcdFx0XHR0b29sYmFyQ29udGFpbmVyID0gdGhpcy5fdG9vbGJhcnNbdG9vbGJhcklkXS5hZGRUb29sYmFyKG1hcCk7XG5cblx0XHRcdFx0aWYgKHRvb2xiYXJDb250YWluZXIpIHtcblx0XHRcdFx0XHQvLyBBZGQgY2xhc3MgdG8gdGhlIGZpcnN0IHRvb2xiYXIgdG8gcmVtb3ZlIHRoZSBtYXJnaW5cblx0XHRcdFx0XHRpZiAoIWFkZGVkVG9wQ2xhc3MpIHtcblx0XHRcdFx0XHRcdGlmICghTC5Eb21VdGlsLmhhc0NsYXNzKHRvb2xiYXJDb250YWluZXIsIHRvcENsYXNzTmFtZSkpIHtcblx0XHRcdFx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRvb2xiYXJDb250YWluZXIuY2hpbGROb2Rlc1swXSwgdG9wQ2xhc3NOYW1lKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFkZGVkVG9wQ2xhc3MgPSB0cnVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0b29sYmFyQ29udGFpbmVyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjb250YWluZXI7XG5cdH0sXG5cblx0b25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHRmb3IgKHZhciB0b29sYmFySWQgaW4gdGhpcy5fdG9vbGJhcnMpIHtcblx0XHRcdGlmICh0aGlzLl90b29sYmFycy5oYXNPd25Qcm9wZXJ0eSh0b29sYmFySWQpKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2xiYXJzW3Rvb2xiYXJJZF0ucmVtb3ZlVG9vbGJhcigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXREcmF3aW5nT3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRmb3IgKHZhciB0b29sYmFySWQgaW4gdGhpcy5fdG9vbGJhcnMpIHtcblx0XHRcdGlmICh0aGlzLl90b29sYmFyc1t0b29sYmFySWRdIGluc3RhbmNlb2YgTC5EcmF3VG9vbGJhcikge1xuXHRcdFx0XHR0aGlzLl90b29sYmFyc1t0b29sYmFySWRdLnNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF90b29sYmFyRW5hYmxlZDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgaWQgPSAnJyArIEwuc3RhbXAoZS50YXJnZXQpO1xuXG5cdFx0Zm9yICh2YXIgdG9vbGJhcklkIGluIHRoaXMuX3Rvb2xiYXJzKSB7XG5cdFx0XHRpZiAodGhpcy5fdG9vbGJhcnMuaGFzT3duUHJvcGVydHkodG9vbGJhcklkKSAmJiB0b29sYmFySWQgIT09IGlkKSB7XG5cdFx0XHRcdHRoaXMuX3Rvb2xiYXJzW3Rvb2xiYXJJZF0uZGlzYWJsZSgpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSk7XG5cbkwuTWFwLm1lcmdlT3B0aW9ucyh7XG5cdGRyYXdDb250cm9sVG9vbHRpcHM6IHRydWUsXG5cdGRyYXdDb250cm9sOiBmYWxzZVxufSk7XG5cbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcblx0aWYgKHRoaXMub3B0aW9ucy5kcmF3Q29udHJvbCkge1xuXHRcdHRoaXMuZHJhd0NvbnRyb2wgPSBuZXcgTC5Db250cm9sLkRyYXcoKTtcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy5kcmF3Q29udHJvbCk7XG5cdH1cbn0pO1xuXG5cbkwuVG9vbGJhciA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5jbHVkZXM6IFtMLk1peGluLkV2ZW50c10sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0XHR0aGlzLl9tb2RlcyA9IHt9O1xuXHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnMgPSBbXTtcblx0XHR0aGlzLl9hY3RpdmVNb2RlID0gbnVsbDtcblx0fSxcblxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FjdGl2ZU1vZGUgIT09IG51bGw7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5lbmFibGVkKCkpIHsgcmV0dXJuOyB9XG5cblx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuZGlzYWJsZSgpO1xuXHR9LFxuXG5cdGFkZFRvb2xiYXI6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtZHJhdy1zZWN0aW9uJyksXG5cdFx0XHRidXR0b25JbmRleCA9IDAsXG5cdFx0XHRidXR0b25DbGFzc1ByZWZpeCA9IHRoaXMuX3Rvb2xiYXJDbGFzcyB8fCAnJyxcblx0XHRcdG1vZGVIYW5kbGVycyA9IHRoaXMuZ2V0TW9kZUhhbmRsZXJzKG1hcCksXG5cdFx0XHRpO1xuXG5cdFx0dGhpcy5fdG9vbGJhckNvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWRyYXctdG9vbGJhciBsZWFmbGV0LWJhcicpO1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBtb2RlSGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGlmIChtb2RlSGFuZGxlcnNbaV0uZW5hYmxlZCkge1xuXHRcdFx0XHR0aGlzLl9pbml0TW9kZUhhbmRsZXIoXG5cdFx0XHRcdFx0bW9kZUhhbmRsZXJzW2ldLmhhbmRsZXIsXG5cdFx0XHRcdFx0dGhpcy5fdG9vbGJhckNvbnRhaW5lcixcblx0XHRcdFx0XHRidXR0b25JbmRleCsrLFxuXHRcdFx0XHRcdGJ1dHRvbkNsYXNzUHJlZml4LFxuXHRcdFx0XHRcdG1vZGVIYW5kbGVyc1tpXS50aXRsZVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIGlmIG5vIGJ1dHRvbnMgd2VyZSBhZGRlZCwgZG8gbm90IGFkZCB0aGUgdG9vbGJhclxuXHRcdGlmICghYnV0dG9uSW5kZXgpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBTYXZlIGJ1dHRvbiBpbmRleCBvZiB0aGUgbGFzdCBidXR0b24sIC0xIGFzIHdlIHdvdWxkIGhhdmUgKysgYWZ0ZXIgdGhlIGxhc3QgYnV0dG9uXG5cdFx0dGhpcy5fbGFzdEJ1dHRvbkluZGV4ID0gLS1idXR0b25JbmRleDtcblxuXHRcdC8vIENyZWF0ZSBlbXB0eSBhY3Rpb25zIHBhcnQgb2YgdGhlIHRvb2xiYXJcblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgndWwnLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMnKTtcblxuXHRcdC8vIEFkZCBkcmF3IGFuZCBjYW5jZWwgY29udGFpbmVycyB0byB0aGUgY29udHJvbCBjb250YWluZXJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fdG9vbGJhckNvbnRhaW5lcik7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuX2FjdGlvbnNDb250YWluZXIpO1xuXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcblx0fSxcblxuXHRyZW1vdmVUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gRGlzcG9zZSBlYWNoIGhhbmRsZXJcblx0XHRmb3IgKHZhciBoYW5kbGVySWQgaW4gdGhpcy5fbW9kZXMpIHtcblx0XHRcdGlmICh0aGlzLl9tb2Rlcy5oYXNPd25Qcm9wZXJ0eShoYW5kbGVySWQpKSB7XG5cdFx0XHRcdC8vIFVuYmluZCBoYW5kbGVyIGJ1dHRvblxuXHRcdFx0XHR0aGlzLl9kaXNwb3NlQnV0dG9uKFxuXHRcdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uYnV0dG9uLFxuXHRcdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uaGFuZGxlci5lbmFibGUsXG5cdFx0XHRcdFx0dGhpcy5fbW9kZXNbaGFuZGxlcklkXS5oYW5kbGVyXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIGlzIGRpc2FibGVkXG5cdFx0XHRcdHRoaXMuX21vZGVzW2hhbmRsZXJJZF0uaGFuZGxlci5kaXNhYmxlKCk7XG5cblx0XHRcdFx0Ly8gVW5iaW5kIGhhbmRsZXJcblx0XHRcdFx0dGhpcy5fbW9kZXNbaGFuZGxlcklkXS5oYW5kbGVyXG5cdFx0XHRcdFx0Lm9mZignZW5hYmxlZCcsIHRoaXMuX2hhbmRsZXJBY3RpdmF0ZWQsIHRoaXMpXG5cdFx0XHRcdFx0Lm9mZignZGlzYWJsZWQnLCB0aGlzLl9oYW5kbGVyRGVhY3RpdmF0ZWQsIHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9tb2RlcyA9IHt9O1xuXG5cdFx0Ly8gRGlzcG9zZSB0aGUgYWN0aW9ucyB0b29sYmFyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9hY3Rpb25CdXR0b25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dGhpcy5fZGlzcG9zZUJ1dHRvbihcblx0XHRcdFx0dGhpcy5fYWN0aW9uQnV0dG9uc1tpXS5idXR0b24sXG5cdFx0XHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnNbaV0uY2FsbGJhY2ssXG5cdFx0XHRcdHRoaXNcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHRoaXMuX2FjdGlvbkJ1dHRvbnMgPSBbXTtcblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyID0gbnVsbDtcblx0fSxcblxuXHRfaW5pdE1vZGVIYW5kbGVyOiBmdW5jdGlvbiAoaGFuZGxlciwgY29udGFpbmVyLCBidXR0b25JbmRleCwgY2xhc3NOYW1lUHJlZGl4LCBidXR0b25UaXRsZSkge1xuXHRcdHZhciB0eXBlID0gaGFuZGxlci50eXBlO1xuXG5cdFx0dGhpcy5fbW9kZXNbdHlwZV0gPSB7fTtcblxuXHRcdHRoaXMuX21vZGVzW3R5cGVdLmhhbmRsZXIgPSBoYW5kbGVyO1xuXG5cdFx0dGhpcy5fbW9kZXNbdHlwZV0uYnV0dG9uID0gdGhpcy5fY3JlYXRlQnV0dG9uKHtcblx0XHRcdHRpdGxlOiBidXR0b25UaXRsZSxcblx0XHRcdGNsYXNzTmFtZTogY2xhc3NOYW1lUHJlZGl4ICsgJy0nICsgdHlwZSxcblx0XHRcdGNvbnRhaW5lcjogY29udGFpbmVyLFxuXHRcdFx0Y2FsbGJhY2s6IHRoaXMuX21vZGVzW3R5cGVdLmhhbmRsZXIuZW5hYmxlLFxuXHRcdFx0Y29udGV4dDogdGhpcy5fbW9kZXNbdHlwZV0uaGFuZGxlclxuXHRcdH0pO1xuXHRcdGlmKHR5cGUgPT0gJ2VkaXREYXRhJyl7XG5cdFx0XHR0aGlzLl9tb2Rlc1t0eXBlXS5idXR0b24uY2xhc3NOYW1lID0gJ2ZhIGZhLWJhcnMnO1xuXHRcdH1cblxuXHRcdGlmKHR5cGUgPT0gJ2lzb2Nocm9uZScpe1xuXHRcdFx0dGhpcy5fbW9kZXNbdHlwZV0uYnV0dG9uLmNsYXNzTmFtZSA9ICdmYSBmYS1kb3QtY2lyY2xlLW8nO1xuXHRcdH1cblxuXHRcdHRoaXMuX21vZGVzW3R5cGVdLmJ1dHRvbkluZGV4ID0gYnV0dG9uSW5kZXg7XG5cblx0XHR0aGlzLl9tb2Rlc1t0eXBlXS5oYW5kbGVyXG5cdFx0XHQub24oJ2VuYWJsZWQnLCB0aGlzLl9oYW5kbGVyQWN0aXZhdGVkLCB0aGlzKVxuXHRcdFx0Lm9uKCdkaXNhYmxlZCcsIHRoaXMuX2hhbmRsZXJEZWFjdGl2YXRlZCwgdGhpcyk7XG5cdH0sXG5cblx0X2NyZWF0ZUJ1dHRvbjogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHR2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBvcHRpb25zLmNsYXNzTmFtZSB8fCAnJywgb3B0aW9ucy5jb250YWluZXIpO1xuXHRcdGxpbmsuaHJlZiA9ICcjJztcblxuXHRcdGlmIChvcHRpb25zLnRleHQpIHtcblx0XHRcdGxpbmsuaW5uZXJIVE1MID0gb3B0aW9ucy50ZXh0O1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLnRpdGxlKSB7XG5cdFx0XHRsaW5rLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcblx0XHR9XG5cblx0XHRMLkRvbUV2ZW50XG5cdFx0XHQub24obGluaywgJ2NsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub24obGluaywgJ21vdXNlZG93bicsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0Lm9uKGxpbmssICdkYmxjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKVxuXHRcdFx0Lm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpXG5cdFx0XHQub24obGluaywgJ2NsaWNrJywgb3B0aW9ucy5jYWxsYmFjaywgb3B0aW9ucy5jb250ZXh0KTtcblxuXHRcdHJldHVybiBsaW5rO1xuXHR9LFxuXG5cdF9kaXNwb3NlQnV0dG9uOiBmdW5jdGlvbiAoYnV0dG9uLCBjYWxsYmFjaykge1xuXHRcdEwuRG9tRXZlbnRcblx0XHRcdC5vZmYoYnV0dG9uLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbilcblx0XHRcdC5vZmYoYnV0dG9uLCAnbW91c2Vkb3duJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub2ZmKGJ1dHRvbiwgJ2RibGNsaWNrJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pXG5cdFx0XHQub2ZmKGJ1dHRvbiwgJ2NsaWNrJywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdClcblx0XHRcdC5vZmYoYnV0dG9uLCAnY2xpY2snLCBjYWxsYmFjayk7XG5cdH0sXG5cblx0X2hhbmRsZXJBY3RpdmF0ZWQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0Ly8gRGlzYWJsZSBhY3RpdmUgbW9kZSAoaWYgcHJlc2VudClcblx0XHR0aGlzLmRpc2FibGUoKTtcblxuXHRcdC8vIENhY2hlIG5ldyBhY3RpdmUgZmVhdHVyZVxuXHRcdHRoaXMuX2FjdGl2ZU1vZGUgPSB0aGlzLl9tb2Rlc1tlLmhhbmRsZXJdO1xuXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FjdGl2ZU1vZGUuYnV0dG9uLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItYnV0dG9uLWVuYWJsZWQnKTtcblxuXHRcdHRoaXMuX3Nob3dBY3Rpb25zVG9vbGJhcigpO1xuXG5cdFx0dGhpcy5maXJlKCdlbmFibGUnKTtcblx0fSxcblxuXHRfaGFuZGxlckRlYWN0aXZhdGVkOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faGlkZUFjdGlvbnNUb29sYmFyKCk7XG5cblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWN0aXZlTW9kZS5idXR0b24sICdsZWFmbGV0LWRyYXctdG9vbGJhci1idXR0b24tZW5hYmxlZCcpO1xuXG5cdFx0dGhpcy5fYWN0aXZlTW9kZSA9IG51bGw7XG5cblx0XHR0aGlzLmZpcmUoJ2Rpc2FibGUnKTtcblx0fSxcblxuXHRfY3JlYXRlQWN0aW9uczogZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fYWN0aW9uc0NvbnRhaW5lcixcblx0XHRcdGJ1dHRvbnMgPSB0aGlzLmdldEFjdGlvbnMoaGFuZGxlciksXG5cdFx0XHRsID0gYnV0dG9ucy5sZW5ndGgsXG5cdFx0XHRsaSwgZGksIGRsLCBidXR0b247XG5cblx0XHQvLyBEaXNwb3NlIHRoZSBhY3Rpb25zIHRvb2xiYXIgKHRvZG86IGRpc3Bvc2Ugb25seSBub3QgdXNlZCBidXR0b25zKVxuXHRcdGZvciAoZGkgPSAwLCBkbCA9IHRoaXMuX2FjdGlvbkJ1dHRvbnMubGVuZ3RoOyBkaSA8IGRsOyBkaSsrKSB7XG5cdFx0XHR0aGlzLl9kaXNwb3NlQnV0dG9uKHRoaXMuX2FjdGlvbkJ1dHRvbnNbZGldLmJ1dHRvbiwgdGhpcy5fYWN0aW9uQnV0dG9uc1tkaV0uY2FsbGJhY2spO1xuXHRcdH1cblx0XHR0aGlzLl9hY3Rpb25CdXR0b25zID0gW107XG5cblx0XHQvLyBSZW1vdmUgYWxsIG9sZCBidXR0b25zXG5cdFx0d2hpbGUgKGNvbnRhaW5lci5maXJzdENoaWxkKSB7XG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoY29udGFpbmVyLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoJ2VuYWJsZWQnIGluIGJ1dHRvbnNbaV0gJiYgIWJ1dHRvbnNbaV0uZW5hYmxlZCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bGkgPSBMLkRvbVV0aWwuY3JlYXRlKCdsaScsICcnLCBjb250YWluZXIpO1xuXG5cdFx0XHRidXR0b24gPSB0aGlzLl9jcmVhdGVCdXR0b24oe1xuXHRcdFx0XHR0aXRsZTogYnV0dG9uc1tpXS50aXRsZSxcblx0XHRcdFx0dGV4dDogYnV0dG9uc1tpXS50ZXh0LFxuXHRcdFx0XHRjb250YWluZXI6IGxpLFxuXHRcdFx0XHRjYWxsYmFjazogYnV0dG9uc1tpXS5jYWxsYmFjayxcblx0XHRcdFx0Y29udGV4dDogYnV0dG9uc1tpXS5jb250ZXh0XG5cdFx0XHR9KTtcblxuXHRcdFx0dGhpcy5fYWN0aW9uQnV0dG9ucy5wdXNoKHtcblx0XHRcdFx0YnV0dG9uOiBidXR0b24sXG5cdFx0XHRcdGNhbGxiYWNrOiBidXR0b25zW2ldLmNhbGxiYWNrXG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X3Nob3dBY3Rpb25zVG9vbGJhcjogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBidXR0b25JbmRleCA9IHRoaXMuX2FjdGl2ZU1vZGUuYnV0dG9uSW5kZXgsXG5cdFx0XHRsYXN0QnV0dG9uSW5kZXggPSB0aGlzLl9sYXN0QnV0dG9uSW5kZXgsXG5cdFx0XHR0b29sYmFyUG9zaXRpb24gPSB0aGlzLl9hY3RpdmVNb2RlLmJ1dHRvbi5vZmZzZXRUb3AgLSAxO1xuXG5cdFx0Ly8gUmVjcmVhdGUgYWN0aW9uIGJ1dHRvbnMgb24gZXZlcnkgY2xpY2tcblx0XHR0aGlzLl9jcmVhdGVBY3Rpb25zKHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlcik7XG5cblx0XHQvLyBDb3JyZWN0bHkgcG9zaXRpb24gdGhlIGNhbmNlbCBidXR0b25cblx0XHR0aGlzLl9hY3Rpb25zQ29udGFpbmVyLnN0eWxlLnRvcCA9IHRvb2xiYXJQb3NpdGlvbiArICdweCc7XG5cblx0XHRpZiAoYnV0dG9uSW5kZXggPT09IDApIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm90b3AnKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtdG9wJyk7XG5cdFx0fVxuXG5cdFx0aWYgKGJ1dHRvbkluZGV4ID09PSBsYXN0QnV0dG9uSW5kZXgpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm9ib3R0b20nKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtYm90dG9tJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWN0aW9uc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0fSxcblxuXHRfaGlkZUFjdGlvbnNUb29sYmFyOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5fYWN0aW9uc0NvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3Rvb2xiYXJDb250YWluZXIsICdsZWFmbGV0LWRyYXctdG9vbGJhci1ub3RvcCcpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl90b29sYmFyQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LXRvb2xiYXItbm9ib3R0b20nKTtcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fYWN0aW9uc0NvbnRhaW5lciwgJ2xlYWZsZXQtZHJhdy1hY3Rpb25zLXRvcCcpO1xuXHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9hY3Rpb25zQ29udGFpbmVyLCAnbGVhZmxldC1kcmF3LWFjdGlvbnMtYm90dG9tJyk7XG5cdH1cbn0pO1xuXG5cbkwuVG9vbHRpcCA9IEwuQ2xhc3MuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdHRoaXMuX21hcCA9IG1hcDtcblx0XHR0aGlzLl9wb3B1cFBhbmUgPSBtYXAuX3BhbmVzLnBvcHVwUGFuZTtcblxuXHRcdHRoaXMuX2NvbnRhaW5lciA9IG1hcC5vcHRpb25zLmRyYXdDb250cm9sVG9vbHRpcHMgPyBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC1kcmF3LXRvb2x0aXAnLCB0aGlzLl9wb3B1cFBhbmUpIDogbnVsbDtcblx0XHR0aGlzLl9zaW5nbGVMaW5lTGFiZWwgPSBmYWxzZTtcblx0fSxcblxuXHRkaXNwb3NlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xuXHRcdFx0dGhpcy5fcG9wdXBQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XG5cdFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHR1cGRhdGVDb250ZW50OiBmdW5jdGlvbiAobGFiZWxUZXh0KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRsYWJlbFRleHQuc3VidGV4dCA9IGxhYmVsVGV4dC5zdWJ0ZXh0IHx8ICcnO1xuXG5cdFx0Ly8gdXBkYXRlIHRoZSB2ZXJ0aWNhbCBwb3NpdGlvbiAob25seSBpZiBjaGFuZ2VkKVxuXHRcdGlmIChsYWJlbFRleHQuc3VidGV4dC5sZW5ndGggPT09IDAgJiYgIXRoaXMuX3NpbmdsZUxpbmVMYWJlbCkge1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtZHJhdy10b29sdGlwLXNpbmdsZScpO1xuXHRcdFx0dGhpcy5fc2luZ2xlTGluZUxhYmVsID0gdHJ1ZTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAobGFiZWxUZXh0LnN1YnRleHQubGVuZ3RoID4gMCAmJiB0aGlzLl9zaW5nbGVMaW5lTGFiZWwpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWRyYXctdG9vbHRpcC1zaW5nbGUnKTtcblx0XHRcdHRoaXMuX3NpbmdsZUxpbmVMYWJlbCA9IGZhbHNlO1xuXHRcdH1cblxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPVxuXHRcdFx0KGxhYmVsVGV4dC5zdWJ0ZXh0Lmxlbmd0aCA+IDAgPyAnPHNwYW4gY2xhc3M9XCJsZWFmbGV0LWRyYXctdG9vbHRpcC1zdWJ0ZXh0XCI+JyArIGxhYmVsVGV4dC5zdWJ0ZXh0ICsgJzwvc3Bhbj4nICsgJzxiciAvPicgOiAnJykgK1xuXHRcdFx0JzxzcGFuPicgKyBsYWJlbFRleHQudGV4dCArICc8L3NwYW4+JztcblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHVwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAobGF0bG5nKSB7XG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKSxcblx0XHRcdHRvb2x0aXBDb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XG5cblx0XHRpZiAodGhpcy5fY29udGFpbmVyKSB7XG5cdFx0XHR0b29sdGlwQ29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaW5oZXJpdCc7XG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odG9vbHRpcENvbnRhaW5lciwgcG9zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaG93QXNFcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWVycm9yLWRyYXctdG9vbHRpcCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVFcnJvcjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWVycm9yLWRyYXctdG9vbHRpcCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbkwuRHJhd1Rvb2xiYXIgPSBMLlRvb2xiYXIuZXh0ZW5kKHtcblxuXHRvcHRpb25zOiB7XG5cdFx0cG9seWxpbmU6IHt9LFxuXHRcdHBvbHlnb246IHt9LFxuXHRcdHJlY3RhbmdsZToge30sXG5cdFx0Y2lyY2xlOiB7fSxcblx0XHRtYXJrZXI6IHt9LFxuXHRcdGlzb2Nocm9uZTp7fVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG5cdFx0Ly8gRW5zdXJlIHRoYXQgdGhlIG9wdGlvbnMgYXJlIG1lcmdlZCBjb3JyZWN0bHkgc2luY2UgTC5leHRlbmQgaXMgb25seSBzaGFsbG93XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiB0aGlzLm9wdGlvbnMpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuaGFzT3duUHJvcGVydHkodHlwZSkpIHtcblx0XHRcdFx0aWYgKG9wdGlvbnNbdHlwZV0pIHtcblx0XHRcdFx0XHRvcHRpb25zW3R5cGVdID0gTC5leHRlbmQoe30sIHRoaXMub3B0aW9uc1t0eXBlXSwgb3B0aW9uc1t0eXBlXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl90b29sYmFyQ2xhc3MgPSAnbGVhZmxldC1kcmF3LWRyYXcnO1xuXHRcdEwuVG9vbGJhci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9mb3JtT3B0aW9uczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5mb3JtT3B0aW9ucyh0aGlzKTtcblx0XHQvL3RoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCk7XG5cdH0sXG5cblx0Z2V0TW9kZUhhbmRsZXJzOiBmdW5jdGlvbiAobWFwKSB7XG5cdFx0cmV0dXJuIFtcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLnBvbHlsaW5lLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5EcmF3LlBvbHlsaW5lKG1hcCwgdGhpcy5vcHRpb25zLnBvbHlsaW5lKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnBvbHlsaW5lXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMucG9seWdvbixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5Qb2x5Z29uKG1hcCwgdGhpcy5vcHRpb25zLnBvbHlnb24pLFxuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmJ1dHRvbnMucG9seWdvblxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLnJlY3RhbmdsZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5SZWN0YW5nbGUobWFwLCB0aGlzLm9wdGlvbnMucmVjdGFuZ2xlKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLnJlY3RhbmdsZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmNpcmNsZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5DaXJjbGUobWFwLCB0aGlzLm9wdGlvbnMuY2lyY2xlKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmNpcmNsZVxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLm1hcmtlcixcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5NYXJrZXIobWFwLCB0aGlzLm9wdGlvbnMubWFya2VyKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLm1hcmtlclxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmlzb2Nocm9uZSxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRHJhdy5Jc29jaHJvbmUobWFwLCB0aGlzLm9wdGlvbnMuaXNvY2hyb25lKSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5idXR0b25zLmlzb2Nocm9uZVxuXHRcdFx0fVxuXHRcdF07XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBhY3Rpb25zIHBhcnQgb2YgdGhlIHRvb2xiYXJcblx0Z2V0QWN0aW9uczogZnVuY3Rpb24gKGhhbmRsZXIpIHtcblx0XHRpZih0aGlzLm9wdGlvbnMuaXNvY2hyb25lKXtcblx0XHRcdHJldHVybiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmFjdGlvbnNJc28ub3B0aW9uLnRpdGxlLFxuXHRcdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5hY3Rpb25zSXNvLm9wdGlvbi50ZXh0LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiB0aGlzLl9mb3JtT3B0aW9ucyxcblx0XHRcdFx0XHRjb250ZXh0OiB0aGlzXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLmFjdGlvbnNJc28uY2FuY2VsLnRpdGxlLFxuXHRcdFx0XHRcdHRleHQ6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5hY3Rpb25zSXNvLmNhbmNlbC50ZXh0LFxuXHRcdFx0XHRcdGNhbGxiYWNrOiB0aGlzLmRpc2FibGUsXG5cdFx0XHRcdFx0Y29udGV4dDogdGhpc1xuXHRcdFx0XHR9XG5cdFx0XHRdO1xuXHRcdH07XG5cblx0XHRyZXR1cm4gW1xuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiBoYW5kbGVyLmRlbGV0ZUxhc3RWZXJ0ZXgsXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIudW5kby50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZHJhdy50b29sYmFyLnVuZG8udGV4dCxcblx0XHRcdFx0Y2FsbGJhY2s6IGhhbmRsZXIuZGVsZXRlTGFzdFZlcnRleCxcblx0XHRcdFx0Y29udGV4dDogaGFuZGxlclxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmRyYXcudG9vbGJhci5hY3Rpb25zLnRpdGxlLFxuXHRcdFx0XHR0ZXh0OiBMLmRyYXdMb2NhbC5kcmF3LnRvb2xiYXIuYWN0aW9ucy50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5kaXNhYmxlLFxuXHRcdFx0XHRjb250ZXh0OiB0aGlzXG5cdFx0XHR9XG5cdFx0XTtcblx0XG5cdH0sXG5cblx0c2V0T3B0aW9uczogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cblx0XHRmb3IgKHZhciB0eXBlIGluIHRoaXMuX21vZGVzKSB7XG5cdFx0XHRpZiAodGhpcy5fbW9kZXMuaGFzT3duUHJvcGVydHkodHlwZSkgJiYgb3B0aW9ucy5oYXNPd25Qcm9wZXJ0eSh0eXBlKSkge1xuXHRcdFx0XHR0aGlzLl9tb2Rlc1t0eXBlXS5oYW5kbGVyLnNldE9wdGlvbnMob3B0aW9uc1t0eXBlXSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9kaXNhYmxlZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuaXNvY2hyb25lKSB7XG5cdFx0XHRidXR0b24gPSB0aGlzLl9tb2Rlcy5pc29jaHJvbmUuYnV0dG9uO1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGJ1dHRvbiwgJ2xlYWZsZXQtZGlzYWJsZWQnKTtcblx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhidXR0b24sICdsZWFmbGV0LWRyYXctdG9vbGJhci1idXR0b24tZW5hYmxlZCcpO1xuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGJ1dHRvbiwgJ2xlYWZsZXQtZHJhdy10b29sYmFyLWJ1dHRvbi1kaXNhYmxlZCcpO1xuXHRcdFx0dGhpcy5fYWN0aXZlTW9kZS5oYW5kbGVyLmRpc2FibGUoKTsgLy9xdWl0YSBlbCBtYXJrZXIgZGVsIHJhdG9uXG5cdFx0XHR0aGlzLl9tb2Rlcy5pc29jaHJvbmUuaGFuZGxlci5fZW5hYmxlZCA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdF9lbmFibGVkOiBmdW5jdGlvbigpe1xuXHRcdGlmICh0aGlzLm9wdGlvbnMuaXNvY2hyb25lKSB7XG5cdFx0XHRidXR0b24gPSB0aGlzLl9tb2Rlcy5pc29jaHJvbmUuYnV0dG9uO1xuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGJ1dHRvbiwgJ2xlYWZsZXQtZGlzYWJsZWQnKTtcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhidXR0b24sICdsZWFmbGV0LWRyYXctdG9vbGJhci1idXR0b24tZW5hYmxlZCcpO1xuXHRcdFx0dGhpcy5fbW9kZXMuaXNvY2hyb25lLmhhbmRsZXIuX2VuYWJsZWQgPSBmYWxzZTtcblx0XHRcdHRoaXMuX21vZGVzLmlzb2Nocm9uZS5oYW5kbGVyLmVuYWJsZSgpO1xuXG5cdFx0XHRcdFx0XHRcblx0XHR9XG5cdH1cbn0pO1xuXG5cbi8qTC5NYXAubWVyZ2VPcHRpb25zKHtcblx0ZWRpdENvbnRyb2w6IHRydWVcbn0pOyovXG5cbkwuRWRpdFRvb2xiYXIgPSBMLlRvb2xiYXIuZXh0ZW5kKHtcblx0b3B0aW9uczoge1xuXHRcdGVkaXQ6IHtcblx0XHRcdHNlbGVjdGVkUGF0aE9wdGlvbnM6IHtcblx0XHRcdFx0Y29sb3I6ICcjZmU1N2ExJywgLyogSG90IHBpbmsgYWxsIHRoZSB0aGluZ3MhICovXG5cdFx0XHRcdG9wYWNpdHk6IDAuNixcblx0XHRcdFx0ZGFzaEFycmF5OiAnMTAsIDEwJyxcblxuXHRcdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0XHRmaWxsQ29sb3I6ICcjZmU1N2ExJyxcblx0XHRcdFx0ZmlsbE9wYWNpdHk6IDAuMVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZWRpdERhdGE6e30sXG5cdFx0cmVtb3ZlOiB7fSxcblx0XHRmZWF0dXJlR3JvdXA6IG51bGwgLyogUkVRVUlSRUQhIFRPRE86IHBlcmhhcHMgaWYgbm90IHNldCB0aGVuIGFsbCBsYXllcnMgb24gdGhlIG1hcCBhcmUgc2VsZWN0YWJsZT8gKi9cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRcdC8vIE5lZWQgdG8gc2V0IHRoaXMgbWFudWFsbHkgc2luY2UgbnVsbCBpcyBhbiBhY2NlcHRhYmxlIHZhbHVlIGhlcmVcblx0XHRpZiAob3B0aW9ucy5lZGl0KSB7XG5cdFx0XHRpZiAodHlwZW9mIG9wdGlvbnMuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zID09PSAndW5kZWZpbmVkJykge1xuXHRcdFx0XHRvcHRpb25zLmVkaXQuc2VsZWN0ZWRQYXRoT3B0aW9ucyA9IHRoaXMub3B0aW9ucy5lZGl0LnNlbGVjdGVkUGF0aE9wdGlvbnM7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmVkaXQgPSBMLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmVkaXQsIG9wdGlvbnMuZWRpdCk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZWRpdERhdGEpIHtcblx0XHRcdG9wdGlvbnMuZWRpdERhdGEgPSBMLmV4dGVuZCh7fSwgdGhpcy5vcHRpb25zLmVkaXREYXRhLCBvcHRpb25zLmVkaXREYXRhKTtcblx0XHR9XG5cdFx0aWYgKG9wdGlvbnMucmVtb3ZlKSB7XG5cdFx0XHRvcHRpb25zLnJlbW92ZSA9IEwuZXh0ZW5kKHt9LCB0aGlzLm9wdGlvbnMucmVtb3ZlLCBvcHRpb25zLnJlbW92ZSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdG9vbGJhckNsYXNzID0gJ2xlYWZsZXQtZHJhdy1lZGl0Jztcblx0XHRMLlRvb2xiYXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuXHRcdHRoaXMuX3NlbGVjdGVkRmVhdHVyZUNvdW50ID0gMDtcblx0fSxcblxuXHRnZXRNb2RlSGFuZGxlcnM6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgZmVhdHVyZUdyb3VwID0gdGhpcy5vcHRpb25zLmZlYXR1cmVHcm91cDtcblx0XHRyZXR1cm4gW1xuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMuZWRpdCxcblx0XHRcdFx0aGFuZGxlcjogbmV3IEwuRWRpdFRvb2xiYXIuRWRpdChtYXAsIHtcblx0XHRcdFx0XHRmZWF0dXJlR3JvdXA6IGZlYXR1cmVHcm91cCxcblx0XHRcdFx0XHRzZWxlY3RlZFBhdGhPcHRpb25zOiB0aGlzLm9wdGlvbnMuZWRpdC5zZWxlY3RlZFBhdGhPcHRpb25zXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmJ1dHRvbnMuZWRpdFxuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0ZW5hYmxlZDogdGhpcy5vcHRpb25zLmVkaXREYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5FZGl0VG9vbGJhci5FZGl0RGF0YShtYXAsIHtcblx0XHRcdFx0XHRmZWF0dXJlR3JvdXA6IGZlYXR1cmVHcm91cFxuXHRcdFx0XHR9KSxcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXREYXRhXG5cdFx0XHR9LFxuXHRcdFx0e1xuXHRcdFx0XHRlbmFibGVkOiB0aGlzLm9wdGlvbnMucmVtb3ZlLFxuXHRcdFx0XHRoYW5kbGVyOiBuZXcgTC5FZGl0VG9vbGJhci5EZWxldGUobWFwLCB7XG5cdFx0XHRcdFx0ZmVhdHVyZUdyb3VwOiBmZWF0dXJlR3JvdXBcblx0XHRcdFx0fSksXG5cdFx0XHRcdHRpdGxlOiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmVcblx0XHRcdH1cblx0XHRdO1xuXHR9LFxuXG5cdGdldEFjdGlvbnM6IGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gW1xuXHRcdFx0e1xuXHRcdFx0XHR0aXRsZTogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmFjdGlvbnMuc2F2ZS50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmFjdGlvbnMuc2F2ZS50ZXh0LFxuXHRcdFx0XHRjYWxsYmFjazogdGhpcy5fc2F2ZSxcblx0XHRcdFx0Y29udGV4dDogdGhpc1xuXHRcdFx0fSxcblx0XHRcdHtcblx0XHRcdFx0dGl0bGU6IEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5hY3Rpb25zLmNhbmNlbC50aXRsZSxcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmFjdGlvbnMuY2FuY2VsLnRleHQsXG5cdFx0XHRcdGNhbGxiYWNrOiB0aGlzLmRpc2FibGUsXG5cdFx0XHRcdGNvbnRleHQ6IHRoaXNcblx0XHRcdH1cblx0XHRdO1xuXHR9LFxuXG5cdGFkZFRvb2xiYXI6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR2YXIgY29udGFpbmVyID0gTC5Ub29sYmFyLnByb3RvdHlwZS5hZGRUb29sYmFyLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdHRoaXMuX2NoZWNrRGlzYWJsZWQoKTtcblxuXHRcdHRoaXMub3B0aW9ucy5mZWF0dXJlR3JvdXAub24oJ2xheWVyYWRkIGxheWVycmVtb3ZlJywgdGhpcy5fY2hlY2tEaXNhYmxlZCwgdGhpcyk7XG5cblx0XHRyZXR1cm4gY29udGFpbmVyO1xuXHR9LFxuXG5cdHJlbW92ZVRvb2xiYXI6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLm9wdGlvbnMuZmVhdHVyZUdyb3VwLm9mZignbGF5ZXJhZGQgbGF5ZXJyZW1vdmUnLCB0aGlzLl9jaGVja0Rpc2FibGVkLCB0aGlzKTtcblxuXHRcdEwuVG9vbGJhci5wcm90b3R5cGUucmVtb3ZlVG9vbGJhci5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdGRpc2FibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAoIXRoaXMuZW5hYmxlZCgpKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fYWN0aXZlTW9kZS5oYW5kbGVyLnJldmVydExheWVycygpO1xuXG5cdFx0TC5Ub29sYmFyLnByb3RvdHlwZS5kaXNhYmxlLmNhbGwodGhpcyk7XG5cdH0sXG5cblx0X3NhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9hY3RpdmVNb2RlLmhhbmRsZXIuc2F2ZSgpO1xuXHRcdHRoaXMuX2FjdGl2ZU1vZGUuaGFuZGxlci5kaXNhYmxlKCk7XG5cdH0sXG5cblx0X2NoZWNrRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZmVhdHVyZUdyb3VwID0gdGhpcy5vcHRpb25zLmZlYXR1cmVHcm91cCxcblx0XHRcdGhhc0xheWVycyA9IGZlYXR1cmVHcm91cC5nZXRMYXllcnMoKS5sZW5ndGggIT09IDAsXG5cdFx0XHRidXR0b247XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLmVkaXQpIHtcblx0XHRcdGJ1dHRvbiA9IHRoaXMuX21vZGVzW0wuRWRpdFRvb2xiYXIuRWRpdC5UWVBFXS5idXR0b247XG5cblx0XHRcdGlmIChoYXNMYXllcnMpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGJ1dHRvbiwgJ2xlYWZsZXQtZGlzYWJsZWQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdCd0aXRsZScsXG5cdFx0XHRcdGhhc0xheWVycyA/XG5cdFx0XHRcdEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXRcblx0XHRcdFx0OiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5lZGl0RGlzYWJsZWRcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5lZGl0RGF0YSkge1xuXHRcdFx0YnV0dG9uID0gdGhpcy5fbW9kZXNbTC5FZGl0VG9vbGJhci5FZGl0RGF0YS5UWVBFXS5idXR0b247XG5cblx0XHRcdGlmIChoYXNMYXllcnMpIHtcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGJ1dHRvbiwgJ2xlYWZsZXQtZGlzYWJsZWQnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9XG5cblx0XHRcdGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXG5cdFx0XHRcdCd0aXRsZScsXG5cdFx0XHRcdGhhc0xheWVycyA/XG5cdFx0XHRcdEwuZHJhd0xvY2FsLmVkaXQudG9vbGJhci5idXR0b25zLmVkaXREYXRhXG5cdFx0XHRcdDogTC5kcmF3TG9jYWwuZWRpdC50b29sYmFyLmJ1dHRvbnMuZWRpdERhdGFEaXNhYmxlZFxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5vcHRpb25zLnJlbW92ZSkge1xuXHRcdFx0YnV0dG9uID0gdGhpcy5fbW9kZXNbTC5FZGl0VG9vbGJhci5EZWxldGUuVFlQRV0uYnV0dG9uO1xuXG5cdFx0XHRpZiAoaGFzTGF5ZXJzKSB7XG5cdFx0XHRcdEwuRG9tVXRpbC5yZW1vdmVDbGFzcyhidXR0b24sICdsZWFmbGV0LWRpc2FibGVkJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoYnV0dG9uLCAnbGVhZmxldC1kaXNhYmxlZCcpO1xuXHRcdFx0fVxuXG5cdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKFxuXHRcdFx0XHQndGl0bGUnLFxuXHRcdFx0XHRoYXNMYXllcnMgP1xuXHRcdFx0XHRMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmVcblx0XHRcdFx0OiBMLmRyYXdMb2NhbC5lZGl0LnRvb2xiYXIuYnV0dG9ucy5yZW1vdmVEaXNhYmxlZFxuXHRcdFx0KTtcblx0XHR9XG5cdH1cbn0pO1xuXG5cbkwuRWRpdFRvb2xiYXIuRWRpdCA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ2VkaXQnXG5cdH0sXG5cblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChtYXAsIG9wdGlvbnMpIHtcblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gU2V0IG9wdGlvbnMgdG8gdGhlIGRlZmF1bHQgdW5sZXNzIGFscmVhZHkgc2V0XG5cdFx0dGhpcy5fc2VsZWN0ZWRQYXRoT3B0aW9ucyA9IG9wdGlvbnMuc2VsZWN0ZWRQYXRoT3B0aW9ucztcblxuXHRcdC8vIFN0b3JlIHRoZSBzZWxlY3RhYmxlIGxheWVyIGdyb3VwIGZvciBlYXNlIG9mIGFjY2Vzc1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IG9wdGlvbnMuZmVhdHVyZUdyb3VwO1xuXG5cdFx0aWYgKCEodGhpcy5fZmVhdHVyZUdyb3VwIGluc3RhbmNlb2YgTC5GZWF0dXJlR3JvdXApKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMuZmVhdHVyZUdyb3VwIG11c3QgYmUgYSBMLkZlYXR1cmVHcm91cCcpO1xuXHRcdH1cblxuXHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2F2ZSB0aGUgdHlwZSBzbyBzdXBlciBjYW4gZmlyZSwgbmVlZCB0byBkbyB0aGlzIGFzIGNhbm5vdCBkbyB0aGlzLlRZUEUgOihcblx0XHR0aGlzLnR5cGUgPSBMLkVkaXRUb29sYmFyLkVkaXQuVFlQRTtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCAhdGhpcy5faGFzQXZhaWxhYmxlTGF5ZXJzKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5maXJlKCdlbmFibGVkJywge2hhbmRsZXI6IHRoaXMudHlwZX0pO1xuXHRcdFx0Ly90aGlzIGRpc2FibGUgb3RoZXIgaGFuZGxlcnNcblxuXHRcdHRoaXMuX21hcC5maXJlKCdkcmF3OmVkaXRzdGFydCcsIHsgaGFuZGxlcjogdGhpcy50eXBlIH0pO1xuXHRcdFx0Ly9hbGxvdyBkcmF3TGF5ZXIgdG8gYmUgdXBkYXRlZCBiZWZvcmUgYmVnaW5uaW5nIGVkaXRpb24uXG5cblx0XHRMLkhhbmRsZXIucHJvdG90eXBlLmVuYWJsZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cFxuXHRcdFx0Lm9uKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRWRpdCwgdGhpcylcblx0XHRcdC5vbignbGF5ZXJyZW1vdmUnLCB0aGlzLl9kaXNhYmxlTGF5ZXJFZGl0LCB0aGlzKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cFxuXHRcdFx0Lm9mZignbGF5ZXJhZGQnLCB0aGlzLl9lbmFibGVMYXllckVkaXQsIHRoaXMpXG5cdFx0XHQub2ZmKCdsYXllcnJlbW92ZScsIHRoaXMuX2Rpc2FibGVMYXllckVkaXQsIHRoaXMpO1xuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX21hcC5maXJlKCdkcmF3OmVkaXRzdG9wJywgeyBoYW5kbGVyOiB0aGlzLnR5cGUgfSk7XG5cdFx0dGhpcy5maXJlKCdkaXNhYmxlZCcsIHtoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRtYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcblxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9lbmFibGVMYXllckVkaXQsIHRoaXMpO1xuXG5cdFx0XHR0aGlzLl90b29sdGlwID0gbmV3IEwuVG9vbHRpcCh0aGlzLl9tYXApO1xuXHRcdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVDb250ZW50KHtcblx0XHRcdFx0dGV4dDogTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAudGV4dCxcblx0XHRcdFx0c3VidGV4dDogTC5kcmF3TG9jYWwuZWRpdC5oYW5kbGVycy5lZGl0LnRvb2x0aXAuc3VidGV4dFxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9tYXApIHtcblx0XHRcdC8vIENsZWFuIHVwIHNlbGVjdGVkIGxheWVycy5cblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIodGhpcy5fZGlzYWJsZUxheWVyRWRpdCwgdGhpcyk7XG5cblx0XHRcdC8vIENsZWFyIHRoZSBiYWNrdXBzIG9mIHRoZSBvcmlnaW5hbCBsYXllcnNcblx0XHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wcyA9IHt9O1xuXG5cdFx0XHR0aGlzLl90b29sdGlwLmRpc3Bvc2UoKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAgPSBudWxsO1xuXG5cdFx0XHR0aGlzLl9tYXAub2ZmKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHJldmVydExheWVyczogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9yZXZlcnRMYXllcihsYXllcik7XG5cdFx0fSwgdGhpcyk7XG5cdH0sXG5cblx0c2F2ZTogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBlZGl0ZWRMYXllcnMgPSBuZXcgTC5MYXllckdyb3VwKCk7XG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRcdGlmIChsYXllci5lZGl0ZWQpIHtcblx0XHRcdFx0ZWRpdGVkTGF5ZXJzLmFkZExheWVyKGxheWVyKTtcblx0XHRcdFx0bGF5ZXIuZWRpdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2RyYXc6ZWRpdGVkJywge2xheWVyczogZWRpdGVkTGF5ZXJzfSk7XG5cdH0sXG5cblx0X2JhY2t1cExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLlV0aWwuc3RhbXAobGF5ZXIpO1xuXG5cdFx0aWYgKCF0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbaWRdKSB7XG5cdFx0XHQvLyBQb2x5bGluZSwgUG9seWdvbiBvciBSZWN0YW5nbGVcblx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuUG9seWxpbmUgfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlnb24gfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLlJlY3RhbmdsZSkge1xuXHRcdFx0XHR0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbaWRdID0ge1xuXHRcdFx0XHRcdGxhdGxuZ3M6IEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZ3MobGF5ZXIuZ2V0TGF0TG5ncygpKVxuXHRcdFx0XHR9O1xuXHRcdFx0fSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlKSB7XG5cdFx0XHRcdHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0gPSB7XG5cdFx0XHRcdFx0bGF0bG5nOiBMLkxhdExuZ1V0aWwuY2xvbmVMYXRMbmcobGF5ZXIuZ2V0TGF0TG5nKCkpLFxuXHRcdFx0XHRcdHJhZGl1czogbGF5ZXIuZ2V0UmFkaXVzKClcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikgeyAvLyBNYXJrZXJcblx0XHRcdFx0dGhpcy5fdW5lZGl0ZWRMYXllclByb3BzW2lkXSA9IHtcblx0XHRcdFx0XHRsYXRsbmc6IEwuTGF0TG5nVXRpbC5jbG9uZUxhdExuZyhsYXllci5nZXRMYXRMbmcoKSlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JldmVydExheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHR2YXIgaWQgPSBMLlV0aWwuc3RhbXAobGF5ZXIpO1xuXHRcdGxheWVyLmVkaXRlZCA9IGZhbHNlO1xuXHRcdGlmICh0aGlzLl91bmVkaXRlZExheWVyUHJvcHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XG5cdFx0XHQvLyBQb2x5bGluZSwgUG9seWdvbiBvciBSZWN0YW5nbGVcblx0XHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuUG9seWxpbmUgfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlnb24gfHwgbGF5ZXIgaW5zdGFuY2VvZiBMLlJlY3RhbmdsZSkge1xuXHRcdFx0XHRsYXllci5zZXRMYXRMbmdzKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0ubGF0bG5ncyk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgTC5DaXJjbGUpIHtcblx0XHRcdFx0bGF5ZXIuc2V0TGF0TG5nKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0ubGF0bG5nKTtcblx0XHRcdFx0bGF5ZXIuc2V0UmFkaXVzKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0ucmFkaXVzKTtcblx0XHRcdH0gZWxzZSBpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikgeyAvLyBNYXJrZXJcblx0XHRcdFx0bGF5ZXIuc2V0TGF0TG5nKHRoaXMuX3VuZWRpdGVkTGF5ZXJQcm9wc1tpZF0ubGF0bG5nKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3RvZ2dsZU1hcmtlckhpZ2hsaWdodDogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdGlmICghbWFya2VyLl9pY29uKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdC8vIFRoaXMgaXMgcXVpdGUgbmF1Z2h0eSwgYnV0IEkgZG9uJ3Qgc2VlIGFub3RoZXIgd2F5IG9mIGRvaW5nIGl0LiAoc2hvcnQgb2Ygc2V0dGluZyBhIG5ldyBpY29uKVxuXHRcdHZhciBpY29uID0gbWFya2VyLl9pY29uO1xuXG5cdFx0aWNvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG5cdFx0aWYgKEwuRG9tVXRpbC5oYXNDbGFzcyhpY29uLCAnbGVhZmxldC1lZGl0LW1hcmtlci1zZWxlY3RlZCcpKSB7XG5cdFx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtZWRpdC1tYXJrZXItc2VsZWN0ZWQnKTtcblx0XHRcdC8vIE9mZnNldCBhcyB0aGUgYm9yZGVyIHdpbGwgbWFrZSB0aGUgaWNvbiBtb3ZlLlxuXHRcdFx0dGhpcy5fb2Zmc2V0TWFya2VyKGljb24sIC00KTtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtZWRpdC1tYXJrZXItc2VsZWN0ZWQnKTtcblx0XHRcdC8vIE9mZnNldCBhcyB0aGUgYm9yZGVyIHdpbGwgbWFrZSB0aGUgaWNvbiBtb3ZlLlxuXHRcdFx0dGhpcy5fb2Zmc2V0TWFya2VyKGljb24sIDQpO1xuXHRcdH1cblxuXHRcdGljb24uc3R5bGUuZGlzcGxheSA9ICcnO1xuXHR9LFxuXG5cdF9vZmZzZXRNYXJrZXI6IGZ1bmN0aW9uIChpY29uLCBvZmZzZXQpIHtcblx0XHR2YXIgaWNvbk1hcmdpblRvcCA9IHBhcnNlSW50KGljb24uc3R5bGUubWFyZ2luVG9wLCAxMCkgLSBvZmZzZXQsXG5cdFx0XHRpY29uTWFyZ2luTGVmdCA9IHBhcnNlSW50KGljb24uc3R5bGUubWFyZ2luTGVmdCwgMTApIC0gb2Zmc2V0O1xuXG5cdFx0aWNvbi5zdHlsZS5tYXJnaW5Ub3AgPSBpY29uTWFyZ2luVG9wICsgJ3B4Jztcblx0XHRpY29uLnN0eWxlLm1hcmdpbkxlZnQgPSBpY29uTWFyZ2luTGVmdCArICdweCc7XG5cdH0sXG5cblx0X2VuYWJsZUxheWVyRWRpdDogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbGF5ZXIgPSBlLmxheWVyIHx8IGUudGFyZ2V0IHx8IGUsXG5cdFx0XHRpc01hcmtlciA9IGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIsXG5cdFx0XHRwYXRoT3B0aW9ucztcblxuXHRcdC8vIERvbid0IGRvIGFueXRoaW5nIGlmIHRoaXMgbGF5ZXIgaXMgYSBtYXJrZXIgYnV0IGRvZXNuJ3QgaGF2ZSBhbiBpY29uLiBNYXJrZXJzXG5cdFx0Ly8gc2hvdWxkIHVzdWFsbHkgaGF2ZSBpY29ucy4gSWYgdXNpbmcgTGVhZmxldC5kcmF3IHdpdGggTGVhZmxlci5tYXJrZXJjbHVzdGVyIHRoZXJlXG5cdFx0Ly8gaXMgYSBjaGFuY2UgdGhhdCBhIG1hcmtlciBkb2Vzbid0LlxuXHRcdGlmIChpc01hcmtlciAmJiAhbGF5ZXIuX2ljb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBCYWNrIHVwIHRoaXMgbGF5ZXIgKGlmIGhhdmVuJ3QgYmVmb3JlKVxuXHRcdHRoaXMuX2JhY2t1cExheWVyKGxheWVyKTtcblxuXHRcdC8vIFVwZGF0ZSBsYXllciBzdHlsZSBzbyBhcHBlYXJzIGVkaXRhYmxlXG5cdFx0aWYgKHRoaXMuX3NlbGVjdGVkUGF0aE9wdGlvbnMpIHtcblx0XHRcdHBhdGhPcHRpb25zID0gTC5VdGlsLmV4dGVuZCh7fSwgdGhpcy5fc2VsZWN0ZWRQYXRoT3B0aW9ucyk7XG5cblx0XHRcdGlmIChpc01hcmtlcikge1xuXHRcdFx0XHR0aGlzLl90b2dnbGVNYXJrZXJIaWdobGlnaHQobGF5ZXIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGF5ZXIub3B0aW9ucy5wcmV2aW91c09wdGlvbnMgPSBMLlV0aWwuZXh0ZW5kKHsgZGFzaEFycmF5OiBudWxsIH0sIGxheWVyLm9wdGlvbnMpO1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IFBvbHlsaW5lcyBhcmUgbm90IGZpbGxlZFxuXHRcdFx0XHRpZiAoIShsYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlKSAmJiAhKGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5Z29uKSAmJiAhKGxheWVyIGluc3RhbmNlb2YgTC5SZWN0YW5nbGUpKSB7XG5cdFx0XHRcdFx0cGF0aE9wdGlvbnMuZmlsbCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0bGF5ZXIuc2V0U3R5bGUocGF0aE9wdGlvbnMpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChpc01hcmtlcikge1xuXHRcdFx0bGF5ZXIuZHJhZ2dpbmcuZW5hYmxlKCk7XG5cdFx0XHRsYXllci5vbignZHJhZ2VuZCcsIHRoaXMuX29uTWFya2VyRHJhZ0VuZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLmVkaXRpbmcuZW5hYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kaXNhYmxlTGF5ZXJFZGl0OiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblx0XHRsYXllci5lZGl0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIFJlc2V0IGxheWVyIHN0eWxlcyB0byB0aGF0IG9mIGJlZm9yZSBzZWxlY3Rcblx0XHRpZiAodGhpcy5fc2VsZWN0ZWRQYXRoT3B0aW9ucykge1xuXHRcdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIpIHtcblx0XHRcdFx0dGhpcy5fdG9nZ2xlTWFya2VySGlnaGxpZ2h0KGxheWVyKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vIHJlc2V0IHRoZSBsYXllciBzdHlsZSB0byB3aGF0IGlzIHdhcyBiZWZvcmUgYmVpbmcgc2VsZWN0ZWRcblx0XHRcdFx0bGF5ZXIuc2V0U3R5bGUobGF5ZXIub3B0aW9ucy5wcmV2aW91c09wdGlvbnMpO1xuXHRcdFx0XHQvLyByZW1vdmUgdGhlIGNhY2hlZCBvcHRpb25zIGZvciB0aGUgbGF5ZXIgb2JqZWN0XG5cdFx0XHRcdGRlbGV0ZSBsYXllci5vcHRpb25zLnByZXZpb3VzT3B0aW9ucztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0bGF5ZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXHRcdFx0bGF5ZXIub2ZmKCdkcmFnZW5kJywgdGhpcy5fb25NYXJrZXJEcmFnRW5kLCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bGF5ZXIuZWRpdGluZy5kaXNhYmxlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9vbk1hcmtlckRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS50YXJnZXQ7XG5cdFx0bGF5ZXIuZWRpdGVkID0gdHJ1ZTtcblx0fSxcblxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dGhpcy5fdG9vbHRpcC51cGRhdGVQb3NpdGlvbihlLmxhdGxuZyk7XG5cdH0sXG5cblx0X2hhc0F2YWlsYWJsZUxheWVyczogZnVuY3Rpb24gKCkge1xuXHRcdHJldHVybiB0aGlzLl9mZWF0dXJlR3JvdXAuZ2V0TGF5ZXJzKCkubGVuZ3RoICE9PSAwO1xuXHR9XG59KTtcblxuTC5FZGl0VG9vbGJhci5FZGl0RGF0YSA9IEwuSGFuZGxlci5leHRlbmQoe1xuXHRzdGF0aWNzOiB7XG5cdFx0VFlQRTogJ2VkaXREYXRhJyAvLyBub3QgZGVsZXRlIGFzIGRlbGV0ZSBpcyByZXNlcnZlZCBpbiBqc1xuXHR9LFxuXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwKTtcblxuXG5cdFx0Ly8gU3RvcmUgdGhlIHNlbGVjdGFibGUgbGF5ZXIgZ3JvdXAgZm9yIGVhc2Ugb2YgYWNjZXNzXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwID0gb3B0aW9ucy5mZWF0dXJlR3JvdXA7XG5cblx0XHRpZiAoISh0aGlzLl9mZWF0dXJlR3JvdXAgaW5zdGFuY2VvZiBMLkZlYXR1cmVHcm91cCkpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5mZWF0dXJlR3JvdXAgbXVzdCBiZSBhIEwuRmVhdHVyZUdyb3VwJyk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fdW5lZGl0ZWRMYXllclByb3BzID0ge307XG5cblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRWRpdFRvb2xiYXIuRWRpdERhdGEuVFlQRTtcblx0fSxcblxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fZW5hYmxlZCB8fCAhdGhpcy5faGFzQXZhaWxhYmxlTGF5ZXJzKCkpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5maXJlKCdlbmFibGVkJywgeyBoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblxuXHRcdHRoaXMuX21hcC5maXJlKCdkcmF3OmVkaXREYXRhc3RhcnQnLCB7IGhhbmRsZXI6IHRoaXMudHlwZSB9KTtcblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZW5hYmxlLmNhbGwodGhpcyk7XG5cblx0XHR0aGlzLl9mZWF0dXJlR3JvdXBcblx0XHRcdC5vbignbGF5ZXJhZGQnLCB0aGlzLl9lbmFibGVMYXllckVkaXREYXRhLCB0aGlzKVxuXHRcdFx0Lm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX2Rpc2FibGVMYXllckVkaXREYXRhLCB0aGlzKTtcblx0fSxcblxuXHRkaXNhYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxuXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwXG5cdFx0XHQub2ZmKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRWRpdERhdGEsIHRoaXMpXG5cdFx0XHQub2ZmKCdsYXllcnJlbW92ZScsIHRoaXMuX2Rpc2FibGVMYXllckVkaXREYXRhLCB0aGlzKTtcblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2RyYXc6ZWRpdERhdGFzdG9wJywgeyBoYW5kbGVyOiB0aGlzLnR5cGUgfSk7XG5cblx0XHR0aGlzLmZpcmUoJ2Rpc2FibGVkJywgeyBoYW5kbGVyOiB0aGlzLnR5cGV9KTtcblx0fSxcblxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XG5cblx0XHRpZiAobWFwKSB7XG5cdFx0XHRtYXAuZ2V0Q29udGFpbmVyKCkuZm9jdXMoKTtcblxuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLmVhY2hMYXllcih0aGlzLl9lbmFibGVMYXllckVkaXREYXRhLCB0aGlzKTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBMLlRvb2x0aXAodGhpcy5fbWFwKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh7IHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMuZWRpdERhdGEudG9vbHRpcC50ZXh0IH0pO1xuXG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKHRoaXMuX2Rpc2FibGVMYXllckVkaXREYXRhLCB0aGlzKTtcblxuXG5cdFx0XHQvLyBDbGVhciB0aGUgYmFja3VwcyBvZiB0aGUgb3JpZ2luYWwgbGF5ZXJzXG5cdFx0XHR0aGlzLl91bmVkaXRlZExheWVyUHJvcHMgPSB7fTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcC5kaXNwb3NlKCk7XG5cdFx0XHR0aGlzLl90b29sdGlwID0gbnVsbDtcblxuXHRcdFx0dGhpcy5fbWFwLm9mZignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRyZXZlcnRMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuZWFjaExheWVyKGZ1bmN0aW9uIChsYXllcikge1xuXHRcdFx0dGhpcy5fcmV2ZXJ0TGF5ZXIobGF5ZXIpO1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdF9yZXZlcnRMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0dmFyIGlkID0gTC5VdGlsLnN0YW1wKGxheWVyKTtcblx0XHRsYXllci5lZGl0ZWQgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5fdW5lZGl0ZWRMYXllclByb3BzLmhhc093blByb3BlcnR5KGlkKSkge1xuXHRcdFx0Ly8gUG9seWxpbmUsIFBvbHlnb24gb3IgUmVjdGFuZ2xlXG5cdFx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLlBvbHlsaW5lIHx8IGxheWVyIGluc3RhbmNlb2YgTC5Qb2x5Z29uIHx8IGxheWVyIGluc3RhbmNlb2YgTC5SZWN0YW5nbGUpIHtcblx0XHRcdFx0bGF5ZXIuc2V0TGF0TG5ncyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbaWRdLmxhdGxuZ3MpO1xuXHRcdFx0fSBlbHNlIGlmIChsYXllciBpbnN0YW5jZW9mIEwuQ2lyY2xlKSB7XG5cdFx0XHRcdGxheWVyLnNldExhdExuZyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbaWRdLmxhdGxuZyk7XG5cdFx0XHRcdGxheWVyLnNldFJhZGl1cyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbaWRdLnJhZGl1cyk7XG5cdFx0XHR9IGVsc2UgaWYgKGxheWVyIGluc3RhbmNlb2YgTC5NYXJrZXIpIHsgLy8gTWFya2VyXG5cdFx0XHRcdGxheWVyLnNldExhdExuZyh0aGlzLl91bmVkaXRlZExheWVyUHJvcHNbaWRdLmxhdGxuZyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZWRpdGVkTGF5ZXJzID0gbmV3IEwuTGF5ZXJHcm91cCgpO1xuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHRpZiAobGF5ZXIuZWRpdGVkKSB7XG5cdFx0XHRcdGVkaXRlZExheWVycy5hZGRMYXllcihsYXllcik7XG5cdFx0XHRcdGxheWVyLmVkaXRlZCA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdHRoaXMuX21hcC5maXJlKCdkcmF3OmVkaXRlZERhdGEnLCB7bGF5ZXJzOiBlZGl0ZWRMYXllcnN9KTtcblxuXHR9LFxuXG5cdF9lbmFibGVMYXllckVkaXREYXRhOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuXHRcdFx0bGF5ZXIuZHJhZ2dpbmcuZGlzYWJsZSgpO1xuXHRcdFx0bGF5ZXIub24oJ2NsaWNrJywgdGhpcy5fZWRpdERhdGFMYXllciwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLmVkaXRpbmcuZGlzYWJsZSgpO1xuXHRcdH1cblxuXHRcdFxuXHR9LFxuXG5cdF9kaXNhYmxlTGF5ZXJFZGl0RGF0YTogZnVuY3Rpb24gKGUpIHtcblxuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XG5cdFx0XHRsYXllci5kcmFnZ2luZy5kaXNhYmxlKCk7XG5cdFx0XHRsYXllci5vZmYoJ2NsaWNrJywgdGhpcy5fZWRpdERhdGFMYXllciwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxheWVyLmVkaXRpbmcuZGlzYWJsZSgpO1xuXHRcdH1cblxuXHR9LFxuXG5cdF9lZGl0RGF0YUxheWVyOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUudGFyZ2V0O1xuXHRcdGxheWVyLmVkaXRlZCA9IHRydWU7XG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2VkaXRBdHRyaWJ1dGVzJywge2xheWVyOiBsYXllcn0pO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGUubGF0bG5nKTtcblx0fSxcblxuXHRfaGFzQXZhaWxhYmxlTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ZlYXR1cmVHcm91cC5nZXRMYXllcnMoKS5sZW5ndGggIT09IDA7XG5cdH1cbn0pO1xuXG5cbkwuRWRpdFRvb2xiYXIuRGVsZXRlID0gTC5IYW5kbGVyLmV4dGVuZCh7XG5cdHN0YXRpY3M6IHtcblx0XHRUWVBFOiAncmVtb3ZlJyAvLyBub3QgZGVsZXRlIGFzIGRlbGV0ZSBpcyByZXNlcnZlZCBpbiBqc1xuXHR9LFxuXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwLCBvcHRpb25zKSB7XG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbWFwKTtcblxuXHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG5cdFx0Ly8gU3RvcmUgdGhlIHNlbGVjdGFibGUgbGF5ZXIgZ3JvdXAgZm9yIGVhc2Ugb2YgYWNjZXNzXG5cdFx0dGhpcy5fZGVsZXRhYmxlTGF5ZXJzID0gdGhpcy5vcHRpb25zLmZlYXR1cmVHcm91cDtcblxuXHRcdGlmICghKHRoaXMuX2RlbGV0YWJsZUxheWVycyBpbnN0YW5jZW9mIEwuRmVhdHVyZUdyb3VwKSkge1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdvcHRpb25zLmZlYXR1cmVHcm91cCBtdXN0IGJlIGEgTC5GZWF0dXJlR3JvdXAnKTtcblx0XHR9XG5cblx0XHQvLyBTYXZlIHRoZSB0eXBlIHNvIHN1cGVyIGNhbiBmaXJlLCBuZWVkIHRvIGRvIHRoaXMgYXMgY2Fubm90IGRvIHRoaXMuVFlQRSA6KFxuXHRcdHRoaXMudHlwZSA9IEwuRWRpdFRvb2xiYXIuRGVsZXRlLlRZUEU7XG5cdH0sXG5cblx0ZW5hYmxlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQgfHwgIXRoaXMuX2hhc0F2YWlsYWJsZUxheWVycygpKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuZmlyZSgnZW5hYmxlZCcsIHsgaGFuZGxlcjogdGhpcy50eXBlfSk7XG5cblx0XHR0aGlzLl9tYXAuZmlyZSgnZHJhdzpkZWxldGVzdGFydCcsIHsgaGFuZGxlcjogdGhpcy50eXBlIH0pO1xuXG5cdFx0TC5IYW5kbGVyLnByb3RvdHlwZS5lbmFibGUuY2FsbCh0aGlzKTtcblxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVyc1xuXHRcdFx0Lm9uKCdsYXllcmFkZCcsIHRoaXMuX2VuYWJsZUxheWVyRGVsZXRlLCB0aGlzKVxuXHRcdFx0Lm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX2Rpc2FibGVMYXllckRlbGV0ZSwgdGhpcyk7XG5cdH0sXG5cblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fZW5hYmxlZCkgeyByZXR1cm47IH1cblxuXHRcdHRoaXMuX2RlbGV0YWJsZUxheWVyc1xuXHRcdFx0Lm9mZignbGF5ZXJhZGQnLCB0aGlzLl9lbmFibGVMYXllckRlbGV0ZSwgdGhpcylcblx0XHRcdC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fZGlzYWJsZUxheWVyRGVsZXRlLCB0aGlzKTtcblxuXHRcdEwuSGFuZGxlci5wcm90b3R5cGUuZGlzYWJsZS5jYWxsKHRoaXMpO1xuXG5cdFx0dGhpcy5fbWFwLmZpcmUoJ2RyYXc6ZGVsZXRlc3RvcCcsIHsgaGFuZGxlcjogdGhpcy50eXBlIH0pO1xuXG5cdFx0dGhpcy5maXJlKCdkaXNhYmxlZCcsIHsgaGFuZGxlcjogdGhpcy50eXBlfSk7XG5cdH0sXG5cblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKG1hcCkge1xuXHRcdFx0bWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XG5cblx0XHRcdHRoaXMuX2RlbGV0YWJsZUxheWVycy5lYWNoTGF5ZXIodGhpcy5fZW5hYmxlTGF5ZXJEZWxldGUsIHRoaXMpO1xuXHRcdFx0dGhpcy5fZGVsZXRlZExheWVycyA9IG5ldyBMLmxheWVyR3JvdXAoKTtcblxuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG5ldyBMLlRvb2x0aXAodGhpcy5fbWFwKTtcblx0XHRcdHRoaXMuX3Rvb2x0aXAudXBkYXRlQ29udGVudCh7IHRleHQ6IEwuZHJhd0xvY2FsLmVkaXQuaGFuZGxlcnMucmVtb3ZlLnRvb2x0aXAudGV4dCB9KTtcblxuXHRcdFx0dGhpcy5fbWFwLm9uKCdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSwgdGhpcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fZGVsZXRhYmxlTGF5ZXJzLmVhY2hMYXllcih0aGlzLl9kaXNhYmxlTGF5ZXJEZWxldGUsIHRoaXMpO1xuXHRcdFx0dGhpcy5fZGVsZXRlZExheWVycyA9IG51bGw7XG5cblx0XHRcdHRoaXMuX3Rvb2x0aXAuZGlzcG9zZSgpO1xuXHRcdFx0dGhpcy5fdG9vbHRpcCA9IG51bGw7XG5cblx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcblx0XHR9XG5cdH0sXG5cblx0cmV2ZXJ0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gSXRlcmF0ZSBvZiB0aGUgZGVsZXRlZCBsYXllcnMgYW5kIGFkZCB0aGVtIGJhY2sgaW50byB0aGUgZmVhdHVyZUdyb3VwXG5cdFx0dGhpcy5fZGVsZXRlZExheWVycy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0XHR0aGlzLl9kZWxldGFibGVMYXllcnMuYWRkTGF5ZXIobGF5ZXIpO1xuXHRcdH0sIHRoaXMpO1xuXHR9LFxuXG5cdHNhdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAuZmlyZSgnZHJhdzpkZWxldGVkJywgeyBsYXllcnM6IHRoaXMuX2RlbGV0ZWRMYXllcnMgfSk7XG5cdH0sXG5cblx0X2VuYWJsZUxheWVyRGVsZXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLm9uKCdjbGljaycsIHRoaXMuX3JlbW92ZUxheWVyLCB0aGlzKTtcblx0fSxcblxuXHRfZGlzYWJsZUxheWVyRGVsZXRlOiBmdW5jdGlvbiAoZSkge1xuXHRcdHZhciBsYXllciA9IGUubGF5ZXIgfHwgZS50YXJnZXQgfHwgZTtcblxuXHRcdGxheWVyLm9mZignY2xpY2snLCB0aGlzLl9yZW1vdmVMYXllciwgdGhpcyk7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSB0aGUgZGVsZXRlZCBsYXllcnMgc28gd2UgY2FuJ3QgYWNjaWRlbnRseSByZXZlcnQgaWYgdGhlIHVzZXIgcHJlc3NlcyBjYW5jZWxcblx0XHR0aGlzLl9kZWxldGVkTGF5ZXJzLnJlbW92ZUxheWVyKGxheWVyKTtcblx0fSxcblxuXHRfcmVtb3ZlTGF5ZXI6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIGxheWVyID0gZS5sYXllciB8fCBlLnRhcmdldCB8fCBlO1xuXG5cdFx0dGhpcy5fZGVsZXRhYmxlTGF5ZXJzLnJlbW92ZUxheWVyKGxheWVyKTtcblxuXHRcdHRoaXMuX2RlbGV0ZWRMYXllcnMuYWRkTGF5ZXIobGF5ZXIpO1xuXHR9LFxuXG5cdF9vbk1vdXNlTW92ZTogZnVuY3Rpb24gKGUpIHtcblx0XHR0aGlzLl90b29sdGlwLnVwZGF0ZVBvc2l0aW9uKGUubGF0bG5nKTtcblx0fSxcblxuXHRfaGFzQXZhaWxhYmxlTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlbGV0YWJsZUxheWVycy5nZXRMYXllcnMoKS5sZW5ndGggIT09IDA7XG5cdH1cbn0pO1xuXG5cbn0od2luZG93LCBkb2N1bWVudCkpOyIsIi8qXG4gTGVhZmxldC5tYXJrZXJjbHVzdGVyLCBQcm92aWRlcyBCZWF1dGlmdWwgQW5pbWF0ZWQgTWFya2VyIENsdXN0ZXJpbmcgZnVuY3Rpb25hbGl0eSBmb3IgTGVhZmxldCwgYSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzLlxuIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQubWFya2VyY2x1c3RlclxuIChjKSAyMDEyLTIwMTMsIERhdmUgTGVhdmVyLCBzbWFydHJha1xuKi9cbihmdW5jdGlvbiAod2luZG93LCBkb2N1bWVudCwgdW5kZWZpbmVkKSB7XG4vKlxuICogTC5NYXJrZXJDbHVzdGVyR3JvdXAgZXh0ZW5kcyBMLkZlYXR1cmVHcm91cCBieSBjbHVzdGVyaW5nIHRoZSBtYXJrZXJzIGNvbnRhaW5lZCB3aXRoaW5cbiAqL1xuXG5MLk1hcmtlckNsdXN0ZXJHcm91cCA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XG5cblx0b3B0aW9uczoge1xuXHRcdG1heENsdXN0ZXJSYWRpdXM6IDgwLCAvL0EgY2x1c3RlciB3aWxsIGNvdmVyIGF0IG1vc3QgdGhpcyBtYW55IHBpeGVscyBmcm9tIGl0cyBjZW50ZXJcblx0XHRpY29uQ3JlYXRlRnVuY3Rpb246IG51bGwsXG5cblx0XHRzcGlkZXJmeU9uTWF4Wm9vbTogdHJ1ZSxcblx0XHRzaG93Q292ZXJhZ2VPbkhvdmVyOiB0cnVlLFxuXHRcdHpvb21Ub0JvdW5kc09uQ2xpY2s6IHRydWUsXG5cdFx0c2luZ2xlTWFya2VyTW9kZTogZmFsc2UsXG5cblx0XHRkaXNhYmxlQ2x1c3RlcmluZ0F0Wm9vbTogbnVsbCxcblxuXHRcdC8vIFNldHRpbmcgdGhpcyB0byBmYWxzZSBwcmV2ZW50cyB0aGUgcmVtb3ZhbCBvZiBhbnkgY2x1c3RlcnMgb3V0c2lkZSBvZiB0aGUgdmlld3BvaW50LCB3aGljaFxuXHRcdC8vIGlzIHRoZSBkZWZhdWx0IGJlaGF2aW91ciBmb3IgcGVyZm9ybWFuY2UgcmVhc29ucy5cblx0XHRyZW1vdmVPdXRzaWRlVmlzaWJsZUJvdW5kczogdHJ1ZSxcblxuXHRcdC8vV2hldGhlciB0byBhbmltYXRlIGFkZGluZyBtYXJrZXJzIGFmdGVyIGFkZGluZyB0aGUgTWFya2VyQ2x1c3Rlckdyb3VwIHRvIHRoZSBtYXBcblx0XHQvLyBJZiB5b3UgYXJlIGFkZGluZyBpbmRpdmlkdWFsIG1hcmtlcnMgc2V0IHRvIHRydWUsIGlmIGFkZGluZyBidWxrIG1hcmtlcnMgbGVhdmUgZmFsc2UgZm9yIG1hc3NpdmUgcGVyZm9ybWFuY2UgZ2FpbnMuXG5cdFx0YW5pbWF0ZUFkZGluZ01hcmtlcnM6IGZhbHNlLFxuXG5cdFx0Ly9JbmNyZWFzZSB0byBpbmNyZWFzZSB0aGUgZGlzdGFuY2UgYXdheSB0aGF0IHNwaWRlcmZpZWQgbWFya2VycyBhcHBlYXIgZnJvbSB0aGUgY2VudGVyXG5cdFx0c3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXI6IDEsXG5cblx0XHQvL09wdGlvbnMgdG8gcGFzcyB0byB0aGUgTC5Qb2x5Z29uIGNvbnN0cnVjdG9yXG5cdFx0cG9seWdvbk9wdGlvbnM6IHt9XG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcblx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24pIHtcblx0XHRcdHRoaXMub3B0aW9ucy5pY29uQ3JlYXRlRnVuY3Rpb24gPSB0aGlzLl9kZWZhdWx0SWNvbkNyZWF0ZUZ1bmN0aW9uO1xuXHRcdH1cblxuXHRcdHRoaXMuX2ZlYXR1cmVHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLm9uKEwuRmVhdHVyZUdyb3VwLkVWRU5UUywgdGhpcy5fcHJvcGFnYXRlRXZlbnQsIHRoaXMpO1xuXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cCA9IEwuZmVhdHVyZUdyb3VwKCk7XG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5vbihMLkZlYXR1cmVHcm91cC5FVkVOVFMsIHRoaXMuX3Byb3BhZ2F0ZUV2ZW50LCB0aGlzKTtcblxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbiA9IDA7XG5cdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XG5cdFx0dGhpcy5fbmVlZHNSZW1vdmluZyA9IFtdOyAvL01hcmtlcnMgcmVtb3ZlZCB3aGlsZSB3ZSBhcmVuJ3Qgb24gdGhlIG1hcCBuZWVkIHRvIGJlIGtlcHQgdHJhY2sgb2Zcblx0XHQvL1RoZSBib3VuZHMgb2YgdGhlIGN1cnJlbnRseSBzaG93biBhcmVhIChmcm9tIF9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMpIFVwZGF0ZWQgb24gem9vbS9tb3ZlXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbnVsbDtcblxuXHRcdHRoaXMuX3F1ZXVlID0gW107XG5cdH0sXG5cblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xuXG5cdFx0aWYgKGxheWVyIGluc3RhbmNlb2YgTC5MYXllckdyb3VwKSB7XG5cdFx0XHR2YXIgYXJyYXkgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgaW4gbGF5ZXIuX2xheWVycykge1xuXHRcdFx0XHRhcnJheS5wdXNoKGxheWVyLl9sYXllcnNbaV0pO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXJzKGFycmF5KTtcblx0XHR9XG5cblx0XHQvL0Rvbid0IGNsdXN0ZXIgbm9uIHBvaW50IGRhdGFcblx0XHRpZiAoIWxheWVyLmdldExhdExuZykge1xuXHRcdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5hZGRMYXllcihsYXllcik7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuX21hcCkge1xuXHRcdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nLnB1c2gobGF5ZXIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblxuXHRcdC8vSWYgd2UgaGF2ZSBhbHJlYWR5IGNsdXN0ZXJlZCB3ZSdsbCBuZWVkIHRvIGFkZCB0aGlzIG9uZSB0byBhIGNsdXN0ZXJcblxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIHRoaXMuX21heFpvb20pO1xuXG5cdFx0Ly9Xb3JrIG91dCB3aGF0IGlzIHZpc2libGVcblx0XHR2YXIgdmlzaWJsZUxheWVyID0gbGF5ZXIsXG5cdFx0XHRjdXJyZW50Wm9vbSA9IHRoaXMuX21hcC5nZXRab29tKCk7XG5cdFx0aWYgKGxheWVyLl9fcGFyZW50KSB7XG5cdFx0XHR3aGlsZSAodmlzaWJsZUxheWVyLl9fcGFyZW50Ll96b29tID49IGN1cnJlbnRab29tKSB7XG5cdFx0XHRcdHZpc2libGVMYXllciA9IHZpc2libGVMYXllci5fX3BhcmVudDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodGhpcy5fY3VycmVudFNob3duQm91bmRzLmNvbnRhaW5zKHZpc2libGVMYXllci5nZXRMYXRMbmcoKSkpIHtcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuYW5pbWF0ZUFkZGluZ01hcmtlcnMpIHtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXIobGF5ZXIsIHZpc2libGVMYXllcik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLl9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkKGxheWVyLCB2aXNpYmxlTGF5ZXIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cblx0XHRpZiAobGF5ZXIgaW5zdGFuY2VvZiBMLkxheWVyR3JvdXApXG5cdFx0e1xuXHRcdFx0dmFyIGFycmF5ID0gW107XG5cdFx0XHRmb3IgKHZhciBpIGluIGxheWVyLl9sYXllcnMpIHtcblx0XHRcdFx0YXJyYXkucHVzaChsYXllci5fbGF5ZXJzW2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJlbW92ZUxheWVycyhhcnJheSk7XG5cdFx0fVxuXG5cdFx0Ly9Ob24gcG9pbnQgbGF5ZXJzXG5cdFx0aWYgKCFsYXllci5nZXRMYXRMbmcpIHtcblx0XHRcdHRoaXMuX25vblBvaW50R3JvdXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdGlmICghdGhpcy5fYXJyYXlTcGxpY2UodGhpcy5fbmVlZHNDbHVzdGVyaW5nLCBsYXllcikgJiYgdGhpcy5oYXNMYXllcihsYXllcikpIHtcblx0XHRcdFx0dGhpcy5fbmVlZHNSZW1vdmluZy5wdXNoKGxheWVyKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICghbGF5ZXIuX19wYXJlbnQpIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl91bnNwaWRlcmZ5KSB7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdFx0XHR0aGlzLl91bnNwaWRlcmZ5TGF5ZXIobGF5ZXIpO1xuXHRcdH1cblxuXHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBjbHVzdGVyc1xuXHRcdHRoaXMuX3JlbW92ZUxheWVyKGxheWVyLCB0cnVlKTtcblxuXHRcdGlmICh0aGlzLl9mZWF0dXJlR3JvdXAuaGFzTGF5ZXIobGF5ZXIpKSB7XG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuXHRcdFx0aWYgKGxheWVyLnNldE9wYWNpdHkpIHtcblx0XHRcdFx0bGF5ZXIuc2V0T3BhY2l0eSgxKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvL1Rha2VzIGFuIGFycmF5IG9mIG1hcmtlcnMgYW5kIGFkZHMgdGhlbSBpbiBidWxrXG5cdGFkZExheWVyczogZnVuY3Rpb24gKGxheWVyc0FycmF5KSB7XG5cdFx0dmFyIGksIGwsIG0sXG5cdFx0XHRvbk1hcCA9IHRoaXMuX21hcCxcblx0XHRcdGZnID0gdGhpcy5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0bnBnID0gdGhpcy5fbm9uUG9pbnRHcm91cDtcblxuXHRcdGZvciAoaSA9IDAsIGwgPSBsYXllcnNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdG0gPSBsYXllcnNBcnJheVtpXTtcblxuXHRcdFx0Ly9Ob3QgcG9pbnQgZGF0YSwgY2FuJ3QgYmUgY2x1c3RlcmVkXG5cdFx0XHRpZiAoIW0uZ2V0TGF0TG5nKSB7XG5cdFx0XHRcdG5wZy5hZGRMYXllcihtKTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0aGlzLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIW9uTWFwKSB7XG5cdFx0XHRcdHRoaXMuX25lZWRzQ2x1c3RlcmluZy5wdXNoKG0pO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIobSwgdGhpcy5fbWF4Wm9vbSk7XG5cblx0XHRcdC8vSWYgd2UganVzdCBtYWRlIGEgY2x1c3RlciBvZiBzaXplIDIgdGhlbiB3ZSBuZWVkIHRvIHJlbW92ZSB0aGUgb3RoZXIgbWFya2VyIGZyb20gdGhlIG1hcCAoaWYgaXQgaXMpIG9yIHdlIG5ldmVyIHdpbGxcblx0XHRcdGlmIChtLl9fcGFyZW50KSB7XG5cdFx0XHRcdGlmIChtLl9fcGFyZW50LmdldENoaWxkQ291bnQoKSA9PT0gMikge1xuXHRcdFx0XHRcdHZhciBtYXJrZXJzID0gbS5fX3BhcmVudC5nZXRBbGxDaGlsZE1hcmtlcnMoKSxcblx0XHRcdFx0XHRcdG90aGVyTWFya2VyID0gbWFya2Vyc1swXSA9PT0gbSA/IG1hcmtlcnNbMV0gOiBtYXJrZXJzWzBdO1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKG90aGVyTWFya2VyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChvbk1hcCkge1xuXHRcdFx0Ly9VcGRhdGUgdGhlIGljb25zIG9mIGFsbCB0aG9zZSB2aXNpYmxlIGNsdXN0ZXJzIHRoYXQgd2VyZSBhZmZlY3RlZFxuXHRcdFx0ZmcuZWFjaExheWVyKGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdGlmIChjIGluc3RhbmNlb2YgTC5NYXJrZXJDbHVzdGVyICYmIGMuX2ljb25OZWVkc1VwZGF0ZSkge1xuXHRcdFx0XHRcdGMuX3VwZGF0ZUljb24oKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwKG51bGwsIHRoaXMuX3pvb20sIHRoaXMuX2N1cnJlbnRTaG93bkJvdW5kcyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Ly9UYWtlcyBhbiBhcnJheSBvZiBtYXJrZXJzIGFuZCByZW1vdmVzIHRoZW0gaW4gYnVsa1xuXHRyZW1vdmVMYXllcnM6IGZ1bmN0aW9uIChsYXllcnNBcnJheSkge1xuXHRcdHZhciBpLCBsLCBtLFxuXHRcdFx0ZmcgPSB0aGlzLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRucGcgPSB0aGlzLl9ub25Qb2ludEdyb3VwO1xuXG5cdFx0aWYgKCF0aGlzLl9tYXApIHtcblx0XHRcdGZvciAoaSA9IDAsIGwgPSBsYXllcnNBcnJheS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0bSA9IGxheWVyc0FycmF5W2ldO1xuXHRcdFx0XHR0aGlzLl9hcnJheVNwbGljZSh0aGlzLl9uZWVkc0NsdXN0ZXJpbmcsIG0pO1xuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsID0gbGF5ZXJzQXJyYXkubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRtID0gbGF5ZXJzQXJyYXlbaV07XG5cblx0XHRcdGlmICghbS5fX3BhcmVudCkge1xuXHRcdFx0XHRucGcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcihtLCB0cnVlLCB0cnVlKTtcblxuXHRcdFx0aWYgKGZnLmhhc0xheWVyKG0pKSB7XG5cdFx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRpZiAobS5zZXRPcGFjaXR5KSB7XG5cdFx0XHRcdFx0bS5zZXRPcGFjaXR5KDEpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly9GaXggdXAgdGhlIGNsdXN0ZXJzIGFuZCBtYXJrZXJzIG9uIHRoZSBtYXBcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xuXG5cdFx0ZmcuZWFjaExheWVyKGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRpZiAoYyBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0XHRjLl91cGRhdGVJY29uKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvL1JlbW92ZXMgYWxsIGxheWVycyBmcm9tIHRoZSBNYXJrZXJDbHVzdGVyR3JvdXBcblx0Y2xlYXJMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHQvL05lZWQgb3VyIG93biBzcGVjaWFsIGltcGxlbWVudGF0aW9uIGFzIHRoZSBMYXllckdyb3VwIG9uZSBkb2Vzbid0IHdvcmsgZm9yIHVzXG5cblx0XHQvL0lmIHdlIGFyZW4ndCBvbiB0aGUgbWFwICh5ZXQpLCBibG93IGF3YXkgdGhlIG1hcmtlcnMgd2Uga25vdyBvZlxuXHRcdGlmICghdGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9uZWVkc0NsdXN0ZXJpbmcgPSBbXTtcblx0XHRcdGRlbGV0ZSB0aGlzLl9ncmlkQ2x1c3RlcnM7XG5cdFx0XHRkZWxldGUgdGhpcy5fZ3JpZFVuY2x1c3RlcmVkO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnkpIHtcblx0XHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHRcdH1cblxuXHRcdC8vUmVtb3ZlIGFsbCB0aGUgdmlzaWJsZSBsYXllcnNcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLmNsZWFyTGF5ZXJzKCk7XG5cblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0XHRkZWxldGUgbWFya2VyLl9fcGFyZW50O1xuXHRcdH0pO1xuXG5cdFx0aWYgKHRoaXMuX21hcCkge1xuXHRcdFx0Ly9SZXNldCBfdG9wQ2x1c3RlckxldmVsIGFuZCB0aGUgRGlzdGFuY2VHcmlkc1xuXHRcdFx0dGhpcy5fZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnMoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHQvL092ZXJyaWRlIEZlYXR1cmVHcm91cC5nZXRCb3VuZHMgYXMgaXQgZG9lc24ndCB3b3JrXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblx0XHRpZiAodGhpcy5fdG9wQ2x1c3RlckxldmVsKSB7XG5cdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYm91bmRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgaSA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRib3VuZHMuZXh0ZW5kKHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXS5nZXRMYXRMbmcoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ym91bmRzLmV4dGVuZCh0aGlzLl9ub25Qb2ludEdyb3VwLmdldEJvdW5kcygpKTtcblxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5lYWNoTGF5ZXJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmcuc2xpY2UoKSxcblx0XHQgICAgaTtcblxuXHRcdGlmICh0aGlzLl90b3BDbHVzdGVyTGV2ZWwpIHtcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5nZXRBbGxDaGlsZE1hcmtlcnMobWFya2Vycyk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gbWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0bWV0aG9kLmNhbGwoY29udGV4dCwgbWFya2Vyc1tpXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5lYWNoTGF5ZXIobWV0aG9kLCBjb250ZXh0KTtcblx0fSxcblxuXHQvL092ZXJyaWRlcyBMYXllckdyb3VwLmdldExheWVyc1xuXHRnZXRMYXllcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbGF5ZXJzID0gW107XG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGwpIHtcblx0XHRcdGxheWVycy5wdXNoKGwpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBsYXllcnM7XG5cdH0sXG5cblx0Ly9PdmVycmlkZXMgTGF5ZXJHcm91cC5nZXRMYXllciwgV0FSTklORzogUmVhbGx5IGJhZCBwZXJmb3JtYW5jZVxuXHRnZXRMYXllcjogZnVuY3Rpb24gKGlkKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG51bGw7XG5cblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobCkge1xuXHRcdFx0aWYgKEwuc3RhbXAobCkgPT09IGlkKSB7XG5cdFx0XHRcdHJlc3VsdCA9IGw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9LFxuXG5cdC8vUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBsYXllciBpcyBpbiB0aGlzIE1hcmtlckNsdXN0ZXJHcm91cFxuXHRoYXNMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XG5cdFx0aWYgKCFsYXllcikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHZhciBpLCBhbkFycmF5ID0gdGhpcy5fbmVlZHNDbHVzdGVyaW5nO1xuXG5cdFx0Zm9yIChpID0gYW5BcnJheS5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0aWYgKGFuQXJyYXlbaV0gPT09IGxheWVyKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGFuQXJyYXkgPSB0aGlzLl9uZWVkc1JlbW92aW5nO1xuXHRcdGZvciAoaSA9IGFuQXJyYXkubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdGlmIChhbkFycmF5W2ldID09PSBsYXllcikge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuICEhKGxheWVyLl9fcGFyZW50ICYmIGxheWVyLl9fcGFyZW50Ll9ncm91cCA9PT0gdGhpcykgfHwgdGhpcy5fbm9uUG9pbnRHcm91cC5oYXNMYXllcihsYXllcik7XG5cdH0sXG5cblx0Ly9ab29tIGRvd24gdG8gc2hvdyB0aGUgZ2l2ZW4gbGF5ZXIgKHNwaWRlcmZ5aW5nIGlmIG5lY2Vzc2FyeSkgdGhlbiBjYWxscyB0aGUgY2FsbGJhY2tcblx0em9vbVRvU2hvd0xheWVyOiBmdW5jdGlvbiAobGF5ZXIsIGNhbGxiYWNrKSB7XG5cblx0XHR2YXIgc2hvd01hcmtlciA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdGlmICgobGF5ZXIuX2ljb24gfHwgbGF5ZXIuX19wYXJlbnQuX2ljb24pICYmICF0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdFx0dGhpcy5fbWFwLm9mZignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0XHR0aGlzLm9mZignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cblx0XHRcdFx0aWYgKGxheWVyLl9pY29uKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fSBlbHNlIGlmIChsYXllci5fX3BhcmVudC5faWNvbikge1xuXHRcdFx0XHRcdHZhciBhZnRlclNwaWRlcmZ5ID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5vZmYoJ3NwaWRlcmZpZWQnLCBhZnRlclNwaWRlcmZ5LCB0aGlzKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0fTtcblxuXHRcdFx0XHRcdHRoaXMub24oJ3NwaWRlcmZpZWQnLCBhZnRlclNwaWRlcmZ5LCB0aGlzKTtcblx0XHRcdFx0XHRsYXllci5fX3BhcmVudC5zcGlkZXJmeSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGlmIChsYXllci5faWNvbiAmJiB0aGlzLl9tYXAuZ2V0Qm91bmRzKCkuY29udGFpbnMobGF5ZXIuZ2V0TGF0TG5nKCkpKSB7XG5cdFx0XHRjYWxsYmFjaygpO1xuXHRcdH0gZWxzZSBpZiAobGF5ZXIuX19wYXJlbnQuX3pvb20gPCB0aGlzLl9tYXAuZ2V0Wm9vbSgpKSB7XG5cdFx0XHQvL0xheWVyIHNob3VsZCBiZSB2aXNpYmxlIG5vdyBidXQgaXNuJ3Qgb24gc2NyZWVuLCBqdXN0IHBhbiBvdmVyIHRvIGl0XG5cdFx0XHR0aGlzLl9tYXAub24oJ21vdmVlbmQnLCBzaG93TWFya2VyLCB0aGlzKTtcblx0XHRcdHRoaXMuX21hcC5wYW5UbyhsYXllci5nZXRMYXRMbmcoKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHNob3dNYXJrZXIsIHRoaXMpO1xuXHRcdFx0dGhpcy5vbignYW5pbWF0aW9uZW5kJywgc2hvd01hcmtlciwgdGhpcyk7XG5cdFx0XHR0aGlzLl9tYXAuc2V0VmlldyhsYXllci5nZXRMYXRMbmcoKSwgbGF5ZXIuX19wYXJlbnQuX3pvb20gKyAxKTtcblx0XHRcdGxheWVyLl9fcGFyZW50Lnpvb21Ub0JvdW5kcygpO1xuXHRcdH1cblx0fSxcblxuXHQvL092ZXJyaWRlcyBGZWF0dXJlR3JvdXAub25BZGRcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcblx0XHR0aGlzLl9tYXAgPSBtYXA7XG5cdFx0dmFyIGksIGwsIGxheWVyO1xuXG5cdFx0aWYgKCFpc0Zpbml0ZSh0aGlzLl9tYXAuZ2V0TWF4Wm9vbSgpKSkge1xuXHRcdFx0dGhyb3cgXCJNYXAgaGFzIG5vIG1heFpvb20gc3BlY2lmaWVkXCI7XG5cdFx0fVxuXG5cdFx0dGhpcy5fZmVhdHVyZUdyb3VwLm9uQWRkKG1hcCk7XG5cdFx0dGhpcy5fbm9uUG9pbnRHcm91cC5vbkFkZChtYXApO1xuXG5cdFx0aWYgKCF0aGlzLl9ncmlkQ2x1c3RlcnMpIHtcblx0XHRcdHRoaXMuX2dlbmVyYXRlSW5pdGlhbENsdXN0ZXJzKCk7XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbCA9IHRoaXMuX25lZWRzUmVtb3ZpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX25lZWRzUmVtb3ZpbmdbaV07XG5cdFx0XHR0aGlzLl9yZW1vdmVMYXllcihsYXllciwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX25lZWRzUmVtb3ZpbmcgPSBbXTtcblxuXHRcdGZvciAoaSA9IDAsIGwgPSB0aGlzLl9uZWVkc0NsdXN0ZXJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsYXllciA9IHRoaXMuX25lZWRzQ2x1c3RlcmluZ1tpXTtcblxuXHRcdFx0Ly9JZiB0aGUgbGF5ZXIgZG9lc24ndCBoYXZlIGEgZ2V0TGF0TG5nIHRoZW4gd2UgY2FuJ3QgY2x1c3RlciBpdCwgc28gYWRkIGl0IHRvIG91ciBjaGlsZCBmZWF0dXJlR3JvdXBcblx0XHRcdGlmICghbGF5ZXIuZ2V0TGF0TG5nKSB7XG5cdFx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihsYXllcik7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cblx0XHRcdGlmIChsYXllci5fX3BhcmVudCkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZExheWVyKGxheWVyLCB0aGlzLl9tYXhab29tKTtcblx0XHR9XG5cdFx0dGhpcy5fbmVlZHNDbHVzdGVyaW5nID0gW107XG5cblxuXHRcdHRoaXMuX21hcC5vbignem9vbWVuZCcsIHRoaXMuX3pvb21FbmQsIHRoaXMpO1xuXHRcdHRoaXMuX21hcC5vbignbW92ZWVuZCcsIHRoaXMuX21vdmVFbmQsIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZXJPbkFkZCkgeyAvL1RPRE8gRklYTUU6IE5vdCBzdXJlIGhvdyB0byBoYXZlIHNwaWRlcmZpZXIgYWRkIHNvbWV0aGluZyBvbiBoZXJlIG5pY2VseVxuXHRcdFx0dGhpcy5fc3BpZGVyZmllck9uQWRkKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5fYmluZEV2ZW50cygpO1xuXG5cblx0XHQvL0FjdHVhbGx5IGFkZCBvdXIgbWFya2VycyB0byB0aGUgbWFwOlxuXG5cdFx0Ly9SZW1lbWJlciB0aGUgY3VycmVudCB6b29tIGxldmVsIGFuZCBib3VuZHNcblx0XHR0aGlzLl96b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcblx0XHR0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdC8vTWFrZSB0aGluZ3MgYXBwZWFyIG9uIHRoZSBtYXBcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCB0aGlzLl96b29tLCB0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMpO1xuXHR9LFxuXG5cdC8vT3ZlcnJpZGVzIEZlYXR1cmVHcm91cC5vblJlbW92ZVxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl96b29tRW5kLCB0aGlzKTtcblx0XHRtYXAub2ZmKCdtb3ZlZW5kJywgdGhpcy5fbW92ZUVuZCwgdGhpcyk7XG5cblx0XHR0aGlzLl91bmJpbmRFdmVudHMoKTtcblxuXHRcdC8vSW4gY2FzZSB3ZSBhcmUgaW4gYSBjbHVzdGVyIGFuaW1hdGlvblxuXHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgPSB0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNsdXN0ZXItYW5pbScsICcnKTtcblxuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVyT25SZW1vdmUpIHsgLy9UT0RPIEZJWE1FOiBOb3Qgc3VyZSBob3cgdG8gaGF2ZSBzcGlkZXJmaWVyIGFkZCBzb21ldGhpbmcgb24gaGVyZSBuaWNlbHlcblx0XHRcdHRoaXMuX3NwaWRlcmZpZXJPblJlbW92ZSgpO1xuXHRcdH1cblxuXG5cblx0XHQvL0NsZWFuIHVwIGFsbCB0aGUgbGF5ZXJzIHdlIGFkZGVkIHRvIHRoZSBtYXBcblx0XHR0aGlzLl9oaWRlQ292ZXJhZ2UoKTtcblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAub25SZW1vdmUobWFwKTtcblx0XHR0aGlzLl9ub25Qb2ludEdyb3VwLm9uUmVtb3ZlKG1hcCk7XG5cblx0XHR0aGlzLl9mZWF0dXJlR3JvdXAuY2xlYXJMYXllcnMoKTtcblxuXHRcdHRoaXMuX21hcCA9IG51bGw7XG5cdH0sXG5cblx0Z2V0VmlzaWJsZVBhcmVudDogZnVuY3Rpb24gKG1hcmtlcikge1xuXHRcdHZhciB2TWFya2VyID0gbWFya2VyO1xuXHRcdHdoaWxlICh2TWFya2VyICYmICF2TWFya2VyLl9pY29uKSB7XG5cdFx0XHR2TWFya2VyID0gdk1hcmtlci5fX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHZNYXJrZXIgfHwgbnVsbDtcblx0fSxcblxuXHQvL1JlbW92ZSB0aGUgZ2l2ZW4gb2JqZWN0IGZyb20gdGhlIGdpdmVuIGFycmF5XG5cdF9hcnJheVNwbGljZTogZnVuY3Rpb24gKGFuQXJyYXksIG9iaikge1xuXHRcdGZvciAodmFyIGkgPSBhbkFycmF5Lmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRpZiAoYW5BcnJheVtpXSA9PT0gb2JqKSB7XG5cdFx0XHRcdGFuQXJyYXkuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly9JbnRlcm5hbCBmdW5jdGlvbiBmb3IgcmVtb3ZpbmcgYSBtYXJrZXIgZnJvbSBldmVyeXRoaW5nLlxuXHQvL2RvbnRVcGRhdGVNYXA6IHNldCB0byB0cnVlIGlmIHlvdSB3aWxsIGhhbmRsZSB1cGRhdGluZyB0aGUgbWFwIG1hbnVhbGx5IChmb3IgYnVsayBmdW5jdGlvbnMpXG5cdF9yZW1vdmVMYXllcjogZnVuY3Rpb24gKG1hcmtlciwgcmVtb3ZlRnJvbURpc3RhbmNlR3JpZCwgZG9udFVwZGF0ZU1hcCkge1xuXHRcdHZhciBncmlkQ2x1c3RlcnMgPSB0aGlzLl9ncmlkQ2x1c3RlcnMsXG5cdFx0XHRncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXG5cdFx0XHRmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcblx0XHRcdG1hcCA9IHRoaXMuX21hcDtcblxuXHRcdC8vUmVtb3ZlIHRoZSBtYXJrZXIgZnJvbSBkaXN0YW5jZSBjbHVzdGVycyBpdCBtaWdodCBiZSBpblxuXHRcdGlmIChyZW1vdmVGcm9tRGlzdGFuY2VHcmlkKSB7XG5cdFx0XHRmb3IgKHZhciB6ID0gdGhpcy5fbWF4Wm9vbTsgeiA+PSAwOyB6LS0pIHtcblx0XHRcdFx0aWYgKCFncmlkVW5jbHVzdGVyZWRbel0ucmVtb3ZlT2JqZWN0KG1hcmtlciwgbWFwLnByb2plY3QobWFya2VyLmdldExhdExuZygpLCB6KSkpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vV29yayBvdXIgd2F5IHVwIHRoZSBjbHVzdGVycyByZW1vdmluZyB0aGVtIGFzIHdlIGdvIGlmIHJlcXVpcmVkXG5cdFx0dmFyIGNsdXN0ZXIgPSBtYXJrZXIuX19wYXJlbnQsXG5cdFx0XHRtYXJrZXJzID0gY2x1c3Rlci5fbWFya2Vycyxcblx0XHRcdG90aGVyTWFya2VyO1xuXG5cdFx0Ly9SZW1vdmUgdGhlIG1hcmtlciBmcm9tIHRoZSBpbW1lZGlhdGUgcGFyZW50cyBtYXJrZXIgbGlzdFxuXHRcdHRoaXMuX2FycmF5U3BsaWNlKG1hcmtlcnMsIG1hcmtlcik7XG5cblx0XHR3aGlsZSAoY2x1c3Rlcikge1xuXHRcdFx0Y2x1c3Rlci5fY2hpbGRDb3VudC0tO1xuXG5cdFx0XHRpZiAoY2x1c3Rlci5fem9vbSA8IDApIHtcblx0XHRcdFx0Ly9Ub3AgbGV2ZWwsIGRvIG5vdGhpbmdcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9IGVsc2UgaWYgKHJlbW92ZUZyb21EaXN0YW5jZUdyaWQgJiYgY2x1c3Rlci5fY2hpbGRDb3VudCA8PSAxKSB7IC8vQ2x1c3RlciBubyBsb25nZXIgcmVxdWlyZWRcblx0XHRcdFx0Ly9XZSBuZWVkIHRvIHB1c2ggdGhlIG90aGVyIG1hcmtlciB1cCB0byB0aGUgcGFyZW50XG5cdFx0XHRcdG90aGVyTWFya2VyID0gY2x1c3Rlci5fbWFya2Vyc1swXSA9PT0gbWFya2VyID8gY2x1c3Rlci5fbWFya2Vyc1sxXSA6IGNsdXN0ZXIuX21hcmtlcnNbMF07XG5cblx0XHRcdFx0Ly9VcGRhdGUgZGlzdGFuY2UgZ3JpZFxuXHRcdFx0XHRncmlkQ2x1c3RlcnNbY2x1c3Rlci5fem9vbV0ucmVtb3ZlT2JqZWN0KGNsdXN0ZXIsIG1hcC5wcm9qZWN0KGNsdXN0ZXIuX2NMYXRMbmcsIGNsdXN0ZXIuX3pvb20pKTtcblx0XHRcdFx0Z3JpZFVuY2x1c3RlcmVkW2NsdXN0ZXIuX3pvb21dLmFkZE9iamVjdChvdGhlck1hcmtlciwgbWFwLnByb2plY3Qob3RoZXJNYXJrZXIuZ2V0TGF0TG5nKCksIGNsdXN0ZXIuX3pvb20pKTtcblxuXHRcdFx0XHQvL01vdmUgb3RoZXJNYXJrZXIgdXAgdG8gcGFyZW50XG5cdFx0XHRcdHRoaXMuX2FycmF5U3BsaWNlKGNsdXN0ZXIuX19wYXJlbnQuX2NoaWxkQ2x1c3RlcnMsIGNsdXN0ZXIpO1xuXHRcdFx0XHRjbHVzdGVyLl9fcGFyZW50Ll9tYXJrZXJzLnB1c2gob3RoZXJNYXJrZXIpO1xuXHRcdFx0XHRvdGhlck1hcmtlci5fX3BhcmVudCA9IGNsdXN0ZXIuX19wYXJlbnQ7XG5cblx0XHRcdFx0aWYgKGNsdXN0ZXIuX2ljb24pIHtcblx0XHRcdFx0XHQvL0NsdXN0ZXIgaXMgY3VycmVudGx5IG9uIHRoZSBtYXAsIG5lZWQgdG8gcHV0IHRoZSBtYXJrZXIgb24gdGhlIG1hcCBpbnN0ZWFkXG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoY2x1c3Rlcik7XG5cdFx0XHRcdFx0aWYgKCFkb250VXBkYXRlTWFwKSB7XG5cdFx0XHRcdFx0XHRmZy5hZGRMYXllcihvdGhlck1hcmtlcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbHVzdGVyLl9yZWNhbGN1bGF0ZUJvdW5kcygpO1xuXHRcdFx0XHRpZiAoIWRvbnRVcGRhdGVNYXAgfHwgIWNsdXN0ZXIuX2ljb24pIHtcblx0XHRcdFx0XHRjbHVzdGVyLl91cGRhdGVJY29uKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Y2x1c3RlciA9IGNsdXN0ZXIuX19wYXJlbnQ7XG5cdFx0fVxuXG5cdFx0ZGVsZXRlIG1hcmtlci5fX3BhcmVudDtcblx0fSxcblxuXHRfaXNPcklzUGFyZW50OiBmdW5jdGlvbiAoZWwsIG9lbCkge1xuXHRcdHdoaWxlIChvZWwpIHtcblx0XHRcdGlmIChlbCA9PT0gb2VsKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0b2VsID0gb2VsLnBhcmVudE5vZGU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRfcHJvcGFnYXRlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKGUubGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpIHtcblx0XHRcdC8vUHJldmVudCBtdWx0aXBsZSBjbHVzdGVybW91c2VvdmVyL29mZiBldmVudHMgaWYgdGhlIGljb24gaXMgbWFkZSB1cCBvZiBzdGFja2VkIGRpdnMgKERvZXNuJ3Qgd29yayBpbiBpZSA8PSA4LCBubyByZWxhdGVkVGFyZ2V0KVxuXHRcdFx0aWYgKGUub3JpZ2luYWxFdmVudCAmJiB0aGlzLl9pc09ySXNQYXJlbnQoZS5sYXllci5faWNvbiwgZS5vcmlnaW5hbEV2ZW50LnJlbGF0ZWRUYXJnZXQpKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGUudHlwZSA9ICdjbHVzdGVyJyArIGUudHlwZTtcblx0XHR9XG5cblx0XHR0aGlzLmZpcmUoZS50eXBlLCBlKTtcblx0fSxcblxuXHQvL0RlZmF1bHQgZnVuY3Rpb25hbGl0eVxuXHRfZGVmYXVsdEljb25DcmVhdGVGdW5jdGlvbjogZnVuY3Rpb24gKGNsdXN0ZXIpIHtcblx0XHR2YXIgY2hpbGRDb3VudCA9IGNsdXN0ZXIuZ2V0Q2hpbGRDb3VudCgpO1xuXG5cdFx0dmFyIGMgPSAnIG1hcmtlci1jbHVzdGVyLSc7XG5cdFx0aWYgKGNoaWxkQ291bnQgPCAxMCkge1xuXHRcdFx0YyArPSAnc21hbGwnO1xuXHRcdH0gZWxzZSBpZiAoY2hpbGRDb3VudCA8IDEwMCkge1xuXHRcdFx0YyArPSAnbWVkaXVtJztcblx0XHR9IGVsc2Uge1xuXHRcdFx0YyArPSAnbGFyZ2UnO1xuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgTC5EaXZJY29uKHsgaHRtbDogJzxkaXY+PHNwYW4+JyArIGNoaWxkQ291bnQgKyAnPC9zcGFuPjwvZGl2PicsIGNsYXNzTmFtZTogJ21hcmtlci1jbHVzdGVyJyArIGMsIGljb25TaXplOiBuZXcgTC5Qb2ludCg0MCwgNDApIH0pO1xuXHR9LFxuXG5cdF9iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcblx0XHQgICAgc3BpZGVyZnlPbk1heFpvb20gPSB0aGlzLm9wdGlvbnMuc3BpZGVyZnlPbk1heFpvb20sXG5cdFx0ICAgIHNob3dDb3ZlcmFnZU9uSG92ZXIgPSB0aGlzLm9wdGlvbnMuc2hvd0NvdmVyYWdlT25Ib3Zlcixcblx0XHQgICAgem9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrO1xuXG5cdFx0Ly9ab29tIG9uIGNsdXN0ZXIgY2xpY2sgb3Igc3BpZGVyZnkgaWYgd2UgYXJlIGF0IHRoZSBsb3dlc3QgbGV2ZWxcblx0XHRpZiAoc3BpZGVyZnlPbk1heFpvb20gfHwgem9vbVRvQm91bmRzT25DbGljaykge1xuXHRcdFx0dGhpcy5vbignY2x1c3RlcmNsaWNrJywgdGhpcy5fem9vbU9yU3BpZGVyZnksIHRoaXMpO1xuXHRcdH1cblxuXHRcdC8vU2hvdyBjb252ZXggaHVsbCAoYm91bmRhcnkpIHBvbHlnb24gb24gbW91c2Ugb3ZlclxuXHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XG5cdFx0XHR0aGlzLm9uKCdjbHVzdGVybW91c2VvdmVyJywgdGhpcy5fc2hvd0NvdmVyYWdlLCB0aGlzKTtcblx0XHRcdHRoaXMub24oJ2NsdXN0ZXJtb3VzZW91dCcsIHRoaXMuX2hpZGVDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHRtYXAub24oJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfem9vbU9yU3BpZGVyZnk6IGZ1bmN0aW9uIChlKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcblx0XHRpZiAobWFwLmdldE1heFpvb20oKSA9PT0gbWFwLmdldFpvb20oKSkge1xuXHRcdFx0aWYgKHRoaXMub3B0aW9ucy5zcGlkZXJmeU9uTWF4Wm9vbSkge1xuXHRcdFx0XHRlLmxheWVyLnNwaWRlcmZ5KCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuem9vbVRvQm91bmRzT25DbGljaykge1xuXHRcdFx0ZS5sYXllci56b29tVG9Cb3VuZHMoKTtcblx0XHR9XG5cbiAgICAvLyBGb2N1cyB0aGUgbWFwIGFnYWluIGZvciBrZXlib2FyZCB1c2Vycy5cblx0XHRpZiAoZS5vcmlnaW5hbEV2ZW50ICYmIGUub3JpZ2luYWxFdmVudC5rZXlDb2RlID09PSAxMykge1xuXHRcdFx0bWFwLl9jb250YWluZXIuZm9jdXMoKTtcblx0XHR9XG5cdH0sXG5cblx0X3Nob3dDb3ZlcmFnZTogZnVuY3Rpb24gKGUpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xuXHRcdGlmICh0aGlzLl9pblpvb21BbmltYXRpb24pIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xuXHRcdFx0bWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XG5cdFx0fVxuXHRcdGlmIChlLmxheWVyLmdldENoaWxkQ291bnQoKSA+IDIgJiYgZS5sYXllciAhPT0gdGhpcy5fc3BpZGVyZmllZCkge1xuXHRcdFx0dGhpcy5fc2hvd25Qb2x5Z29uID0gbmV3IEwuUG9seWdvbihlLmxheWVyLmdldENvbnZleEh1bGwoKSwgdGhpcy5vcHRpb25zLnBvbHlnb25PcHRpb25zKTtcblx0XHRcdG1hcC5hZGRMYXllcih0aGlzLl9zaG93blBvbHlnb24pO1xuXHRcdH1cblx0fSxcblxuXHRfaGlkZUNvdmVyYWdlOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3Nob3duUG9seWdvbikge1xuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX3Nob3duUG9seWdvbik7XG5cdFx0XHR0aGlzLl9zaG93blBvbHlnb24gPSBudWxsO1xuXHRcdH1cblx0fSxcblxuXHRfdW5iaW5kRXZlbnRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIHNwaWRlcmZ5T25NYXhab29tID0gdGhpcy5vcHRpb25zLnNwaWRlcmZ5T25NYXhab29tLFxuXHRcdFx0c2hvd0NvdmVyYWdlT25Ib3ZlciA9IHRoaXMub3B0aW9ucy5zaG93Q292ZXJhZ2VPbkhvdmVyLFxuXHRcdFx0em9vbVRvQm91bmRzT25DbGljayA9IHRoaXMub3B0aW9ucy56b29tVG9Cb3VuZHNPbkNsaWNrLFxuXHRcdFx0bWFwID0gdGhpcy5fbWFwO1xuXG5cdFx0aWYgKHNwaWRlcmZ5T25NYXhab29tIHx8IHpvb21Ub0JvdW5kc09uQ2xpY2spIHtcblx0XHRcdHRoaXMub2ZmKCdjbHVzdGVyY2xpY2snLCB0aGlzLl96b29tT3JTcGlkZXJmeSwgdGhpcyk7XG5cdFx0fVxuXHRcdGlmIChzaG93Q292ZXJhZ2VPbkhvdmVyKSB7XG5cdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3ZlcicsIHRoaXMuX3Nob3dDb3ZlcmFnZSwgdGhpcyk7XG5cdFx0XHR0aGlzLm9mZignY2x1c3Rlcm1vdXNlb3V0JywgdGhpcy5faGlkZUNvdmVyYWdlLCB0aGlzKTtcblx0XHRcdG1hcC5vZmYoJ3pvb21lbmQnLCB0aGlzLl9oaWRlQ292ZXJhZ2UsIHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHRfem9vbUVuZDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLl9tZXJnZVNwbGl0Q2x1c3RlcnMoKTtcblxuXHRcdHRoaXMuX3pvb20gPSB0aGlzLl9tYXAuX3pvb207XG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gdGhpcy5fZ2V0RXhwYW5kZWRWaXNpYmxlQm91bmRzKCk7XG5cdH0sXG5cblx0X21vdmVFbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIG5ld0JvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpO1xuXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIHRoaXMuX3pvb20sIG5ld0JvdW5kcyk7XG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgdGhpcy5fbWFwLl96b29tLCBuZXdCb3VuZHMpO1xuXG5cdFx0dGhpcy5fY3VycmVudFNob3duQm91bmRzID0gbmV3Qm91bmRzO1xuXHRcdHJldHVybjtcblx0fSxcblxuXHRfZ2VuZXJhdGVJbml0aWFsQ2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgbWF4Wm9vbSA9IHRoaXMuX21hcC5nZXRNYXhab29tKCksXG5cdFx0XHRyYWRpdXMgPSB0aGlzLm9wdGlvbnMubWF4Q2x1c3RlclJhZGl1cztcblxuXHRcdGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20pIHtcblx0XHRcdG1heFpvb20gPSB0aGlzLm9wdGlvbnMuZGlzYWJsZUNsdXN0ZXJpbmdBdFpvb20gLSAxO1xuXHRcdH1cblx0XHR0aGlzLl9tYXhab29tID0gbWF4Wm9vbTtcblx0XHR0aGlzLl9ncmlkQ2x1c3RlcnMgPSB7fTtcblx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWQgPSB7fTtcblxuXHRcdC8vU2V0IHVwIERpc3RhbmNlR3JpZHMgZm9yIGVhY2ggem9vbVxuXHRcdGZvciAodmFyIHpvb20gPSBtYXhab29tOyB6b29tID49IDA7IHpvb20tLSkge1xuXHRcdFx0dGhpcy5fZ3JpZENsdXN0ZXJzW3pvb21dID0gbmV3IEwuRGlzdGFuY2VHcmlkKHJhZGl1cyk7XG5cdFx0XHR0aGlzLl9ncmlkVW5jbHVzdGVyZWRbem9vbV0gPSBuZXcgTC5EaXN0YW5jZUdyaWQocmFkaXVzKTtcblx0XHR9XG5cblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwgPSBuZXcgTC5NYXJrZXJDbHVzdGVyKHRoaXMsIC0xKTtcblx0fSxcblxuXHQvL1pvb206IFpvb20gdG8gc3RhcnQgYWRkaW5nIGF0IChQYXNzIHRoaXMuX21heFpvb20gdG8gc3RhcnQgYXQgdGhlIGJvdHRvbSlcblx0X2FkZExheWVyOiBmdW5jdGlvbiAobGF5ZXIsIHpvb20pIHtcblx0XHR2YXIgZ3JpZENsdXN0ZXJzID0gdGhpcy5fZ3JpZENsdXN0ZXJzLFxuXHRcdCAgICBncmlkVW5jbHVzdGVyZWQgPSB0aGlzLl9ncmlkVW5jbHVzdGVyZWQsXG5cdFx0ICAgIG1hcmtlclBvaW50LCB6O1xuXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5zaW5nbGVNYXJrZXJNb2RlKSB7XG5cdFx0XHRsYXllci5vcHRpb25zLmljb24gPSB0aGlzLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHtcblx0XHRcdFx0Z2V0Q2hpbGRDb3VudDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRnZXRBbGxDaGlsZE1hcmtlcnM6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0XHRyZXR1cm4gW2xheWVyXTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0Ly9GaW5kIHRoZSBsb3dlc3Qgem9vbSBsZXZlbCB0byBzbG90IHRoaXMgb25lIGluXG5cdFx0Zm9yICg7IHpvb20gPj0gMDsgem9vbS0tKSB7XG5cdFx0XHRtYXJrZXJQb2ludCA9IHRoaXMuX21hcC5wcm9qZWN0KGxheWVyLmdldExhdExuZygpLCB6b29tKTsgLy8gY2FsY3VsYXRlIHBpeGVsIHBvc2l0aW9uXG5cblx0XHRcdC8vVHJ5IGZpbmQgYSBjbHVzdGVyIGNsb3NlIGJ5XG5cdFx0XHR2YXIgY2xvc2VzdCA9IGdyaWRDbHVzdGVyc1t6b29tXS5nZXROZWFyT2JqZWN0KG1hcmtlclBvaW50KTtcblx0XHRcdGlmIChjbG9zZXN0KSB7XG5cdFx0XHRcdGNsb3Nlc3QuX2FkZENoaWxkKGxheWVyKTtcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBjbG9zZXN0O1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vVHJ5IGZpbmQgYSBtYXJrZXIgY2xvc2UgYnkgdG8gZm9ybSBhIG5ldyBjbHVzdGVyIHdpdGhcblx0XHRcdGNsb3Nlc3QgPSBncmlkVW5jbHVzdGVyZWRbem9vbV0uZ2V0TmVhck9iamVjdChtYXJrZXJQb2ludCk7XG5cdFx0XHRpZiAoY2xvc2VzdCkge1xuXHRcdFx0XHR2YXIgcGFyZW50ID0gY2xvc2VzdC5fX3BhcmVudDtcblx0XHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHRcdHRoaXMuX3JlbW92ZUxheWVyKGNsb3Nlc3QsIGZhbHNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vQ3JlYXRlIG5ldyBjbHVzdGVyIHdpdGggdGhlc2UgMiBpbiBpdFxuXG5cdFx0XHRcdHZhciBuZXdDbHVzdGVyID0gbmV3IEwuTWFya2VyQ2x1c3Rlcih0aGlzLCB6b29tLCBjbG9zZXN0LCBsYXllcik7XG5cdFx0XHRcdGdyaWRDbHVzdGVyc1t6b29tXS5hZGRPYmplY3QobmV3Q2x1c3RlciwgdGhpcy5fbWFwLnByb2plY3QobmV3Q2x1c3Rlci5fY0xhdExuZywgem9vbSkpO1xuXHRcdFx0XHRjbG9zZXN0Ll9fcGFyZW50ID0gbmV3Q2x1c3Rlcjtcblx0XHRcdFx0bGF5ZXIuX19wYXJlbnQgPSBuZXdDbHVzdGVyO1xuXG5cdFx0XHRcdC8vRmlyc3QgY3JlYXRlIGFueSBuZXcgaW50ZXJtZWRpYXRlIHBhcmVudCBjbHVzdGVycyB0aGF0IGRvbid0IGV4aXN0XG5cdFx0XHRcdHZhciBsYXN0UGFyZW50ID0gbmV3Q2x1c3Rlcjtcblx0XHRcdFx0Zm9yICh6ID0gem9vbSAtIDE7IHogPiBwYXJlbnQuX3pvb207IHotLSkge1xuXHRcdFx0XHRcdGxhc3RQYXJlbnQgPSBuZXcgTC5NYXJrZXJDbHVzdGVyKHRoaXMsIHosIGxhc3RQYXJlbnQpO1xuXHRcdFx0XHRcdGdyaWRDbHVzdGVyc1t6XS5hZGRPYmplY3QobGFzdFBhcmVudCwgdGhpcy5fbWFwLnByb2plY3QoY2xvc2VzdC5nZXRMYXRMbmcoKSwgeikpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhcmVudC5fYWRkQ2hpbGQobGFzdFBhcmVudCk7XG5cblx0XHRcdFx0Ly9SZW1vdmUgY2xvc2VzdCBmcm9tIHRoaXMgem9vbSBsZXZlbCBhbmQgYW55IGFib3ZlIHRoYXQgaXQgaXMgaW4sIHJlcGxhY2Ugd2l0aCBuZXdDbHVzdGVyXG5cdFx0XHRcdGZvciAoeiA9IHpvb207IHogPj0gMDsgei0tKSB7XG5cdFx0XHRcdFx0aWYgKCFncmlkVW5jbHVzdGVyZWRbel0ucmVtb3ZlT2JqZWN0KGNsb3Nlc3QsIHRoaXMuX21hcC5wcm9qZWN0KGNsb3Nlc3QuZ2V0TGF0TG5nKCksIHopKSkge1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvL0RpZG4ndCBtYW5hZ2UgdG8gY2x1c3RlciBpbiBhdCB0aGlzIHpvb20sIHJlY29yZCB1cyBhcyBhIG1hcmtlciBoZXJlIGFuZCBjb250aW51ZSB1cHdhcmRzXG5cdFx0XHRncmlkVW5jbHVzdGVyZWRbem9vbV0uYWRkT2JqZWN0KGxheWVyLCBtYXJrZXJQb2ludCk7XG5cdFx0fVxuXG5cdFx0Ly9EaWRuJ3QgZ2V0IGluIGFueXRoaW5nLCBhZGQgdXMgdG8gdGhlIHRvcFxuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fYWRkQ2hpbGQobGF5ZXIpO1xuXHRcdGxheWVyLl9fcGFyZW50ID0gdGhpcy5fdG9wQ2x1c3RlckxldmVsO1xuXHRcdHJldHVybjtcblx0fSxcblxuXHQvL0VucXVldWUgY29kZSB0byBmaXJlIGFmdGVyIHRoZSBtYXJrZXIgZXhwYW5kL2NvbnRyYWN0IGhhcyBoYXBwZW5lZFxuXHRfZW5xdWV1ZTogZnVuY3Rpb24gKGZuKSB7XG5cdFx0dGhpcy5fcXVldWUucHVzaChmbik7XG5cdFx0aWYgKCF0aGlzLl9xdWV1ZVRpbWVvdXQpIHtcblx0XHRcdHRoaXMuX3F1ZXVlVGltZW91dCA9IHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX3Byb2Nlc3NRdWV1ZSwgdGhpcyksIDMwMCk7XG5cdFx0fVxuXHR9LFxuXHRfcHJvY2Vzc1F1ZXVlOiBmdW5jdGlvbiAoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dGhpcy5fcXVldWVbaV0uY2FsbCh0aGlzKTtcblx0XHR9XG5cdFx0dGhpcy5fcXVldWUubGVuZ3RoID0gMDtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fcXVldWVUaW1lb3V0KTtcblx0XHR0aGlzLl9xdWV1ZVRpbWVvdXQgPSBudWxsO1xuXHR9LFxuXG5cdC8vTWVyZ2UgYW5kIHNwbGl0IGFueSBleGlzdGluZyBjbHVzdGVycyB0aGF0IGFyZSB0b28gYmlnIG9yIHNtYWxsXG5cdF9tZXJnZVNwbGl0Q2x1c3RlcnM6IGZ1bmN0aW9uICgpIHtcblxuXHRcdC8vSW5jYXNlIHdlIGFyZSBzdGFydGluZyB0byBzcGxpdCBiZWZvcmUgdGhlIGFuaW1hdGlvbiBmaW5pc2hlZFxuXHRcdHRoaXMuX3Byb2Nlc3NRdWV1ZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3pvb20gPCB0aGlzLl9tYXAuX3pvb20gJiYgdGhpcy5fY3VycmVudFNob3duQm91bmRzLmNvbnRhaW5zKHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKSkgeyAvL1pvb20gaW4sIHNwbGl0XG5cdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xuXHRcdFx0Ly9SZW1vdmUgY2x1c3RlcnMgbm93IG9mZiBzY3JlZW5cblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCB0aGlzLl96b29tLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cblx0XHRcdHRoaXMuX2FuaW1hdGlvblpvb21Jbih0aGlzLl96b29tLCB0aGlzLl9tYXAuX3pvb20pO1xuXG5cdFx0fSBlbHNlIGlmICh0aGlzLl96b29tID4gdGhpcy5fbWFwLl96b29tKSB7IC8vWm9vbSBvdXQsIG1lcmdlXG5cdFx0XHR0aGlzLl9hbmltYXRpb25TdGFydCgpO1xuXG5cdFx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0KHRoaXMuX3pvb20sIHRoaXMuX21hcC5fem9vbSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX21vdmVFbmQoKTtcblx0XHR9XG5cdH0sXG5cblx0Ly9HZXRzIHRoZSBtYXBzIHZpc2libGUgYm91bmRzIGV4cGFuZGVkIGluIGVhY2ggZGlyZWN0aW9uIGJ5IHRoZSBzaXplIG9mIHRoZSBzY3JlZW4gKHNvIHRoZSB1c2VyIGNhbm5vdCBzZWUgYW4gYXJlYSB3ZSBkbyBub3QgY292ZXIgaW4gb25lIHBhbilcblx0X2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kczogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5vcHRpb25zLnJlbW92ZU91dHNpZGVWaXNpYmxlQm91bmRzKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHR9XG5cblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxuXHRcdFx0Ym91bmRzID0gbWFwLmdldEJvdW5kcygpLFxuXHRcdFx0c3cgPSBib3VuZHMuX3NvdXRoV2VzdCxcblx0XHRcdG5lID0gYm91bmRzLl9ub3J0aEVhc3QsXG5cdFx0XHRsYXREaWZmID0gTC5Ccm93c2VyLm1vYmlsZSA/IDAgOiBNYXRoLmFicyhzdy5sYXQgLSBuZS5sYXQpLFxuXHRcdFx0bG5nRGlmZiA9IEwuQnJvd3Nlci5tb2JpbGUgPyAwIDogTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKTtcblxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXG5cdFx0XHRuZXcgTC5MYXRMbmcoc3cubGF0IC0gbGF0RGlmZiwgc3cubG5nIC0gbG5nRGlmZiwgdHJ1ZSksXG5cdFx0XHRuZXcgTC5MYXRMbmcobmUubGF0ICsgbGF0RGlmZiwgbmUubG5nICsgbG5nRGlmZiwgdHJ1ZSkpO1xuXHR9LFxuXG5cdC8vU2hhcmVkIGFuaW1hdGlvbiBjb2RlXG5cdF9hbmltYXRpb25BZGRMYXllck5vbkFuaW1hdGVkOiBmdW5jdGlvbiAobGF5ZXIsIG5ld0NsdXN0ZXIpIHtcblx0XHRpZiAobmV3Q2x1c3RlciA9PT0gbGF5ZXIpIHtcblx0XHRcdHRoaXMuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihsYXllcik7XG5cdFx0fSBlbHNlIGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID09PSAyKSB7XG5cdFx0XHRuZXdDbHVzdGVyLl9hZGRUb01hcCgpO1xuXG5cdFx0XHR2YXIgbWFya2VycyA9IG5ld0NsdXN0ZXIuZ2V0QWxsQ2hpbGRNYXJrZXJzKCk7XG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1swXSk7XG5cdFx0XHR0aGlzLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobWFya2Vyc1sxXSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcblx0XHR9XG5cdH1cbn0pO1xuXG5MLk1hcmtlckNsdXN0ZXJHcm91cC5pbmNsdWRlKCFMLkRvbVV0aWwuVFJBTlNJVElPTiA/IHtcblxuXHQvL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXG5cdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdC8vRG8gbm90aGluZy4uLlxuXHR9LFxuXHRfYW5pbWF0aW9uWm9vbUluOiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCk7XG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdH0sXG5cdF9hbmltYXRpb25ab29tT3V0OiBmdW5jdGlvbiAocHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAodGhpcy5fY3VycmVudFNob3duQm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCk7XG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdH0sXG5cdF9hbmltYXRpb25BZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuZXdDbHVzdGVyKSB7XG5cdFx0dGhpcy5fYW5pbWF0aW9uQWRkTGF5ZXJOb25BbmltYXRlZChsYXllciwgbmV3Q2x1c3Rlcik7XG5cdH1cbn0gOiB7XG5cblx0Ly9BbmltYXRlZCB2ZXJzaW9ucyBoZXJlXG5cdF9hbmltYXRpb25TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX21hcC5fbWFwUGFuZS5jbGFzc05hbWUgKz0gJyBsZWFmbGV0LWNsdXN0ZXItYW5pbSc7XG5cdFx0dGhpcy5faW5ab29tQW5pbWF0aW9uKys7XG5cdH0sXG5cdF9hbmltYXRpb25FbmQ6IGZ1bmN0aW9uICgpIHtcblx0XHRpZiAodGhpcy5fbWFwKSB7XG5cdFx0XHR0aGlzLl9tYXAuX21hcFBhbmUuY2xhc3NOYW1lID0gdGhpcy5fbWFwLl9tYXBQYW5lLmNsYXNzTmFtZS5yZXBsYWNlKCcgbGVhZmxldC1jbHVzdGVyLWFuaW0nLCAnJyk7XG5cdFx0fVxuXHRcdHRoaXMuX2luWm9vbUFuaW1hdGlvbi0tO1xuXHRcdHRoaXMuZmlyZSgnYW5pbWF0aW9uZW5kJyk7XG5cdH0sXG5cdF9hbmltYXRpb25ab29tSW46IGZ1bmN0aW9uIChwcmV2aW91c1pvb21MZXZlbCwgbmV3Wm9vbUxldmVsKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpLFxuXHRcdCAgICBmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cCxcblx0XHQgICAgaTtcblxuXHRcdC8vQWRkIGFsbCBjaGlsZHJlbiBvZiBjdXJyZW50IGNsdXN0ZXJzIHRvIG1hcCBhbmQgcmVtb3ZlIHRob3NlIGNsdXN0ZXJzIGZyb20gbWFwXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCAwLCBmdW5jdGlvbiAoYykge1xuXHRcdFx0dmFyIHN0YXJ0UG9zID0gYy5fbGF0bG5nLFxuXHRcdFx0XHRtYXJrZXJzID0gYy5fbWFya2Vycyxcblx0XHRcdFx0bTtcblxuXHRcdFx0aWYgKCFib3VuZHMuY29udGFpbnMoc3RhcnRQb3MpKSB7XG5cdFx0XHRcdHN0YXJ0UG9zID0gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgKyAxID09PSBuZXdab29tTGV2ZWwpIHsgLy9JbW1lZGlhdGVseSBhZGQgdGhlIG5ldyBjaGlsZCBhbmQgcmVtb3ZlIHVzXG5cdFx0XHRcdGZnLnJlbW92ZUxheWVyKGMpO1xuXHRcdFx0XHRjLl9yZWN1cnNpdmVseUFkZENoaWxkcmVuVG9NYXAobnVsbCwgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Ly9GYWRlIG91dCBvbGQgY2x1c3RlclxuXHRcdFx0XHRjLnNldE9wYWNpdHkoMCk7XG5cdFx0XHRcdGMuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChzdGFydFBvcywgbmV3Wm9vbUxldmVsLCBib3VuZHMpO1xuXHRcdFx0fVxuXG5cdFx0XHQvL1JlbW92ZSBhbGwgbWFya2VycyB0aGF0IGFyZW4ndCB2aXNpYmxlIGFueSBtb3JlXG5cdFx0XHQvL1RPRE86IERvIHdlIGFjdHVhbGx5IG5lZWQgdG8gZG8gdGhpcyBvbiB0aGUgaGlnaGVyIGxldmVscyB0b28/XG5cdFx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdG0gPSBtYXJrZXJzW2ldO1xuXHRcdFx0XHRpZiAoIWJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcblxuXHRcdC8vVXBkYXRlIG9wYWNpdGllc1xuXHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcblx0XHQvL1RPRE8gTWF5YmU/IFVwZGF0ZSBtYXJrZXJzIGluIF9yZWN1cnNpdmVseUJlY29tZVZpc2libGVcblx0XHRmZy5lYWNoTGF5ZXIoZnVuY3Rpb24gKG4pIHtcblx0XHRcdGlmICghKG4gaW5zdGFuY2VvZiBMLk1hcmtlckNsdXN0ZXIpICYmIG4uX2ljb24pIHtcblx0XHRcdFx0bi5zZXRPcGFjaXR5KDEpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly91cGRhdGUgdGhlIHBvc2l0aW9ucyBvZiB0aGUganVzdCBhZGRlZCBjbHVzdGVycy9tYXJrZXJzXG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseShib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwsIGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRjLl9yZWN1cnNpdmVseVJlc3RvcmVDaGlsZFBvc2l0aW9ucyhuZXdab29tTGV2ZWwpO1xuXHRcdH0pO1xuXG5cdFx0Ly9SZW1vdmUgdGhlIG9sZCBjbHVzdGVycyBhbmQgY2xvc2UgdGhlIHpvb20gYW5pbWF0aW9uXG5cdFx0dGhpcy5fZW5xdWV1ZShmdW5jdGlvbiAoKSB7XG5cdFx0XHQvL3VwZGF0ZSB0aGUgcG9zaXRpb25zIG9mIHRoZSBqdXN0IGFkZGVkIGNsdXN0ZXJzL21hcmtlcnNcblx0XHRcdHRoaXMuX3RvcENsdXN0ZXJMZXZlbC5fcmVjdXJzaXZlbHkoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCwgMCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0ZmcucmVtb3ZlTGF5ZXIoYyk7XG5cdFx0XHRcdGMuc2V0T3BhY2l0eSgxKTtcblx0XHRcdH0pO1xuXG5cdFx0XHR0aGlzLl9hbmltYXRpb25FbmQoKTtcblx0XHR9KTtcblx0fSxcblxuXHRfYW5pbWF0aW9uWm9vbU91dDogZnVuY3Rpb24gKHByZXZpb3VzWm9vbUxldmVsLCBuZXdab29tTGV2ZWwpIHtcblx0XHR0aGlzLl9hbmltYXRpb25ab29tT3V0U2luZ2xlKHRoaXMuX3RvcENsdXN0ZXJMZXZlbCwgcHJldmlvdXNab29tTGV2ZWwgLSAxLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0Ly9OZWVkIHRvIGFkZCBtYXJrZXJzIGZvciB0aG9zZSB0aGF0IHdlcmVuJ3Qgb24gdGhlIG1hcCBiZWZvcmUgYnV0IGFyZSBub3dcblx0XHR0aGlzLl90b3BDbHVzdGVyTGV2ZWwuX3JlY3Vyc2l2ZWx5QWRkQ2hpbGRyZW5Ub01hcChudWxsLCBuZXdab29tTGV2ZWwsIHRoaXMuX2dldEV4cGFuZGVkVmlzaWJsZUJvdW5kcygpKTtcblx0XHQvL1JlbW92ZSBtYXJrZXJzIHRoYXQgd2VyZSBvbiB0aGUgbWFwIGJlZm9yZSBidXQgd29uJ3QgYmUgbm93XG5cdFx0dGhpcy5fdG9wQ2x1c3RlckxldmVsLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcCh0aGlzLl9jdXJyZW50U2hvd25Cb3VuZHMsIHByZXZpb3VzWm9vbUxldmVsLCB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKSk7XG5cdH0sXG5cdF9hbmltYXRpb25ab29tT3V0U2luZ2xlOiBmdW5jdGlvbiAoY2x1c3RlciwgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRFeHBhbmRlZFZpc2libGVCb3VuZHMoKTtcblxuXHRcdC8vQW5pbWF0ZSBhbGwgb2YgdGhlIG1hcmtlcnMgaW4gdGhlIGNsdXN0ZXJzIHRvIG1vdmUgdG8gdGhlaXIgY2x1c3RlciBjZW50ZXIgcG9pbnRcblx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluQW5kQWRkU2VsZlRvTWFwKGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwgKyAxLCBuZXdab29tTGV2ZWwpO1xuXG5cdFx0dmFyIG1lID0gdGhpcztcblxuXHRcdC8vVXBkYXRlIHRoZSBvcGFjaXR5IChJZiB3ZSBpbW1lZGlhdGVseSBzZXQgaXQgdGhleSB3b24ndCBhbmltYXRlKVxuXHRcdHRoaXMuX2ZvcmNlTGF5b3V0KCk7XG5cdFx0Y2x1c3Rlci5fcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlKGJvdW5kcywgbmV3Wm9vbUxldmVsKTtcblxuXHRcdC8vVE9ETzogTWF5YmUgdXNlIHRoZSB0cmFuc2l0aW9uIHRpbWluZyBzdHVmZiB0byBtYWtlIHRoaXMgbW9yZSByZWxpYWJsZVxuXHRcdC8vV2hlbiB0aGUgYW5pbWF0aW9ucyBhcmUgZG9uZSwgdGlkeSB1cFxuXHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xuXG5cdFx0XHQvL1RoaXMgY2x1c3RlciBzdG9wcGVkIGJlaW5nIGEgY2x1c3RlciBiZWZvcmUgdGhlIHRpbWVvdXQgZmlyZWRcblx0XHRcdGlmIChjbHVzdGVyLl9jaGlsZENvdW50ID09PSAxKSB7XG5cdFx0XHRcdHZhciBtID0gY2x1c3Rlci5fbWFya2Vyc1swXTtcblx0XHRcdFx0Ly9JZiB3ZSB3ZXJlIGluIGEgY2x1c3RlciBhbmltYXRpb24gYXQgdGhlIHRpbWUgdGhlbiB0aGUgb3BhY2l0eSBhbmQgcG9zaXRpb24gb2Ygb3VyIGNoaWxkIGNvdWxkIGJlIHdyb25nIG5vdywgc28gZml4IGl0XG5cdFx0XHRcdG0uc2V0TGF0TG5nKG0uZ2V0TGF0TG5nKCkpO1xuXHRcdFx0XHRtLnNldE9wYWNpdHkoMSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbHVzdGVyLl9yZWN1cnNpdmVseShib3VuZHMsIG5ld1pvb21MZXZlbCwgMCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseVJlbW92ZUNoaWxkcmVuRnJvbU1hcChib3VuZHMsIHByZXZpb3VzWm9vbUxldmVsICsgMSk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdH0pO1xuXHR9LFxuXHRfYW5pbWF0aW9uQWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllciwgbmV3Q2x1c3Rlcikge1xuXHRcdHZhciBtZSA9IHRoaXMsXG5cdFx0XHRmZyA9IHRoaXMuX2ZlYXR1cmVHcm91cDtcblxuXHRcdGZnLmFkZExheWVyKGxheWVyKTtcblx0XHRpZiAobmV3Q2x1c3RlciAhPT0gbGF5ZXIpIHtcblx0XHRcdGlmIChuZXdDbHVzdGVyLl9jaGlsZENvdW50ID4gMikgeyAvL1dhcyBhbHJlYWR5IGEgY2x1c3RlclxuXG5cdFx0XHRcdG5ld0NsdXN0ZXIuX3VwZGF0ZUljb24oKTtcblx0XHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcblx0XHRcdFx0dGhpcy5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdFx0XHRsYXllci5fc2V0UG9zKHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobmV3Q2x1c3Rlci5nZXRMYXRMbmcoKSkpO1xuXHRcdFx0XHRsYXllci5zZXRPcGFjaXR5KDApO1xuXG5cdFx0XHRcdHRoaXMuX2VucXVldWUoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdGZnLnJlbW92ZUxheWVyKGxheWVyKTtcblx0XHRcdFx0XHRsYXllci5zZXRPcGFjaXR5KDEpO1xuXG5cdFx0XHRcdFx0bWUuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdFx0XHR9KTtcblxuXHRcdFx0fSBlbHNlIHsgLy9KdXN0IGJlY2FtZSBhIGNsdXN0ZXJcblx0XHRcdFx0dGhpcy5fZm9yY2VMYXlvdXQoKTtcblxuXHRcdFx0XHRtZS5fYW5pbWF0aW9uU3RhcnQoKTtcblx0XHRcdFx0bWUuX2FuaW1hdGlvblpvb21PdXRTaW5nbGUobmV3Q2x1c3RlciwgdGhpcy5fbWFwLmdldE1heFpvb20oKSwgdGhpcy5fbWFwLmdldFpvb20oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vRm9yY2UgYSBicm93c2VyIGxheW91dCBvZiBzdHVmZiBpbiB0aGUgbWFwXG5cdC8vIFNob3VsZCBhcHBseSB0aGUgY3VycmVudCBvcGFjaXR5IGFuZCBsb2NhdGlvbiB0byBhbGwgZWxlbWVudHMgc28gd2UgY2FuIHVwZGF0ZSB0aGVtIGFnYWluIGZvciBhbiBhbmltYXRpb25cblx0X2ZvcmNlTGF5b3V0OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9JbiBteSB0ZXN0aW5nIHRoaXMgd29ya3MsIGluZmFjdCBvZmZzZXRXaWR0aCBvZiBhbnkgZWxlbWVudCBzZWVtcyB0byB3b3JrLlxuXHRcdC8vQ291bGQgbG9vcCBhbGwgdGhpcy5fbGF5ZXJzIGFuZCBkbyB0aGlzIGZvciBlYWNoIF9pY29uIGlmIGl0IHN0b3BzIHdvcmtpbmdcblxuXHRcdEwuVXRpbC5mYWxzZUZuKGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGgpO1xuXHR9XG59KTtcblxuTC5tYXJrZXJDbHVzdGVyR3JvdXAgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuXHRyZXR1cm4gbmV3IEwuTWFya2VyQ2x1c3Rlckdyb3VwKG9wdGlvbnMpO1xufTtcblxuXG5MLk1hcmtlckNsdXN0ZXIgPSBMLk1hcmtlci5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ3JvdXAsIHpvb20sIGEsIGIpIHtcblxuXHRcdEwuTWFya2VyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgYSA/IChhLl9jTGF0TG5nIHx8IGEuZ2V0TGF0TG5nKCkpIDogbmV3IEwuTGF0TG5nKDAsIDApLCB7IGljb246IHRoaXMgfSk7XG5cblxuXHRcdHRoaXMuX2dyb3VwID0gZ3JvdXA7XG5cdFx0dGhpcy5fem9vbSA9IHpvb207XG5cblx0XHR0aGlzLl9tYXJrZXJzID0gW107XG5cdFx0dGhpcy5fY2hpbGRDbHVzdGVycyA9IFtdO1xuXHRcdHRoaXMuX2NoaWxkQ291bnQgPSAwO1xuXHRcdHRoaXMuX2ljb25OZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHR0aGlzLl9ib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcblxuXHRcdGlmIChhKSB7XG5cdFx0XHR0aGlzLl9hZGRDaGlsZChhKTtcblx0XHR9XG5cdFx0aWYgKGIpIHtcblx0XHRcdHRoaXMuX2FkZENoaWxkKGIpO1xuXHRcdH1cblx0fSxcblxuXHQvL1JlY3Vyc2l2ZWx5IHJldHJpZXZlIGFsbCBjaGlsZCBtYXJrZXJzIG9mIHRoaXMgY2x1c3RlclxuXHRnZXRBbGxDaGlsZE1hcmtlcnM6IGZ1bmN0aW9uIChzdG9yYWdlQXJyYXkpIHtcblx0XHRzdG9yYWdlQXJyYXkgPSBzdG9yYWdlQXJyYXkgfHwgW107XG5cblx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1tpXS5nZXRBbGxDaGlsZE1hcmtlcnMoc3RvcmFnZUFycmF5KTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBqID0gdGhpcy5fbWFya2Vycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0c3RvcmFnZUFycmF5LnB1c2godGhpcy5fbWFya2Vyc1tqXSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHN0b3JhZ2VBcnJheTtcblx0fSxcblxuXHQvL1JldHVybnMgdGhlIGNvdW50IG9mIGhvdyBtYW55IGNoaWxkIG1hcmtlcnMgd2UgaGF2ZVxuXHRnZXRDaGlsZENvdW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ291bnQ7XG5cdH0sXG5cblx0Ly9ab29tIHRvIHRoZSBtaW5pbXVtIG9mIHNob3dpbmcgYWxsIG9mIHRoZSBjaGlsZCBtYXJrZXJzLCBvciB0aGUgZXh0ZW50cyBvZiB0aGlzIGNsdXN0ZXJcblx0em9vbVRvQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLnNsaWNlKCksXG5cdFx0XHRtYXAgPSB0aGlzLl9ncm91cC5fbWFwLFxuXHRcdFx0Ym91bmRzWm9vbSA9IG1hcC5nZXRCb3VuZHNab29tKHRoaXMuX2JvdW5kcyksXG5cdFx0XHR6b29tID0gdGhpcy5fem9vbSArIDEsXG5cdFx0XHRtYXBab29tID0gbWFwLmdldFpvb20oKSxcblx0XHRcdGk7XG5cblx0XHQvL2NhbGN1bGF0ZSBob3cgZmFyZSB3ZSBuZWVkIHRvIHpvb20gZG93biB0byBzZWUgYWxsIG9mIHRoZSBtYXJrZXJzXG5cdFx0d2hpbGUgKGNoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiBib3VuZHNab29tID4gem9vbSkge1xuXHRcdFx0em9vbSsrO1xuXHRcdFx0dmFyIG5ld0NsdXN0ZXJzID0gW107XG5cdFx0XHRmb3IgKGkgPSAwOyBpIDwgY2hpbGRDbHVzdGVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRuZXdDbHVzdGVycyA9IG5ld0NsdXN0ZXJzLmNvbmNhdChjaGlsZENsdXN0ZXJzW2ldLl9jaGlsZENsdXN0ZXJzKTtcblx0XHRcdH1cblx0XHRcdGNoaWxkQ2x1c3RlcnMgPSBuZXdDbHVzdGVycztcblx0XHR9XG5cblx0XHRpZiAoYm91bmRzWm9vbSA+IHpvb20pIHtcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIHpvb20pO1xuXHRcdH0gZWxzZSBpZiAoYm91bmRzWm9vbSA8PSBtYXBab29tKSB7IC8vSWYgZml0Qm91bmRzIHdvdWxkbid0IHpvb20gdXMgZG93biwgem9vbSB1cyBkb3duIGluc3RlYWRcblx0XHRcdHRoaXMuX2dyb3VwLl9tYXAuc2V0Vmlldyh0aGlzLl9sYXRsbmcsIG1hcFpvb20gKyAxKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fZ3JvdXAuX21hcC5maXRCb3VuZHModGhpcy5fYm91bmRzKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBMLkxhdExuZ0JvdW5kcygpO1xuXHRcdGJvdW5kcy5leHRlbmQodGhpcy5fYm91bmRzKTtcblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdF91cGRhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5faWNvbikge1xuXHRcdFx0dGhpcy5zZXRJY29uKHRoaXMpO1xuXHRcdH1cblx0fSxcblxuXHQvL0NsdWRnZSBmb3IgSWNvbiwgd2UgcHJldGVuZCB0byBiZSBhbiBpY29uIGZvciBwZXJmb3JtYW5jZVxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX2ljb25OZWVkc1VwZGF0ZSkge1xuXHRcdFx0dGhpcy5faWNvbk9iaiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuaWNvbkNyZWF0ZUZ1bmN0aW9uKHRoaXMpO1xuXHRcdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pY29uT2JqLmNyZWF0ZUljb24oKTtcblx0fSxcblx0Y3JlYXRlU2hhZG93OiBmdW5jdGlvbiAoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ljb25PYmouY3JlYXRlU2hhZG93KCk7XG5cdH0sXG5cblxuXHRfYWRkQ2hpbGQ6IGZ1bmN0aW9uIChuZXcxLCBpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xuXG5cdFx0dGhpcy5faWNvbk5lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR0aGlzLl9leHBhbmRCb3VuZHMobmV3MSk7XG5cblx0XHRpZiAobmV3MSBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0aWYgKCFpc05vdGlmaWNhdGlvbkZyb21DaGlsZCkge1xuXHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzLnB1c2gobmV3MSk7XG5cdFx0XHRcdG5ldzEuX19wYXJlbnQgPSB0aGlzO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hpbGRDb3VudCArPSBuZXcxLl9jaGlsZENvdW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIWlzTm90aWZpY2F0aW9uRnJvbUNoaWxkKSB7XG5cdFx0XHRcdHRoaXMuX21hcmtlcnMucHVzaChuZXcxKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoaWxkQ291bnQrKztcblx0XHR9XG5cblx0XHRpZiAodGhpcy5fX3BhcmVudCkge1xuXHRcdFx0dGhpcy5fX3BhcmVudC5fYWRkQ2hpbGQobmV3MSwgdHJ1ZSk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vRXhwYW5kIG91ciBib3VuZHMgYW5kIHRlbGwgb3VyIHBhcmVudCB0b1xuXHRfZXhwYW5kQm91bmRzOiBmdW5jdGlvbiAobWFya2VyKSB7XG5cdFx0dmFyIGFkZGVkQ291bnQsXG5cdFx0ICAgIGFkZGVkTGF0TG5nID0gbWFya2VyLl93TGF0TG5nIHx8IG1hcmtlci5fbGF0bG5nO1xuXG5cdFx0aWYgKG1hcmtlciBpbnN0YW5jZW9mIEwuTWFya2VyQ2x1c3Rlcikge1xuXHRcdFx0dGhpcy5fYm91bmRzLmV4dGVuZChtYXJrZXIuX2JvdW5kcyk7XG5cdFx0XHRhZGRlZENvdW50ID0gbWFya2VyLl9jaGlsZENvdW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMuZXh0ZW5kKGFkZGVkTGF0TG5nKTtcblx0XHRcdGFkZGVkQ291bnQgPSAxO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5fY0xhdExuZykge1xuXHRcdFx0Ly8gd2hlbiBjbHVzdGVyaW5nLCB0YWtlIHBvc2l0aW9uIG9mIHRoZSBmaXJzdCBwb2ludCBhcyB0aGUgY2x1c3RlciBjZW50ZXJcblx0XHRcdHRoaXMuX2NMYXRMbmcgPSBtYXJrZXIuX2NMYXRMbmcgfHwgYWRkZWRMYXRMbmc7XG5cdFx0fVxuXG5cdFx0Ly8gd2hlbiBzaG93aW5nIGNsdXN0ZXJzLCB0YWtlIHdlaWdodGVkIGF2ZXJhZ2Ugb2YgYWxsIHBvaW50cyBhcyBjbHVzdGVyIGNlbnRlclxuXHRcdHZhciB0b3RhbENvdW50ID0gdGhpcy5fY2hpbGRDb3VudCArIGFkZGVkQ291bnQ7XG5cblx0XHQvL0NhbGN1bGF0ZSB3ZWlnaHRlZCBsYXRsbmcgZm9yIGRpc3BsYXlcblx0XHRpZiAoIXRoaXMuX3dMYXRMbmcpIHtcblx0XHRcdHRoaXMuX2xhdGxuZyA9IHRoaXMuX3dMYXRMbmcgPSBuZXcgTC5MYXRMbmcoYWRkZWRMYXRMbmcubGF0LCBhZGRlZExhdExuZy5sbmcpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl93TGF0TG5nLmxhdCA9IChhZGRlZExhdExuZy5sYXQgKiBhZGRlZENvdW50ICsgdGhpcy5fd0xhdExuZy5sYXQgKiB0aGlzLl9jaGlsZENvdW50KSAvIHRvdGFsQ291bnQ7XG5cdFx0XHR0aGlzLl93TGF0TG5nLmxuZyA9IChhZGRlZExhdExuZy5sbmcgKiBhZGRlZENvdW50ICsgdGhpcy5fd0xhdExuZy5sbmcgKiB0aGlzLl9jaGlsZENvdW50KSAvIHRvdGFsQ291bnQ7XG5cdFx0fVxuXHR9LFxuXG5cdC8vU2V0IG91ciBtYXJrZXJzIHBvc2l0aW9uIGFzIGdpdmVuIGFuZCBhZGQgaXQgdG8gdGhlIG1hcFxuXHRfYWRkVG9NYXA6IGZ1bmN0aW9uIChzdGFydFBvcykge1xuXHRcdGlmIChzdGFydFBvcykge1xuXHRcdFx0dGhpcy5fYmFja3VwTGF0bG5nID0gdGhpcy5fbGF0bG5nO1xuXHRcdFx0dGhpcy5zZXRMYXRMbmcoc3RhcnRQb3MpO1xuXHRcdH1cblx0XHR0aGlzLl9ncm91cC5fZmVhdHVyZUdyb3VwLmFkZExheWVyKHRoaXMpO1xuXHR9LFxuXG5cdF9yZWN1cnNpdmVseUFuaW1hdGVDaGlsZHJlbkluOiBmdW5jdGlvbiAoYm91bmRzLCBjZW50ZXIsIG1heFpvb20pIHtcblx0XHR0aGlzLl9yZWN1cnNpdmVseShib3VuZHMsIDAsIG1heFpvb20gLSAxLFxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0dmFyIG1hcmtlcnMgPSBjLl9tYXJrZXJzLFxuXHRcdFx0XHRcdGksIG07XG5cdFx0XHRcdGZvciAoaSA9IG1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRtID0gbWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdC8vT25seSBkbyBpdCBpZiB0aGUgaWNvbiBpcyBzdGlsbCBvbiB0aGUgbWFwXG5cdFx0XHRcdFx0aWYgKG0uX2ljb24pIHtcblx0XHRcdFx0XHRcdG0uX3NldFBvcyhjZW50ZXIpO1xuXHRcdFx0XHRcdFx0bS5zZXRPcGFjaXR5KDApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGZ1bmN0aW9uIChjKSB7XG5cdFx0XHRcdHZhciBjaGlsZENsdXN0ZXJzID0gYy5fY2hpbGRDbHVzdGVycyxcblx0XHRcdFx0XHRqLCBjbTtcblx0XHRcdFx0Zm9yIChqID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdGNtID0gY2hpbGRDbHVzdGVyc1tqXTtcblx0XHRcdFx0XHRpZiAoY20uX2ljb24pIHtcblx0XHRcdFx0XHRcdGNtLl9zZXRQb3MoY2VudGVyKTtcblx0XHRcdFx0XHRcdGNtLnNldE9wYWNpdHkoMCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblxuXHRfcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5JbkFuZEFkZFNlbGZUb01hcDogZnVuY3Rpb24gKGJvdW5kcywgcHJldmlvdXNab29tTGV2ZWwsIG5ld1pvb21MZXZlbCkge1xuXHRcdHRoaXMuX3JlY3Vyc2l2ZWx5KGJvdW5kcywgbmV3Wm9vbUxldmVsLCAwLFxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlBbmltYXRlQ2hpbGRyZW5Jbihib3VuZHMsIGMuX2dyb3VwLl9tYXAubGF0TG5nVG9MYXllclBvaW50KGMuZ2V0TGF0TG5nKCkpLnJvdW5kKCksIHByZXZpb3VzWm9vbUxldmVsKTtcblxuXHRcdFx0XHQvL1RPRE86IGRlcHRoVG9BbmltYXRlSW4gYWZmZWN0cyBfaXNTaW5nbGVQYXJlbnQsIGlmIHRoZXJlIGlzIGEgbXVsdGl6b29tIHdlIG1heS9tYXkgbm90IGJlLlxuXHRcdFx0XHQvL0FzIGEgaGFjayB3ZSBvbmx5IGRvIGEgYW5pbWF0aW9uIGZyZWUgem9vbSBvbiBhIHNpbmdsZSBsZXZlbCB6b29tLCBpZiBzb21lb25lIGRvZXMgbXVsdGlwbGUgbGV2ZWxzIHRoZW4gd2UgYWx3YXlzIGFuaW1hdGVcblx0XHRcdFx0aWYgKGMuX2lzU2luZ2xlUGFyZW50KCkgJiYgcHJldmlvdXNab29tTGV2ZWwgLSAxID09PSBuZXdab29tTGV2ZWwpIHtcblx0XHRcdFx0XHRjLnNldE9wYWNpdHkoMSk7XG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHlSZW1vdmVDaGlsZHJlbkZyb21NYXAoYm91bmRzLCBwcmV2aW91c1pvb21MZXZlbCk7IC8vSW1tZWRpYXRlbHkgcmVtb3ZlIG91ciBjaGlsZHJlbiBhcyB3ZSBhcmUgcmVwbGFjaW5nIHRoZW0uIFRPRE8gcHJldmlvdXNCb3VuZHMgbm90IGJvdW5kc1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGMuc2V0T3BhY2l0eSgwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGMuX2FkZFRvTWFwKCk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblxuXHRfcmVjdXJzaXZlbHlCZWNvbWVWaXNpYmxlOiBmdW5jdGlvbiAoYm91bmRzLCB6b29tTGV2ZWwpIHtcblx0XHR0aGlzLl9yZWN1cnNpdmVseShib3VuZHMsIDAsIHpvb21MZXZlbCwgbnVsbCwgZnVuY3Rpb24gKGMpIHtcblx0XHRcdGMuc2V0T3BhY2l0eSgxKTtcblx0XHR9KTtcblx0fSxcblxuXHRfcmVjdXJzaXZlbHlBZGRDaGlsZHJlblRvTWFwOiBmdW5jdGlvbiAoc3RhcnRQb3MsIHpvb21MZXZlbCwgYm91bmRzKSB7XG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkoYm91bmRzLCAtMSwgem9vbUxldmVsLFxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0aWYgKHpvb21MZXZlbCA9PT0gYy5fem9vbSkge1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vQWRkIG91ciBjaGlsZCBtYXJrZXJzIGF0IHN0YXJ0UG9zIChzbyB0aGV5IGNhbiBiZSBhbmltYXRlZCBvdXQpXG5cdFx0XHRcdGZvciAodmFyIGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0dmFyIG5tID0gYy5fbWFya2Vyc1tpXTtcblxuXHRcdFx0XHRcdGlmICghYm91bmRzLmNvbnRhaW5zKG5tLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRpZiAoc3RhcnRQb3MpIHtcblx0XHRcdFx0XHRcdG5tLl9iYWNrdXBMYXRsbmcgPSBubS5nZXRMYXRMbmcoKTtcblxuXHRcdFx0XHRcdFx0bm0uc2V0TGF0TG5nKHN0YXJ0UG9zKTtcblx0XHRcdFx0XHRcdGlmIChubS5zZXRPcGFjaXR5KSB7XG5cdFx0XHRcdFx0XHRcdG5tLnNldE9wYWNpdHkoMCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Yy5fZ3JvdXAuX2ZlYXR1cmVHcm91cC5hZGRMYXllcihubSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRmdW5jdGlvbiAoYykge1xuXHRcdFx0XHRjLl9hZGRUb01hcChzdGFydFBvcyk7XG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblxuXHRfcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnM6IGZ1bmN0aW9uICh6b29tTGV2ZWwpIHtcblx0XHQvL0ZpeCBwb3NpdGlvbnMgb2YgY2hpbGQgbWFya2Vyc1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgbm0gPSB0aGlzLl9tYXJrZXJzW2ldO1xuXHRcdFx0aWYgKG5tLl9iYWNrdXBMYXRsbmcpIHtcblx0XHRcdFx0bm0uc2V0TGF0TG5nKG5tLl9iYWNrdXBMYXRsbmcpO1xuXHRcdFx0XHRkZWxldGUgbm0uX2JhY2t1cExhdGxuZztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoem9vbUxldmVsIC0gMSA9PT0gdGhpcy5fem9vbSkge1xuXHRcdFx0Ly9SZXBvc2l0aW9uIGNoaWxkIGNsdXN0ZXJzXG5cdFx0XHRmb3IgKHZhciBqID0gdGhpcy5fY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHR0aGlzLl9jaGlsZENsdXN0ZXJzW2pdLl9yZXN0b3JlUG9zaXRpb24oKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0Zm9yICh2YXIgayA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgayA+PSAwOyBrLS0pIHtcblx0XHRcdFx0dGhpcy5fY2hpbGRDbHVzdGVyc1trXS5fcmVjdXJzaXZlbHlSZXN0b3JlQ2hpbGRQb3NpdGlvbnMoem9vbUxldmVsKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3Jlc3RvcmVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9iYWNrdXBMYXRsbmcpIHtcblx0XHRcdHRoaXMuc2V0TGF0TG5nKHRoaXMuX2JhY2t1cExhdGxuZyk7XG5cdFx0XHRkZWxldGUgdGhpcy5fYmFja3VwTGF0bG5nO1xuXHRcdH1cblx0fSxcblxuXHQvL2V4Y2VwdEJvdW5kczogSWYgc2V0LCBkb24ndCByZW1vdmUgYW55IG1hcmtlcnMvY2x1c3RlcnMgaW4gaXRcblx0X3JlY3Vyc2l2ZWx5UmVtb3ZlQ2hpbGRyZW5Gcm9tTWFwOiBmdW5jdGlvbiAocHJldmlvdXNCb3VuZHMsIHpvb21MZXZlbCwgZXhjZXB0Qm91bmRzKSB7XG5cdFx0dmFyIG0sIGk7XG5cdFx0dGhpcy5fcmVjdXJzaXZlbHkocHJldmlvdXNCb3VuZHMsIC0xLCB6b29tTGV2ZWwgLSAxLFxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0Ly9SZW1vdmUgbWFya2VycyBhdCBldmVyeSBsZXZlbFxuXHRcdFx0XHRmb3IgKGkgPSBjLl9tYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdFx0bSA9IGMuX21hcmtlcnNbaV07XG5cdFx0XHRcdFx0aWYgKCFleGNlcHRCb3VuZHMgfHwgIWV4Y2VwdEJvdW5kcy5jb250YWlucyhtLl9sYXRsbmcpKSB7XG5cdFx0XHRcdFx0XHRjLl9ncm91cC5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKG0pO1xuXHRcdFx0XHRcdFx0aWYgKG0uc2V0T3BhY2l0eSkge1xuXHRcdFx0XHRcdFx0XHRtLnNldE9wYWNpdHkoMSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZnVuY3Rpb24gKGMpIHtcblx0XHRcdFx0Ly9SZW1vdmUgY2hpbGQgY2x1c3RlcnMgYXQganVzdCB0aGUgYm90dG9tIGxldmVsXG5cdFx0XHRcdGZvciAoaSA9IGMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0XHRtID0gYy5fY2hpbGRDbHVzdGVyc1tpXTtcblx0XHRcdFx0XHRpZiAoIWV4Y2VwdEJvdW5kcyB8fCAhZXhjZXB0Qm91bmRzLmNvbnRhaW5zKG0uX2xhdGxuZykpIHtcblx0XHRcdFx0XHRcdGMuX2dyb3VwLl9mZWF0dXJlR3JvdXAucmVtb3ZlTGF5ZXIobSk7XG5cdFx0XHRcdFx0XHRpZiAobS5zZXRPcGFjaXR5KSB7XG5cdFx0XHRcdFx0XHRcdG0uc2V0T3BhY2l0eSgxKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHQpO1xuXHR9LFxuXG5cdC8vUnVuIHRoZSBnaXZlbiBmdW5jdGlvbnMgcmVjdXJzaXZlbHkgdG8gdGhpcyBhbmQgY2hpbGQgY2x1c3RlcnNcblx0Ly8gYm91bmRzVG9BcHBseVRvOiBhIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudGluZyB0aGUgYm91bmRzIG9mIHdoYXQgY2x1c3RlcnMgdG8gcmVjdXJzZSBpbiB0b1xuXHQvLyB6b29tTGV2ZWxUb1N0YXJ0OiB6b29tIGxldmVsIHRvIHN0YXJ0IHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXG5cdC8vIHpvb21MZXZlbFRvU3RvcDogem9vbSBsZXZlbCB0byBzdG9wIHJ1bm5pbmcgZnVuY3Rpb25zIChpbmNsdXNpdmUpXG5cdC8vIHJ1bkF0RXZlcnlMZXZlbDogZnVuY3Rpb24gdGhhdCB0YWtlcyBhbiBMLk1hcmtlckNsdXN0ZXIgYXMgYW4gYXJndW1lbnQgdGhhdCBzaG91bGQgYmUgYXBwbGllZCBvbiBldmVyeSBsZXZlbFxuXHQvLyBydW5BdEJvdHRvbUxldmVsOiBmdW5jdGlvbiB0aGF0IHRha2VzIGFuIEwuTWFya2VyQ2x1c3RlciBhcyBhbiBhcmd1bWVudCB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIGF0IG9ubHkgdGhlIGJvdHRvbSBsZXZlbFxuXHRfcmVjdXJzaXZlbHk6IGZ1bmN0aW9uIChib3VuZHNUb0FwcGx5VG8sIHpvb21MZXZlbFRvU3RhcnQsIHpvb21MZXZlbFRvU3RvcCwgcnVuQXRFdmVyeUxldmVsLCBydW5BdEJvdHRvbUxldmVsKSB7XG5cdFx0dmFyIGNoaWxkQ2x1c3RlcnMgPSB0aGlzLl9jaGlsZENsdXN0ZXJzLFxuXHRcdCAgICB6b29tID0gdGhpcy5fem9vbSxcblx0XHRcdGksIGM7XG5cblx0XHRpZiAoem9vbUxldmVsVG9TdGFydCA+IHpvb20pIHsgLy9TdGlsbCBnb2luZyBkb3duIHRvIHJlcXVpcmVkIGRlcHRoLCBqdXN0IHJlY3Vyc2UgdG8gY2hpbGQgY2x1c3RlcnNcblx0XHRcdGZvciAoaSA9IGNoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0YyA9IGNoaWxkQ2x1c3RlcnNbaV07XG5cdFx0XHRcdGlmIChib3VuZHNUb0FwcGx5VG8uaW50ZXJzZWN0cyhjLl9ib3VuZHMpKSB7XG5cdFx0XHRcdFx0Yy5fcmVjdXJzaXZlbHkoYm91bmRzVG9BcHBseVRvLCB6b29tTGV2ZWxUb1N0YXJ0LCB6b29tTGV2ZWxUb1N0b3AsIHJ1bkF0RXZlcnlMZXZlbCwgcnVuQXRCb3R0b21MZXZlbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgeyAvL0luIHJlcXVpcmVkIGRlcHRoXG5cblx0XHRcdGlmIChydW5BdEV2ZXJ5TGV2ZWwpIHtcblx0XHRcdFx0cnVuQXRFdmVyeUxldmVsKHRoaXMpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHJ1bkF0Qm90dG9tTGV2ZWwgJiYgdGhpcy5fem9vbSA9PT0gem9vbUxldmVsVG9TdG9wKSB7XG5cdFx0XHRcdHJ1bkF0Qm90dG9tTGV2ZWwodGhpcyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vVE9ETzogVGhpcyBsb29wIGlzIGFsbW9zdCB0aGUgc2FtZSBhcyBhYm92ZVxuXHRcdFx0aWYgKHpvb21MZXZlbFRvU3RvcCA+IHpvb20pIHtcblx0XHRcdFx0Zm9yIChpID0gY2hpbGRDbHVzdGVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRcdGMgPSBjaGlsZENsdXN0ZXJzW2ldO1xuXHRcdFx0XHRcdGlmIChib3VuZHNUb0FwcGx5VG8uaW50ZXJzZWN0cyhjLl9ib3VuZHMpKSB7XG5cdFx0XHRcdFx0XHRjLl9yZWN1cnNpdmVseShib3VuZHNUb0FwcGx5VG8sIHpvb21MZXZlbFRvU3RhcnQsIHpvb21MZXZlbFRvU3RvcCwgcnVuQXRFdmVyeUxldmVsLCBydW5BdEJvdHRvbUxldmVsKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X3JlY2FsY3VsYXRlQm91bmRzOiBmdW5jdGlvbiAoKSB7XG5cdFx0dmFyIG1hcmtlcnMgPSB0aGlzLl9tYXJrZXJzLFxuXHRcdFx0Y2hpbGRDbHVzdGVycyA9IHRoaXMuX2NoaWxkQ2x1c3RlcnMsXG5cdFx0XHRpO1xuXG5cdFx0dGhpcy5fYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKCk7XG5cdFx0ZGVsZXRlIHRoaXMuX3dMYXRMbmc7XG5cblx0XHRmb3IgKGkgPSBtYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR0aGlzLl9leHBhbmRCb3VuZHMobWFya2Vyc1tpXSk7XG5cdFx0fVxuXHRcdGZvciAoaSA9IGNoaWxkQ2x1c3RlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHRoaXMuX2V4cGFuZEJvdW5kcyhjaGlsZENsdXN0ZXJzW2ldKTtcblx0XHR9XG5cdH0sXG5cblxuXHQvL1JldHVybnMgdHJ1ZSBpZiB3ZSBhcmUgdGhlIHBhcmVudCBvZiBvbmx5IG9uZSBjbHVzdGVyIGFuZCB0aGF0IGNsdXN0ZXIgaXMgdGhlIHNhbWUgYXMgdXNcblx0X2lzU2luZ2xlUGFyZW50OiBmdW5jdGlvbiAoKSB7XG5cdFx0Ly9Eb24ndCBuZWVkIHRvIGNoZWNrIHRoaXMuX21hcmtlcnMgYXMgdGhlIHJlc3Qgd29uJ3Qgd29yayBpZiB0aGVyZSBhcmUgYW55XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkQ2x1c3RlcnMubGVuZ3RoID4gMCAmJiB0aGlzLl9jaGlsZENsdXN0ZXJzWzBdLl9jaGlsZENvdW50ID09PSB0aGlzLl9jaGlsZENvdW50O1xuXHR9XG59KTtcblxuXG5cbkwuRGlzdGFuY2VHcmlkID0gZnVuY3Rpb24gKGNlbGxTaXplKSB7XG5cdHRoaXMuX2NlbGxTaXplID0gY2VsbFNpemU7XG5cdHRoaXMuX3NxQ2VsbFNpemUgPSBjZWxsU2l6ZSAqIGNlbGxTaXplO1xuXHR0aGlzLl9ncmlkID0ge307XG5cdHRoaXMuX29iamVjdFBvaW50ID0geyB9O1xufTtcblxuTC5EaXN0YW5jZUdyaWQucHJvdG90eXBlID0ge1xuXG5cdGFkZE9iamVjdDogZnVuY3Rpb24gKG9iaiwgcG9pbnQpIHtcblx0XHR2YXIgeCA9IHRoaXMuX2dldENvb3JkKHBvaW50LngpLFxuXHRcdCAgICB5ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueSksXG5cdFx0ICAgIGdyaWQgPSB0aGlzLl9ncmlkLFxuXHRcdCAgICByb3cgPSBncmlkW3ldID0gZ3JpZFt5XSB8fCB7fSxcblx0XHQgICAgY2VsbCA9IHJvd1t4XSA9IHJvd1t4XSB8fCBbXSxcblx0XHQgICAgc3RhbXAgPSBMLlV0aWwuc3RhbXAob2JqKTtcblxuXHRcdHRoaXMuX29iamVjdFBvaW50W3N0YW1wXSA9IHBvaW50O1xuXG5cdFx0Y2VsbC5wdXNoKG9iaik7XG5cdH0sXG5cblx0dXBkYXRlT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xuXHRcdHRoaXMucmVtb3ZlT2JqZWN0KG9iaik7XG5cdFx0dGhpcy5hZGRPYmplY3Qob2JqLCBwb2ludCk7XG5cdH0sXG5cblx0Ly9SZXR1cm5zIHRydWUgaWYgdGhlIG9iamVjdCB3YXMgZm91bmRcblx0cmVtb3ZlT2JqZWN0OiBmdW5jdGlvbiAob2JqLCBwb2ludCkge1xuXHRcdHZhciB4ID0gdGhpcy5fZ2V0Q29vcmQocG9pbnQueCksXG5cdFx0ICAgIHkgPSB0aGlzLl9nZXRDb29yZChwb2ludC55KSxcblx0XHQgICAgZ3JpZCA9IHRoaXMuX2dyaWQsXG5cdFx0ICAgIHJvdyA9IGdyaWRbeV0gPSBncmlkW3ldIHx8IHt9LFxuXHRcdCAgICBjZWxsID0gcm93W3hdID0gcm93W3hdIHx8IFtdLFxuXHRcdCAgICBpLCBsZW47XG5cblx0XHRkZWxldGUgdGhpcy5fb2JqZWN0UG9pbnRbTC5VdGlsLnN0YW1wKG9iaildO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNlbGxbaV0gPT09IG9iaikge1xuXG5cdFx0XHRcdGNlbGwuc3BsaWNlKGksIDEpO1xuXG5cdFx0XHRcdGlmIChsZW4gPT09IDEpIHtcblx0XHRcdFx0XHRkZWxldGUgcm93W3hdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdH0sXG5cblx0ZWFjaE9iamVjdDogZnVuY3Rpb24gKGZuLCBjb250ZXh0KSB7XG5cdFx0dmFyIGksIGosIGssIGxlbiwgcm93LCBjZWxsLCByZW1vdmVkLFxuXHRcdCAgICBncmlkID0gdGhpcy5fZ3JpZDtcblxuXHRcdGZvciAoaSBpbiBncmlkKSB7XG5cdFx0XHRyb3cgPSBncmlkW2ldO1xuXG5cdFx0XHRmb3IgKGogaW4gcm93KSB7XG5cdFx0XHRcdGNlbGwgPSByb3dbal07XG5cblx0XHRcdFx0Zm9yIChrID0gMCwgbGVuID0gY2VsbC5sZW5ndGg7IGsgPCBsZW47IGsrKykge1xuXHRcdFx0XHRcdHJlbW92ZWQgPSBmbi5jYWxsKGNvbnRleHQsIGNlbGxba10pO1xuXHRcdFx0XHRcdGlmIChyZW1vdmVkKSB7XG5cdFx0XHRcdFx0XHRrLS07XG5cdFx0XHRcdFx0XHRsZW4tLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0TmVhck9iamVjdDogZnVuY3Rpb24gKHBvaW50KSB7XG5cdFx0dmFyIHggPSB0aGlzLl9nZXRDb29yZChwb2ludC54KSxcblx0XHQgICAgeSA9IHRoaXMuX2dldENvb3JkKHBvaW50LnkpLFxuXHRcdCAgICBpLCBqLCBrLCByb3csIGNlbGwsIGxlbiwgb2JqLCBkaXN0LFxuXHRcdCAgICBvYmplY3RQb2ludCA9IHRoaXMuX29iamVjdFBvaW50LFxuXHRcdCAgICBjbG9zZXN0RGlzdFNxID0gdGhpcy5fc3FDZWxsU2l6ZSxcblx0XHQgICAgY2xvc2VzdCA9IG51bGw7XG5cblx0XHRmb3IgKGkgPSB5IC0gMTsgaSA8PSB5ICsgMTsgaSsrKSB7XG5cdFx0XHRyb3cgPSB0aGlzLl9ncmlkW2ldO1xuXHRcdFx0aWYgKHJvdykge1xuXG5cdFx0XHRcdGZvciAoaiA9IHggLSAxOyBqIDw9IHggKyAxOyBqKyspIHtcblx0XHRcdFx0XHRjZWxsID0gcm93W2pdO1xuXHRcdFx0XHRcdGlmIChjZWxsKSB7XG5cblx0XHRcdFx0XHRcdGZvciAoayA9IDAsIGxlbiA9IGNlbGwubGVuZ3RoOyBrIDwgbGVuOyBrKyspIHtcblx0XHRcdFx0XHRcdFx0b2JqID0gY2VsbFtrXTtcblx0XHRcdFx0XHRcdFx0ZGlzdCA9IHRoaXMuX3NxRGlzdChvYmplY3RQb2ludFtMLlV0aWwuc3RhbXAob2JqKV0sIHBvaW50KTtcblx0XHRcdFx0XHRcdFx0aWYgKGRpc3QgPCBjbG9zZXN0RGlzdFNxKSB7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdCA9IG9iajtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gY2xvc2VzdDtcblx0fSxcblxuXHRfZ2V0Q29vcmQ6IGZ1bmN0aW9uICh4KSB7XG5cdFx0cmV0dXJuIE1hdGguZmxvb3IoeCAvIHRoaXMuX2NlbGxTaXplKTtcblx0fSxcblxuXHRfc3FEaXN0OiBmdW5jdGlvbiAocCwgcDIpIHtcblx0XHR2YXIgZHggPSBwMi54IC0gcC54LFxuXHRcdCAgICBkeSA9IHAyLnkgLSBwLnk7XG5cdFx0cmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xuXHR9XG59O1xuXG5cbi8qIENvcHlyaWdodCAoYykgMjAxMiB0aGUgYXV0aG9ycyBsaXN0ZWQgYXQgdGhlIGZvbGxvd2luZyBVUkwsIGFuZC9vclxudGhlIGF1dGhvcnMgb2YgcmVmZXJlbmNlZCBhcnRpY2xlcyBvciBpbmNvcnBvcmF0ZWQgZXh0ZXJuYWwgY29kZTpcbmh0dHA6Ly9lbi5saXRlcmF0ZXByb2dyYW1zLm9yZy9RdWlja2h1bGxfKEphdmFzY3JpcHQpP2FjdGlvbj1oaXN0b3J5Jm9mZnNldD0yMDEyMDQxMDE3NTI1NlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbmEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG53aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG5kaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbnBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xudGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG5FWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbk1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbklOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG5DTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcblNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5SZXRyaWV2ZWQgZnJvbTogaHR0cDovL2VuLmxpdGVyYXRlcHJvZ3JhbXMub3JnL1F1aWNraHVsbF8oSmF2YXNjcmlwdCk/b2xkaWQ9MTg0MzRcbiovXG5cbihmdW5jdGlvbiAoKSB7XG5cdEwuUXVpY2tIdWxsID0ge1xuXG5cdFx0Lypcblx0XHQgKiBAcGFyYW0ge09iamVjdH0gY3B0IGEgcG9pbnQgdG8gYmUgbWVhc3VyZWQgZnJvbSB0aGUgYmFzZWxpbmVcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBibCB0aGUgYmFzZWxpbmUsIGFzIHJlcHJlc2VudGVkIGJ5IGEgdHdvLWVsZW1lbnRcblx0XHQgKiAgIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzLlxuXHRcdCAqIEByZXR1cm5zIHtOdW1iZXJ9IGFuIGFwcHJveGltYXRlIGRpc3RhbmNlIG1lYXN1cmVcblx0XHQgKi9cblx0XHRnZXREaXN0YW50OiBmdW5jdGlvbiAoY3B0LCBibCkge1xuXHRcdFx0dmFyIHZZID0gYmxbMV0ubGF0IC0gYmxbMF0ubGF0LFxuXHRcdFx0XHR2WCA9IGJsWzBdLmxuZyAtIGJsWzFdLmxuZztcblx0XHRcdHJldHVybiAodlggKiAoY3B0LmxhdCAtIGJsWzBdLmxhdCkgKyB2WSAqIChjcHQubG5nIC0gYmxbMF0ubG5nKSk7XG5cdFx0fSxcblxuXHRcdC8qXG5cdFx0ICogQHBhcmFtIHtBcnJheX0gYmFzZUxpbmUgYSB0d28tZWxlbWVudCBhcnJheSBvZiBsYXRsbmcgb2JqZWN0c1xuXHRcdCAqICAgcmVwcmVzZW50aW5nIHRoZSBiYXNlbGluZSB0byBwcm9qZWN0IGZyb21cblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzIGFuIGFycmF5IG9mIGxhdGxuZyBvYmplY3RzXG5cdFx0ICogQHJldHVybnMge09iamVjdH0gdGhlIG1heGltdW0gcG9pbnQgYW5kIGFsbCBuZXcgcG9pbnRzIHRvIHN0YXlcblx0XHQgKiAgIGluIGNvbnNpZGVyYXRpb24gZm9yIHRoZSBodWxsLlxuXHRcdCAqL1xuXHRcdGZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcblx0XHRcdHZhciBtYXhEID0gMCxcblx0XHRcdFx0bWF4UHQgPSBudWxsLFxuXHRcdFx0XHRuZXdQb2ludHMgPSBbXSxcblx0XHRcdFx0aSwgcHQsIGQ7XG5cblx0XHRcdGZvciAoaSA9IGxhdExuZ3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0cHQgPSBsYXRMbmdzW2ldO1xuXHRcdFx0XHRkID0gdGhpcy5nZXREaXN0YW50KHB0LCBiYXNlTGluZSk7XG5cblx0XHRcdFx0aWYgKGQgPiAwKSB7XG5cdFx0XHRcdFx0bmV3UG9pbnRzLnB1c2gocHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGQgPiBtYXhEKSB7XG5cdFx0XHRcdFx0bWF4RCA9IGQ7XG5cdFx0XHRcdFx0bWF4UHQgPSBwdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBtYXhQb2ludDogbWF4UHQsIG5ld1BvaW50czogbmV3UG9pbnRzIH07XG5cdFx0fSxcblxuXG5cdFx0Lypcblx0XHQgKiBHaXZlbiBhIGJhc2VsaW5lLCBjb21wdXRlIHRoZSBjb252ZXggaHVsbCBvZiBsYXRMbmdzIGFzIGFuIGFycmF5XG5cdFx0ICogb2YgbGF0TG5ncy5cblx0XHQgKlxuXHRcdCAqIEBwYXJhbSB7QXJyYXl9IGxhdExuZ3Ncblx0XHQgKiBAcmV0dXJucyB7QXJyYXl9XG5cdFx0ICovXG5cdFx0YnVpbGRDb252ZXhIdWxsOiBmdW5jdGlvbiAoYmFzZUxpbmUsIGxhdExuZ3MpIHtcblx0XHRcdHZhciBjb252ZXhIdWxsQmFzZUxpbmVzID0gW10sXG5cdFx0XHRcdHQgPSB0aGlzLmZpbmRNb3N0RGlzdGFudFBvaW50RnJvbUJhc2VMaW5lKGJhc2VMaW5lLCBsYXRMbmdzKTtcblxuXHRcdFx0aWYgKHQubWF4UG9pbnQpIHsgLy8gaWYgdGhlcmUgaXMgc3RpbGwgYSBwb2ludCBcIm91dHNpZGVcIiB0aGUgYmFzZSBsaW5lXG5cdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMgPVxuXHRcdFx0XHRcdGNvbnZleEh1bGxCYXNlTGluZXMuY29uY2F0KFxuXHRcdFx0XHRcdFx0dGhpcy5idWlsZENvbnZleEh1bGwoW2Jhc2VMaW5lWzBdLCB0Lm1heFBvaW50XSwgdC5uZXdQb2ludHMpXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcyA9XG5cdFx0XHRcdFx0Y29udmV4SHVsbEJhc2VMaW5lcy5jb25jYXQoXG5cdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbdC5tYXhQb2ludCwgYmFzZUxpbmVbMV1dLCB0Lm5ld1BvaW50cylcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRyZXR1cm4gY29udmV4SHVsbEJhc2VMaW5lcztcblx0XHRcdH0gZWxzZSB7ICAvLyBpZiB0aGVyZSBpcyBubyBtb3JlIHBvaW50IFwib3V0c2lkZVwiIHRoZSBiYXNlIGxpbmUsIHRoZSBjdXJyZW50IGJhc2UgbGluZSBpcyBwYXJ0IG9mIHRoZSBjb252ZXggaHVsbFxuXHRcdFx0XHRyZXR1cm4gW2Jhc2VMaW5lWzBdXTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Lypcblx0XHQgKiBHaXZlbiBhbiBhcnJheSBvZiBsYXRsbmdzLCBjb21wdXRlIGEgY29udmV4IGh1bGwgYXMgYW4gYXJyYXlcblx0XHQgKiBvZiBsYXRsbmdzXG5cdFx0ICpcblx0XHQgKiBAcGFyYW0ge0FycmF5fSBsYXRMbmdzXG5cdFx0ICogQHJldHVybnMge0FycmF5fVxuXHRcdCAqL1xuXHRcdGdldENvbnZleEh1bGw6IGZ1bmN0aW9uIChsYXRMbmdzKSB7XG5cdFx0XHQvLyBmaW5kIGZpcnN0IGJhc2VsaW5lXG5cdFx0XHR2YXIgbWF4TGF0ID0gZmFsc2UsIG1pbkxhdCA9IGZhbHNlLFxuXHRcdFx0XHRtYXhQdCA9IG51bGwsIG1pblB0ID0gbnVsbCxcblx0XHRcdFx0aTtcblxuXHRcdFx0Zm9yIChpID0gbGF0TG5ncy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHR2YXIgcHQgPSBsYXRMbmdzW2ldO1xuXHRcdFx0XHRpZiAobWF4TGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPiBtYXhMYXQpIHtcblx0XHRcdFx0XHRtYXhQdCA9IHB0O1xuXHRcdFx0XHRcdG1heExhdCA9IHB0LmxhdDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobWluTGF0ID09PSBmYWxzZSB8fCBwdC5sYXQgPCBtaW5MYXQpIHtcblx0XHRcdFx0XHRtaW5QdCA9IHB0O1xuXHRcdFx0XHRcdG1pbkxhdCA9IHB0LmxhdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNoID0gW10uY29uY2F0KHRoaXMuYnVpbGRDb252ZXhIdWxsKFttaW5QdCwgbWF4UHRdLCBsYXRMbmdzKSxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmJ1aWxkQ29udmV4SHVsbChbbWF4UHQsIG1pblB0XSwgbGF0TG5ncykpO1xuXHRcdFx0cmV0dXJuIGNoO1xuXHRcdH1cblx0fTtcbn0oKSk7XG5cbkwuTWFya2VyQ2x1c3Rlci5pbmNsdWRlKHtcblx0Z2V0Q29udmV4SHVsbDogZnVuY3Rpb24gKCkge1xuXHRcdHZhciBjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycygpLFxuXHRcdFx0cG9pbnRzID0gW10sXG5cdFx0XHRwLCBpO1xuXG5cdFx0Zm9yIChpID0gY2hpbGRNYXJrZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRwID0gY2hpbGRNYXJrZXJzW2ldLmdldExhdExuZygpO1xuXHRcdFx0cG9pbnRzLnB1c2gocCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIEwuUXVpY2tIdWxsLmdldENvbnZleEh1bGwocG9pbnRzKTtcblx0fVxufSk7XG5cblxuLy9UaGlzIGNvZGUgaXMgMTAwJSBiYXNlZCBvbiBodHRwczovL2dpdGh1Yi5jb20vamF3ai9PdmVybGFwcGluZ01hcmtlclNwaWRlcmZpZXItTGVhZmxldFxuLy9IdWdlIHRoYW5rcyB0byBqYXdqIGZvciBpbXBsZW1lbnRpbmcgaXQgZmlyc3QgdG8gbWFrZSBteSBqb2IgZWFzeSA6LSlcblxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoe1xuXG5cdF8yUEk6IE1hdGguUEkgKiAyLFxuXHRfY2lyY2xlRm9vdFNlcGFyYXRpb246IDI1LCAvL3JlbGF0ZWQgdG8gY2lyY3VtZmVyZW5jZSBvZiBjaXJjbGVcblx0X2NpcmNsZVN0YXJ0QW5nbGU6IE1hdGguUEkgLyA2LFxuXG5cdF9zcGlyYWxGb290U2VwYXJhdGlvbjogIDI4LCAvL3JlbGF0ZWQgdG8gc2l6ZSBvZiBzcGlyYWwgKGV4cGVyaW1lbnQhKVxuXHRfc3BpcmFsTGVuZ3RoU3RhcnQ6IDExLFxuXHRfc3BpcmFsTGVuZ3RoRmFjdG9yOiA1LFxuXG5cdF9jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyOiA5LCAvL3Nob3cgc3BpcmFsIGluc3RlYWQgb2YgY2lyY2xlIGZyb20gdGhpcyBtYXJrZXIgY291bnQgdXB3YXJkcy5cblx0XHRcdFx0XHRcdFx0XHQvLyAwIC0+IGFsd2F5cyBzcGlyYWw7IEluZmluaXR5IC0+IGFsd2F5cyBjaXJjbGVcblxuXHRzcGlkZXJmeTogZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0aGlzLl9ncm91cC5fc3BpZGVyZmllZCA9PT0gdGhpcyB8fCB0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGNoaWxkTWFya2VycyA9IHRoaXMuZ2V0QWxsQ2hpbGRNYXJrZXJzKCksXG5cdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdGNlbnRlciA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcblx0XHRcdHBvc2l0aW9ucztcblxuXHRcdHRoaXMuX2dyb3VwLl91bnNwaWRlcmZ5KCk7XG5cdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSB0aGlzO1xuXG5cdFx0Ly9UT0RPIE1heWJlOiBjaGlsZE1hcmtlcnMgb3JkZXIgYnkgZGlzdGFuY2UgdG8gY2VudGVyXG5cblx0XHRpZiAoY2hpbGRNYXJrZXJzLmxlbmd0aCA+PSB0aGlzLl9jaXJjbGVTcGlyYWxTd2l0Y2hvdmVyKSB7XG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c1NwaXJhbChjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjZW50ZXIueSArPSAxMDsgLy9PdGhlcndpc2UgY2lyY2xlcyBsb29rIHdyb25nXG5cdFx0XHRwb3NpdGlvbnMgPSB0aGlzLl9nZW5lcmF0ZVBvaW50c0NpcmNsZShjaGlsZE1hcmtlcnMubGVuZ3RoLCBjZW50ZXIpO1xuXHRcdH1cblxuXHRcdHRoaXMuX2FuaW1hdGlvblNwaWRlcmZ5KGNoaWxkTWFya2VycywgcG9zaXRpb25zKTtcblx0fSxcblxuXHR1bnNwaWRlcmZ5OiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHQvLy8gPHBhcmFtIE5hbWU9XCJ6b29tRGV0YWlsc1wiPkFyZ3VtZW50IGZyb20gem9vbWFuaW0gaWYgYmVpbmcgY2FsbGVkIGluIGEgem9vbSBhbmltYXRpb24gb3IgbnVsbCBvdGhlcndpc2U8L3BhcmFtPlxuXHRcdGlmICh0aGlzLl9ncm91cC5faW5ab29tQW5pbWF0aW9uKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMuX2FuaW1hdGlvblVuc3BpZGVyZnkoem9vbURldGFpbHMpO1xuXG5cdFx0dGhpcy5fZ3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xuXHR9LFxuXG5cdF9nZW5lcmF0ZVBvaW50c0NpcmNsZTogZnVuY3Rpb24gKGNvdW50LCBjZW50ZXJQdCkge1xuXHRcdHZhciBjaXJjdW1mZXJlbmNlID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX2NpcmNsZUZvb3RTZXBhcmF0aW9uICogKDIgKyBjb3VudCksXG5cdFx0XHRsZWdMZW5ndGggPSBjaXJjdW1mZXJlbmNlIC8gdGhpcy5fMlBJLCAgLy9yYWRpdXMgZnJvbSBjaXJjdW1mZXJlbmNlXG5cdFx0XHRhbmdsZVN0ZXAgPSB0aGlzLl8yUEkgLyBjb3VudCxcblx0XHRcdHJlcyA9IFtdLFxuXHRcdFx0aSwgYW5nbGU7XG5cblx0XHRyZXMubGVuZ3RoID0gY291bnQ7XG5cblx0XHRmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRhbmdsZSA9IHRoaXMuX2NpcmNsZVN0YXJ0QW5nbGUgKyBpICogYW5nbGVTdGVwO1xuXHRcdFx0cmVzW2ldID0gbmV3IEwuUG9pbnQoY2VudGVyUHQueCArIGxlZ0xlbmd0aCAqIE1hdGguY29zKGFuZ2xlKSwgY2VudGVyUHQueSArIGxlZ0xlbmd0aCAqIE1hdGguc2luKGFuZ2xlKSkuX3JvdW5kKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZ2VuZXJhdGVQb2ludHNTcGlyYWw6IGZ1bmN0aW9uIChjb3VudCwgY2VudGVyUHQpIHtcblx0XHR2YXIgbGVnTGVuZ3RoID0gdGhpcy5fZ3JvdXAub3B0aW9ucy5zcGlkZXJmeURpc3RhbmNlTXVsdGlwbGllciAqIHRoaXMuX3NwaXJhbExlbmd0aFN0YXJ0LFxuXHRcdFx0c2VwYXJhdGlvbiA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxGb290U2VwYXJhdGlvbixcblx0XHRcdGxlbmd0aEZhY3RvciA9IHRoaXMuX2dyb3VwLm9wdGlvbnMuc3BpZGVyZnlEaXN0YW5jZU11bHRpcGxpZXIgKiB0aGlzLl9zcGlyYWxMZW5ndGhGYWN0b3IsXG5cdFx0XHRhbmdsZSA9IDAsXG5cdFx0XHRyZXMgPSBbXSxcblx0XHRcdGk7XG5cblx0XHRyZXMubGVuZ3RoID0gY291bnQ7XG5cblx0XHRmb3IgKGkgPSBjb3VudCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRhbmdsZSArPSBzZXBhcmF0aW9uIC8gbGVnTGVuZ3RoICsgaSAqIDAuMDAwNTtcblx0XHRcdHJlc1tpXSA9IG5ldyBMLlBvaW50KGNlbnRlclB0LnggKyBsZWdMZW5ndGggKiBNYXRoLmNvcyhhbmdsZSksIGNlbnRlclB0LnkgKyBsZWdMZW5ndGggKiBNYXRoLnNpbihhbmdsZSkpLl9yb3VuZCgpO1xuXHRcdFx0bGVnTGVuZ3RoICs9IHRoaXMuXzJQSSAqIGxlbmd0aEZhY3RvciAvIGFuZ2xlO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9ub2FuaW1hdGlvblVuc3BpZGVyZnk6IGZ1bmN0aW9uICgpIHtcblx0XHR2YXIgZ3JvdXAgPSB0aGlzLl9ncm91cCxcblx0XHRcdG1hcCA9IGdyb3VwLl9tYXAsXG5cdFx0XHRmZyA9IGdyb3VwLl9mZWF0dXJlR3JvdXAsXG5cdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycygpLFxuXHRcdFx0bSwgaTtcblxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdGZnLnJlbW92ZUxheWVyKG0pO1xuXG5cdFx0XHRpZiAobS5fcHJlU3BpZGVyZnlMYXRsbmcpIHtcblx0XHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xuXHRcdFx0XHRkZWxldGUgbS5fcHJlU3BpZGVyZnlMYXRsbmc7XG5cdFx0XHR9XG5cdFx0XHRpZiAobS5zZXRaSW5kZXhPZmZzZXQpIHtcblx0XHRcdFx0bS5zZXRaSW5kZXhPZmZzZXQoMCk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChtLl9zcGlkZXJMZWcpIHtcblx0XHRcdFx0bWFwLnJlbW92ZUxheWVyKG0uX3NwaWRlckxlZyk7XG5cdFx0XHRcdGRlbGV0ZSBtLl9zcGlkZXJMZWc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Z3JvdXAuX3NwaWRlcmZpZWQgPSBudWxsO1xuXHR9XG59KTtcblxuTC5NYXJrZXJDbHVzdGVyLmluY2x1ZGUoIUwuRG9tVXRpbC5UUkFOU0lUSU9OID8ge1xuXHQvL05vbiBBbmltYXRlZCB2ZXJzaW9ucyBvZiBldmVyeXRoaW5nXG5cdF9hbmltYXRpb25TcGlkZXJmeTogZnVuY3Rpb24gKGNoaWxkTWFya2VycywgcG9zaXRpb25zKSB7XG5cdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0aSwgbSwgbGVnLCBuZXdQb3M7XG5cblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdG0uX3ByZVNwaWRlcmZ5TGF0bG5nID0gbS5fbGF0bG5nO1xuXHRcdFx0bS5zZXRMYXRMbmcobmV3UG9zKTtcblx0XHRcdGlmIChtLnNldFpJbmRleE9mZnNldCkge1xuXHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgxMDAwMDAwKTsgLy9NYWtlIHRoZXNlIGFwcGVhciBvbiB0b3Agb2YgRVZFUllUSElOR1xuXHRcdFx0fVxuXG5cdFx0XHRmZy5hZGRMYXllcihtKTtcblxuXG5cdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbdGhpcy5fbGF0bG5nLCBuZXdQb3NdLCB7IHdlaWdodDogMS41LCBjb2xvcjogJyMyMjInIH0pO1xuXHRcdFx0bWFwLmFkZExheWVyKGxlZyk7XG5cdFx0XHRtLl9zcGlkZXJMZWcgPSBsZWc7XG5cdFx0fVxuXHRcdHRoaXMuc2V0T3BhY2l0eSgwLjMpO1xuXHRcdGdyb3VwLmZpcmUoJ3NwaWRlcmZpZWQnKTtcblx0fSxcblxuXHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKCkge1xuXHRcdHRoaXMuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHR9XG59IDoge1xuXHQvL0FuaW1hdGVkIHZlcnNpb25zIGhlcmVcblx0U1ZHX0FOSU1BVElPTjogKGZ1bmN0aW9uICgpIHtcblx0XHRyZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdhbmltYXRlJykudG9TdHJpbmcoKS5pbmRleE9mKCdTVkdBbmltYXRlJykgPiAtMTtcblx0fSgpKSxcblxuXHRfYW5pbWF0aW9uU3BpZGVyZnk6IGZ1bmN0aW9uIChjaGlsZE1hcmtlcnMsIHBvc2l0aW9ucykge1xuXHRcdHZhciBtZSA9IHRoaXMsXG5cdFx0XHRncm91cCA9IHRoaXMuX2dyb3VwLFxuXHRcdFx0bWFwID0gZ3JvdXAuX21hcCxcblx0XHRcdGZnID0gZ3JvdXAuX2ZlYXR1cmVHcm91cCxcblx0XHRcdHRoaXNMYXllclBvcyA9IG1hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKSxcblx0XHRcdGksIG0sIGxlZywgbmV3UG9zO1xuXG5cdFx0Ly9BZGQgbWFya2VycyB0byBtYXAgaGlkZGVuIGF0IG91ciBjZW50ZXIgcG9pbnRcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdC8vSWYgaXQgaXMgYSBtYXJrZXIsIGFkZCBpdCBub3cgYW5kIHdlJ2xsIGFuaW1hdGUgaXQgb3V0XG5cdFx0XHRpZiAobS5zZXRPcGFjaXR5KSB7XG5cdFx0XHRcdG0uc2V0WkluZGV4T2Zmc2V0KDEwMDAwMDApOyAvL01ha2UgdGhlc2UgYXBwZWFyIG9uIHRvcCBvZiBFVkVSWVRISU5HXG5cdFx0XHRcdG0uc2V0T3BhY2l0eSgwKTtcblx0XHRcdFxuXHRcdFx0XHRmZy5hZGRMYXllcihtKTtcblxuXHRcdFx0XHRtLl9zZXRQb3ModGhpc0xheWVyUG9zKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdC8vVmVjdG9ycyBqdXN0IGdldCBpbW1lZGlhdGVseSBhZGRlZFxuXHRcdFx0XHRmZy5hZGRMYXllcihtKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRncm91cC5fZm9yY2VMYXlvdXQoKTtcblx0XHRncm91cC5fYW5pbWF0aW9uU3RhcnQoKTtcblxuXHRcdHZhciBpbml0aWFsTGVnT3BhY2l0eSA9IEwuUGF0aC5TVkcgPyAwIDogMC4zLFxuXHRcdFx0eG1sbnMgPSBMLlBhdGguU1ZHX05TO1xuXG5cblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdG5ld1BvcyA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcocG9zaXRpb25zW2ldKTtcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdC8vTW92ZSBtYXJrZXIgdG8gbmV3IHBvc2l0aW9uXG5cdFx0XHRtLl9wcmVTcGlkZXJmeUxhdGxuZyA9IG0uX2xhdGxuZztcblx0XHRcdG0uc2V0TGF0TG5nKG5ld1Bvcyk7XG5cdFx0XHRcblx0XHRcdGlmIChtLnNldE9wYWNpdHkpIHtcblx0XHRcdFx0bS5zZXRPcGFjaXR5KDEpO1xuXHRcdFx0fVxuXG5cblx0XHRcdC8vQWRkIExlZ3MuXG5cdFx0XHRsZWcgPSBuZXcgTC5Qb2x5bGluZShbbWUuX2xhdGxuZywgbmV3UG9zXSwgeyB3ZWlnaHQ6IDEuNSwgY29sb3I6ICcjMjIyJywgb3BhY2l0eTogaW5pdGlhbExlZ09wYWNpdHkgfSk7XG5cdFx0XHRtYXAuYWRkTGF5ZXIobGVnKTtcblx0XHRcdG0uX3NwaWRlckxlZyA9IGxlZztcblxuXHRcdFx0Ly9Gb2xsb3dpbmcgYW5pbWF0aW9ucyBkb24ndCB3b3JrIGZvciBjYW52YXNcblx0XHRcdGlmICghTC5QYXRoLlNWRyB8fCAhdGhpcy5TVkdfQU5JTUFUSU9OKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvL0hvdyB0aGlzIHdvcmtzOlxuXHRcdFx0Ly9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzU5MjQyMzgvaG93LWRvLXlvdS1hbmltYXRlLWFuLXN2Zy1wYXRoLWluLWlvc1xuXHRcdFx0Ly9odHRwOi8vZGV2Lm9wZXJhLmNvbS9hcnRpY2xlcy92aWV3L2FkdmFuY2VkLXN2Zy1hbmltYXRpb24tdGVjaG5pcXVlcy9cblxuXHRcdFx0Ly9BbmltYXRlIGxlbmd0aFxuXHRcdFx0dmFyIGxlbmd0aCA9IGxlZy5fcGF0aC5nZXRUb3RhbExlbmd0aCgpO1xuXHRcdFx0bGVnLl9wYXRoLnNldEF0dHJpYnV0ZShcInN0cm9rZS1kYXNoYXJyYXlcIiwgbGVuZ3RoICsgXCIsXCIgKyBsZW5ndGgpO1xuXG5cdFx0XHR2YXIgYW5pbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyh4bWxucywgXCJhbmltYXRlXCIpO1xuXHRcdFx0YW5pbS5zZXRBdHRyaWJ1dGUoXCJhdHRyaWJ1dGVOYW1lXCIsIFwic3Ryb2tlLWRhc2hvZmZzZXRcIik7XG5cdFx0XHRhbmltLnNldEF0dHJpYnV0ZShcImJlZ2luXCIsIFwiaW5kZWZpbml0ZVwiKTtcblx0XHRcdGFuaW0uc2V0QXR0cmlidXRlKFwiZnJvbVwiLCBsZW5ndGgpO1xuXHRcdFx0YW5pbS5zZXRBdHRyaWJ1dGUoXCJ0b1wiLCAwKTtcblx0XHRcdGFuaW0uc2V0QXR0cmlidXRlKFwiZHVyXCIsIDAuMjUpO1xuXHRcdFx0bGVnLl9wYXRoLmFwcGVuZENoaWxkKGFuaW0pO1xuXHRcdFx0YW5pbS5iZWdpbkVsZW1lbnQoKTtcblxuXHRcdFx0Ly9BbmltYXRlIG9wYWNpdHlcblx0XHRcdGFuaW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoeG1sbnMsIFwiYW5pbWF0ZVwiKTtcblx0XHRcdGFuaW0uc2V0QXR0cmlidXRlKFwiYXR0cmlidXRlTmFtZVwiLCBcInN0cm9rZS1vcGFjaXR5XCIpO1xuXHRcdFx0YW5pbS5zZXRBdHRyaWJ1dGUoXCJhdHRyaWJ1dGVOYW1lXCIsIFwic3Ryb2tlLW9wYWNpdHlcIik7XG5cdFx0XHRhbmltLnNldEF0dHJpYnV0ZShcImJlZ2luXCIsIFwiaW5kZWZpbml0ZVwiKTtcblx0XHRcdGFuaW0uc2V0QXR0cmlidXRlKFwiZnJvbVwiLCAwKTtcblx0XHRcdGFuaW0uc2V0QXR0cmlidXRlKFwidG9cIiwgMC41KTtcblx0XHRcdGFuaW0uc2V0QXR0cmlidXRlKFwiZHVyXCIsIDAuMjUpO1xuXHRcdFx0bGVnLl9wYXRoLmFwcGVuZENoaWxkKGFuaW0pO1xuXHRcdFx0YW5pbS5iZWdpbkVsZW1lbnQoKTtcblx0XHR9XG5cdFx0bWUuc2V0T3BhY2l0eSgwLjMpO1xuXG5cdFx0Ly9TZXQgdGhlIG9wYWNpdHkgb2YgdGhlIHNwaWRlckxlZ3MgYmFjayB0byB0aGVpciBjb3JyZWN0IHZhbHVlXG5cdFx0Ly8gVGhlIGFuaW1hdGlvbnMgYWJvdmUgb3ZlcnJpZGUgdGhpcyB1bnRpbCB0aGV5IGNvbXBsZXRlLlxuXHRcdC8vIElmIHRoZSBpbml0aWFsIG9wYWNpdHkgb2YgdGhlIHNwaWRlcmxlZ3MgaXNuJ3QgMCB0aGVuIHRoZXkgYXBwZWFyIGJlZm9yZSB0aGUgYW5pbWF0aW9uIHN0YXJ0cy5cblx0XHRpZiAoTC5QYXRoLlNWRykge1xuXHRcdFx0dGhpcy5fZ3JvdXAuX2ZvcmNlTGF5b3V0KCk7XG5cblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldLl9zcGlkZXJMZWc7XG5cblx0XHRcdFx0bS5vcHRpb25zLm9wYWNpdHkgPSAwLjU7XG5cdFx0XHRcdG0uX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIDAuNSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG5cdFx0XHRncm91cC5fYW5pbWF0aW9uRW5kKCk7XG5cdFx0XHRncm91cC5maXJlKCdzcGlkZXJmaWVkJyk7XG5cdFx0fSwgMjAwKTtcblx0fSxcblxuXHRfYW5pbWF0aW9uVW5zcGlkZXJmeTogZnVuY3Rpb24gKHpvb21EZXRhaWxzKSB7XG5cdFx0dmFyIGdyb3VwID0gdGhpcy5fZ3JvdXAsXG5cdFx0XHRtYXAgPSBncm91cC5fbWFwLFxuXHRcdFx0ZmcgPSBncm91cC5fZmVhdHVyZUdyb3VwLFxuXHRcdFx0dGhpc0xheWVyUG9zID0gem9vbURldGFpbHMgPyBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIHpvb21EZXRhaWxzLnpvb20sIHpvb21EZXRhaWxzLmNlbnRlcikgOiBtYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2xhdGxuZyksXG5cdFx0XHRjaGlsZE1hcmtlcnMgPSB0aGlzLmdldEFsbENoaWxkTWFya2VycygpLFxuXHRcdFx0c3ZnID0gTC5QYXRoLlNWRyAmJiB0aGlzLlNWR19BTklNQVRJT04sXG5cdFx0XHRtLCBpLCBhO1xuXG5cdFx0Z3JvdXAuX2FuaW1hdGlvblN0YXJ0KCk7XG5cblx0XHQvL01ha2UgdXMgdmlzaWJsZSBhbmQgYnJpbmcgdGhlIGNoaWxkIG1hcmtlcnMgYmFjayBpblxuXHRcdHRoaXMuc2V0T3BhY2l0eSgxKTtcblx0XHRmb3IgKGkgPSBjaGlsZE1hcmtlcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdG0gPSBjaGlsZE1hcmtlcnNbaV07XG5cblx0XHRcdC8vTWFya2VyIHdhcyBhZGRlZCB0byB1cyBhZnRlciB3ZSB3ZXJlIHNwaWRpZmllZFxuXHRcdFx0aWYgKCFtLl9wcmVTcGlkZXJmeUxhdGxuZykge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly9GaXggdXAgdGhlIGxvY2F0aW9uIHRvIHRoZSByZWFsIG9uZVxuXHRcdFx0bS5zZXRMYXRMbmcobS5fcHJlU3BpZGVyZnlMYXRsbmcpO1xuXHRcdFx0ZGVsZXRlIG0uX3ByZVNwaWRlcmZ5TGF0bG5nO1xuXHRcdFx0Ly9IYWNrIG92ZXJyaWRlIHRoZSBsb2NhdGlvbiB0byBiZSBvdXIgY2VudGVyXG5cdFx0XHRpZiAobS5zZXRPcGFjaXR5KSB7XG5cdFx0XHRcdG0uX3NldFBvcyh0aGlzTGF5ZXJQb3MpO1xuXHRcdFx0XHRtLnNldE9wYWNpdHkoMCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcblx0XHRcdH1cblxuXHRcdFx0Ly9BbmltYXRlIHRoZSBzcGlkZXIgbGVncyBiYWNrIGluXG5cdFx0XHRpZiAoc3ZnKSB7XG5cdFx0XHRcdGEgPSBtLl9zcGlkZXJMZWcuX3BhdGguY2hpbGROb2Rlc1swXTtcblx0XHRcdFx0YS5zZXRBdHRyaWJ1dGUoJ3RvJywgYS5nZXRBdHRyaWJ1dGUoJ2Zyb20nKSk7XG5cdFx0XHRcdGEuc2V0QXR0cmlidXRlKCdmcm9tJywgMCk7XG5cdFx0XHRcdGEuYmVnaW5FbGVtZW50KCk7XG5cblx0XHRcdFx0YSA9IG0uX3NwaWRlckxlZy5fcGF0aC5jaGlsZE5vZGVzWzFdO1xuXHRcdFx0XHRhLnNldEF0dHJpYnV0ZSgnZnJvbScsIDAuNSk7XG5cdFx0XHRcdGEuc2V0QXR0cmlidXRlKCd0bycsIDApO1xuXHRcdFx0XHRhLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCAwKTtcblx0XHRcdFx0YS5iZWdpbkVsZW1lbnQoKTtcblxuXHRcdFx0XHRtLl9zcGlkZXJMZWcuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2Utb3BhY2l0eScsIDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0Ly9JZiB3ZSBoYXZlIG9ubHkgPD0gb25lIGNoaWxkIGxlZnQgdGhlbiB0aGF0IG1hcmtlciB3aWxsIGJlIHNob3duIG9uIHRoZSBtYXAgc28gZG9uJ3QgcmVtb3ZlIGl0IVxuXHRcdFx0dmFyIHN0aWxsVGhlcmVDaGlsZENvdW50ID0gMDtcblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXHRcdFx0XHRpZiAobS5fc3BpZGVyTGVnKSB7XG5cdFx0XHRcdFx0c3RpbGxUaGVyZUNoaWxkQ291bnQrKztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cblx0XHRcdGZvciAoaSA9IGNoaWxkTWFya2Vycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRtID0gY2hpbGRNYXJrZXJzW2ldO1xuXG5cdFx0XHRcdGlmICghbS5fc3BpZGVyTGVnKSB7IC8vSGFzIGFscmVhZHkgYmVlbiB1bnNwaWRlcmZpZWRcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXG5cblx0XHRcdFx0aWYgKG0uc2V0T3BhY2l0eSkge1xuXHRcdFx0XHRcdG0uc2V0T3BhY2l0eSgxKTtcblx0XHRcdFx0XHRtLnNldFpJbmRleE9mZnNldCgwKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmIChzdGlsbFRoZXJlQ2hpbGRDb3VudCA+IDEpIHtcblx0XHRcdFx0XHRmZy5yZW1vdmVMYXllcihtKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG1hcC5yZW1vdmVMYXllcihtLl9zcGlkZXJMZWcpO1xuXHRcdFx0XHRkZWxldGUgbS5fc3BpZGVyTGVnO1xuXHRcdFx0fVxuXHRcdFx0Z3JvdXAuX2FuaW1hdGlvbkVuZCgpO1xuXHRcdH0sIDIwMCk7XG5cdH1cbn0pO1xuXG5cbkwuTWFya2VyQ2x1c3Rlckdyb3VwLmluY2x1ZGUoe1xuXHQvL1RoZSBNYXJrZXJDbHVzdGVyIGN1cnJlbnRseSBzcGlkZXJmaWVkIChpZiBhbnkpXG5cdF9zcGlkZXJmaWVkOiBudWxsLFxuXG5cdF9zcGlkZXJmaWVyT25BZGQ6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fdW5zcGlkZXJmeVdyYXBwZXIsIHRoaXMpO1xuXG5cdFx0aWYgKHRoaXMuX21hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcblx0XHRcdHRoaXMuX21hcC5vbignem9vbXN0YXJ0JywgdGhpcy5fdW5zcGlkZXJmeVpvb21TdGFydCwgdGhpcyk7XG5cdFx0fVxuXHRcdC8vQnJvd3NlcnMgd2l0aG91dCB6b29tQW5pbWF0aW9uIG9yIGEgYmlnIHpvb20gZG9uJ3QgZmlyZSB6b29tc3RhcnRcblx0XHR0aGlzLl9tYXAub24oJ3pvb21lbmQnLCB0aGlzLl9ub2FuaW1hdGlvblVuc3BpZGVyZnksIHRoaXMpO1xuXG5cdFx0aWYgKEwuUGF0aC5TVkcgJiYgIUwuQnJvd3Nlci50b3VjaCkge1xuXHRcdFx0dGhpcy5fbWFwLl9pbml0UGF0aFJvb3QoKTtcblx0XHRcdC8vTmVlZHMgdG8gaGFwcGVuIGluIHRoZSBwYWdlbG9hZCwgbm90IGFmdGVyLCBvciBhbmltYXRpb25zIGRvbid0IHdvcmsgaW4gd2Via2l0XG5cdFx0XHQvLyAgaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84NDU1MjAwL3N2Zy1hbmltYXRlLXdpdGgtZHluYW1pY2FsbHktYWRkZWQtZWxlbWVudHNcblx0XHRcdC8vRGlzYWJsZSBvbiB0b3VjaCBicm93c2VycyBhcyB0aGUgYW5pbWF0aW9uIG1lc3NlcyB1cCBvbiBhIHRvdWNoIHpvb20gYW5kIGlzbid0IHZlcnkgbm90aWNhYmxlXG5cdFx0fVxuXHR9LFxuXG5cdF9zcGlkZXJmaWVyT25SZW1vdmU6IGZ1bmN0aW9uICgpIHtcblx0XHR0aGlzLl9tYXAub2ZmKCdjbGljaycsIHRoaXMuX3Vuc3BpZGVyZnlXcmFwcGVyLCB0aGlzKTtcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tc3RhcnQnLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbVN0YXJ0LCB0aGlzKTtcblx0XHR0aGlzLl9tYXAub2ZmKCd6b29tYW5pbScsIHRoaXMuX3Vuc3BpZGVyZnlab29tQW5pbSwgdGhpcyk7XG5cblx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7IC8vRW5zdXJlIHRoYXQgbWFya2VycyBhcmUgYmFjayB3aGVyZSB0aGV5IHNob3VsZCBiZVxuXHR9LFxuXG5cblx0Ly9PbiB6b29tIHN0YXJ0IHdlIGFkZCBhIHpvb21hbmltIGhhbmRsZXIgc28gdGhhdCB3ZSBhcmUgZ3VhcmFudGVlZCB0byBiZSBsYXN0IChhZnRlciBtYXJrZXJzIGFyZSBhbmltYXRlZClcblx0Ly9UaGlzIG1lYW5zIHdlIGNhbiBkZWZpbmUgdGhlIGFuaW1hdGlvbiB0aGV5IGRvIHJhdGhlciB0aGFuIE1hcmtlcnMgZG9pbmcgYW4gYW5pbWF0aW9uIHRvIHRoZWlyIGFjdHVhbCBsb2NhdGlvblxuXHRfdW5zcGlkZXJmeVpvb21TdGFydDogZnVuY3Rpb24gKCkge1xuXHRcdGlmICghdGhpcy5fbWFwKSB7IC8vTWF5IGhhdmUgYmVlbiByZW1vdmVkIGZyb20gdGhlIG1hcCBieSBhIHpvb21FbmQgaGFuZGxlclxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcC5vbignem9vbWFuaW0nLCB0aGlzLl91bnNwaWRlcmZ5Wm9vbUFuaW0sIHRoaXMpO1xuXHR9LFxuXHRfdW5zcGlkZXJmeVpvb21BbmltOiBmdW5jdGlvbiAoem9vbURldGFpbHMpIHtcblx0XHQvL1dhaXQgdW50aWwgdGhlIGZpcnN0IHpvb21hbmltIGFmdGVyIHRoZSB1c2VyIGhhcyBmaW5pc2hlZCB0b3VjaC16b29taW5nIGJlZm9yZSBydW5uaW5nIHRoZSBhbmltYXRpb25cblx0XHRpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX21hcC5fbWFwUGFuZSwgJ2xlYWZsZXQtdG91Y2hpbmcnKSkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuX21hcC5vZmYoJ3pvb21hbmltJywgdGhpcy5fdW5zcGlkZXJmeVpvb21BbmltLCB0aGlzKTtcblx0XHR0aGlzLl91bnNwaWRlcmZ5KHpvb21EZXRhaWxzKTtcblx0fSxcblxuXG5cdF91bnNwaWRlcmZ5V3JhcHBlcjogZnVuY3Rpb24gKCkge1xuXHRcdC8vLyA8c3VtbWFyeT5fdW5zcGlkZXJmeSBidXQgcGFzc2VzIG5vIGFyZ3VtZW50czwvc3VtbWFyeT5cblx0XHR0aGlzLl91bnNwaWRlcmZ5KCk7XG5cdH0sXG5cblx0X3Vuc3BpZGVyZnk6IGZ1bmN0aW9uICh6b29tRGV0YWlscykge1xuXHRcdGlmICh0aGlzLl9zcGlkZXJmaWVkKSB7XG5cdFx0XHR0aGlzLl9zcGlkZXJmaWVkLnVuc3BpZGVyZnkoem9vbURldGFpbHMpO1xuXHRcdH1cblx0fSxcblxuXHRfbm9hbmltYXRpb25VbnNwaWRlcmZ5OiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHRoaXMuX3NwaWRlcmZpZWQpIHtcblx0XHRcdHRoaXMuX3NwaWRlcmZpZWQuX25vYW5pbWF0aW9uVW5zcGlkZXJmeSgpO1xuXHRcdH1cblx0fSxcblxuXHQvL0lmIHRoZSBnaXZlbiBsYXllciBpcyBjdXJyZW50bHkgYmVpbmcgc3BpZGVyZmllZCB0aGVuIHdlIHVuc3BpZGVyZnkgaXQgc28gaXQgaXNuJ3Qgb24gdGhlIG1hcCBhbnltb3JlIGV0Y1xuXHRfdW5zcGlkZXJmeUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcblx0XHRpZiAobGF5ZXIuX3NwaWRlckxlZykge1xuXHRcdFx0dGhpcy5fZmVhdHVyZUdyb3VwLnJlbW92ZUxheWVyKGxheWVyKTtcblxuXHRcdFx0bGF5ZXIuc2V0T3BhY2l0eSgxKTtcblx0XHRcdC8vUG9zaXRpb24gd2lsbCBiZSBmaXhlZCB1cCBpbW1lZGlhdGVseSBpbiBfYW5pbWF0aW9uVW5zcGlkZXJmeVxuXHRcdFx0bGF5ZXIuc2V0WkluZGV4T2Zmc2V0KDApO1xuXG5cdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIobGF5ZXIuX3NwaWRlckxlZyk7XG5cdFx0XHRkZWxldGUgbGF5ZXIuX3NwaWRlckxlZztcblx0XHR9XG5cdH1cbn0pO1xuXG5cbn0od2luZG93LCBkb2N1bWVudCkpOyIsIi8qXHJcbiBMZWFmbGV0LCBhIEphdmFTY3JpcHQgbGlicmFyeSBmb3IgbW9iaWxlLWZyaWVuZGx5IGludGVyYWN0aXZlIG1hcHMuIGh0dHA6Ly9sZWFmbGV0anMuY29tXHJcbiAoYykgMjAxMC0yMDEzLCBWbGFkaW1pciBBZ2Fmb25raW5cclxuIChjKSAyMDEwLTIwMTEsIENsb3VkTWFkZVxyXG4qL1xyXG4oZnVuY3Rpb24gKHdpbmRvdywgZG9jdW1lbnQsIHVuZGVmaW5lZCkge1xyXG52YXIgb2xkTCA9IHdpbmRvdy5MLFxyXG4gICAgTCA9IHt9O1xyXG5cclxuTC52ZXJzaW9uID0gJzAuNy4yJztcclxuXHJcbi8vIGRlZmluZSBMZWFmbGV0IGZvciBOb2RlIG1vZHVsZSBwYXR0ZXJuIGxvYWRlcnMsIGluY2x1ZGluZyBCcm93c2VyaWZ5XHJcbmlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlLmV4cG9ydHMgPT09ICdvYmplY3QnKSB7XHJcblx0bW9kdWxlLmV4cG9ydHMgPSBMO1xyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYW4gQU1EIG1vZHVsZVxyXG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG5cdGRlZmluZShMKTtcclxufVxyXG5cclxuLy8gZGVmaW5lIExlYWZsZXQgYXMgYSBnbG9iYWwgTCB2YXJpYWJsZSwgc2F2aW5nIHRoZSBvcmlnaW5hbCBMIHRvIHJlc3RvcmUgbGF0ZXIgaWYgbmVlZGVkXHJcblxyXG5MLm5vQ29uZmxpY3QgPSBmdW5jdGlvbiAoKSB7XHJcblx0d2luZG93LkwgPSBvbGRMO1xyXG5cdHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxud2luZG93LkwgPSBMO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuVXRpbCBjb250YWlucyB2YXJpb3VzIHV0aWxpdHkgZnVuY3Rpb25zIHVzZWQgdGhyb3VnaG91dCBMZWFmbGV0IGNvZGUuXHJcbiAqL1xyXG5cclxuTC5VdGlsID0ge1xyXG5cdGV4dGVuZDogZnVuY3Rpb24gKGRlc3QpIHsgLy8gKE9iamVjdFssIE9iamVjdCwgLi4uXSkgLT5cclxuXHRcdHZhciBzb3VyY2VzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBqLCBsZW4sIHNyYztcclxuXHJcblx0XHRmb3IgKGogPSAwLCBsZW4gPSBzb3VyY2VzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XHJcblx0XHRcdHNyYyA9IHNvdXJjZXNbal0gfHwge307XHJcblx0XHRcdGZvciAoaSBpbiBzcmMpIHtcclxuXHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KGkpKSB7XHJcblx0XHRcdFx0XHRkZXN0W2ldID0gc3JjW2ldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGRlc3Q7XHJcblx0fSxcclxuXHJcblx0YmluZDogZnVuY3Rpb24gKGZuLCBvYmopIHsgLy8gKEZ1bmN0aW9uLCBPYmplY3QpIC0+IEZ1bmN0aW9uXHJcblx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyID8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSA6IG51bGw7XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRyZXR1cm4gZm4uYXBwbHkob2JqLCBhcmdzIHx8IGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdHN0YW1wOiAoZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGxhc3RJZCA9IDAsXHJcblx0XHQgICAga2V5ID0gJ19sZWFmbGV0X2lkJztcclxuXHRcdHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHRcdG9ialtrZXldID0gb2JqW2tleV0gfHwgKytsYXN0SWQ7XHJcblx0XHRcdHJldHVybiBvYmpba2V5XTtcclxuXHRcdH07XHJcblx0fSgpKSxcclxuXHJcblx0aW52b2tlRWFjaDogZnVuY3Rpb24gKG9iaiwgbWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgaSwgYXJncztcclxuXHJcblx0XHRpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcclxuXHRcdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XHJcblxyXG5cdFx0XHRmb3IgKGkgaW4gb2JqKSB7XHJcblx0XHRcdFx0bWV0aG9kLmFwcGx5KGNvbnRleHQsIFtpLCBvYmpbaV1dLmNvbmNhdChhcmdzKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdGxpbWl0RXhlY0J5SW50ZXJ2YWw6IGZ1bmN0aW9uIChmbiwgdGltZSwgY29udGV4dCkge1xyXG5cdFx0dmFyIGxvY2ssIGV4ZWNPblVubG9jaztcclxuXHJcblx0XHRyZXR1cm4gZnVuY3Rpb24gd3JhcHBlckZuKCkge1xyXG5cdFx0XHR2YXIgYXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHRcdGlmIChsb2NrKSB7XHJcblx0XHRcdFx0ZXhlY09uVW5sb2NrID0gdHJ1ZTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGxvY2sgPSB0cnVlO1xyXG5cclxuXHRcdFx0c2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0bG9jayA9IGZhbHNlO1xyXG5cclxuXHRcdFx0XHRpZiAoZXhlY09uVW5sb2NrKSB7XHJcblx0XHRcdFx0XHR3cmFwcGVyRm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHRcdFx0XHRleGVjT25VbmxvY2sgPSBmYWxzZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0sIHRpbWUpO1xyXG5cclxuXHRcdFx0Zm4uYXBwbHkoY29udGV4dCwgYXJncyk7XHJcblx0XHR9O1xyXG5cdH0sXHJcblxyXG5cdGZhbHNlRm46IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRmb3JtYXROdW06IGZ1bmN0aW9uIChudW0sIGRpZ2l0cykge1xyXG5cdFx0dmFyIHBvdyA9IE1hdGgucG93KDEwLCBkaWdpdHMgfHwgNSk7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChudW0gKiBwb3cpIC8gcG93O1xyXG5cdH0sXHJcblxyXG5cdHRyaW06IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBzdHIudHJpbSA/IHN0ci50cmltKCkgOiBzdHIucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgJycpO1xyXG5cdH0sXHJcblxyXG5cdHNwbGl0V29yZHM6IGZ1bmN0aW9uIChzdHIpIHtcclxuXHRcdHJldHVybiBMLlV0aWwudHJpbShzdHIpLnNwbGl0KC9cXHMrLyk7XHJcblx0fSxcclxuXHJcblx0c2V0T3B0aW9uczogZnVuY3Rpb24gKG9iaiwgb3B0aW9ucykge1xyXG5cdFx0b2JqLm9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgb2JqLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIG9iai5vcHRpb25zO1xyXG5cdH0sXHJcblxyXG5cdGdldFBhcmFtU3RyaW5nOiBmdW5jdGlvbiAob2JqLCBleGlzdGluZ1VybCwgdXBwZXJjYXNlKSB7XHJcblx0XHR2YXIgcGFyYW1zID0gW107XHJcblx0XHRmb3IgKHZhciBpIGluIG9iaikge1xyXG5cdFx0XHRwYXJhbXMucHVzaChlbmNvZGVVUklDb21wb25lbnQodXBwZXJjYXNlID8gaS50b1VwcGVyQ2FzZSgpIDogaSkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQob2JqW2ldKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gKCghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgcGFyYW1zLmpvaW4oJyYnKTtcclxuXHR9LFxyXG5cdHRlbXBsYXRlOiBmdW5jdGlvbiAoc3RyLCBkYXRhKSB7XHJcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xceyAqKFtcXHdfXSspICpcXH0vZywgZnVuY3Rpb24gKHN0ciwga2V5KSB7XHJcblx0XHRcdHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcclxuXHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ05vIHZhbHVlIHByb3ZpZGVkIGZvciB2YXJpYWJsZSAnICsgc3RyKTtcclxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHR2YWx1ZSA9IHZhbHVlKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdGlzQXJyYXk6IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iaikge1xyXG5cdFx0cmV0dXJuIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyk7XHJcblx0fSxcclxuXHJcblx0ZW1wdHlJbWFnZVVybDogJ2RhdGE6aW1hZ2UvZ2lmO2Jhc2U2NCxSMGxHT0RsaEFRQUJBQUQvQUN3QUFBQUFBUUFCQUFBQ0FEcz0nXHJcbn07XHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuXHQvLyBpbnNwaXJlZCBieSBodHRwOi8vcGF1bGlyaXNoLmNvbS8yMDExL3JlcXVlc3RhbmltYXRpb25mcmFtZS1mb3Itc21hcnQtYW5pbWF0aW5nL1xyXG5cclxuXHRmdW5jdGlvbiBnZXRQcmVmaXhlZChuYW1lKSB7XHJcblx0XHR2YXIgaSwgZm4sXHJcblx0XHQgICAgcHJlZml4ZXMgPSBbJ3dlYmtpdCcsICdtb3onLCAnbycsICdtcyddO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBwcmVmaXhlcy5sZW5ndGggJiYgIWZuOyBpKyspIHtcclxuXHRcdFx0Zm4gPSB3aW5kb3dbcHJlZml4ZXNbaV0gKyBuYW1lXTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gZm47XHJcblx0fVxyXG5cclxuXHR2YXIgbGFzdFRpbWUgPSAwO1xyXG5cclxuXHRmdW5jdGlvbiB0aW1lb3V0RGVmZXIoZm4pIHtcclxuXHRcdHZhciB0aW1lID0gK25ldyBEYXRlKCksXHJcblx0XHQgICAgdGltZVRvQ2FsbCA9IE1hdGgubWF4KDAsIDE2IC0gKHRpbWUgLSBsYXN0VGltZSkpO1xyXG5cclxuXHRcdGxhc3RUaW1lID0gdGltZSArIHRpbWVUb0NhbGw7XHJcblx0XHRyZXR1cm4gd2luZG93LnNldFRpbWVvdXQoZm4sIHRpbWVUb0NhbGwpO1xyXG5cdH1cclxuXHJcblx0dmFyIHJlcXVlc3RGbiA9IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgfHxcclxuXHQgICAgICAgIGdldFByZWZpeGVkKCdSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fCB0aW1lb3V0RGVmZXI7XHJcblxyXG5cdHZhciBjYW5jZWxGbiA9IHdpbmRvdy5jYW5jZWxBbmltYXRpb25GcmFtZSB8fFxyXG5cdCAgICAgICAgZ2V0UHJlZml4ZWQoJ0NhbmNlbEFuaW1hdGlvbkZyYW1lJykgfHxcclxuXHQgICAgICAgIGdldFByZWZpeGVkKCdDYW5jZWxSZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSB8fFxyXG5cdCAgICAgICAgZnVuY3Rpb24gKGlkKSB7IHdpbmRvdy5jbGVhclRpbWVvdXQoaWQpOyB9O1xyXG5cclxuXHJcblx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUgPSBmdW5jdGlvbiAoZm4sIGNvbnRleHQsIGltbWVkaWF0ZSwgZWxlbWVudCkge1xyXG5cdFx0Zm4gPSBMLmJpbmQoZm4sIGNvbnRleHQpO1xyXG5cclxuXHRcdGlmIChpbW1lZGlhdGUgJiYgcmVxdWVzdEZuID09PSB0aW1lb3V0RGVmZXIpIHtcclxuXHRcdFx0Zm4oKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiByZXF1ZXN0Rm4uY2FsbCh3aW5kb3csIGZuLCBlbGVtZW50KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XHJcblx0XHRpZiAoaWQpIHtcclxuXHRcdFx0Y2FuY2VsRm4uY2FsbCh3aW5kb3csIGlkKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxufSgpKTtcclxuXHJcbi8vIHNob3J0Y3V0cyBmb3IgbW9zdCB1c2VkIHV0aWxpdHkgZnVuY3Rpb25zXHJcbkwuZXh0ZW5kID0gTC5VdGlsLmV4dGVuZDtcclxuTC5iaW5kID0gTC5VdGlsLmJpbmQ7XHJcbkwuc3RhbXAgPSBMLlV0aWwuc3RhbXA7XHJcbkwuc2V0T3B0aW9ucyA9IEwuVXRpbC5zZXRPcHRpb25zO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuQ2xhc3MgcG93ZXJzIHRoZSBPT1AgZmFjaWxpdGllcyBvZiB0aGUgbGlicmFyeS5cclxuICogVGhhbmtzIHRvIEpvaG4gUmVzaWcgYW5kIERlYW4gRWR3YXJkcyBmb3IgaW5zcGlyYXRpb24hXHJcbiAqL1xyXG5cclxuTC5DbGFzcyA9IGZ1bmN0aW9uICgpIHt9O1xyXG5cclxuTC5DbGFzcy5leHRlbmQgPSBmdW5jdGlvbihwcm9wcywgY2xhc3NJbmNsdWRlcykge1xyXG5cclxuICAgIC8vIGV4dGVuZGVkIGNsYXNzIHdpdGggdGhlIG5ldyBwcm90b3R5cGVcclxuICAgIHZhciBOZXdDbGFzcyA9IGZ1bmN0aW9uKCkge1xyXG5cclxuICAgICAgICAvLyBjYWxsIHRoZSBjb25zdHJ1Y3RvclxyXG4gICAgICAgIGlmICh0aGlzLmluaXRpYWxpemUpIHtcclxuICAgICAgICAgICAgdGhpcy5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBjYWxsIGFsbCBjb25zdHJ1Y3RvciBob29rc1xyXG4gICAgICAgIGlmICh0aGlzLl9pbml0SG9va3MpIHtcclxuICAgICAgICAgICAgdGhpcy5jYWxsSW5pdEhvb2tzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBpbnN0YW50aWF0ZSBjbGFzcyB3aXRob3V0IGNhbGxpbmcgY29uc3RydWN0b3JcclxuICAgIHZhciBGID0gZnVuY3Rpb24oKSB7fTtcclxuICAgIEYucHJvdG90eXBlID0gdGhpcy5wcm90b3R5cGU7XHJcblxyXG4gICAgdmFyIHByb3RvID0gbmV3IEYoKTtcclxuICAgIHByb3RvLmNvbnN0cnVjdG9yID0gTmV3Q2xhc3M7XHJcblxyXG4gICAgTmV3Q2xhc3MucHJvdG90eXBlID0gcHJvdG87XHJcblxyXG4gICAgLy9pbmhlcml0IHBhcmVudCdzIHN0YXRpY3NcclxuICAgIHZhciBpO1xyXG4gICAgZm9yIChpIGluIHRoaXMpIHtcclxuICAgICAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAncHJvdG90eXBlJykge1xyXG4gICAgICAgICAgICBOZXdDbGFzc1tpXSA9IHRoaXNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaGVyaXQgaW5jbHVkZWQgY2xhc3Nlcycgc3RhdGljcy5cclxuICAgIGlmIChjbGFzc0luY2x1ZGVzICYmIGNsYXNzSW5jbHVkZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjbGFzc0luY2x1ZGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBpbmNsdWRlZENsYXNzID0gY2xhc3NJbmNsdWRlc1tpXTtcclxuICAgICAgICAgICAgZm9yIChpIGluIGluY2x1ZGVkQ2xhc3MpIHtcclxuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlZENsYXNzLmhhc093blByb3BlcnR5KGkpICYmIGkgIT09ICdwcm90b3R5cGUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgTmV3Q2xhc3NbaV0gPSBpbmNsdWRlZENsYXNzW2ldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBtaXggc3RhdGljIHByb3BlcnRpZXMgaW50byB0aGUgY2xhc3NcclxuICAgIGlmIChwcm9wcy5zdGF0aWNzKSB7XHJcbiAgICAgICAgTC5leHRlbmQoTmV3Q2xhc3MsIHByb3BzLnN0YXRpY3MpO1xyXG4gICAgICAgIGRlbGV0ZSBwcm9wcy5zdGF0aWNzO1xyXG4gICAgfVxyXG5cclxuXHJcbiAgICAvLyBtaXggaW5jbHVkZWQgY2xhc3NlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuICAgIGlmIChjbGFzc0luY2x1ZGVzICYmIGNsYXNzSW5jbHVkZXMubGVuZ3RoKSB7XHJcbiAgICBcdGlmKCEgcHJvdG8ub3B0aW9ucykge1xyXG4gICAgXHRcdHByb3RvLm9wdGlvbnMgPSB7fTtcclxuICAgIFx0fVxyXG5cclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY2xhc3NJbmNsdWRlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICB2YXIgaW5jbHVkZWRDbGFzc1Byb3RvID0gY2xhc3NJbmNsdWRlc1tpXS5wcm90b3R5cGU7XHJcbiAgICAgICAgICAgIHZhciBpbmNsdWRlZENsYXNzUHJvdG9PcHRzID0gaW5jbHVkZWRDbGFzc1Byb3RvLm9wdGlvbnM7XHJcbiAgICAgICAgICAgIHByb3RvLm9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgcHJvdG8ub3B0aW9ucywgaW5jbHVkZWRDbGFzc1Byb3RvT3B0cyk7XHJcblxyXG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIGluY2x1ZGVkQ2xhc3NQcm90bykge1xyXG4gICAgICAgICAgICAgICAgaWYgKGogIT09IFwib3B0aW9uc1wiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9bal0gPSBpbmNsdWRlZENsYXNzUHJvdG9bal07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgTC5VdGlsLmV4dGVuZC5hcHBseShudWxsLCBbcHJvdG9dLmNvbmNhdChwcm9wcy5pbmNsdWRlcykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIG1peCBpbmNsdWRlcyBpbnRvIHRoZSBwcm90b3R5cGVcclxuICAgIGlmIChwcm9wcy5pbmNsdWRlcykge1xyXG4gICAgICAgIEwuVXRpbC5leHRlbmQuYXBwbHkobnVsbCwgW3Byb3RvXS5jb25jYXQocHJvcHMuaW5jbHVkZXMpKTtcclxuICAgICAgICBkZWxldGUgcHJvcHMuaW5jbHVkZXM7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xyXG4gICAgaWYgKHByb3BzLm9wdGlvbnMgJiYgcHJvdG8ub3B0aW9ucykge1xyXG4gICAgICAgIHByb3BzLm9wdGlvbnMgPSBMLmV4dGVuZCh7fSwgcHJvdG8ub3B0aW9ucywgcHJvcHMub3B0aW9ucyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gbWl4IGdpdmVuIHByb3BlcnRpZXMgaW50byB0aGUgcHJvdG90eXBlXHJcbiAgICBMLmV4dGVuZChwcm90bywgcHJvcHMpO1xyXG5cclxuICAgIHByb3RvLl9pbml0SG9va3MgPSBbXTtcclxuXHJcbiAgICB2YXIgcGFyZW50ID0gdGhpcztcclxuICAgIC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcbiAgICBOZXdDbGFzcy5fX3N1cGVyX18gPSBwYXJlbnQucHJvdG90eXBlO1xyXG4gICAgTmV3Q2xhc3MucHJvdG90eXBlLl9fc3VwZXJfXyA9IHBhcmVudC5wcm90b3R5cGU7XHJcblxyXG4gICAgLy8gYWRkIG1ldGhvZCBmb3IgY2FsbGluZyBhbGwgaG9va3NcclxuICAgIHByb3RvLmNhbGxJbml0SG9va3MgPSBmdW5jdGlvbigpIHtcclxuXHJcbiAgICAgICAgaWYgKHRoaXMuX2luaXRIb29rc0NhbGxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAocGFyZW50LnByb3RvdHlwZS5jYWxsSW5pdEhvb2tzKSB7XHJcbiAgICAgICAgICAgIHBhcmVudC5wcm90b3R5cGUuY2FsbEluaXRIb29rcy5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5faW5pdEhvb2tzQ2FsbGVkID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHByb3RvLl9pbml0SG9va3MubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICAgICAgcHJvdG8uX2luaXRIb29rc1tpXS5jYWxsKHRoaXMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIE5ld0NsYXNzO1xyXG59O1xyXG5cclxuXHJcbi8vIG1ldGhvZCBmb3IgYWRkaW5nIHByb3BlcnRpZXMgdG8gcHJvdG90eXBlXHJcbkwuQ2xhc3MuaW5jbHVkZSA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG5cdEwuZXh0ZW5kKHRoaXMucHJvdG90eXBlLCBwcm9wcyk7XHJcbn07XHJcblxyXG4vLyBtZXJnZSBuZXcgZGVmYXVsdCBvcHRpb25zIHRvIHRoZSBDbGFzc1xyXG5MLkNsYXNzLm1lcmdlT3B0aW9ucyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0TC5leHRlbmQodGhpcy5wcm90b3R5cGUub3B0aW9ucywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG4vLyBhZGQgYSBjb25zdHJ1Y3RvciBob29rXHJcbkwuQ2xhc3MuYWRkSW5pdEhvb2sgPSBmdW5jdGlvbiAoZm4pIHsgLy8gKEZ1bmN0aW9uKSB8fCAoU3RyaW5nLCBhcmdzLi4uKVxyXG5cdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHJcblx0dmFyIGluaXQgPSB0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicgPyBmbiA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXNbZm5dLmFwcGx5KHRoaXMsIGFyZ3MpO1xyXG5cdH07XHJcblxyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MgPSB0aGlzLnByb3RvdHlwZS5faW5pdEhvb2tzIHx8IFtdO1xyXG5cdHRoaXMucHJvdG90eXBlLl9pbml0SG9va3MucHVzaChpbml0KTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLk1peGluLkV2ZW50cyBpcyB1c2VkIHRvIGFkZCBjdXN0b20gZXZlbnRzIGZ1bmN0aW9uYWxpdHkgdG8gTGVhZmxldCBjbGFzc2VzLlxyXG4gKi9cclxuXHJcbnZhciBldmVudHNLZXkgPSAnX2xlYWZsZXRfZXZlbnRzJztcclxuXHJcbkwuTWl4aW4gPSB7fTtcclxuXHJcbkwuTWl4aW4uRXZlbnRzID0ge1xyXG5cclxuXHRhZGRFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7IC8vIChTdHJpbmcsIEZ1bmN0aW9uWywgT2JqZWN0XSkgb3IgKE9iamVjdFssIE9iamVjdF0pXHJcblxyXG5cdFx0Ly8gdHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXHJcblx0XHRpZiAoTC5VdGlsLmludm9rZUVhY2godHlwZXMsIHRoaXMuYWRkRXZlbnRMaXN0ZW5lciwgdGhpcywgZm4sIGNvbnRleHQpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XSA9IHRoaXNbZXZlbnRzS2V5XSB8fCB7fSxcclxuXHRcdCAgICBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KSxcclxuXHRcdCAgICBpLCBsZW4sIGV2ZW50LCB0eXBlLCBpbmRleEtleSwgaW5kZXhMZW5LZXksIHR5cGVJbmRleDtcclxuXHJcblx0XHQvLyB0eXBlcyBjYW4gYmUgYSBzdHJpbmcgb2Ygc3BhY2Utc2VwYXJhdGVkIHdvcmRzXHJcblx0XHR0eXBlcyA9IEwuVXRpbC5zcGxpdFdvcmRzKHR5cGVzKTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0eXBlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRldmVudCA9IHtcclxuXHRcdFx0XHRhY3Rpb246IGZuLFxyXG5cdFx0XHRcdGNvbnRleHQ6IGNvbnRleHQgfHwgdGhpc1xyXG5cdFx0XHR9O1xyXG5cdFx0XHR0eXBlID0gdHlwZXNbaV07XHJcblxyXG5cdFx0XHRpZiAoY29udGV4dElkKSB7XHJcblx0XHRcdFx0Ly8gc3RvcmUgbGlzdGVuZXJzIG9mIGEgcGFydGljdWxhciBjb250ZXh0IGluIGEgc2VwYXJhdGUgaGFzaCAoaWYgaXQgaGFzIGFuIGlkKVxyXG5cdFx0XHRcdC8vIGdpdmVzIGEgbWFqb3IgcGVyZm9ybWFuY2UgYm9vc3Qgd2hlbiByZW1vdmluZyB0aG91c2FuZHMgb2YgbWFwIGxheWVyc1xyXG5cclxuXHRcdFx0XHRpbmRleEtleSA9IHR5cGUgKyAnX2lkeCc7XHJcblx0XHRcdFx0aW5kZXhMZW5LZXkgPSBpbmRleEtleSArICdfbGVuJztcclxuXHJcblx0XHRcdFx0dHlwZUluZGV4ID0gZXZlbnRzW2luZGV4S2V5XSA9IGV2ZW50c1tpbmRleEtleV0gfHwge307XHJcblxyXG5cdFx0XHRcdGlmICghdHlwZUluZGV4W2NvbnRleHRJZF0pIHtcclxuXHRcdFx0XHRcdHR5cGVJbmRleFtjb250ZXh0SWRdID0gW107XHJcblxyXG5cdFx0XHRcdFx0Ly8ga2VlcCB0cmFjayBvZiB0aGUgbnVtYmVyIG9mIGtleXMgaW4gdGhlIGluZGV4IHRvIHF1aWNrbHkgY2hlY2sgaWYgaXQncyBlbXB0eVxyXG5cdFx0XHRcdFx0ZXZlbnRzW2luZGV4TGVuS2V5XSA9IChldmVudHNbaW5kZXhMZW5LZXldIHx8IDApICsgMTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdHR5cGVJbmRleFtjb250ZXh0SWRdLnB1c2goZXZlbnQpO1xyXG5cclxuXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXZlbnRzW3R5cGVdID0gZXZlbnRzW3R5cGVdIHx8IFtdO1xyXG5cdFx0XHRcdGV2ZW50c1t0eXBlXS5wdXNoKGV2ZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGhhc0V2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAodHlwZSkgeyAvLyAoU3RyaW5nKSAtPiBCb29sZWFuXHJcblx0XHR2YXIgZXZlbnRzID0gdGhpc1tldmVudHNLZXldO1xyXG5cdFx0cmV0dXJuICEhZXZlbnRzICYmICgodHlwZSBpbiBldmVudHMgJiYgZXZlbnRzW3R5cGVdLmxlbmd0aCA+IDApIHx8XHJcblx0XHQgICAgICAgICAgICAgICAgICAgICh0eXBlICsgJ19pZHgnIGluIGV2ZW50cyAmJiBldmVudHNbdHlwZSArICdfaWR4X2xlbiddID4gMCkpO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uICh0eXBlcywgZm4sIGNvbnRleHQpIHsgLy8gKFtTdHJpbmcsIEZ1bmN0aW9uLCBPYmplY3RdKSBvciAoT2JqZWN0WywgT2JqZWN0XSlcclxuXHJcblx0XHRpZiAoIXRoaXNbZXZlbnRzS2V5XSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXR5cGVzKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLmNsZWFyQWxsRXZlbnRMaXN0ZW5lcnMoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5VdGlsLmludm9rZUVhY2godHlwZXMsIHRoaXMucmVtb3ZlRXZlbnRMaXN0ZW5lciwgdGhpcywgZm4sIGNvbnRleHQpKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XSxcclxuXHRcdCAgICBjb250ZXh0SWQgPSBjb250ZXh0ICYmIGNvbnRleHQgIT09IHRoaXMgJiYgTC5zdGFtcChjb250ZXh0KSxcclxuXHRcdCAgICBpLCBsZW4sIHR5cGUsIGxpc3RlbmVycywgaiwgaW5kZXhLZXksIGluZGV4TGVuS2V5LCB0eXBlSW5kZXgsIHJlbW92ZWQ7XHJcblxyXG5cdFx0dHlwZXMgPSBMLlV0aWwuc3BsaXRXb3Jkcyh0eXBlcyk7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gdHlwZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0dHlwZSA9IHR5cGVzW2ldO1xyXG5cdFx0XHRpbmRleEtleSA9IHR5cGUgKyAnX2lkeCc7XHJcblx0XHRcdGluZGV4TGVuS2V5ID0gaW5kZXhLZXkgKyAnX2xlbic7XHJcblxyXG5cdFx0XHR0eXBlSW5kZXggPSBldmVudHNbaW5kZXhLZXldO1xyXG5cclxuXHRcdFx0aWYgKCFmbikge1xyXG5cdFx0XHRcdC8vIGNsZWFyIGFsbCBsaXN0ZW5lcnMgZm9yIGEgdHlwZSBpZiBmdW5jdGlvbiBpc24ndCBzcGVjaWZpZWRcclxuXHRcdFx0XHRkZWxldGUgZXZlbnRzW3R5cGVdO1xyXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbaW5kZXhLZXldO1xyXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbaW5kZXhMZW5LZXldO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnMgPSBjb250ZXh0SWQgJiYgdHlwZUluZGV4ID8gdHlwZUluZGV4W2NvbnRleHRJZF0gOiBldmVudHNbdHlwZV07XHJcblxyXG5cdFx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHRcdGZvciAoaiA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBqID49IDA7IGotLSkge1xyXG5cdFx0XHRcdFx0XHRpZiAoKGxpc3RlbmVyc1tqXS5hY3Rpb24gPT09IGZuKSAmJiAoIWNvbnRleHQgfHwgKGxpc3RlbmVyc1tqXS5jb250ZXh0ID09PSBjb250ZXh0KSkpIHtcclxuXHRcdFx0XHRcdFx0XHRyZW1vdmVkID0gbGlzdGVuZXJzLnNwbGljZShqLCAxKTtcclxuXHRcdFx0XHRcdFx0XHQvLyBzZXQgdGhlIG9sZCBhY3Rpb24gdG8gYSBuby1vcCwgYmVjYXVzZSBpdCBpcyBwb3NzaWJsZVxyXG5cdFx0XHRcdFx0XHRcdC8vIHRoYXQgdGhlIGxpc3RlbmVyIGlzIGJlaW5nIGl0ZXJhdGVkIG92ZXIgYXMgcGFydCBvZiBhIGRpc3BhdGNoXHJcblx0XHRcdFx0XHRcdFx0cmVtb3ZlZFswXS5hY3Rpb24gPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRcdGlmIChjb250ZXh0ICYmIHR5cGVJbmRleCAmJiAobGlzdGVuZXJzLmxlbmd0aCA9PT0gMCkpIHtcclxuXHRcdFx0XHRcdFx0ZGVsZXRlIHR5cGVJbmRleFtjb250ZXh0SWRdO1xyXG5cdFx0XHRcdFx0XHRldmVudHNbaW5kZXhMZW5LZXldLS07XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y2xlYXJBbGxFdmVudExpc3RlbmVyczogZnVuY3Rpb24gKCkge1xyXG5cdFx0ZGVsZXRlIHRoaXNbZXZlbnRzS2V5XTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGZpcmVFdmVudDogZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHsgLy8gKFN0cmluZ1ssIE9iamVjdF0pXHJcblx0XHRpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcnModHlwZSkpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGV2ZW50ID0gTC5VdGlsLmV4dGVuZCh7fSwgZGF0YSwgeyB0eXBlOiB0eXBlLCB0YXJnZXQ6IHRoaXMgfSk7XHJcblxyXG5cdFx0dmFyIGV2ZW50cyA9IHRoaXNbZXZlbnRzS2V5XSxcclxuXHRcdCAgICBsaXN0ZW5lcnMsIGksIGxlbiwgdHlwZUluZGV4LCBjb250ZXh0SWQ7XHJcblxyXG5cdFx0aWYgKGV2ZW50c1t0eXBlXSkge1xyXG5cdFx0XHQvLyBtYWtlIHN1cmUgYWRkaW5nL3JlbW92aW5nIGxpc3RlbmVycyBpbnNpZGUgb3RoZXIgbGlzdGVuZXJzIHdvbid0IGNhdXNlIGluZmluaXRlIGxvb3BcclxuXHRcdFx0bGlzdGVuZXJzID0gZXZlbnRzW3R5cGVdLnNsaWNlKCk7XHJcblxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRsaXN0ZW5lcnNbaV0uYWN0aW9uLmNhbGwobGlzdGVuZXJzW2ldLmNvbnRleHQsIGV2ZW50KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGZpcmUgZXZlbnQgZm9yIHRoZSBjb250ZXh0LWluZGV4ZWQgbGlzdGVuZXJzIGFzIHdlbGxcclxuXHRcdHR5cGVJbmRleCA9IGV2ZW50c1t0eXBlICsgJ19pZHgnXTtcclxuXHJcblx0XHRmb3IgKGNvbnRleHRJZCBpbiB0eXBlSW5kZXgpIHtcclxuXHRcdFx0bGlzdGVuZXJzID0gdHlwZUluZGV4W2NvbnRleHRJZF0uc2xpY2UoKTtcclxuXHJcblx0XHRcdGlmIChsaXN0ZW5lcnMpIHtcclxuXHRcdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRcdGxpc3RlbmVyc1tpXS5hY3Rpb24uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgZXZlbnQpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZE9uZVRpbWVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiAodHlwZXMsIGZuLCBjb250ZXh0KSB7XHJcblxyXG5cdFx0aWYgKEwuVXRpbC5pbnZva2VFYWNoKHR5cGVzLCB0aGlzLmFkZE9uZVRpbWVFdmVudExpc3RlbmVyLCB0aGlzLCBmbiwgY29udGV4dCkpIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHR2YXIgaGFuZGxlciA9IEwuYmluZChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVzLCBmbiwgY29udGV4dClcclxuXHRcdFx0ICAgIC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzXHJcblx0XHQgICAgLmFkZEV2ZW50TGlzdGVuZXIodHlwZXMsIGZuLCBjb250ZXh0KVxyXG5cdFx0ICAgIC5hZGRFdmVudExpc3RlbmVyKHR5cGVzLCBoYW5kbGVyLCBjb250ZXh0KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1peGluLkV2ZW50cy5vbiA9IEwuTWl4aW4uRXZlbnRzLmFkZEV2ZW50TGlzdGVuZXI7XHJcbkwuTWl4aW4uRXZlbnRzLm9mZiA9IEwuTWl4aW4uRXZlbnRzLnJlbW92ZUV2ZW50TGlzdGVuZXI7XHJcbkwuTWl4aW4uRXZlbnRzLm9uY2UgPSBMLk1peGluLkV2ZW50cy5hZGRPbmVUaW1lRXZlbnRMaXN0ZW5lcjtcclxuTC5NaXhpbi5FdmVudHMuZmlyZSA9IEwuTWl4aW4uRXZlbnRzLmZpcmVFdmVudDtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkJyb3dzZXIgaGFuZGxlcyBkaWZmZXJlbnQgYnJvd3NlciBhbmQgZmVhdHVyZSBkZXRlY3Rpb25zIGZvciBpbnRlcm5hbCBMZWFmbGV0IHVzZS5cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cclxuXHR2YXIgaWUgPSAnQWN0aXZlWE9iamVjdCcgaW4gd2luZG93LFxyXG5cdFx0aWVsdDkgPSBpZSAmJiAhZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcixcclxuXHJcblx0ICAgIC8vIHRlcnJpYmxlIGJyb3dzZXIgZGV0ZWN0aW9uIHRvIHdvcmsgYXJvdW5kIFNhZmFyaSAvIGlPUyAvIEFuZHJvaWQgYnJvd3NlciBidWdzXHJcblx0ICAgIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxyXG5cdCAgICB3ZWJraXQgPSB1YS5pbmRleE9mKCd3ZWJraXQnKSAhPT0gLTEsXHJcblx0ICAgIGNocm9tZSA9IHVhLmluZGV4T2YoJ2Nocm9tZScpICE9PSAtMSxcclxuXHQgICAgcGhhbnRvbWpzID0gdWEuaW5kZXhPZigncGhhbnRvbScpICE9PSAtMSxcclxuXHQgICAgYW5kcm9pZCA9IHVhLmluZGV4T2YoJ2FuZHJvaWQnKSAhPT0gLTEsXHJcblx0ICAgIGFuZHJvaWQyMyA9IHVhLnNlYXJjaCgnYW5kcm9pZCBbMjNdJykgIT09IC0xLFxyXG5cdFx0Z2Vja28gPSB1YS5pbmRleE9mKCdnZWNrbycpICE9PSAtMSxcclxuXHJcblx0ICAgIG1vYmlsZSA9IHR5cGVvZiBvcmllbnRhdGlvbiAhPT0gdW5kZWZpbmVkICsgJycsXHJcblx0ICAgIG1zUG9pbnRlciA9IHdpbmRvdy5uYXZpZ2F0b3IgJiYgd2luZG93Lm5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkICYmXHJcblx0ICAgICAgICAgICAgICB3aW5kb3cubmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgJiYgIXdpbmRvdy5Qb2ludGVyRXZlbnQsXHJcblx0XHRwb2ludGVyID0gKHdpbmRvdy5Qb2ludGVyRXZlbnQgJiYgd2luZG93Lm5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCAmJiB3aW5kb3cubmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzKSB8fFxyXG5cdFx0XHRcdCAgbXNQb2ludGVyLFxyXG5cdCAgICByZXRpbmEgPSAoJ2RldmljZVBpeGVsUmF0aW8nIGluIHdpbmRvdyAmJiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpIHx8XHJcblx0ICAgICAgICAgICAgICgnbWF0Y2hNZWRpYScgaW4gd2luZG93ICYmIHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXJlc29sdXRpb246MTQ0ZHBpKScpICYmXHJcblx0ICAgICAgICAgICAgICB3aW5kb3cubWF0Y2hNZWRpYSgnKG1pbi1yZXNvbHV0aW9uOjE0NGRwaSknKS5tYXRjaGVzKSxcclxuXHJcblx0ICAgIGRvYyA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHQgICAgaWUzZCA9IGllICYmICgndHJhbnNpdGlvbicgaW4gZG9jLnN0eWxlKSxcclxuXHQgICAgd2Via2l0M2QgPSAoJ1dlYktpdENTU01hdHJpeCcgaW4gd2luZG93KSAmJiAoJ20xMScgaW4gbmV3IHdpbmRvdy5XZWJLaXRDU1NNYXRyaXgoKSkgJiYgIWFuZHJvaWQyMyxcclxuXHQgICAgZ2Vja28zZCA9ICdNb3pQZXJzcGVjdGl2ZScgaW4gZG9jLnN0eWxlLFxyXG5cdCAgICBvcGVyYTNkID0gJ09UcmFuc2l0aW9uJyBpbiBkb2Muc3R5bGUsXHJcblx0ICAgIGFueTNkID0gIXdpbmRvdy5MX0RJU0FCTEVfM0QgJiYgKGllM2QgfHwgd2Via2l0M2QgfHwgZ2Vja28zZCB8fCBvcGVyYTNkKSAmJiAhcGhhbnRvbWpzO1xyXG5cclxuXHJcblx0Ly8gUGhhbnRvbUpTIGhhcyAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsIGJ1dCBkb2Vzbid0IGFjdHVhbGx5IHN1cHBvcnQgdG91Y2guXHJcblx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9wdWxsLzE0MzQjaXNzdWVjb21tZW50LTEzODQzMTUxXHJcblxyXG5cdHZhciB0b3VjaCA9ICF3aW5kb3cuTF9OT19UT1VDSCAmJiAhcGhhbnRvbWpzICYmIChmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0dmFyIHN0YXJ0TmFtZSA9ICdvbnRvdWNoc3RhcnQnO1xyXG5cclxuXHRcdC8vIElFMTArIChXZSBzaW11bGF0ZSB0aGVzZSBpbnRvIHRvdWNoKiBldmVudHMgaW4gTC5Eb21FdmVudCBhbmQgTC5Eb21FdmVudC5Qb2ludGVyKSBvciBXZWJLaXQsIGV0Yy5cclxuXHRcdGlmIChwb2ludGVyIHx8IChzdGFydE5hbWUgaW4gZG9jKSkge1xyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaXJlZm94L0dlY2tvXHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXHJcblx0XHQgICAgc3VwcG9ydGVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKCFkaXYuc2V0QXR0cmlidXRlKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGRpdi5zZXRBdHRyaWJ1dGUoc3RhcnROYW1lLCAncmV0dXJuOycpO1xyXG5cclxuXHRcdGlmICh0eXBlb2YgZGl2W3N0YXJ0TmFtZV0gPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0c3VwcG9ydGVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRkaXYucmVtb3ZlQXR0cmlidXRlKHN0YXJ0TmFtZSk7XHJcblx0XHRkaXYgPSBudWxsO1xyXG5cclxuXHRcdHJldHVybiBzdXBwb3J0ZWQ7XHJcblx0fSgpKTtcclxuXHJcblxyXG5cdEwuQnJvd3NlciA9IHtcclxuXHRcdGllOiBpZSxcclxuXHRcdGllbHQ5OiBpZWx0OSxcclxuXHRcdHdlYmtpdDogd2Via2l0LFxyXG5cdFx0Z2Vja286IGdlY2tvICYmICF3ZWJraXQgJiYgIXdpbmRvdy5vcGVyYSAmJiAhaWUsXHJcblxyXG5cdFx0YW5kcm9pZDogYW5kcm9pZCxcclxuXHRcdGFuZHJvaWQyMzogYW5kcm9pZDIzLFxyXG5cclxuXHRcdGNocm9tZTogY2hyb21lLFxyXG5cclxuXHRcdGllM2Q6IGllM2QsXHJcblx0XHR3ZWJraXQzZDogd2Via2l0M2QsXHJcblx0XHRnZWNrbzNkOiBnZWNrbzNkLFxyXG5cdFx0b3BlcmEzZDogb3BlcmEzZCxcclxuXHRcdGFueTNkOiBhbnkzZCxcclxuXHJcblx0XHRtb2JpbGU6IG1vYmlsZSxcclxuXHRcdG1vYmlsZVdlYmtpdDogbW9iaWxlICYmIHdlYmtpdCxcclxuXHRcdG1vYmlsZVdlYmtpdDNkOiBtb2JpbGUgJiYgd2Via2l0M2QsXHJcblx0XHRtb2JpbGVPcGVyYTogbW9iaWxlICYmIHdpbmRvdy5vcGVyYSxcclxuXHJcblx0XHR0b3VjaDogdG91Y2gsXHJcblx0XHRtc1BvaW50ZXI6IG1zUG9pbnRlcixcclxuXHRcdHBvaW50ZXI6IHBvaW50ZXIsXHJcblxyXG5cdFx0cmV0aW5hOiByZXRpbmFcclxuXHR9O1xyXG5cclxufSgpKTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLlBvaW50IHJlcHJlc2VudHMgYSBwb2ludCB3aXRoIHggYW5kIHkgY29vcmRpbmF0ZXMuXHJcbiAqL1xyXG5cclxuTC5Qb2ludCA9IGZ1bmN0aW9uICgvKk51bWJlciovIHgsIC8qTnVtYmVyKi8geSwgLypCb29sZWFuKi8gcm91bmQpIHtcclxuXHR0aGlzLnggPSAocm91bmQgPyBNYXRoLnJvdW5kKHgpIDogeCk7XHJcblx0dGhpcy55ID0gKHJvdW5kID8gTWF0aC5yb3VuZCh5KSA6IHkpO1xyXG59O1xyXG5cclxuTC5Qb2ludC5wcm90b3R5cGUgPSB7XHJcblxyXG5cdGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy54LCB0aGlzLnkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG5vbi1kZXN0cnVjdGl2ZSwgcmV0dXJucyBhIG5ldyBwb2ludFxyXG5cdGFkZDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9hZGQoTC5wb2ludChwb2ludCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGRlc3RydWN0aXZlLCB1c2VkIGRpcmVjdGx5IGZvciBwZXJmb3JtYW5jZSBpbiBzaXR1YXRpb25zIHdoZXJlIGl0J3Mgc2FmZSB0byBtb2RpZnkgZXhpc3RpbmcgcG9pbnRcclxuXHRfYWRkOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCArPSBwb2ludC54O1xyXG5cdFx0dGhpcy55ICs9IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzdWJ0cmFjdDogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9zdWJ0cmFjdChMLnBvaW50KHBvaW50KSk7XHJcblx0fSxcclxuXHJcblx0X3N1YnRyYWN0OiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHRoaXMueCAtPSBwb2ludC54O1xyXG5cdFx0dGhpcy55IC09IHBvaW50Lnk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRkaXZpZGVCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fZGl2aWRlQnkobnVtKTtcclxuXHR9LFxyXG5cclxuXHRfZGl2aWRlQnk6IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHRoaXMueCAvPSBudW07XHJcblx0XHR0aGlzLnkgLz0gbnVtO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0bXVsdGlwbHlCeTogZnVuY3Rpb24gKG51bSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xvbmUoKS5fbXVsdGlwbHlCeShudW0pO1xyXG5cdH0sXHJcblxyXG5cdF9tdWx0aXBseUJ5OiBmdW5jdGlvbiAobnVtKSB7XHJcblx0XHR0aGlzLnggKj0gbnVtO1xyXG5cdFx0dGhpcy55ICo9IG51bTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJvdW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbG9uZSgpLl9yb3VuZCgpO1xyXG5cdH0sXHJcblxyXG5cdF9yb3VuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy54ID0gTWF0aC5yb3VuZCh0aGlzLngpO1xyXG5cdFx0dGhpcy55ID0gTWF0aC5yb3VuZCh0aGlzLnkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Zmxvb3I6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmNsb25lKCkuX2Zsb29yKCk7XHJcblx0fSxcclxuXHJcblx0X2Zsb29yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLnggPSBNYXRoLmZsb29yKHRoaXMueCk7XHJcblx0XHR0aGlzLnkgPSBNYXRoLmZsb29yKHRoaXMueSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy54LFxyXG5cdFx0ICAgIHkgPSBwb2ludC55IC0gdGhpcy55O1xyXG5cclxuXHRcdHJldHVybiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcblx0fSxcclxuXHJcblx0ZXF1YWxzOiBmdW5jdGlvbiAocG9pbnQpIHtcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0cmV0dXJuIHBvaW50LnggPT09IHRoaXMueCAmJlxyXG5cdFx0ICAgICAgIHBvaW50LnkgPT09IHRoaXMueTtcclxuXHR9LFxyXG5cclxuXHRjb250YWluczogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHRwb2ludCA9IEwucG9pbnQocG9pbnQpO1xyXG5cclxuXHRcdHJldHVybiBNYXRoLmFicyhwb2ludC54KSA8PSBNYXRoLmFicyh0aGlzLngpICYmXHJcblx0XHQgICAgICAgTWF0aC5hYnMocG9pbnQueSkgPD0gTWF0aC5hYnModGhpcy55KTtcclxuXHR9LFxyXG5cclxuXHR0b1N0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICdQb2ludCgnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLngpICsgJywgJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy55KSArICcpJztcclxuXHR9XHJcbn07XHJcblxyXG5MLnBvaW50ID0gZnVuY3Rpb24gKHgsIHksIHJvdW5kKSB7XHJcblx0aWYgKHggaW5zdGFuY2VvZiBMLlBvaW50KSB7XHJcblx0XHRyZXR1cm4geDtcclxuXHR9XHJcblx0aWYgKEwuVXRpbC5pc0FycmF5KHgpKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeFswXSwgeFsxXSk7XHJcblx0fVxyXG5cdGlmICh4ID09PSB1bmRlZmluZWQgfHwgeCA9PT0gbnVsbCkge1xyXG5cdFx0cmV0dXJuIHg7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5Qb2ludCh4LCB5LCByb3VuZCk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5Cb3VuZHMgcmVwcmVzZW50cyBhIHJlY3Rhbmd1bGFyIGFyZWEgb24gdGhlIHNjcmVlbiBpbiBwaXhlbCBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLkJvdW5kcyA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vKFBvaW50LCBQb2ludCkgb3IgUG9pbnRbXVxyXG5cdGlmICghYSkgeyByZXR1cm47IH1cclxuXHJcblx0dmFyIHBvaW50cyA9IGIgPyBbYSwgYl0gOiBhO1xyXG5cclxuXHRmb3IgKHZhciBpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChwb2ludHNbaV0pO1xyXG5cdH1cclxufTtcclxuXHJcbkwuQm91bmRzLnByb3RvdHlwZSA9IHtcclxuXHQvLyBleHRlbmQgdGhlIGJvdW5kcyB0byBjb250YWluIHRoZSBnaXZlbiBwb2ludFxyXG5cdGV4dGVuZDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludClcclxuXHRcdHBvaW50ID0gTC5wb2ludChwb2ludCk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm1pbiAmJiAhdGhpcy5tYXgpIHtcclxuXHRcdFx0dGhpcy5taW4gPSBwb2ludC5jbG9uZSgpO1xyXG5cdFx0XHR0aGlzLm1heCA9IHBvaW50LmNsb25lKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm1pbi54ID0gTWF0aC5taW4ocG9pbnQueCwgdGhpcy5taW4ueCk7XHJcblx0XHRcdHRoaXMubWF4LnggPSBNYXRoLm1heChwb2ludC54LCB0aGlzLm1heC54KTtcclxuXHRcdFx0dGhpcy5taW4ueSA9IE1hdGgubWluKHBvaW50LnksIHRoaXMubWluLnkpO1xyXG5cdFx0XHR0aGlzLm1heC55ID0gTWF0aC5tYXgocG9pbnQueSwgdGhpcy5tYXgueSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uIChyb3VuZCkgeyAvLyAoQm9vbGVhbikgLT4gUG9pbnRcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChcclxuXHRcdCAgICAgICAgKHRoaXMubWluLnggKyB0aGlzLm1heC54KSAvIDIsXHJcblx0XHQgICAgICAgICh0aGlzLm1pbi55ICsgdGhpcy5tYXgueSkgLyAyLCByb3VuZCk7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm90dG9tTGVmdDogZnVuY3Rpb24gKCkgeyAvLyAtPiBQb2ludFxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHRoaXMubWluLngsIHRoaXMubWF4LnkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFRvcFJpZ2h0OiBmdW5jdGlvbiAoKSB7IC8vIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQodGhpcy5tYXgueCwgdGhpcy5taW4ueSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWF4LnN1YnRyYWN0KHRoaXMubWluKTtcclxuXHR9LFxyXG5cclxuXHRjb250YWluczogZnVuY3Rpb24gKG9iaikgeyAvLyAoQm91bmRzKSBvciAoUG9pbnQpIC0+IEJvb2xlYW5cclxuXHRcdHZhciBtaW4sIG1heDtcclxuXHJcblx0XHRpZiAodHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgfHwgb2JqIGluc3RhbmNlb2YgTC5Qb2ludCkge1xyXG5cdFx0XHRvYmogPSBMLnBvaW50KG9iaik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmJvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkJvdW5kcykge1xyXG5cdFx0XHRtaW4gPSBvYmoubWluO1xyXG5cdFx0XHRtYXggPSBvYmoubWF4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bWluID0gbWF4ID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAobWluLnggPj0gdGhpcy5taW4ueCkgJiZcclxuXHRcdCAgICAgICAobWF4LnggPD0gdGhpcy5tYXgueCkgJiZcclxuXHRcdCAgICAgICAobWluLnkgPj0gdGhpcy5taW4ueSkgJiZcclxuXHRcdCAgICAgICAobWF4LnkgPD0gdGhpcy5tYXgueSk7XHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoQm91bmRzKSAtPiBCb29sZWFuXHJcblx0XHRib3VuZHMgPSBMLmJvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHZhciBtaW4gPSB0aGlzLm1pbixcclxuXHRcdCAgICBtYXggPSB0aGlzLm1heCxcclxuXHRcdCAgICBtaW4yID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXgyID0gYm91bmRzLm1heCxcclxuXHRcdCAgICB4SW50ZXJzZWN0cyA9IChtYXgyLnggPj0gbWluLngpICYmIChtaW4yLnggPD0gbWF4LngpLFxyXG5cdFx0ICAgIHlJbnRlcnNlY3RzID0gKG1heDIueSA+PSBtaW4ueSkgJiYgKG1pbjIueSA8PSBtYXgueSk7XHJcblxyXG5cdFx0cmV0dXJuIHhJbnRlcnNlY3RzICYmIHlJbnRlcnNlY3RzO1xyXG5cdH0sXHJcblxyXG5cdGlzVmFsaWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhISh0aGlzLm1pbiAmJiB0aGlzLm1heCk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5ib3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoQm91bmRzKSBvciAoUG9pbnQsIFBvaW50KSBvciAoUG9pbnRbXSlcclxuXHRpZiAoIWEgfHwgYSBpbnN0YW5jZW9mIEwuQm91bmRzKSB7XHJcblx0XHRyZXR1cm4gYTtcclxuXHR9XHJcblx0cmV0dXJuIG5ldyBMLkJvdW5kcyhhLCBiKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLlRyYW5zZm9ybWF0aW9uIGlzIGFuIHV0aWxpdHkgY2xhc3MgdG8gcGVyZm9ybSBzaW1wbGUgcG9pbnQgdHJhbnNmb3JtYXRpb25zIHRocm91Z2ggYSAyZC1tYXRyaXguXHJcbiAqL1xyXG5cclxuTC5UcmFuc2Zvcm1hdGlvbiA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7XHJcblx0dGhpcy5fYSA9IGE7XHJcblx0dGhpcy5fYiA9IGI7XHJcblx0dGhpcy5fYyA9IGM7XHJcblx0dGhpcy5fZCA9IGQ7XHJcbn07XHJcblxyXG5MLlRyYW5zZm9ybWF0aW9uLnByb3RvdHlwZSA9IHtcclxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uIChwb2ludCwgc2NhbGUpIHsgLy8gKFBvaW50LCBOdW1iZXIpIC0+IFBvaW50XHJcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtKHBvaW50LmNsb25lKCksIHNjYWxlKTtcclxuXHR9LFxyXG5cclxuXHQvLyBkZXN0cnVjdGl2ZSB0cmFuc2Zvcm0gKGZhc3RlcilcclxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRwb2ludC54ID0gc2NhbGUgKiAodGhpcy5fYSAqIHBvaW50LnggKyB0aGlzLl9iKTtcclxuXHRcdHBvaW50LnkgPSBzY2FsZSAqICh0aGlzLl9jICogcG9pbnQueSArIHRoaXMuX2QpO1xyXG5cdFx0cmV0dXJuIHBvaW50O1xyXG5cdH0sXHJcblxyXG5cdHVudHJhbnNmb3JtOiBmdW5jdGlvbiAocG9pbnQsIHNjYWxlKSB7XHJcblx0XHRzY2FsZSA9IHNjYWxlIHx8IDE7XHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgIChwb2ludC54IC8gc2NhbGUgLSB0aGlzLl9iKSAvIHRoaXMuX2EsXHJcblx0XHQgICAgICAgIChwb2ludC55IC8gc2NhbGUgLSB0aGlzLl9kKSAvIHRoaXMuX2MpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkRvbVV0aWwgY29udGFpbnMgdmFyaW91cyB1dGlsaXR5IGZ1bmN0aW9ucyBmb3Igd29ya2luZyB3aXRoIERPTS5cclxuICovXHJcblxyXG5MLkRvbVV0aWwgPSB7XHJcblx0Z2V0OiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHJldHVybiAodHlwZW9mIGlkID09PSAnc3RyaW5nJyA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKSA6IGlkKTtcclxuXHR9LFxyXG5cclxuXHRnZXRTdHlsZTogZnVuY3Rpb24gKGVsLCBzdHlsZSkge1xyXG5cclxuXHRcdHZhciB2YWx1ZSA9IGVsLnN0eWxlW3N0eWxlXTtcclxuXHJcblx0XHRpZiAoIXZhbHVlICYmIGVsLmN1cnJlbnRTdHlsZSkge1xyXG5cdFx0XHR2YWx1ZSA9IGVsLmN1cnJlbnRTdHlsZVtzdHlsZV07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCghdmFsdWUgfHwgdmFsdWUgPT09ICdhdXRvJykgJiYgZG9jdW1lbnQuZGVmYXVsdFZpZXcpIHtcclxuXHRcdFx0dmFyIGNzcyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3LmdldENvbXB1dGVkU3R5bGUoZWwsIG51bGwpO1xyXG5cdFx0XHR2YWx1ZSA9IGNzcyA/IGNzc1tzdHlsZV0gOiBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ2F1dG8nID8gbnVsbCA6IHZhbHVlO1xyXG5cdH0sXHJcblxyXG5cdGdldFZpZXdwb3J0T2Zmc2V0OiBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG5cclxuXHRcdHZhciB0b3AgPSAwLFxyXG5cdFx0ICAgIGxlZnQgPSAwLFxyXG5cdFx0ICAgIGVsID0gZWxlbWVudCxcclxuXHRcdCAgICBkb2NCb2R5ID0gZG9jdW1lbnQuYm9keSxcclxuXHRcdCAgICBkb2NFbCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCxcclxuXHRcdCAgICBwb3M7XHJcblxyXG5cdFx0ZG8ge1xyXG5cdFx0XHR0b3AgICs9IGVsLm9mZnNldFRvcCAgfHwgMDtcclxuXHRcdFx0bGVmdCArPSBlbC5vZmZzZXRMZWZ0IHx8IDA7XHJcblxyXG5cdFx0XHQvL2FkZCBib3JkZXJzXHJcblx0XHRcdHRvcCArPSBwYXJzZUludChMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdib3JkZXJUb3BXaWR0aCcpLCAxMCkgfHwgMDtcclxuXHRcdFx0bGVmdCArPSBwYXJzZUludChMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdib3JkZXJMZWZ0V2lkdGgnKSwgMTApIHx8IDA7XHJcblxyXG5cdFx0XHRwb3MgPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdwb3NpdGlvbicpO1xyXG5cclxuXHRcdFx0aWYgKGVsLm9mZnNldFBhcmVudCA9PT0gZG9jQm9keSAmJiBwb3MgPT09ICdhYnNvbHV0ZScpIHsgYnJlYWs7IH1cclxuXHJcblx0XHRcdGlmIChwb3MgPT09ICdmaXhlZCcpIHtcclxuXHRcdFx0XHR0b3AgICs9IGRvY0JvZHkuc2Nyb2xsVG9wICB8fCBkb2NFbC5zY3JvbGxUb3AgIHx8IDA7XHJcblx0XHRcdFx0bGVmdCArPSBkb2NCb2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdCB8fCAwO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAocG9zID09PSAncmVsYXRpdmUnICYmICFlbC5vZmZzZXRMZWZ0KSB7XHJcblx0XHRcdFx0dmFyIHdpZHRoID0gTC5Eb21VdGlsLmdldFN0eWxlKGVsLCAnd2lkdGgnKSxcclxuXHRcdFx0XHQgICAgbWF4V2lkdGggPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZWwsICdtYXgtd2lkdGgnKSxcclxuXHRcdFx0XHQgICAgciA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG5cclxuXHRcdFx0XHRpZiAod2lkdGggIT09ICdub25lJyB8fCBtYXhXaWR0aCAhPT0gJ25vbmUnKSB7XHJcblx0XHRcdFx0XHRsZWZ0ICs9IHIubGVmdCArIGVsLmNsaWVudExlZnQ7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvL2NhbGN1bGF0ZSBmdWxsIHkgb2Zmc2V0IHNpbmNlIHdlJ3JlIGJyZWFraW5nIG91dCBvZiB0aGUgbG9vcFxyXG5cdFx0XHRcdHRvcCArPSByLnRvcCArIChkb2NCb2R5LnNjcm9sbFRvcCAgfHwgZG9jRWwuc2Nyb2xsVG9wICB8fCAwKTtcclxuXHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGVsID0gZWwub2Zmc2V0UGFyZW50O1xyXG5cclxuXHRcdH0gd2hpbGUgKGVsKTtcclxuXHJcblx0XHRlbCA9IGVsZW1lbnQ7XHJcblxyXG5cdFx0ZG8ge1xyXG5cdFx0XHRpZiAoZWwgPT09IGRvY0JvZHkpIHsgYnJlYWs7IH1cclxuXHJcblx0XHRcdHRvcCAgLT0gZWwuc2Nyb2xsVG9wICB8fCAwO1xyXG5cdFx0XHRsZWZ0IC09IGVsLnNjcm9sbExlZnQgfHwgMDtcclxuXHJcblx0XHRcdGVsID0gZWwucGFyZW50Tm9kZTtcclxuXHRcdH0gd2hpbGUgKGVsKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQobGVmdCwgdG9wKTtcclxuXHR9LFxyXG5cclxuXHRkb2N1bWVudElzTHRyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIUwuRG9tVXRpbC5fZG9jSXNMdHJDYWNoZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLl9kb2NJc0x0ckNhY2hlZCA9IHRydWU7XHJcblx0XHRcdEwuRG9tVXRpbC5fZG9jSXNMdHIgPSBMLkRvbVV0aWwuZ2V0U3R5bGUoZG9jdW1lbnQuYm9keSwgJ2RpcmVjdGlvbicpID09PSAnbHRyJztcclxuXHRcdH1cclxuXHRcdHJldHVybiBMLkRvbVV0aWwuX2RvY0lzTHRyO1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZTogZnVuY3Rpb24gKHRhZ05hbWUsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblxyXG5cdFx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcclxuXHRcdGVsLmNsYXNzTmFtZSA9IGNsYXNzTmFtZTtcclxuXHJcblx0XHRpZiAoY29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChlbCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGVsO1xyXG5cdH0sXHJcblxyXG5cdGhhc0NsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRyZXR1cm4gZWwuY2xhc3NMaXN0LmNvbnRhaW5zKG5hbWUpO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNsYXNzTmFtZSA9IEwuRG9tVXRpbC5fZ2V0Q2xhc3MoZWwpO1xyXG5cdFx0cmV0dXJuIGNsYXNzTmFtZS5sZW5ndGggPiAwICYmIG5ldyBSZWdFeHAoJyhefFxcXFxzKScgKyBuYW1lICsgJyhcXFxcc3wkKScpLnRlc3QoY2xhc3NOYW1lKTtcclxuXHR9LFxyXG5cclxuXHRhZGRDbGFzczogZnVuY3Rpb24gKGVsLCBuYW1lKSB7XHJcblx0XHRpZiAoZWwuY2xhc3NMaXN0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dmFyIGNsYXNzZXMgPSBMLlV0aWwuc3BsaXRXb3JkcyhuYW1lKTtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IGNsYXNzZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRlbC5jbGFzc0xpc3QuYWRkKGNsYXNzZXNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKCFMLkRvbVV0aWwuaGFzQ2xhc3MoZWwsIG5hbWUpKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBMLkRvbVV0aWwuX2dldENsYXNzKGVsKTtcclxuXHRcdFx0TC5Eb21VdGlsLl9zZXRDbGFzcyhlbCwgKGNsYXNzTmFtZSA/IGNsYXNzTmFtZSArICcgJyA6ICcnKSArIG5hbWUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiAoZWwsIG5hbWUpIHtcclxuXHRcdGlmIChlbC5jbGFzc0xpc3QgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRlbC5jbGFzc0xpc3QucmVtb3ZlKG5hbWUpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLl9zZXRDbGFzcyhlbCwgTC5VdGlsLnRyaW0oKCcgJyArIEwuRG9tVXRpbC5fZ2V0Q2xhc3MoZWwpICsgJyAnKS5yZXBsYWNlKCcgJyArIG5hbWUgKyAnICcsICcgJykpKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfc2V0Q2xhc3M6IGZ1bmN0aW9uIChlbCwgbmFtZSkge1xyXG5cdFx0aWYgKGVsLmNsYXNzTmFtZS5iYXNlVmFsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0ZWwuY2xhc3NOYW1lID0gbmFtZTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIGluIGNhc2Ugb2YgU1ZHIGVsZW1lbnRcclxuXHRcdFx0ZWwuY2xhc3NOYW1lLmJhc2VWYWwgPSBuYW1lO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRDbGFzczogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHRyZXR1cm4gZWwuY2xhc3NOYW1lLmJhc2VWYWwgPT09IHVuZGVmaW5lZCA/IGVsLmNsYXNzTmFtZSA6IGVsLmNsYXNzTmFtZS5iYXNlVmFsO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChlbCwgdmFsdWUpIHtcclxuXHJcblx0XHRpZiAoJ29wYWNpdHknIGluIGVsLnN0eWxlKSB7XHJcblx0XHRcdGVsLnN0eWxlLm9wYWNpdHkgPSB2YWx1ZTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKCdmaWx0ZXInIGluIGVsLnN0eWxlKSB7XHJcblxyXG5cdFx0XHR2YXIgZmlsdGVyID0gZmFsc2UsXHJcblx0XHRcdCAgICBmaWx0ZXJOYW1lID0gJ0RYSW1hZ2VUcmFuc2Zvcm0uTWljcm9zb2Z0LkFscGhhJztcclxuXHJcblx0XHRcdC8vIGZpbHRlcnMgY29sbGVjdGlvbiB0aHJvd3MgYW4gZXJyb3IgaWYgd2UgdHJ5IHRvIHJldHJpZXZlIGEgZmlsdGVyIHRoYXQgZG9lc24ndCBleGlzdFxyXG5cdFx0XHR0cnkge1xyXG5cdFx0XHRcdGZpbHRlciA9IGVsLmZpbHRlcnMuaXRlbShmaWx0ZXJOYW1lKTtcclxuXHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdC8vIGRvbid0IHNldCBvcGFjaXR5IHRvIDEgaWYgd2UgaGF2ZW4ndCBhbHJlYWR5IHNldCBhbiBvcGFjaXR5LFxyXG5cdFx0XHRcdC8vIGl0IGlzbid0IG5lZWRlZCBhbmQgYnJlYWtzIHRyYW5zcGFyZW50IHBuZ3MuXHJcblx0XHRcdFx0aWYgKHZhbHVlID09PSAxKSB7IHJldHVybjsgfVxyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YWx1ZSA9IE1hdGgucm91bmQodmFsdWUgKiAxMDApO1xyXG5cclxuXHRcdFx0aWYgKGZpbHRlcikge1xyXG5cdFx0XHRcdGZpbHRlci5FbmFibGVkID0gKHZhbHVlICE9PSAxMDApO1xyXG5cdFx0XHRcdGZpbHRlci5PcGFjaXR5ID0gdmFsdWU7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZWwuc3R5bGUuZmlsdGVyICs9ICcgcHJvZ2lkOicgKyBmaWx0ZXJOYW1lICsgJyhvcGFjaXR5PScgKyB2YWx1ZSArICcpJztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHRlc3RQcm9wOiBmdW5jdGlvbiAocHJvcHMpIHtcclxuXHJcblx0XHR2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRpZiAocHJvcHNbaV0gaW4gc3R5bGUpIHtcclxuXHRcdFx0XHRyZXR1cm4gcHJvcHNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRnZXRUcmFuc2xhdGVTdHJpbmc6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0Ly8gb24gV2ViS2l0IGJyb3dzZXJzIChDaHJvbWUvU2FmYXJpL2lPUyBTYWZhcmkvQW5kcm9pZCkgdXNpbmcgdHJhbnNsYXRlM2QgaW5zdGVhZCBvZiB0cmFuc2xhdGVcclxuXHRcdC8vIG1ha2VzIGFuaW1hdGlvbiBzbW9vdGhlciBhcyBpdCBlbnN1cmVzIEhXIGFjY2VsIGlzIHVzZWQuIEZpcmVmb3ggMTMgZG9lc24ndCBjYXJlXHJcblx0XHQvLyAoc2FtZSBzcGVlZCBlaXRoZXIgd2F5KSwgT3BlcmEgMTIgZG9lc24ndCBzdXBwb3J0IHRyYW5zbGF0ZTNkXHJcblxyXG5cdFx0dmFyIGlzM2QgPSBMLkJyb3dzZXIud2Via2l0M2QsXHJcblx0XHQgICAgb3BlbiA9ICd0cmFuc2xhdGUnICsgKGlzM2QgPyAnM2QnIDogJycpICsgJygnLFxyXG5cdFx0ICAgIGNsb3NlID0gKGlzM2QgPyAnLDAnIDogJycpICsgJyknO1xyXG5cclxuXHRcdHJldHVybiBvcGVuICsgcG9pbnQueCArICdweCwnICsgcG9pbnQueSArICdweCcgKyBjbG9zZTtcclxuXHR9LFxyXG5cclxuXHRnZXRTY2FsZVN0cmluZzogZnVuY3Rpb24gKHNjYWxlLCBvcmlnaW4pIHtcclxuXHJcblx0XHR2YXIgcHJlVHJhbnNsYXRlU3RyID0gTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhvcmlnaW4uYWRkKG9yaWdpbi5tdWx0aXBseUJ5KC0xICogc2NhbGUpKSksXHJcblx0XHQgICAgc2NhbGVTdHIgPSAnIHNjYWxlKCcgKyBzY2FsZSArICcpICc7XHJcblxyXG5cdFx0cmV0dXJuIHByZVRyYW5zbGF0ZVN0ciArIHNjYWxlU3RyO1xyXG5cdH0sXHJcblxyXG5cdHNldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwsIHBvaW50LCBkaXNhYmxlM0QpIHsgLy8gKEhUTUxFbGVtZW50LCBQb2ludFssIEJvb2xlYW5dKVxyXG5cclxuXHRcdC8vIGpzaGludCBjYW1lbGNhc2U6IGZhbHNlXHJcblx0XHRlbC5fbGVhZmxldF9wb3MgPSBwb2ludDtcclxuXHJcblx0XHRpZiAoIWRpc2FibGUzRCAmJiBMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0ZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TRk9STV0gPSAgTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhwb2ludCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlbC5zdHlsZS5sZWZ0ID0gcG9pbnQueCArICdweCc7XHJcblx0XHRcdGVsLnN0eWxlLnRvcCA9IHBvaW50LnkgKyAncHgnO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbiAoZWwpIHtcclxuXHRcdC8vIHRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBmb3IgZWxlbWVudHMgcHJldmlvdXNseSBwb3NpdGlvbmVkIHVzaW5nIHNldFBvc2l0aW9uLFxyXG5cdFx0Ly8gc28gaXQncyBzYWZlIHRvIGNhY2hlIHRoZSBwb3NpdGlvbiBmb3IgcGVyZm9ybWFuY2VcclxuXHJcblx0XHQvLyBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZVxyXG5cdFx0cmV0dXJuIGVsLl9sZWFmbGV0X3BvcztcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLy8gcHJlZml4IHN0eWxlIHByb3BlcnR5IG5hbWVzXHJcblxyXG5MLkRvbVV0aWwuVFJBTlNGT1JNID0gTC5Eb21VdGlsLnRlc3RQcm9wKFxyXG4gICAgICAgIFsndHJhbnNmb3JtJywgJ1dlYmtpdFRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdtc1RyYW5zZm9ybSddKTtcclxuXHJcbi8vIHdlYmtpdFRyYW5zaXRpb24gY29tZXMgZmlyc3QgYmVjYXVzZSBzb21lIGJyb3dzZXIgdmVyc2lvbnMgdGhhdCBkcm9wIHZlbmRvciBwcmVmaXggZG9uJ3QgZG9cclxuLy8gdGhlIHNhbWUgZm9yIHRoZSB0cmFuc2l0aW9uZW5kIGV2ZW50LCBpbiBwYXJ0aWN1bGFyIHRoZSBBbmRyb2lkIDQuMSBzdG9jayBicm93c2VyXHJcblxyXG5MLkRvbVV0aWwuVFJBTlNJVElPTiA9IEwuRG9tVXRpbC50ZXN0UHJvcChcclxuICAgICAgICBbJ3dlYmtpdFRyYW5zaXRpb24nLCAndHJhbnNpdGlvbicsICdPVHJhbnNpdGlvbicsICdNb3pUcmFuc2l0aW9uJywgJ21zVHJhbnNpdGlvbiddKTtcclxuXHJcbkwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCA9XHJcbiAgICAgICAgTC5Eb21VdGlsLlRSQU5TSVRJT04gPT09ICd3ZWJraXRUcmFuc2l0aW9uJyB8fCBMLkRvbVV0aWwuVFJBTlNJVElPTiA9PT0gJ09UcmFuc2l0aW9uJyA/XHJcbiAgICAgICAgTC5Eb21VdGlsLlRSQU5TSVRJT04gKyAnRW5kJyA6ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBpZiAoJ29uc2VsZWN0c3RhcnQnIGluIGRvY3VtZW50KSB7XHJcbiAgICAgICAgTC5leHRlbmQoTC5Eb21VdGlsLCB7XHJcbiAgICAgICAgICAgIGRpc2FibGVUZXh0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBMLkRvbUV2ZW50Lm9uKHdpbmRvdywgJ3NlbGVjdHN0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcbiAgICAgICAgICAgIH0sXHJcblxyXG4gICAgICAgICAgICBlbmFibGVUZXh0U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdzZWxlY3RzdGFydCcsIEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAgIHZhciB1c2VyU2VsZWN0UHJvcGVydHkgPSBMLkRvbVV0aWwudGVzdFByb3AoXHJcbiAgICAgICAgICAgIFsndXNlclNlbGVjdCcsICdXZWJraXRVc2VyU2VsZWN0JywgJ09Vc2VyU2VsZWN0JywgJ01velVzZXJTZWxlY3QnLCAnbXNVc2VyU2VsZWN0J10pO1xyXG5cclxuICAgICAgICBMLmV4dGVuZChMLkRvbVV0aWwsIHtcclxuICAgICAgICAgICAgZGlzYWJsZVRleHRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGU7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXNlclNlbGVjdCA9IHN0eWxlW3VzZXJTZWxlY3RQcm9wZXJ0eV07XHJcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuXHJcbiAgICAgICAgICAgIGVuYWJsZVRleHRTZWxlY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIGlmICh1c2VyU2VsZWN0UHJvcGVydHkpIHtcclxuICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGVbdXNlclNlbGVjdFByb3BlcnR5XSA9IHRoaXMuX3VzZXJTZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3VzZXJTZWxlY3Q7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcblx0TC5leHRlbmQoTC5Eb21VdGlsLCB7XHJcblx0XHRkaXNhYmxlSW1hZ2VEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24od2luZG93LCAnZHJhZ3N0YXJ0JywgTC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGVuYWJsZUltYWdlRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih3aW5kb3csICdkcmFnc3RhcnQnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdH1cclxuXHR9KTtcclxufSkoKTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkxhdExuZyByZXByZXNlbnRzIGEgZ2VvZ3JhcGhpY2FsIHBvaW50IHdpdGggbGF0aXR1ZGUgYW5kIGxvbmdpdHVkZSBjb29yZGluYXRlcy5cclxuICovXHJcblxyXG5MLkxhdExuZyA9IGZ1bmN0aW9uIChsYXQsIGxuZywgYWx0KSB7IC8vIChOdW1iZXIsIE51bWJlciwgTnVtYmVyKVxyXG5cdGxhdCA9IHBhcnNlRmxvYXQobGF0KTtcclxuXHRsbmcgPSBwYXJzZUZsb2F0KGxuZyk7XHJcblxyXG5cdGlmIChpc05hTihsYXQpIHx8IGlzTmFOKGxuZykpIHtcclxuXHRcdHRocm93IG5ldyBFcnJvcignSW52YWxpZCBMYXRMbmcgb2JqZWN0OiAoJyArIGxhdCArICcsICcgKyBsbmcgKyAnKScpO1xyXG5cdH1cclxuXHJcblx0dGhpcy5sYXQgPSBsYXQ7XHJcblx0dGhpcy5sbmcgPSBsbmc7XHJcblxyXG5cdGlmIChhbHQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0dGhpcy5hbHQgPSBwYXJzZUZsb2F0KGFsdCk7XHJcblx0fVxyXG59O1xyXG5cclxuTC5leHRlbmQoTC5MYXRMbmcsIHtcclxuXHRERUdfVE9fUkFEOiBNYXRoLlBJIC8gMTgwLFxyXG5cdFJBRF9UT19ERUc6IDE4MCAvIE1hdGguUEksXHJcblx0TUFYX01BUkdJTjogMS4wRS05IC8vIG1heCBtYXJnaW4gb2YgZXJyb3IgZm9yIHRoZSBcImVxdWFsc1wiIGNoZWNrXHJcbn0pO1xyXG5cclxuTC5MYXRMbmcucHJvdG90eXBlID0ge1xyXG5cdGVxdWFsczogZnVuY3Rpb24gKG9iaikgeyAvLyAoTGF0TG5nKSAtPiBCb29sZWFuXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cclxuXHRcdHZhciBtYXJnaW4gPSBNYXRoLm1heChcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sYXQgLSBvYmoubGF0KSxcclxuXHRcdCAgICAgICAgTWF0aC5hYnModGhpcy5sbmcgLSBvYmoubG5nKSk7XHJcblxyXG5cdFx0cmV0dXJuIG1hcmdpbiA8PSBMLkxhdExuZy5NQVhfTUFSR0lOO1xyXG5cdH0sXHJcblxyXG5cdHRvU3RyaW5nOiBmdW5jdGlvbiAocHJlY2lzaW9uKSB7IC8vIChOdW1iZXIpIC0+IFN0cmluZ1xyXG5cdFx0cmV0dXJuICdMYXRMbmcoJyArXHJcblx0XHQgICAgICAgIEwuVXRpbC5mb3JtYXROdW0odGhpcy5sYXQsIHByZWNpc2lvbikgKyAnLCAnICtcclxuXHRcdCAgICAgICAgTC5VdGlsLmZvcm1hdE51bSh0aGlzLmxuZywgcHJlY2lzaW9uKSArICcpJztcclxuXHR9LFxyXG5cclxuXHQvLyBIYXZlcnNpbmUgZGlzdGFuY2UgZm9ybXVsYSwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcclxuXHQvLyBUT0RPIG1vdmUgdG8gcHJvamVjdGlvbiBjb2RlLCBMYXRMbmcgc2hvdWxkbid0IGtub3cgYWJvdXQgRWFydGhcclxuXHRkaXN0YW5jZVRvOiBmdW5jdGlvbiAob3RoZXIpIHsgLy8gKExhdExuZykgLT4gTnVtYmVyXHJcblx0XHRvdGhlciA9IEwubGF0TG5nKG90aGVyKTtcclxuXHJcblx0XHR2YXIgUiA9IDYzNzgxMzcsIC8vIGVhcnRoIHJhZGl1cyBpbiBtZXRlcnNcclxuXHRcdCAgICBkMnIgPSBMLkxhdExuZy5ERUdfVE9fUkFELFxyXG5cdFx0ICAgIGRMYXQgPSAob3RoZXIubGF0IC0gdGhpcy5sYXQpICogZDJyLFxyXG5cdFx0ICAgIGRMb24gPSAob3RoZXIubG5nIC0gdGhpcy5sbmcpICogZDJyLFxyXG5cdFx0ICAgIGxhdDEgPSB0aGlzLmxhdCAqIGQycixcclxuXHRcdCAgICBsYXQyID0gb3RoZXIubGF0ICogZDJyLFxyXG5cdFx0ICAgIHNpbjEgPSBNYXRoLnNpbihkTGF0IC8gMiksXHJcblx0XHQgICAgc2luMiA9IE1hdGguc2luKGRMb24gLyAyKTtcclxuXHJcblx0XHR2YXIgYSA9IHNpbjEgKiBzaW4xICsgc2luMiAqIHNpbjIgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xyXG5cclxuXHRcdHJldHVybiBSICogMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKTtcclxuXHR9LFxyXG5cclxuXHR3cmFwOiBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTnVtYmVyLCBOdW1iZXIpIC0+IExhdExuZ1xyXG5cdFx0dmFyIGxuZyA9IHRoaXMubG5nO1xyXG5cclxuXHRcdGEgPSBhIHx8IC0xODA7XHJcblx0XHRiID0gYiB8fCAgMTgwO1xyXG5cclxuXHRcdGxuZyA9IChsbmcgKyBiKSAlIChiIC0gYSkgKyAobG5nIDwgYSB8fCBsbmcgPT09IGIgPyBiIDogYSk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmxhdCwgbG5nKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLmxhdExuZyA9IGZ1bmN0aW9uIChhLCBiKSB7IC8vIChMYXRMbmcpIG9yIChbTnVtYmVyLCBOdW1iZXJdKSBvciAoTnVtYmVyLCBOdW1iZXIpXHJcblx0aWYgKGEgaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdGlmIChMLlV0aWwuaXNBcnJheShhKSkge1xyXG5cdFx0aWYgKHR5cGVvZiBhWzBdID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgYVswXSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhhWzBdLCBhWzFdLCBhWzJdKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGEgPT09IG51bGwpIHtcclxuXHRcdHJldHVybiBhO1xyXG5cdH1cclxuXHRpZiAodHlwZW9mIGEgPT09ICdvYmplY3QnICYmICdsYXQnIGluIGEpIHtcclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmcoYS5sYXQsICdsbmcnIGluIGEgPyBhLmxuZyA6IGEubG9uKTtcclxuXHR9XHJcblx0aWYgKGIgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmcoYSwgYik7XHJcbn07XHJcblxyXG5cclxuXHJcbi8qXHJcbiAqIEwuTGF0TG5nQm91bmRzIHJlcHJlc2VudHMgYSByZWN0YW5ndWxhciBhcmVhIG9uIHRoZSBtYXAgaW4gZ2VvZ3JhcGhpY2FsIGNvb3JkaW5hdGVzLlxyXG4gKi9cclxuXHJcbkwuTGF0TG5nQm91bmRzID0gZnVuY3Rpb24gKHNvdXRoV2VzdCwgbm9ydGhFYXN0KSB7IC8vIChMYXRMbmcsIExhdExuZykgb3IgKExhdExuZ1tdKVxyXG5cdGlmICghc291dGhXZXN0KSB7IHJldHVybjsgfVxyXG5cclxuXHR2YXIgbGF0bG5ncyA9IG5vcnRoRWFzdCA/IFtzb3V0aFdlc3QsIG5vcnRoRWFzdF0gOiBzb3V0aFdlc3Q7XHJcblxyXG5cdGZvciAodmFyIGkgPSAwLCBsZW4gPSBsYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHR0aGlzLmV4dGVuZChsYXRsbmdzW2ldKTtcclxuXHR9XHJcbn07XHJcblxyXG5MLkxhdExuZ0JvdW5kcy5wcm90b3R5cGUgPSB7XHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgdG8gY29udGFpbiB0aGUgZ2l2ZW4gcG9pbnQgb3IgYm91bmRzXHJcblx0ZXh0ZW5kOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmcpIG9yIChMYXRMbmdCb3VuZHMpXHJcblx0XHRpZiAoIW9iaikgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHZhciBsYXRMbmcgPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0aWYgKGxhdExuZyAhPT0gbnVsbCkge1xyXG5cdFx0XHRvYmogPSBsYXRMbmc7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZ0JvdW5kcyhvYmopO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3NvdXRoV2VzdCAmJiAhdGhpcy5fbm9ydGhFYXN0KSB7XHJcblx0XHRcdFx0dGhpcy5fc291dGhXZXN0ID0gbmV3IEwuTGF0TG5nKG9iai5sYXQsIG9iai5sbmcpO1xyXG5cdFx0XHRcdHRoaXMuX25vcnRoRWFzdCA9IG5ldyBMLkxhdExuZyhvYmoubGF0LCBvYmoubG5nKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9zb3V0aFdlc3QubGF0ID0gTWF0aC5taW4ob2JqLmxhdCwgdGhpcy5fc291dGhXZXN0LmxhdCk7XHJcblx0XHRcdFx0dGhpcy5fc291dGhXZXN0LmxuZyA9IE1hdGgubWluKG9iai5sbmcsIHRoaXMuX3NvdXRoV2VzdC5sbmcpO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9ub3J0aEVhc3QubGF0ID0gTWF0aC5tYXgob2JqLmxhdCwgdGhpcy5fbm9ydGhFYXN0LmxhdCk7XHJcblx0XHRcdFx0dGhpcy5fbm9ydGhFYXN0LmxuZyA9IE1hdGgubWF4KG9iai5sbmcsIHRoaXMuX25vcnRoRWFzdC5sbmcpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHRoaXMuZXh0ZW5kKG9iai5fc291dGhXZXN0KTtcclxuXHRcdFx0dGhpcy5leHRlbmQob2JqLl9ub3J0aEVhc3QpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Ly8gZXh0ZW5kIHRoZSBib3VuZHMgYnkgYSBwZXJjZW50YWdlXHJcblx0cGFkOiBmdW5jdGlvbiAoYnVmZmVyUmF0aW8pIHsgLy8gKE51bWJlcikgLT4gTGF0TG5nQm91bmRzXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgaGVpZ2h0QnVmZmVyID0gTWF0aC5hYnMoc3cubGF0IC0gbmUubGF0KSAqIGJ1ZmZlclJhdGlvLFxyXG5cdFx0ICAgIHdpZHRoQnVmZmVyID0gTWF0aC5hYnMoc3cubG5nIC0gbmUubG5nKSAqIGJ1ZmZlclJhdGlvO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIG5ldyBMLkxhdExuZyhzdy5sYXQgLSBoZWlnaHRCdWZmZXIsIHN3LmxuZyAtIHdpZHRoQnVmZmVyKSxcclxuXHRcdCAgICAgICAgbmV3IEwuTGF0TG5nKG5lLmxhdCArIGhlaWdodEJ1ZmZlciwgbmUubG5nICsgd2lkdGhCdWZmZXIpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uICgpIHsgLy8gLT4gTGF0TG5nXHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKFxyXG5cdFx0ICAgICAgICAodGhpcy5fc291dGhXZXN0LmxhdCArIHRoaXMuX25vcnRoRWFzdC5sYXQpIC8gMixcclxuXHRcdCAgICAgICAgKHRoaXMuX3NvdXRoV2VzdC5sbmcgKyB0aGlzLl9ub3J0aEVhc3QubG5nKSAvIDIpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoV2VzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdDtcclxuXHR9LFxyXG5cclxuXHRnZXROb3J0aEVhc3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3Q7XHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ydGhXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gbmV3IEwuTGF0TG5nKHRoaXMuZ2V0Tm9ydGgoKSwgdGhpcy5nZXRXZXN0KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFNvdXRoRWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyh0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHRnZXRXZXN0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc291dGhXZXN0LmxuZztcclxuXHR9LFxyXG5cclxuXHRnZXRTb3V0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5sYXQ7XHJcblx0fSxcclxuXHJcblx0Z2V0RWFzdDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX25vcnRoRWFzdC5sbmc7XHJcblx0fSxcclxuXHJcblx0Z2V0Tm9ydGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9ub3J0aEVhc3QubGF0O1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5zOiBmdW5jdGlvbiAob2JqKSB7IC8vIChMYXRMbmdCb3VuZHMpIG9yIChMYXRMbmcpIC0+IEJvb2xlYW5cclxuXHRcdGlmICh0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyB8fCBvYmogaW5zdGFuY2VvZiBMLkxhdExuZykge1xyXG5cdFx0XHRvYmogPSBMLmxhdExuZyhvYmopO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0b2JqID0gTC5sYXRMbmdCb3VuZHMob2JqKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyLCBuZTI7XHJcblxyXG5cdFx0aWYgKG9iaiBpbnN0YW5jZW9mIEwuTGF0TG5nQm91bmRzKSB7XHJcblx0XHRcdHN3MiA9IG9iai5nZXRTb3V0aFdlc3QoKTtcclxuXHRcdFx0bmUyID0gb2JqLmdldE5vcnRoRWFzdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c3cyID0gbmUyID0gb2JqO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiAoc3cyLmxhdCA+PSBzdy5sYXQpICYmIChuZTIubGF0IDw9IG5lLmxhdCkgJiZcclxuXHRcdCAgICAgICAoc3cyLmxuZyA+PSBzdy5sbmcpICYmIChuZTIubG5nIDw9IG5lLmxuZyk7XHJcblx0fSxcclxuXHJcblx0aW50ZXJzZWN0czogZnVuY3Rpb24gKGJvdW5kcykgeyAvLyAoTGF0TG5nQm91bmRzKVxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgc3cgPSB0aGlzLl9zb3V0aFdlc3QsXHJcblx0XHQgICAgbmUgPSB0aGlzLl9ub3J0aEVhc3QsXHJcblx0XHQgICAgc3cyID0gYm91bmRzLmdldFNvdXRoV2VzdCgpLFxyXG5cdFx0ICAgIG5lMiA9IGJvdW5kcy5nZXROb3J0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgbGF0SW50ZXJzZWN0cyA9IChuZTIubGF0ID49IHN3LmxhdCkgJiYgKHN3Mi5sYXQgPD0gbmUubGF0KSxcclxuXHRcdCAgICBsbmdJbnRlcnNlY3RzID0gKG5lMi5sbmcgPj0gc3cubG5nKSAmJiAoc3cyLmxuZyA8PSBuZS5sbmcpO1xyXG5cclxuXHRcdHJldHVybiBsYXRJbnRlcnNlY3RzICYmIGxuZ0ludGVyc2VjdHM7XHJcblx0fSxcclxuXHJcblx0dG9CQm94U3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gW3RoaXMuZ2V0V2VzdCgpLCB0aGlzLmdldFNvdXRoKCksIHRoaXMuZ2V0RWFzdCgpLCB0aGlzLmdldE5vcnRoKCldLmpvaW4oJywnKTtcclxuXHR9LFxyXG5cclxuXHRlcXVhbHM6IGZ1bmN0aW9uIChib3VuZHMpIHsgLy8gKExhdExuZ0JvdW5kcylcclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdGJvdW5kcyA9IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX3NvdXRoV2VzdC5lcXVhbHMoYm91bmRzLmdldFNvdXRoV2VzdCgpKSAmJlxyXG5cdFx0ICAgICAgIHRoaXMuX25vcnRoRWFzdC5lcXVhbHMoYm91bmRzLmdldE5vcnRoRWFzdCgpKTtcclxuXHR9LFxyXG5cclxuXHRpc1ZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISEodGhpcy5fc291dGhXZXN0ICYmIHRoaXMuX25vcnRoRWFzdCk7XHJcblx0fVxyXG59O1xyXG5cclxuLy9UT0RPIEludGVybmF0aW9uYWwgZGF0ZSBsaW5lP1xyXG5cclxuTC5sYXRMbmdCb3VuZHMgPSBmdW5jdGlvbiAoYSwgYikgeyAvLyAoTGF0TG5nQm91bmRzKSBvciAoTGF0TG5nLCBMYXRMbmcpXHJcblx0aWYgKCFhIHx8IGEgaW5zdGFuY2VvZiBMLkxhdExuZ0JvdW5kcykge1xyXG5cdFx0cmV0dXJuIGE7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoYSwgYik7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5Qcm9qZWN0aW9uIGNvbnRhaW5zIHZhcmlvdXMgZ2VvZ3JhcGhpY2FsIHByb2plY3Rpb25zIHVzZWQgYnkgQ1JTIGNsYXNzZXMuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uID0ge307XHJcblxyXG5cclxuLypcclxuICogU3BoZXJpY2FsIE1lcmNhdG9yIGlzIHRoZSBtb3N0IHBvcHVsYXIgbWFwIHByb2plY3Rpb24sIHVzZWQgYnkgRVBTRzozODU3IENSUyB1c2VkIGJ5IGRlZmF1bHQuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLlNwaGVyaWNhbE1lcmNhdG9yID0ge1xyXG5cdE1BWF9MQVRJVFVERTogODUuMDUxMTI4Nzc5OCxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBQb2ludFxyXG5cdFx0dmFyIGQgPSBMLkxhdExuZy5ERUdfVE9fUkFELFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHggPSBsYXRsbmcubG5nICogZCxcclxuXHRcdCAgICB5ID0gbGF0ICogZDtcclxuXHJcblx0XHR5ID0gTWF0aC5sb2coTWF0aC50YW4oKE1hdGguUEkgLyA0KSArICh5IC8gMikpKTtcclxuXHJcblx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoeCwgeSk7XHJcblx0fSxcclxuXHJcblx0dW5wcm9qZWN0OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50LCBCb29sZWFuKSAtPiBMYXRMbmdcclxuXHRcdHZhciBkID0gTC5MYXRMbmcuUkFEX1RPX0RFRyxcclxuXHRcdCAgICBsbmcgPSBwb2ludC54ICogZCxcclxuXHRcdCAgICBsYXQgPSAoMiAqIE1hdGguYXRhbihNYXRoLmV4cChwb2ludC55KSkgLSAoTWF0aC5QSSAvIDIpKSAqIGQ7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhsYXQsIGxuZyk7XHJcblx0fVxyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIFNpbXBsZSBlcXVpcmVjdGFuZ3VsYXIgKFBsYXRlIENhcnJlZSkgcHJvamVjdGlvbiwgdXNlZCBieSBDUlMgbGlrZSBFUFNHOjQzMjYgYW5kIFNpbXBsZS5cclxuICovXHJcblxyXG5MLlByb2plY3Rpb24uTG9uTGF0ID0ge1xyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChsYXRsbmcubG5nLCBsYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHR1bnByb2plY3Q6IGZ1bmN0aW9uIChwb2ludCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwb2ludC55LCBwb2ludC54KTtcclxuXHR9XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5DUlMgaXMgYSBiYXNlIG9iamVjdCBmb3IgYWxsIGRlZmluZWQgQ1JTIChDb29yZGluYXRlIFJlZmVyZW5jZSBTeXN0ZW1zKSBpbiBMZWFmbGV0LlxyXG4gKi9cclxuXHJcbkwuQ1JTID0ge1xyXG5cdGxhdExuZ1RvUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHsgLy8gKExhdExuZywgTnVtYmVyKSAtPiBQb2ludFxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0aW9uLnByb2plY3QobGF0bG5nKSxcclxuXHRcdCAgICBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtYXRpb24uX3RyYW5zZm9ybShwcm9qZWN0ZWRQb2ludCwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdHBvaW50VG9MYXRMbmc6IGZ1bmN0aW9uIChwb2ludCwgem9vbSkgeyAvLyAoUG9pbnQsIE51bWJlclssIEJvb2xlYW5dKSAtPiBMYXRMbmdcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuc2NhbGUoem9vbSksXHJcblx0XHQgICAgdW50cmFuc2Zvcm1lZFBvaW50ID0gdGhpcy50cmFuc2Zvcm1hdGlvbi51bnRyYW5zZm9ybShwb2ludCwgc2NhbGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnByb2plY3Rpb24udW5wcm9qZWN0KHVudHJhbnNmb3JtZWRQb2ludCk7XHJcblx0fSxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyk7XHJcblx0fSxcclxuXHJcblx0c2NhbGU6IGZ1bmN0aW9uICh6b29tKSB7XHJcblx0XHRyZXR1cm4gMjU2ICogTWF0aC5wb3coMiwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2l6ZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBzID0gdGhpcy5zY2FsZSh6b29tKTtcclxuXHRcdHJldHVybiBMLnBvaW50KHMsIHMpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBBIHNpbXBsZSBDUlMgdGhhdCBjYW4gYmUgdXNlZCBmb3IgZmxhdCBub24tRWFydGggbWFwcyBsaWtlIHBhbm9yYW1hcyBvciBnYW1lIG1hcHMuXHJcbiAqL1xyXG5cclxuTC5DUlMuU2ltcGxlID0gTC5leHRlbmQoe30sIEwuQ1JTLCB7XHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLkxvbkxhdCxcclxuXHR0cmFuc2Zvcm1hdGlvbjogbmV3IEwuVHJhbnNmb3JtYXRpb24oMSwgMCwgLTEsIDApLFxyXG5cclxuXHRzY2FsZTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHJldHVybiBNYXRoLnBvdygyLCB6b29tKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuQ1JTLkVQU0czODU3IChTcGhlcmljYWwgTWVyY2F0b3IpIGlzIHRoZSBtb3N0IGNvbW1vbiBDUlMgZm9yIHdlYiBtYXBwaW5nXHJcbiAqIGFuZCBpcyB1c2VkIGJ5IExlYWZsZXQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHMzg1NyA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xyXG5cdGNvZGU6ICdFUFNHOjM4NTcnLFxyXG5cclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uU3BoZXJpY2FsTWVyY2F0b3IsXHJcblx0dHJhbnNmb3JtYXRpb246IG5ldyBMLlRyYW5zZm9ybWF0aW9uKDAuNSAvIE1hdGguUEksIDAuNSwgLTAuNSAvIE1hdGguUEksIDAuNSksXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcpIHsgLy8gKExhdExuZykgLT4gUG9pbnRcclxuXHRcdHZhciBwcm9qZWN0ZWRQb2ludCA9IHRoaXMucHJvamVjdGlvbi5wcm9qZWN0KGxhdGxuZyksXHJcblx0XHQgICAgZWFydGhSYWRpdXMgPSA2Mzc4MTM3O1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Lm11bHRpcGx5QnkoZWFydGhSYWRpdXMpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLkNSUy5FUFNHOTAwOTEzID0gTC5leHRlbmQoe30sIEwuQ1JTLkVQU0czODU3LCB7XHJcblx0Y29kZTogJ0VQU0c6OTAwOTEzJ1xyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkNSUy5FUFNHNDMyNiBpcyBhIENSUyBwb3B1bGFyIGFtb25nIGFkdmFuY2VkIEdJUyBzcGVjaWFsaXN0cy5cclxuICovXHJcblxyXG5MLkNSUy5FUFNHNDMyNiA9IEwuZXh0ZW5kKHt9LCBMLkNSUywge1xyXG5cdGNvZGU6ICdFUFNHOjQzMjYnLFxyXG5cclxuXHRwcm9qZWN0aW9uOiBMLlByb2plY3Rpb24uTG9uTGF0LFxyXG5cdHRyYW5zZm9ybWF0aW9uOiBuZXcgTC5UcmFuc2Zvcm1hdGlvbigxIC8gMzYwLCAwLjUsIC0xIC8gMzYwLCAwLjUpXHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuTWFwIGlzIHRoZSBjZW50cmFsIGNsYXNzIG9mIHRoZSBBUEkgLSBpdCBpcyB1c2VkIHRvIGNyZWF0ZSBhIG1hcC5cclxuICovXHJcblxyXG5MLk1hcCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRjcnM6IEwuQ1JTLkVQU0czODU3LFxyXG5cclxuXHRcdC8qXHJcblx0XHRjZW50ZXI6IExhdExuZyxcclxuXHRcdHpvb206IE51bWJlcixcclxuXHRcdGxheWVyczogQXJyYXksXHJcblx0XHQqL1xyXG5cclxuXHRcdGZhZGVBbmltYXRpb246IEwuRG9tVXRpbC5UUkFOU0lUSU9OICYmICFMLkJyb3dzZXIuYW5kcm9pZDIzLFxyXG5cdFx0dHJhY2tSZXNpemU6IHRydWUsXHJcblx0XHRtYXJrZXJab29tQW5pbWF0aW9uOiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJiBMLkJyb3dzZXIuYW55M2RcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHsgLy8gKEhUTUxFbGVtZW50IG9yIFN0cmluZywgT2JqZWN0KVxyXG5cdFx0b3B0aW9ucyA9IEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcihpZCk7XHJcblx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblxyXG5cdFx0Ly8gaGFjayBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTk4MFxyXG5cdFx0dGhpcy5fb25SZXNpemUgPSBMLmJpbmQodGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRFdmVudHMoKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0dGhpcy5zZXRNYXhCb3VuZHMob3B0aW9ucy5tYXhCb3VuZHMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmNlbnRlciAmJiBvcHRpb25zLnpvb20gIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHR0aGlzLnNldFZpZXcoTC5sYXRMbmcob3B0aW9ucy5jZW50ZXIpLCBvcHRpb25zLnpvb20sIHtyZXNldDogdHJ1ZX0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsZXJzID0gW107XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl96b29tQm91bmRMYXllcnMgPSB7fTtcclxuXHRcdHRoaXMuX3RpbGVMYXllcnNOdW0gPSAwO1xyXG5cclxuXHRcdHRoaXMuY2FsbEluaXRIb29rcygpO1xyXG5cclxuXHRcdHRoaXMuX2FkZExheWVycyhvcHRpb25zLmxheWVycyk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHB1YmxpYyBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHQvLyByZXBsYWNlZCBieSBhbmltYXRpb24tcG93ZXJlZCBpbXBsZW1lbnRhdGlvbiBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSkge1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuZ2V0Wm9vbSgpIDogem9vbTtcclxuXHRcdHRoaXMuX3Jlc2V0VmlldyhMLmxhdExuZyhjZW50ZXIpLCB0aGlzLl9saW1pdFpvb20oem9vbSkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0Wm9vbTogZnVuY3Rpb24gKHpvb20sIG9wdGlvbnMpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3pvb20gPSB0aGlzLl9saW1pdFpvb20oem9vbSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Vmlldyh0aGlzLmdldENlbnRlcigpLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdHpvb21JbjogZnVuY3Rpb24gKGRlbHRhLCBvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zZXRab29tKHRoaXMuX3pvb20gKyAoZGVsdGEgfHwgMSksIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdHpvb21PdXQ6IGZ1bmN0aW9uIChkZWx0YSwgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuc2V0Wm9vbSh0aGlzLl96b29tIC0gKGRlbHRhIHx8IDEpLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRzZXRab29tQXJvdW5kOiBmdW5jdGlvbiAobGF0bG5nLCB6b29tLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgc2NhbGUgPSB0aGlzLmdldFpvb21TY2FsZSh6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIGNvbnRhaW5lclBvaW50ID0gbGF0bG5nIGluc3RhbmNlb2YgTC5Qb2ludCA/IGxhdGxuZyA6IHRoaXMubGF0TG5nVG9Db250YWluZXJQb2ludChsYXRsbmcpLFxyXG5cclxuXHRcdCAgICBjZW50ZXJPZmZzZXQgPSBjb250YWluZXJQb2ludC5zdWJ0cmFjdCh2aWV3SGFsZikubXVsdGlwbHlCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdCAgICBuZXdDZW50ZXIgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXRMbmcodmlld0hhbGYuYWRkKGNlbnRlck9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcobmV3Q2VudGVyLCB6b29tLCB7em9vbTogb3B0aW9uc30pO1xyXG5cdH0sXHJcblxyXG5cdGZpdEJvdW5kczogZnVuY3Rpb24gKGJvdW5kcywgb3B0aW9ucykge1xyXG5cclxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xyXG5cdFx0Ym91bmRzID0gYm91bmRzLmdldEJvdW5kcyA/IGJvdW5kcy5nZXRCb3VuZHMoKSA6IEwubGF0TG5nQm91bmRzKGJvdW5kcyk7XHJcblxyXG5cdFx0dmFyIHBhZGRpbmdUTCA9IEwucG9pbnQob3B0aW9ucy5wYWRkaW5nVG9wTGVmdCB8fCBvcHRpb25zLnBhZGRpbmcgfHwgWzAsIDBdKSxcclxuXHRcdCAgICBwYWRkaW5nQlIgPSBMLnBvaW50KG9wdGlvbnMucGFkZGluZ0JvdHRvbVJpZ2h0IHx8IG9wdGlvbnMucGFkZGluZyB8fCBbMCwgMF0pLFxyXG5cclxuXHRcdCAgICB6b29tID0gdGhpcy5nZXRCb3VuZHNab29tKGJvdW5kcywgZmFsc2UsIHBhZGRpbmdUTC5hZGQocGFkZGluZ0JSKSksXHJcblx0XHQgICAgcGFkZGluZ09mZnNldCA9IHBhZGRpbmdCUi5zdWJ0cmFjdChwYWRkaW5nVEwpLmRpdmlkZUJ5KDIpLFxyXG5cclxuXHRcdCAgICBzd1BvaW50ID0gdGhpcy5wcm9qZWN0KGJvdW5kcy5nZXRTb3V0aFdlc3QoKSwgem9vbSksXHJcblx0XHQgICAgbmVQb2ludCA9IHRoaXMucHJvamVjdChib3VuZHMuZ2V0Tm9ydGhFYXN0KCksIHpvb20pLFxyXG5cdFx0ICAgIGNlbnRlciA9IHRoaXMudW5wcm9qZWN0KHN3UG9pbnQuYWRkKG5lUG9pbnQpLmRpdmlkZUJ5KDIpLmFkZChwYWRkaW5nT2Zmc2V0KSwgem9vbSk7XHJcblxyXG5cdFx0em9vbSA9IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhab29tID8gTWF0aC5taW4ob3B0aW9ucy5tYXhab29tLCB6b29tKSA6IHpvb207XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuc2V0VmlldyhjZW50ZXIsIHpvb20sIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGZpdFdvcmxkOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIHRoaXMuZml0Qm91bmRzKFtbLTkwLCAtMTgwXSwgWzkwLCAxODBdXSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0cGFuVG86IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHsgLy8gKExhdExuZylcclxuXHRcdHJldHVybiB0aGlzLnNldFZpZXcoY2VudGVyLCB0aGlzLl96b29tLCB7cGFuOiBvcHRpb25zfSk7XHJcblx0fSxcclxuXHJcblx0cGFuQnk6IGZ1bmN0aW9uIChvZmZzZXQpIHsgLy8gKFBvaW50KVxyXG5cdFx0Ly8gcmVwbGFjZWQgd2l0aCBhbmltYXRlZCBwYW5CeSBpbiBNYXAuUGFuQW5pbWF0aW9uLmpzXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cclxuXHRcdHRoaXMuX3Jhd1BhbkJ5KEwucG9pbnQob2Zmc2V0KSk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0fSxcclxuXHJcblx0c2V0TWF4Qm91bmRzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHRib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhib3VuZHMpO1xyXG5cclxuXHRcdHRoaXMub3B0aW9ucy5tYXhCb3VuZHMgPSBib3VuZHM7XHJcblxyXG5cdFx0aWYgKCFib3VuZHMpIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMub2ZmKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX3Bhbkluc2lkZU1heEJvdW5kcygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzLm9uKCdtb3ZlZW5kJywgdGhpcy5fcGFuSW5zaWRlTWF4Qm91bmRzLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRwYW5JbnNpZGVCb3VuZHM6IGZ1bmN0aW9uIChib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldENlbnRlcigpLFxyXG5cdFx0XHRuZXdDZW50ZXIgPSB0aGlzLl9saW1pdENlbnRlcihjZW50ZXIsIHRoaXMuX3pvb20sIGJvdW5kcyk7XHJcblxyXG5cdFx0aWYgKGNlbnRlci5lcXVhbHMobmV3Q2VudGVyKSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHJldHVybiB0aGlzLnBhblRvKG5ld0NlbnRlciwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0Ly8gVE9ETyBtZXRob2QgaXMgdG9vIGJpZywgcmVmYWN0b3JcclxuXHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbGF5ZXJzW2lkXSkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdHRoaXMuX2xheWVyc1tpZF0gPSBsYXllcjtcclxuXHJcblx0XHQvLyBUT0RPIGdldE1heFpvb20sIGdldE1pblpvb20gaW4gSUxheWVyIChpbnN0ZWFkIG9mIG9wdGlvbnMpXHJcblx0XHRpZiAobGF5ZXIub3B0aW9ucyAmJiAoIWlzTmFOKGxheWVyLm9wdGlvbnMubWF4Wm9vbSkgfHwgIWlzTmFOKGxheWVyLm9wdGlvbnMubWluWm9vbSkpKSB7XHJcblx0XHRcdHRoaXMuX3pvb21Cb3VuZExheWVyc1tpZF0gPSBsYXllcjtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gbG9va3MgdWdseSwgcmVmYWN0b3IhISFcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLlRpbGVMYXllciAmJiAobGF5ZXIgaW5zdGFuY2VvZiBMLlRpbGVMYXllcikpIHtcclxuXHRcdFx0dGhpcy5fdGlsZUxheWVyc051bSsrO1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkKys7XHJcblx0XHRcdGxheWVyLm9uKCdsb2FkJywgdGhpcy5fb25UaWxlTGF5ZXJMb2FkLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyQWRkKGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2xheWVyc1tpZF0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdGxheWVyLm9uUmVtb3ZlKHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXSkge1xyXG5cdFx0XHRkZWxldGUgdGhpcy5fem9vbUJvdW5kTGF5ZXJzW2lkXTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlWm9vbUxldmVscygpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRPRE8gbG9va3MgdWdseSwgcmVmYWN0b3JcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLlRpbGVMYXllciAmJiAobGF5ZXIgaW5zdGFuY2VvZiBMLlRpbGVMYXllcikpIHtcclxuXHRcdFx0dGhpcy5fdGlsZUxheWVyc051bS0tO1xyXG5cdFx0XHR0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkLS07XHJcblx0XHRcdGxheWVyLm9mZignbG9hZCcsIHRoaXMuX29uVGlsZUxheWVyTG9hZCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aGFzTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKCFsYXllcikgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRyZXR1cm4gKEwuc3RhbXAobGF5ZXIpIGluIHRoaXMuX2xheWVycyk7XHJcblx0fSxcclxuXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0aW52YWxpZGF0ZVNpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCkgeyByZXR1cm4gdGhpczsgfVxyXG5cclxuXHRcdG9wdGlvbnMgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGFuaW1hdGU6IGZhbHNlLFxyXG5cdFx0XHRwYW46IHRydWVcclxuXHRcdH0sIG9wdGlvbnMgPT09IHRydWUgPyB7YW5pbWF0ZTogdHJ1ZX0gOiBvcHRpb25zKTtcclxuXHJcblx0XHR2YXIgb2xkU2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpO1xyXG5cdFx0dGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xyXG5cdFx0dGhpcy5faW5pdGlhbENlbnRlciA9IG51bGw7XHJcblxyXG5cdFx0dmFyIG5ld1NpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBvbGRDZW50ZXIgPSBvbGRTaXplLmRpdmlkZUJ5KDIpLnJvdW5kKCksXHJcblx0XHQgICAgbmV3Q2VudGVyID0gbmV3U2l6ZS5kaXZpZGVCeSgyKS5yb3VuZCgpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG9sZENlbnRlci5zdWJ0cmFjdChuZXdDZW50ZXIpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAmJiBvcHRpb25zLnBhbikge1xyXG5cdFx0XHR0aGlzLnBhbkJ5KG9mZnNldCk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aWYgKG9wdGlvbnMucGFuKSB7XHJcblx0XHRcdFx0dGhpcy5fcmF3UGFuQnkob2Zmc2V0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblxyXG5cdFx0XHRpZiAob3B0aW9ucy5kZWJvdW5jZU1vdmVlbmQpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9zaXplVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLmZpcmUsIHRoaXMsICdtb3ZlZW5kJyksIDIwMCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5maXJlKCdtb3ZlZW5kJyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdyZXNpemUnLCB7XHJcblx0XHRcdG9sZFNpemU6IG9sZFNpemUsXHJcblx0XHRcdG5ld1NpemU6IG5ld1NpemVcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gaGFuZGxlci5hZGRUb1xyXG5cdGFkZEhhbmRsZXI6IGZ1bmN0aW9uIChuYW1lLCBIYW5kbGVyQ2xhc3MpIHtcclxuXHRcdGlmICghSGFuZGxlckNsYXNzKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSB0aGlzW25hbWVdID0gbmV3IEhhbmRsZXJDbGFzcyh0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9oYW5kbGVycy5wdXNoKGhhbmRsZXIpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnNbbmFtZV0pIHtcclxuXHRcdFx0aGFuZGxlci5lbmFibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd1bmxvYWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9pbml0RXZlbnRzKCdvZmYnKTtcclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHQvLyB0aHJvd3MgZXJyb3IgaW4gSUU2LThcclxuXHRcdFx0ZGVsZXRlIHRoaXMuX2NvbnRhaW5lci5fbGVhZmxldDtcclxuXHRcdH0gY2F0Y2ggKGUpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLl9sZWFmbGV0ID0gdW5kZWZpbmVkO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NsZWFyUGFuZXMoKTtcclxuXHRcdGlmICh0aGlzLl9jbGVhckNvbnRyb2xQb3MpIHtcclxuXHRcdFx0dGhpcy5fY2xlYXJDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY2xlYXJIYW5kbGVycygpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cclxuXHQvLyBwdWJsaWMgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0Z2V0Q2VudGVyOiBmdW5jdGlvbiAoKSB7IC8vIChCb29sZWFuKSAtPiBMYXRMbmdcclxuXHRcdHRoaXMuX2NoZWNrSWZMb2FkZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5faW5pdGlhbENlbnRlciAmJiAhdGhpcy5fbW92ZWQoKSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbENlbnRlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFpvb206IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tO1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICBzdyA9IHRoaXMudW5wcm9qZWN0KGJvdW5kcy5nZXRCb3R0b21MZWZ0KCkpLFxyXG5cdFx0ICAgIG5lID0gdGhpcy51bnByb2plY3QoYm91bmRzLmdldFRvcFJpZ2h0KCkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoc3csIG5lKTtcclxuXHR9LFxyXG5cclxuXHRnZXRNaW5ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1pblpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNaW5ab29tID09PSB1bmRlZmluZWQgPyAwIDogdGhpcy5fbGF5ZXJzTWluWm9vbSkgOlxyXG5cdFx0XHR0aGlzLm9wdGlvbnMubWluWm9vbTtcclxuXHR9LFxyXG5cclxuXHRnZXRNYXhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLm1heFpvb20gPT09IHVuZGVmaW5lZCA/XHJcblx0XHRcdCh0aGlzLl9sYXllcnNNYXhab29tID09PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRoaXMuX2xheWVyc01heFpvb20pIDpcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb207XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzWm9vbTogZnVuY3Rpb24gKGJvdW5kcywgaW5zaWRlLCBwYWRkaW5nKSB7IC8vIChMYXRMbmdCb3VuZHNbLCBCb29sZWFuLCBQb2ludF0pIC0+IE51bWJlclxyXG5cdFx0Ym91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHR2YXIgem9vbSA9IHRoaXMuZ2V0TWluWm9vbSgpIC0gKGluc2lkZSA/IDEgOiAwKSxcclxuXHRcdCAgICBtYXhab29tID0gdGhpcy5nZXRNYXhab29tKCksXHJcblx0XHQgICAgc2l6ZSA9IHRoaXMuZ2V0U2l6ZSgpLFxyXG5cclxuXHRcdCAgICBudyA9IGJvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdCAgICBzZSA9IGJvdW5kcy5nZXRTb3V0aEVhc3QoKSxcclxuXHJcblx0XHQgICAgem9vbU5vdEZvdW5kID0gdHJ1ZSxcclxuXHRcdCAgICBib3VuZHNTaXplO1xyXG5cclxuXHRcdHBhZGRpbmcgPSBMLnBvaW50KHBhZGRpbmcgfHwgWzAsIDBdKTtcclxuXHJcblx0XHRkbyB7XHJcblx0XHRcdHpvb20rKztcclxuXHRcdFx0Ym91bmRzU2l6ZSA9IHRoaXMucHJvamVjdChzZSwgem9vbSkuc3VidHJhY3QodGhpcy5wcm9qZWN0KG53LCB6b29tKSkuYWRkKHBhZGRpbmcpO1xyXG5cdFx0XHR6b29tTm90Rm91bmQgPSAhaW5zaWRlID8gc2l6ZS5jb250YWlucyhib3VuZHNTaXplKSA6IGJvdW5kc1NpemUueCA8IHNpemUueCB8fCBib3VuZHNTaXplLnkgPCBzaXplLnk7XHJcblxyXG5cdFx0fSB3aGlsZSAoem9vbU5vdEZvdW5kICYmIHpvb20gPD0gbWF4Wm9vbSk7XHJcblxyXG5cdFx0aWYgKHpvb21Ob3RGb3VuZCAmJiBpbnNpZGUpIHtcclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGluc2lkZSA/IHpvb20gOiB6b29tIC0gMTtcclxuXHR9LFxyXG5cclxuXHRnZXRTaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3NpemUgfHwgdGhpcy5fc2l6ZUNoYW5nZWQpIHtcclxuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBMLlBvaW50KFxyXG5cdFx0XHRcdHRoaXMuX2NvbnRhaW5lci5jbGllbnRXaWR0aCxcclxuXHRcdFx0XHR0aGlzLl9jb250YWluZXIuY2xpZW50SGVpZ2h0KTtcclxuXHJcblx0XHRcdHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZS5jbG9uZSgpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsQm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdG9wTGVmdFBvaW50ID0gdGhpcy5fZ2V0VG9wTGVmdFBvaW50KCk7XHJcblx0XHRyZXR1cm4gbmV3IEwuQm91bmRzKHRvcExlZnRQb2ludCwgdG9wTGVmdFBvaW50LmFkZCh0aGlzLmdldFNpemUoKSkpO1xyXG5cdH0sXHJcblxyXG5cdGdldFBpeGVsT3JpZ2luOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jaGVja0lmTG9hZGVkKCk7XHJcblx0XHRyZXR1cm4gdGhpcy5faW5pdGlhbFRvcExlZnRQb2ludDtcclxuXHR9LFxyXG5cclxuXHRnZXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BhbmVzO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gVE9ETyByZXBsYWNlIHdpdGggdW5pdmVyc2FsIGltcGxlbWVudGF0aW9uIGFmdGVyIHJlZmFjdG9yaW5nIHByb2plY3Rpb25zXHJcblxyXG5cdGdldFpvb21TY2FsZTogZnVuY3Rpb24gKHRvWm9vbSkge1xyXG5cdFx0dmFyIGNycyA9IHRoaXMub3B0aW9ucy5jcnM7XHJcblx0XHRyZXR1cm4gY3JzLnNjYWxlKHRvWm9vbSkgLyBjcnMuc2NhbGUodGhpcy5fem9vbSk7XHJcblx0fSxcclxuXHJcblx0Z2V0U2NhbGVab29tOiBmdW5jdGlvbiAoc2NhbGUpIHtcclxuXHRcdHJldHVybiB0aGlzLl96b29tICsgKE1hdGgubG9nKHNjYWxlKSAvIE1hdGguTE4yKTtcclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gY29udmVyc2lvbiBtZXRob2RzXHJcblxyXG5cdHByb2plY3Q6IGZ1bmN0aW9uIChsYXRsbmcsIHpvb20pIHsgLy8gKExhdExuZ1ssIE51bWJlcl0pIC0+IFBvaW50XHJcblx0XHR6b29tID0gem9vbSA9PT0gdW5kZWZpbmVkID8gdGhpcy5fem9vbSA6IHpvb207XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmNycy5sYXRMbmdUb1BvaW50KEwubGF0TG5nKGxhdGxuZyksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50LCB6b29tKSB7IC8vIChQb2ludFssIE51bWJlcl0pIC0+IExhdExuZ1xyXG5cdFx0em9vbSA9IHpvb20gPT09IHVuZGVmaW5lZCA/IHRoaXMuX3pvb20gOiB6b29tO1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5jcnMucG9pbnRUb0xhdExuZyhMLnBvaW50KHBvaW50KSwgem9vbSk7XHJcblx0fSxcclxuXHJcblx0bGF5ZXJQb2ludFRvTGF0TG5nOiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuZ2V0UGl4ZWxPcmlnaW4oKSk7XHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QocHJvamVjdGVkUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKVxyXG5cdFx0dmFyIHByb2plY3RlZFBvaW50ID0gdGhpcy5wcm9qZWN0KEwubGF0TG5nKGxhdGxuZykpLl9yb3VuZCgpO1xyXG5cdFx0cmV0dXJuIHByb2plY3RlZFBvaW50Ll9zdWJ0cmFjdCh0aGlzLmdldFBpeGVsT3JpZ2luKCkpO1xyXG5cdH0sXHJcblxyXG5cdGNvbnRhaW5lclBvaW50VG9MYXllclBvaW50OiBmdW5jdGlvbiAocG9pbnQpIHsgLy8gKFBvaW50KVxyXG5cdFx0cmV0dXJuIEwucG9pbnQocG9pbnQpLnN1YnRyYWN0KHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0bGF5ZXJQb2ludFRvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChwb2ludCkgeyAvLyAoUG9pbnQpXHJcblx0XHRyZXR1cm4gTC5wb2ludChwb2ludCkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0fSxcclxuXHJcblx0Y29udGFpbmVyUG9pbnRUb0xhdExuZzogZnVuY3Rpb24gKHBvaW50KSB7XHJcblx0XHR2YXIgbGF5ZXJQb2ludCA9IHRoaXMuY29udGFpbmVyUG9pbnRUb0xheWVyUG9pbnQoTC5wb2ludChwb2ludCkpO1xyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKGxheWVyUG9pbnQpO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvQ29udGFpbmVyUG9pbnQ6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHJldHVybiB0aGlzLmxheWVyUG9pbnRUb0NvbnRhaW5lclBvaW50KHRoaXMubGF0TG5nVG9MYXllclBvaW50KEwubGF0TG5nKGxhdGxuZykpKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9Db250YWluZXJQb2ludDogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gTC5Eb21FdmVudC5nZXRNb3VzZVBvc2l0aW9uKGUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0bW91c2VFdmVudFRvTGF5ZXJQb2ludDogZnVuY3Rpb24gKGUpIHsgLy8gKE1vdXNlRXZlbnQpXHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpKTtcclxuXHR9LFxyXG5cclxuXHRtb3VzZUV2ZW50VG9MYXRMbmc6IGZ1bmN0aW9uIChlKSB7IC8vIChNb3VzZUV2ZW50KVxyXG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIG1hcCBpbml0aWFsaXphdGlvbiBtZXRob2RzXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoaWQpIHtcclxuXHRcdHZhciBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuZ2V0KGlkKTtcclxuXHJcblx0XHRpZiAoIWNvbnRhaW5lcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ01hcCBjb250YWluZXIgbm90IGZvdW5kLicpO1xyXG5cdFx0fSBlbHNlIGlmIChjb250YWluZXIuX2xlYWZsZXQpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdNYXAgY29udGFpbmVyIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGFpbmVyLl9sZWFmbGV0ID0gdHJ1ZTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoY29udGFpbmVyLCAnbGVhZmxldC1jb250YWluZXInICtcclxuXHRcdFx0KEwuQnJvd3Nlci50b3VjaCA/ICcgbGVhZmxldC10b3VjaCcgOiAnJykgK1xyXG5cdFx0XHQoTC5Ccm93c2VyLnJldGluYSA/ICcgbGVhZmxldC1yZXRpbmEnIDogJycpICtcclxuXHRcdFx0KEwuQnJvd3Nlci5pZWx0OSA/ICcgbGVhZmxldC1vbGRpZScgOiAnJykgK1xyXG5cdFx0XHQodGhpcy5vcHRpb25zLmZhZGVBbmltYXRpb24gPyAnIGxlYWZsZXQtZmFkZS1hbmltJyA6ICcnKSk7XHJcblxyXG5cdFx0dmFyIHBvc2l0aW9uID0gTC5Eb21VdGlsLmdldFN0eWxlKGNvbnRhaW5lciwgJ3Bvc2l0aW9uJyk7XHJcblxyXG5cdFx0aWYgKHBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHBvc2l0aW9uICE9PSAncmVsYXRpdmUnICYmIHBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XHJcblx0XHRcdGNvbnRhaW5lci5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdFBhbmVzKCk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2luaXRDb250cm9sUG9zKSB7XHJcblx0XHRcdHRoaXMuX2luaXRDb250cm9sUG9zKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRQYW5lczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhbmVzID0gdGhpcy5fcGFuZXMgPSB7fTtcclxuXHJcblx0XHR0aGlzLl9tYXBQYW5lID0gcGFuZXMubWFwUGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtbWFwLXBhbmUnLCB0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdHRoaXMuX3RpbGVQYW5lID0gcGFuZXMudGlsZVBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LXRpbGUtcGFuZScsIHRoaXMuX21hcFBhbmUpO1xyXG5cdFx0cGFuZXMub2JqZWN0c1BhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LW9iamVjdHMtcGFuZScsIHRoaXMuX21hcFBhbmUpO1xyXG5cdFx0cGFuZXMuc2hhZG93UGFuZSA9IHRoaXMuX2NyZWF0ZVBhbmUoJ2xlYWZsZXQtc2hhZG93LXBhbmUnKTtcclxuXHRcdHBhbmVzLm92ZXJsYXlQYW5lID0gdGhpcy5fY3JlYXRlUGFuZSgnbGVhZmxldC1vdmVybGF5LXBhbmUnKTtcclxuXHRcdHBhbmVzLm1hcmtlclBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LW1hcmtlci1wYW5lJyk7XHJcblx0XHRwYW5lcy5wb3B1cFBhbmUgPSB0aGlzLl9jcmVhdGVQYW5lKCdsZWFmbGV0LXBvcHVwLXBhbmUnKTtcclxuXHJcblx0XHR2YXIgem9vbUhpZGUgPSAnIGxlYWZsZXQtem9vbS1oaWRlJztcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5tYXJrZXJQYW5lLCB6b29tSGlkZSk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5zaGFkb3dQYW5lLCB6b29tSGlkZSk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhwYW5lcy5wb3B1cFBhbmUsIHpvb21IaWRlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlUGFuZTogZnVuY3Rpb24gKGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHRyZXR1cm4gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIgfHwgdGhpcy5fcGFuZXMub2JqZWN0c1BhbmUpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhclBhbmVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5fbWFwUGFuZSk7XHJcblx0fSxcclxuXHJcblx0X2FkZExheWVyczogZnVuY3Rpb24gKGxheWVycykge1xyXG5cdFx0bGF5ZXJzID0gbGF5ZXJzID8gKEwuVXRpbC5pc0FycmF5KGxheWVycykgPyBsYXllcnMgOiBbbGF5ZXJzXSkgOiBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuYWRkTGF5ZXIobGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHJcblx0Ly8gcHJpdmF0ZSBtZXRob2RzIHRoYXQgbW9kaWZ5IG1hcCBzdGF0ZVxyXG5cclxuXHRfcmVzZXRWaWV3OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBwcmVzZXJ2ZU1hcE9mZnNldCwgYWZ0ZXJab29tQW5pbSkge1xyXG5cclxuXHRcdHZhciB6b29tQ2hhbmdlZCA9ICh0aGlzLl96b29tICE9PSB6b29tKTtcclxuXHJcblx0XHRpZiAoIWFmdGVyWm9vbUFuaW0pIHtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3Zlc3RhcnQnKTtcclxuXHJcblx0XHRcdGlmICh6b29tQ2hhbmdlZCkge1xyXG5cdFx0XHRcdHRoaXMuZmlyZSgnem9vbXN0YXJ0Jyk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96b29tID0gem9vbTtcclxuXHRcdHRoaXMuX2luaXRpYWxDZW50ZXIgPSBjZW50ZXI7XHJcblxyXG5cdFx0dGhpcy5faW5pdGlhbFRvcExlZnRQb2ludCA9IHRoaXMuX2dldE5ld1RvcExlZnRQb2ludChjZW50ZXIpO1xyXG5cclxuXHRcdGlmICghcHJlc2VydmVNYXBPZmZzZXQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUsIG5ldyBMLlBvaW50KDAsIDApKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2luaXRpYWxUb3BMZWZ0UG9pbnQuX2FkZCh0aGlzLl9nZXRNYXBQYW5lUG9zKCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RpbGVMYXllcnNUb0xvYWQgPSB0aGlzLl90aWxlTGF5ZXJzTnVtO1xyXG5cclxuXHRcdHZhciBsb2FkaW5nID0gIXRoaXMuX2xvYWRlZDtcclxuXHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XHJcblxyXG5cdFx0aWYgKGxvYWRpbmcpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkJyk7XHJcblx0XHRcdHRoaXMuZWFjaExheWVyKHRoaXMuX2xheWVyQWRkLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ZpZXdyZXNldCcsIHtoYXJkOiAhcHJlc2VydmVNYXBPZmZzZXR9KTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmUnKTtcclxuXHJcblx0XHRpZiAoem9vbUNoYW5nZWQgfHwgYWZ0ZXJab29tQW5pbSkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3pvb21lbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnLCB7aGFyZDogIXByZXNlcnZlTWFwT2Zmc2V0fSk7XHJcblx0fSxcclxuXHJcblx0X3Jhd1BhbkJ5OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSwgdGhpcy5fZ2V0TWFwUGFuZVBvcygpLnN1YnRyYWN0KG9mZnNldCkpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRab29tU3BhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZ2V0TWF4Wm9vbSgpIC0gdGhpcy5nZXRNaW5ab29tKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpvb21MZXZlbHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBpLFxyXG5cdFx0XHRtaW5ab29tID0gSW5maW5pdHksXHJcblx0XHRcdG1heFpvb20gPSAtSW5maW5pdHksXHJcblx0XHRcdG9sZFpvb21TcGFuID0gdGhpcy5fZ2V0Wm9vbVNwYW4oKTtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fem9vbUJvdW5kTGF5ZXJzKSB7XHJcblx0XHRcdHZhciBsYXllciA9IHRoaXMuX3pvb21Cb3VuZExheWVyc1tpXTtcclxuXHRcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1pblpvb20pKSB7XHJcblx0XHRcdFx0bWluWm9vbSA9IE1hdGgubWluKG1pblpvb20sIGxheWVyLm9wdGlvbnMubWluWm9vbSk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKCFpc05hTihsYXllci5vcHRpb25zLm1heFpvb20pKSB7XHJcblx0XHRcdFx0bWF4Wm9vbSA9IE1hdGgubWF4KG1heFpvb20sIGxheWVyLm9wdGlvbnMubWF4Wm9vbSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAoaSA9PT0gdW5kZWZpbmVkKSB7IC8vIHdlIGhhdmUgbm8gdGlsZWxheWVyc1xyXG5cdFx0XHR0aGlzLl9sYXllcnNNYXhab29tID0gdGhpcy5fbGF5ZXJzTWluWm9vbSA9IHVuZGVmaW5lZDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc01heFpvb20gPSBtYXhab29tO1xyXG5cdFx0XHR0aGlzLl9sYXllcnNNaW5ab29tID0gbWluWm9vbTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob2xkWm9vbVNwYW4gIT09IHRoaXMuX2dldFpvb21TcGFuKCkpIHtcclxuXHRcdFx0dGhpcy5maXJlKCd6b29tbGV2ZWxzY2hhbmdlJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3Bhbkluc2lkZU1heEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5wYW5JbnNpZGVCb3VuZHModGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0fSxcclxuXHJcblx0X2NoZWNrSWZMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcignU2V0IG1hcCBjZW50ZXIgYW5kIHpvb20gZmlyc3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gbWFwIGV2ZW50c1xyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKG9uT2ZmKSB7XHJcblx0XHRpZiAoIUwuRG9tRXZlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0b25PZmYgPSBvbk9mZiB8fCAnb24nO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRbb25PZmZdKHRoaXMuX2NvbnRhaW5lciwgJ2NsaWNrJywgdGhpcy5fb25Nb3VzZUNsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgZXZlbnRzID0gWydkYmxjbGljaycsICdtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZWVudGVyJyxcclxuXHRcdCAgICAgICAgICAgICAgJ21vdXNlbGVhdmUnLCAnbW91c2Vtb3ZlJywgJ2NvbnRleHRtZW51J10sXHJcblx0XHQgICAgaSwgbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGV2ZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRMLkRvbUV2ZW50W29uT2ZmXSh0aGlzLl9jb250YWluZXIsIGV2ZW50c1tpXSwgdGhpcy5fZmlyZU1vdXNlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudHJhY2tSZXNpemUpIHtcclxuXHRcdFx0TC5Eb21FdmVudFtvbk9mZl0od2luZG93LCAncmVzaXplJywgdGhpcy5fb25SZXNpemUsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vblJlc2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9yZXNpemVSZXF1ZXN0KTtcclxuXHRcdHRoaXMuX3Jlc2l6ZVJlcXVlc3QgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZShcclxuXHRcdCAgICAgICAgZnVuY3Rpb24gKCkgeyB0aGlzLmludmFsaWRhdGVTaXplKHtkZWJvdW5jZU1vdmVlbmQ6IHRydWV9KTsgfSwgdGhpcywgZmFsc2UsIHRoaXMuX2NvbnRhaW5lcik7XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VDbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5fbG9hZGVkIHx8ICghZS5fc2ltdWxhdGVkICYmXHJcblx0XHQgICAgICAgICgodGhpcy5kcmFnZ2luZyAmJiB0aGlzLmRyYWdnaW5nLm1vdmVkKCkpIHx8XHJcblx0XHQgICAgICAgICAodGhpcy5ib3hab29tICAmJiB0aGlzLmJveFpvb20ubW92ZWQoKSkpKSB8fFxyXG5cdFx0ICAgICAgICAgICAgTC5Eb21FdmVudC5fc2tpcHBlZChlKSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR0aGlzLmZpcmUoJ3ByZWNsaWNrJyk7XHJcblx0XHR0aGlzLl9maXJlTW91c2VFdmVudChlKTtcclxuXHR9LFxyXG5cclxuXHRfZmlyZU1vdXNlRXZlbnQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2xvYWRlZCB8fCBMLkRvbUV2ZW50Ll9za2lwcGVkKGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciB0eXBlID0gZS50eXBlO1xyXG5cclxuXHRcdHR5cGUgPSAodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAodHlwZSA9PT0gJ21vdXNlbGVhdmUnID8gJ21vdXNlb3V0JyA6IHR5cGUpKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuaGFzRXZlbnRMaXN0ZW5lcnModHlwZSkpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY29udGFpbmVyUG9pbnQgPSB0aGlzLm1vdXNlRXZlbnRUb0NvbnRhaW5lclBvaW50KGUpLFxyXG5cdFx0ICAgIGxheWVyUG9pbnQgPSB0aGlzLmNvbnRhaW5lclBvaW50VG9MYXllclBvaW50KGNvbnRhaW5lclBvaW50KSxcclxuXHRcdCAgICBsYXRsbmcgPSB0aGlzLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHJcblx0XHR0aGlzLmZpcmUodHlwZSwge1xyXG5cdFx0XHRsYXRsbmc6IGxhdGxuZyxcclxuXHRcdFx0bGF5ZXJQb2ludDogbGF5ZXJQb2ludCxcclxuXHRcdFx0Y29udGFpbmVyUG9pbnQ6IGNvbnRhaW5lclBvaW50LFxyXG5cdFx0XHRvcmlnaW5hbEV2ZW50OiBlXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfb25UaWxlTGF5ZXJMb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl90aWxlTGF5ZXJzVG9Mb2FkLS07XHJcblx0XHRpZiAodGhpcy5fdGlsZUxheWVyc051bSAmJiAhdGhpcy5fdGlsZUxheWVyc1RvTG9hZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ3RpbGVsYXllcnNsb2FkJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NsZWFySGFuZGxlcnM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9oYW5kbGVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVyc1tpXS5kaXNhYmxlKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0d2hlblJlYWR5OiBmdW5jdGlvbiAoY2FsbGJhY2ssIGNvbnRleHQpIHtcclxuXHRcdGlmICh0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2suY2FsbChjb250ZXh0IHx8IHRoaXMsIHRoaXMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5vbignbG9hZCcsIGNhbGxiYWNrLCBjb250ZXh0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9sYXllckFkZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRsYXllci5vbkFkZCh0aGlzKTtcclxuXHRcdHRoaXMuZmlyZSgnbGF5ZXJhZGQnLCB7bGF5ZXI6IGxheWVyfSk7XHJcblx0fSxcclxuXHJcblxyXG5cdC8vIHByaXZhdGUgbWV0aG9kcyBmb3IgZ2V0dGluZyBtYXAgc3RhdGVcclxuXHJcblx0X2dldE1hcFBhbmVQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fbWFwUGFuZSk7XHJcblx0fSxcclxuXHJcblx0X21vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fZ2V0TWFwUGFuZVBvcygpO1xyXG5cdFx0cmV0dXJuIHBvcyAmJiAhcG9zLmVxdWFscyhbMCwgMF0pO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUb3BMZWZ0UG9pbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmdldFBpeGVsT3JpZ2luKCkuc3VidHJhY3QodGhpcy5fZ2V0TWFwUGFuZVBvcygpKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TmV3VG9wTGVmdFBvaW50OiBmdW5jdGlvbiAoY2VudGVyLCB6b29tKSB7XHJcblx0XHR2YXIgdmlld0hhbGYgPSB0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMik7XHJcblx0XHQvLyBUT0RPIHJvdW5kIG9uIGRpc3BsYXksIG5vdCBjYWxjdWxhdGlvbiB0byBpbmNyZWFzZSBwcmVjaXNpb24/XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGNlbnRlciwgem9vbSkuX3N1YnRyYWN0KHZpZXdIYWxmKS5fcm91bmQoKTtcclxuXHR9LFxyXG5cclxuXHRfbGF0TG5nVG9OZXdMYXllclBvaW50OiBmdW5jdGlvbiAobGF0bG5nLCBuZXdab29tLCBuZXdDZW50ZXIpIHtcclxuXHRcdHZhciB0b3BMZWZ0ID0gdGhpcy5fZ2V0TmV3VG9wTGVmdFBvaW50KG5ld0NlbnRlciwgbmV3Wm9vbSkuYWRkKHRoaXMuX2dldE1hcFBhbmVQb3MoKSk7XHJcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0KGxhdGxuZywgbmV3Wm9vbSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGxheWVyIHBvaW50IG9mIHRoZSBjdXJyZW50IGNlbnRlclxyXG5cdF9nZXRDZW50ZXJMYXllclBvaW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludCh0aGlzLmdldFNpemUoKS5fZGl2aWRlQnkoMikpO1xyXG5cdH0sXHJcblxyXG5cdC8vIG9mZnNldCBvZiB0aGUgc3BlY2lmaWVkIHBsYWNlIHRvIHRoZSBjdXJyZW50IGNlbnRlciBpbiBwaXhlbHNcclxuXHRfZ2V0Q2VudGVyT2Zmc2V0OiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKS5zdWJ0cmFjdCh0aGlzLl9nZXRDZW50ZXJMYXllclBvaW50KCkpO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBjZW50ZXIgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRDZW50ZXI6IGZ1bmN0aW9uIChjZW50ZXIsIHpvb20sIGJvdW5kcykge1xyXG5cclxuXHRcdGlmICghYm91bmRzKSB7IHJldHVybiBjZW50ZXI7IH1cclxuXHJcblx0XHR2YXIgY2VudGVyUG9pbnQgPSB0aGlzLnByb2plY3QoY2VudGVyLCB6b29tKSxcclxuXHRcdCAgICB2aWV3SGFsZiA9IHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHZpZXdCb3VuZHMgPSBuZXcgTC5Cb3VuZHMoY2VudGVyUG9pbnQuc3VidHJhY3Qodmlld0hhbGYpLCBjZW50ZXJQb2ludC5hZGQodmlld0hhbGYpKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRCb3VuZHNPZmZzZXQodmlld0JvdW5kcywgYm91bmRzLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy51bnByb2plY3QoY2VudGVyUG9pbnQuYWRkKG9mZnNldCksIHpvb20pO1xyXG5cdH0sXHJcblxyXG5cdC8vIGFkanVzdCBvZmZzZXQgZm9yIHZpZXcgdG8gZ2V0IGluc2lkZSBib3VuZHNcclxuXHRfbGltaXRPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQsIGJvdW5kcykge1xyXG5cdFx0aWYgKCFib3VuZHMpIHsgcmV0dXJuIG9mZnNldDsgfVxyXG5cclxuXHRcdHZhciB2aWV3Qm91bmRzID0gdGhpcy5nZXRQaXhlbEJvdW5kcygpLFxyXG5cdFx0ICAgIG5ld0JvdW5kcyA9IG5ldyBMLkJvdW5kcyh2aWV3Qm91bmRzLm1pbi5hZGQob2Zmc2V0KSwgdmlld0JvdW5kcy5tYXguYWRkKG9mZnNldCkpO1xyXG5cclxuXHRcdHJldHVybiBvZmZzZXQuYWRkKHRoaXMuX2dldEJvdW5kc09mZnNldChuZXdCb3VuZHMsIGJvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHJldHVybnMgb2Zmc2V0IG5lZWRlZCBmb3IgcHhCb3VuZHMgdG8gZ2V0IGluc2lkZSBtYXhCb3VuZHMgYXQgYSBzcGVjaWZpZWQgem9vbVxyXG5cdF9nZXRCb3VuZHNPZmZzZXQ6IGZ1bmN0aW9uIChweEJvdW5kcywgbWF4Qm91bmRzLCB6b29tKSB7XHJcblx0XHR2YXIgbndPZmZzZXQgPSB0aGlzLnByb2plY3QobWF4Qm91bmRzLmdldE5vcnRoV2VzdCgpLCB6b29tKS5zdWJ0cmFjdChweEJvdW5kcy5taW4pLFxyXG5cdFx0ICAgIHNlT2Zmc2V0ID0gdGhpcy5wcm9qZWN0KG1heEJvdW5kcy5nZXRTb3V0aEVhc3QoKSwgem9vbSkuc3VidHJhY3QocHhCb3VuZHMubWF4KSxcclxuXHJcblx0XHQgICAgZHggPSB0aGlzLl9yZWJvdW5kKG53T2Zmc2V0LngsIC1zZU9mZnNldC54KSxcclxuXHRcdCAgICBkeSA9IHRoaXMuX3JlYm91bmQobndPZmZzZXQueSwgLXNlT2Zmc2V0LnkpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5Qb2ludChkeCwgZHkpO1xyXG5cdH0sXHJcblxyXG5cdF9yZWJvdW5kOiBmdW5jdGlvbiAobGVmdCwgcmlnaHQpIHtcclxuXHRcdHJldHVybiBsZWZ0ICsgcmlnaHQgPiAwID9cclxuXHRcdFx0TWF0aC5yb3VuZChsZWZ0IC0gcmlnaHQpIC8gMiA6XHJcblx0XHRcdE1hdGgubWF4KDAsIE1hdGguY2VpbChsZWZ0KSkgLSBNYXRoLm1heCgwLCBNYXRoLmZsb29yKHJpZ2h0KSk7XHJcblx0fSxcclxuXHJcblx0X2xpbWl0Wm9vbTogZnVuY3Rpb24gKHpvb20pIHtcclxuXHRcdHZhciBtaW4gPSB0aGlzLmdldE1pblpvb20oKSxcclxuXHRcdCAgICBtYXggPSB0aGlzLmdldE1heFpvb20oKTtcclxuXHJcblx0XHRyZXR1cm4gTWF0aC5tYXgobWluLCBNYXRoLm1pbihtYXgsIHpvb20pKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5tYXAgPSBmdW5jdGlvbiAoaWQsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFwKGlkLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBNZXJjYXRvciBwcm9qZWN0aW9uIHRoYXQgdGFrZXMgaW50byBhY2NvdW50IHRoYXQgdGhlIEVhcnRoIGlzIG5vdCBhIHBlcmZlY3Qgc3BoZXJlLlxyXG4gKiBMZXNzIHBvcHVsYXIgdGhhbiBzcGhlcmljYWwgbWVyY2F0b3I7IHVzZWQgYnkgcHJvamVjdGlvbnMgbGlrZSBFUFNHOjMzOTUuXHJcbiAqL1xyXG5cclxuTC5Qcm9qZWN0aW9uLk1lcmNhdG9yID0ge1xyXG5cdE1BWF9MQVRJVFVERTogODUuMDg0MDU5MTU1NixcclxuXHJcblx0Ul9NSU5PUjogNjM1Njc1Mi4zMTQyNDUxNzksXHJcblx0Ul9NQUpPUjogNjM3ODEzNyxcclxuXHJcblx0cHJvamVjdDogZnVuY3Rpb24gKGxhdGxuZykgeyAvLyAoTGF0TG5nKSAtPiBQb2ludFxyXG5cdFx0dmFyIGQgPSBMLkxhdExuZy5ERUdfVE9fUkFELFxyXG5cdFx0ICAgIG1heCA9IHRoaXMuTUFYX0xBVElUVURFLFxyXG5cdFx0ICAgIGxhdCA9IE1hdGgubWF4KE1hdGgubWluKG1heCwgbGF0bG5nLmxhdCksIC1tYXgpLFxyXG5cdFx0ICAgIHIgPSB0aGlzLlJfTUFKT1IsXHJcblx0XHQgICAgcjIgPSB0aGlzLlJfTUlOT1IsXHJcblx0XHQgICAgeCA9IGxhdGxuZy5sbmcgKiBkICogcixcclxuXHRcdCAgICB5ID0gbGF0ICogZCxcclxuXHRcdCAgICB0bXAgPSByMiAvIHIsXHJcblx0XHQgICAgZWNjZW50ID0gTWF0aC5zcXJ0KDEuMCAtIHRtcCAqIHRtcCksXHJcblx0XHQgICAgY29uID0gZWNjZW50ICogTWF0aC5zaW4oeSk7XHJcblxyXG5cdFx0Y29uID0gTWF0aC5wb3coKDEgLSBjb24pIC8gKDEgKyBjb24pLCBlY2NlbnQgKiAwLjUpO1xyXG5cclxuXHRcdHZhciB0cyA9IE1hdGgudGFuKDAuNSAqICgoTWF0aC5QSSAqIDAuNSkgLSB5KSkgLyBjb247XHJcblx0XHR5ID0gLXIgKiBNYXRoLmxvZyh0cyk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH0sXHJcblxyXG5cdHVucHJvamVjdDogZnVuY3Rpb24gKHBvaW50KSB7IC8vIChQb2ludCwgQm9vbGVhbikgLT4gTGF0TG5nXHJcblx0XHR2YXIgZCA9IEwuTGF0TG5nLlJBRF9UT19ERUcsXHJcblx0XHQgICAgciA9IHRoaXMuUl9NQUpPUixcclxuXHRcdCAgICByMiA9IHRoaXMuUl9NSU5PUixcclxuXHRcdCAgICBsbmcgPSBwb2ludC54ICogZCAvIHIsXHJcblx0XHQgICAgdG1wID0gcjIgLyByLFxyXG5cdFx0ICAgIGVjY2VudCA9IE1hdGguc3FydCgxIC0gKHRtcCAqIHRtcCkpLFxyXG5cdFx0ICAgIHRzID0gTWF0aC5leHAoLSBwb2ludC55IC8gciksXHJcblx0XHQgICAgcGhpID0gKE1hdGguUEkgLyAyKSAtIDIgKiBNYXRoLmF0YW4odHMpLFxyXG5cdFx0ICAgIG51bUl0ZXIgPSAxNSxcclxuXHRcdCAgICB0b2wgPSAxZS03LFxyXG5cdFx0ICAgIGkgPSBudW1JdGVyLFxyXG5cdFx0ICAgIGRwaGkgPSAwLjEsXHJcblx0XHQgICAgY29uO1xyXG5cclxuXHRcdHdoaWxlICgoTWF0aC5hYnMoZHBoaSkgPiB0b2wpICYmICgtLWkgPiAwKSkge1xyXG5cdFx0XHRjb24gPSBlY2NlbnQgKiBNYXRoLnNpbihwaGkpO1xyXG5cdFx0XHRkcGhpID0gKE1hdGguUEkgLyAyKSAtIDIgKiBNYXRoLmF0YW4odHMgKlxyXG5cdFx0XHQgICAgICAgICAgICBNYXRoLnBvdygoMS4wIC0gY29uKSAvICgxLjAgKyBjb24pLCAwLjUgKiBlY2NlbnQpKSAtIHBoaTtcclxuXHRcdFx0cGhpICs9IGRwaGk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhwaGkgKiBkLCBsbmcpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG5cclxuTC5DUlMuRVBTRzMzOTUgPSBMLmV4dGVuZCh7fSwgTC5DUlMsIHtcclxuXHRjb2RlOiAnRVBTRzozMzk1JyxcclxuXHJcblx0cHJvamVjdGlvbjogTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cclxuXHR0cmFuc2Zvcm1hdGlvbjogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtID0gTC5Qcm9qZWN0aW9uLk1lcmNhdG9yLFxyXG5cdFx0ICAgIHIgPSBtLlJfTUFKT1IsXHJcblx0XHQgICAgc2NhbGUgPSAwLjUgLyAoTWF0aC5QSSAqIHIpO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5UcmFuc2Zvcm1hdGlvbihzY2FsZSwgMC41LCAtc2NhbGUsIDAuNSk7XHJcblx0fSgpKVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLlRpbGVMYXllciBpcyB1c2VkIGZvciBzdGFuZGFyZCB4eXotbnVtYmVyZWQgdGlsZSBsYXllcnMuXHJcbiAqL1xyXG5cclxuTC5UaWxlTGF5ZXIgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRtaW5ab29tOiAwLFxyXG5cdFx0bWF4Wm9vbTogMTgsXHJcblx0XHR0aWxlU2l6ZTogMjU2LFxyXG5cdFx0c3ViZG9tYWluczogJ2FiYycsXHJcblx0XHRlcnJvclRpbGVVcmw6ICcnLFxyXG5cdFx0YXR0cmlidXRpb246ICcnLFxyXG5cdFx0em9vbU9mZnNldDogMCxcclxuXHRcdG9wYWNpdHk6IDEsXHJcblx0XHQvKlxyXG5cdFx0bWF4TmF0aXZlWm9vbTogbnVsbCxcclxuXHRcdHpJbmRleDogbnVsbCxcclxuXHRcdHRtczogZmFsc2UsXHJcblx0XHRjb250aW51b3VzV29ybGQ6IGZhbHNlLFxyXG5cdFx0bm9XcmFwOiBmYWxzZSxcclxuXHRcdHpvb21SZXZlcnNlOiBmYWxzZSxcclxuXHRcdGRldGVjdFJldGluYTogZmFsc2UsXHJcblx0XHRyZXVzZVRpbGVzOiBmYWxzZSxcclxuXHRcdGJvdW5kczogZmFsc2UsXHJcblx0XHQqL1xyXG5cdFx0dW5sb2FkSW52aXNpYmxlVGlsZXM6IEwuQnJvd3Nlci5tb2JpbGUsXHJcblx0XHR1cGRhdGVXaGVuSWRsZTogTC5Ccm93c2VyLm1vYmlsZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMgPSBMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0Ly8gZGV0ZWN0aW5nIHJldGluYSBkaXNwbGF5cywgYWRqdXN0aW5nIHRpbGVTaXplIGFuZCB6b29tIGxldmVsc1xyXG5cdFx0aWYgKG9wdGlvbnMuZGV0ZWN0UmV0aW5hICYmIEwuQnJvd3Nlci5yZXRpbmEgJiYgb3B0aW9ucy5tYXhab29tID4gMCkge1xyXG5cclxuXHRcdFx0b3B0aW9ucy50aWxlU2l6ZSA9IE1hdGguZmxvb3Iob3B0aW9ucy50aWxlU2l6ZSAvIDIpO1xyXG5cdFx0XHRvcHRpb25zLnpvb21PZmZzZXQrKztcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLm1pblpvb20gPiAwKSB7XHJcblx0XHRcdFx0b3B0aW9ucy5taW5ab29tLS07XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heFpvb20tLTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5ib3VuZHMpIHtcclxuXHRcdFx0b3B0aW9ucy5ib3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhvcHRpb25zLmJvdW5kcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cclxuXHRcdHZhciBzdWJkb21haW5zID0gdGhpcy5vcHRpb25zLnN1YmRvbWFpbnM7XHJcblxyXG5cdFx0aWYgKHR5cGVvZiBzdWJkb21haW5zID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aGlzLm9wdGlvbnMuc3ViZG9tYWlucyA9IHN1YmRvbWFpbnMuc3BsaXQoJycpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdG9uQWRkOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblx0XHR0aGlzLl9hbmltYXRlZCA9IG1hcC5fem9vbUFuaW1hdGVkO1xyXG5cclxuXHRcdC8vIGNyZWF0ZSBhIGNvbnRhaW5lciBkaXYgZm9yIHRpbGVzXHJcblx0XHR0aGlzLl9pbml0Q29udGFpbmVyKCk7XHJcblxyXG5cdFx0Ly8gc2V0IHVwIGV2ZW50c1xyXG5cdFx0bWFwLm9uKHtcclxuXHRcdFx0J3ZpZXdyZXNldCc6IHRoaXMuX3Jlc2V0LFxyXG5cdFx0XHQnbW92ZWVuZCc6IHRoaXMuX3VwZGF0ZVxyXG5cdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdG1hcC5vbih7XHJcblx0XHRcdFx0J3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXHJcblx0XHRcdFx0J3pvb21lbmQnOiB0aGlzLl9lbmRab29tQW5pbVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xyXG5cdFx0XHR0aGlzLl9saW1pdGVkVXBkYXRlID0gTC5VdGlsLmxpbWl0RXhlY0J5SW50ZXJ2YWwodGhpcy5fdXBkYXRlLCAxNTAsIHRoaXMpO1xyXG5cdFx0XHRtYXAub24oJ21vdmUnLCB0aGlzLl9saW1pdGVkVXBkYXRlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZXNldCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9jb250YWluZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdG1hcC5vZmYoe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy5fcmVzZXQsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlXHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0bWFwLm9mZih7XHJcblx0XHRcdFx0J3pvb21hbmltJzogdGhpcy5fYW5pbWF0ZVpvb20sXHJcblx0XHRcdFx0J3pvb21lbmQnOiB0aGlzLl9lbmRab29tQW5pbVxyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVXaGVuSWRsZSkge1xyXG5cdFx0XHRtYXAub2ZmKCdtb3ZlJywgdGhpcy5fbGltaXRlZFVwZGF0ZSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gbnVsbDtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRwYW5lLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgocGFuZSwgTWF0aC5tYXgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGJyaW5nVG9CYWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcGFuZSA9IHRoaXMuX21hcC5fcGFuZXMudGlsZVBhbmU7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRwYW5lLmluc2VydEJlZm9yZSh0aGlzLl9jb250YWluZXIsIHBhbmUuZmlyc3RDaGlsZCk7XHJcblx0XHRcdHRoaXMuX3NldEF1dG9aSW5kZXgocGFuZSwgTWF0aC5taW4pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRhaW5lcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRzZXRPcGFjaXR5OiBmdW5jdGlvbiAob3BhY2l0eSkge1xyXG5cdFx0dGhpcy5vcHRpb25zLm9wYWNpdHkgPSBvcGFjaXR5O1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFpJbmRleDogZnVuY3Rpb24gKHpJbmRleCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHpJbmRleDtcclxuXHRcdHRoaXMuX3VwZGF0ZVpJbmRleCgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCwgbm9SZWRyYXcpIHtcclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHRpZiAoIW5vUmVkcmF3KSB7XHJcblx0XHRcdHRoaXMucmVkcmF3KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KHtoYXJkOiB0cnVlfSk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5lciAmJiB0aGlzLm9wdGlvbnMuekluZGV4ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLnpJbmRleCA9IHRoaXMub3B0aW9ucy56SW5kZXg7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3NldEF1dG9aSW5kZXg6IGZ1bmN0aW9uIChwYW5lLCBjb21wYXJlKSB7XHJcblxyXG5cdFx0dmFyIGxheWVycyA9IHBhbmUuY2hpbGRyZW4sXHJcblx0XHQgICAgZWRnZVpJbmRleCA9IC1jb21wYXJlKEluZmluaXR5LCAtSW5maW5pdHkpLCAvLyAtSW5maW5pdHkgZm9yIG1heCwgSW5maW5pdHkgZm9yIG1pblxyXG5cdFx0ICAgIHpJbmRleCwgaSwgbGVuO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGxheWVycy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cclxuXHRcdFx0aWYgKGxheWVyc1tpXSAhPT0gdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdFx0ekluZGV4ID0gcGFyc2VJbnQobGF5ZXJzW2ldLnN0eWxlLnpJbmRleCwgMTApO1xyXG5cclxuXHRcdFx0XHRpZiAoIWlzTmFOKHpJbmRleCkpIHtcclxuXHRcdFx0XHRcdGVkZ2VaSW5kZXggPSBjb21wYXJlKGVkZ2VaSW5kZXgsIHpJbmRleCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnpJbmRleCA9IHRoaXMuX2NvbnRhaW5lci5zdHlsZS56SW5kZXggPVxyXG5cdFx0ICAgICAgICAoaXNGaW5pdGUoZWRnZVpJbmRleCkgPyBlZGdlWkluZGV4IDogMCkgKyBjb21wYXJlKDEsIC0xKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksXHJcblx0XHQgICAgdGlsZXMgPSB0aGlzLl90aWxlcztcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmllbHQ5KSB7XHJcblx0XHRcdGZvciAoaSBpbiB0aWxlcykge1xyXG5cdFx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGVzW2ldLCB0aGlzLm9wdGlvbnMub3BhY2l0eSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRoaXMuX2NvbnRhaW5lciwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pbml0Q29udGFpbmVyOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZVBhbmUgPSB0aGlzLl9tYXAuX3BhbmVzLnRpbGVQYW5lO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsICdsZWFmbGV0LWxheWVyJyk7XHJcblxyXG5cdFx0XHR0aGlzLl91cGRhdGVaSW5kZXgoKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRcdHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC10aWxlLWNvbnRhaW5lcic7XHJcblxyXG5cdFx0XHRcdHRoaXMuX2JnQnVmZmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCB0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0XHRcdHRoaXMuX3RpbGVDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUsIHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRoaXMuX3RpbGVDb250YWluZXIgPSB0aGlzLl9jb250YWluZXI7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRpbGVQYW5lLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLm9wYWNpdHkgPCAxKSB7XHJcblx0XHRcdFx0dGhpcy5fdXBkYXRlT3BhY2l0eSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3Jlc2V0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgndGlsZXVubG9hZCcsIHt0aWxlOiB0aGlzLl90aWxlc1trZXldfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZXMgPSB7fTtcclxuXHRcdHRoaXMuX3RpbGVzVG9Mb2FkID0gMDtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJldXNlVGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fdW51c2VkVGlsZXMgPSBbXTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl90aWxlQ29udGFpbmVyLmlubmVySFRNTCA9ICcnO1xyXG5cclxuXHRcdGlmICh0aGlzLl9hbmltYXRlZCAmJiBlICYmIGUuaGFyZCkge1xyXG5cdFx0XHR0aGlzLl9jbGVhckJnQnVmZmVyKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5faW5pdENvbnRhaW5lcigpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRUaWxlU2l6ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSArIHRoaXMub3B0aW9ucy56b29tT2Zmc2V0LFxyXG5cdFx0ICAgIHpvb21OID0gdGhpcy5vcHRpb25zLm1heE5hdGl2ZVpvb20sXHJcblx0XHQgICAgdGlsZVNpemUgPSB0aGlzLm9wdGlvbnMudGlsZVNpemU7XHJcblxyXG5cdFx0aWYgKHpvb21OICYmIHpvb20gPiB6b29tTikge1xyXG5cdFx0XHR0aWxlU2l6ZSA9IE1hdGgucm91bmQobWFwLmdldFpvb21TY2FsZSh6b29tKSAvIG1hcC5nZXRab29tU2NhbGUoem9vbU4pICogdGlsZVNpemUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aWxlU2l6ZTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBib3VuZHMgPSBtYXAuZ2V0UGl4ZWxCb3VuZHMoKSxcclxuXHRcdCAgICB6b29tID0gbWFwLmdldFpvb20oKSxcclxuXHRcdCAgICB0aWxlU2l6ZSA9IHRoaXMuX2dldFRpbGVTaXplKCk7XHJcblxyXG5cdFx0aWYgKHpvb20gPiB0aGlzLm9wdGlvbnMubWF4Wm9vbSB8fCB6b29tIDwgdGhpcy5vcHRpb25zLm1pblpvb20pIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0aWxlQm91bmRzID0gTC5ib3VuZHMoXHJcblx0XHQgICAgICAgIGJvdW5kcy5taW4uZGl2aWRlQnkodGlsZVNpemUpLl9mbG9vcigpLFxyXG5cdFx0ICAgICAgICBib3VuZHMubWF4LmRpdmlkZUJ5KHRpbGVTaXplKS5fZmxvb3IoKSk7XHJcblxyXG5cdFx0dGhpcy5fYWRkVGlsZXNGcm9tQ2VudGVyT3V0KHRpbGVCb3VuZHMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudW5sb2FkSW52aXNpYmxlVGlsZXMgfHwgdGhpcy5vcHRpb25zLnJldXNlVGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fcmVtb3ZlT3RoZXJUaWxlcyh0aWxlQm91bmRzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkVGlsZXNGcm9tQ2VudGVyT3V0OiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIgcXVldWUgPSBbXSxcclxuXHRcdCAgICBjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XHJcblxyXG5cdFx0dmFyIGosIGksIHBvaW50O1xyXG5cclxuXHRcdGZvciAoaiA9IGJvdW5kcy5taW4ueTsgaiA8PSBib3VuZHMubWF4Lnk7IGorKykge1xyXG5cdFx0XHRmb3IgKGkgPSBib3VuZHMubWluLng7IGkgPD0gYm91bmRzLm1heC54OyBpKyspIHtcclxuXHRcdFx0XHRwb2ludCA9IG5ldyBMLlBvaW50KGksIGopO1xyXG5cclxuXHRcdFx0XHRpZiAodGhpcy5fdGlsZVNob3VsZEJlTG9hZGVkKHBvaW50KSkge1xyXG5cdFx0XHRcdFx0cXVldWUucHVzaChwb2ludCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHRpbGVzVG9Mb2FkID0gcXVldWUubGVuZ3RoO1xyXG5cclxuXHRcdGlmICh0aWxlc1RvTG9hZCA9PT0gMCkgeyByZXR1cm47IH1cclxuXHJcblx0XHQvLyBsb2FkIHRpbGVzIGluIG9yZGVyIG9mIHRoZWlyIGRpc3RhbmNlIHRvIGNlbnRlclxyXG5cdFx0cXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG5cdFx0XHRyZXR1cm4gYS5kaXN0YW5jZVRvKGNlbnRlcikgLSBiLmRpc3RhbmNlVG8oY2VudGVyKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcclxuXHJcblx0XHQvLyBpZiBpdHMgdGhlIGZpcnN0IGJhdGNoIG9mIHRpbGVzIHRvIGxvYWRcclxuXHRcdGlmICghdGhpcy5fdGlsZXNUb0xvYWQpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdsb2FkaW5nJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fdGlsZXNUb0xvYWQgKz0gdGlsZXNUb0xvYWQ7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IHRpbGVzVG9Mb2FkOyBpKyspIHtcclxuXHRcdFx0dGhpcy5fYWRkVGlsZShxdWV1ZVtpXSwgZnJhZ21lbnQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3RpbGVDb250YWluZXIuYXBwZW5kQ2hpbGQoZnJhZ21lbnQpO1xyXG5cdH0sXHJcblxyXG5cdF90aWxlU2hvdWxkQmVMb2FkZWQ6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHRcdGlmICgodGlsZVBvaW50LnggKyAnOicgKyB0aWxlUG9pbnQueSkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlOyAvLyBhbHJlYWR5IGxvYWRlZFxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmICghb3B0aW9ucy5jb250aW51b3VzV29ybGQpIHtcclxuXHRcdFx0dmFyIGxpbWl0ID0gdGhpcy5fZ2V0V3JhcFRpbGVOdW0oKTtcclxuXHJcblx0XHRcdC8vIGRvbid0IGxvYWQgaWYgZXhjZWVkcyB3b3JsZCBib3VuZHNcclxuXHRcdFx0aWYgKChvcHRpb25zLm5vV3JhcCAmJiAodGlsZVBvaW50LnggPCAwIHx8IHRpbGVQb2ludC54ID49IGxpbWl0LngpKSB8fFxyXG5cdFx0XHRcdHRpbGVQb2ludC55IDwgMCB8fCB0aWxlUG9pbnQueSA+PSBsaW1pdC55KSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmJvdW5kcykge1xyXG5cdFx0XHR2YXIgdGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplLFxyXG5cdFx0XHQgICAgbndQb2ludCA9IHRpbGVQb2ludC5tdWx0aXBseUJ5KHRpbGVTaXplKSxcclxuXHRcdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZChbdGlsZVNpemUsIHRpbGVTaXplXSksXHJcblx0XHRcdCAgICBudyA9IHRoaXMuX21hcC51bnByb2plY3QobndQb2ludCksXHJcblx0XHRcdCAgICBzZSA9IHRoaXMuX21hcC51bnByb2plY3Qoc2VQb2ludCk7XHJcblxyXG5cdFx0XHQvLyBUT0RPIHRlbXBvcmFyeSBoYWNrLCB3aWxsIGJlIHJlbW92ZWQgYWZ0ZXIgcmVmYWN0b3JpbmcgcHJvamVjdGlvbnNcclxuXHRcdFx0Ly8gaHR0cHM6Ly9naXRodWIuY29tL0xlYWZsZXQvTGVhZmxldC9pc3N1ZXMvMTYxOFxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuY29udGludW91c1dvcmxkICYmICFvcHRpb25zLm5vV3JhcCkge1xyXG5cdFx0XHRcdG53ID0gbncud3JhcCgpO1xyXG5cdFx0XHRcdHNlID0gc2Uud3JhcCgpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoIW9wdGlvbnMuYm91bmRzLmludGVyc2VjdHMoW253LCBzZV0pKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVPdGhlclRpbGVzOiBmdW5jdGlvbiAoYm91bmRzKSB7XHJcblx0XHR2YXIga0FyciwgeCwgeSwga2V5O1xyXG5cclxuXHRcdGZvciAoa2V5IGluIHRoaXMuX3RpbGVzKSB7XHJcblx0XHRcdGtBcnIgPSBrZXkuc3BsaXQoJzonKTtcclxuXHRcdFx0eCA9IHBhcnNlSW50KGtBcnJbMF0sIDEwKTtcclxuXHRcdFx0eSA9IHBhcnNlSW50KGtBcnJbMV0sIDEwKTtcclxuXHJcblx0XHRcdC8vIHJlbW92ZSB0aWxlIGlmIGl0J3Mgb3V0IG9mIGJvdW5kc1xyXG5cdFx0XHRpZiAoeCA8IGJvdW5kcy5taW4ueCB8fCB4ID4gYm91bmRzLm1heC54IHx8IHkgPCBib3VuZHMubWluLnkgfHwgeSA+IGJvdW5kcy5tYXgueSkge1xyXG5cdFx0XHRcdHRoaXMuX3JlbW92ZVRpbGUoa2V5KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVUaWxlOiBmdW5jdGlvbiAoa2V5KSB7XHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XHJcblxyXG5cdFx0dGhpcy5maXJlKCd0aWxldW5sb2FkJywge3RpbGU6IHRpbGUsIHVybDogdGlsZS5zcmN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnJldXNlVGlsZXMpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRpbGUsICdsZWFmbGV0LXRpbGUtbG9hZGVkJyk7XHJcblx0XHRcdHRoaXMuX3VudXNlZFRpbGVzLnB1c2godGlsZSk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICh0aWxlLnBhcmVudE5vZGUgPT09IHRoaXMuX3RpbGVDb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fdGlsZUNvbnRhaW5lci5yZW1vdmVDaGlsZCh0aWxlKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBmb3IgaHR0cHM6Ly9naXRodWIuY29tL0Nsb3VkTWFkZS9MZWFmbGV0L2lzc3Vlcy8xMzdcclxuXHRcdGlmICghTC5Ccm93c2VyLmFuZHJvaWQpIHtcclxuXHRcdFx0dGlsZS5vbmxvYWQgPSBudWxsO1xyXG5cdFx0XHR0aWxlLnNyYyA9IEwuVXRpbC5lbXB0eUltYWdlVXJsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl90aWxlc1trZXldO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRUaWxlOiBmdW5jdGlvbiAodGlsZVBvaW50LCBjb250YWluZXIpIHtcclxuXHRcdHZhciB0aWxlUG9zID0gdGhpcy5fZ2V0VGlsZVBvcyh0aWxlUG9pbnQpO1xyXG5cclxuXHRcdC8vIGdldCB1bnVzZWQgdGlsZSAtIG9yIGNyZWF0ZSBhIG5ldyB0aWxlXHJcblx0XHR2YXIgdGlsZSA9IHRoaXMuX2dldFRpbGUoKTtcclxuXHJcblx0XHQvKlxyXG5cdFx0Q2hyb21lIDIwIGxheW91dHMgbXVjaCBmYXN0ZXIgd2l0aCB0b3AvbGVmdCAodmVyaWZ5IHdpdGggdGltZWxpbmUsIGZyYW1lcylcclxuXHRcdEFuZHJvaWQgNCBicm93c2VyIGhhcyBkaXNwbGF5IGlzc3VlcyB3aXRoIHRvcC9sZWZ0IGFuZCByZXF1aXJlcyB0cmFuc2Zvcm0gaW5zdGVhZFxyXG5cdFx0KG90aGVyIGJyb3dzZXJzIGRvbid0IGN1cnJlbnRseSBjYXJlKSAtIHNlZSBkZWJ1Zy9oYWNrcy9qaXR0ZXIuaHRtbCBmb3IgYW4gZXhhbXBsZVxyXG5cdFx0Ki9cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aWxlLCB0aWxlUG9zLCBMLkJyb3dzZXIuY2hyb21lKTtcclxuXHJcblx0XHR0aGlzLl90aWxlc1t0aWxlUG9pbnQueCArICc6JyArIHRpbGVQb2ludC55XSA9IHRpbGU7XHJcblxyXG5cdFx0dGhpcy5fbG9hZFRpbGUodGlsZSwgdGlsZVBvaW50KTtcclxuXHJcblx0XHRpZiAodGlsZS5wYXJlbnROb2RlICE9PSB0aGlzLl90aWxlQ29udGFpbmVyKSB7XHJcblx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZCh0aWxlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0Wm9vbUZvclVybDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIHpvb20gPSB0aGlzLl9tYXAuZ2V0Wm9vbSgpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnpvb21SZXZlcnNlKSB7XHJcblx0XHRcdHpvb20gPSBvcHRpb25zLm1heFpvb20gLSB6b29tO1xyXG5cdFx0fVxyXG5cclxuXHRcdHpvb20gKz0gb3B0aW9ucy56b29tT2Zmc2V0O1xyXG5cclxuXHRcdHJldHVybiBvcHRpb25zLm1heE5hdGl2ZVpvb20gPyBNYXRoLm1pbih6b29tLCBvcHRpb25zLm1heE5hdGl2ZVpvb20pIDogem9vbTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0VGlsZVBvczogZnVuY3Rpb24gKHRpbGVQb2ludCkge1xyXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMuX21hcC5nZXRQaXhlbE9yaWdpbigpLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5fZ2V0VGlsZVNpemUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGlsZVBvaW50Lm11bHRpcGx5QnkodGlsZVNpemUpLnN1YnRyYWN0KG9yaWdpbik7XHJcblx0fSxcclxuXHJcblx0Ly8gaW1hZ2Utc3BlY2lmaWMgY29kZSAob3ZlcnJpZGUgdG8gaW1wbGVtZW50IGUuZy4gQ2FudmFzIG9yIFNWRyB0aWxlIGxheWVyKVxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHRyZXR1cm4gTC5VdGlsLnRlbXBsYXRlKHRoaXMuX3VybCwgTC5leHRlbmQoe1xyXG5cdFx0XHRzOiB0aGlzLl9nZXRTdWJkb21haW4odGlsZVBvaW50KSxcclxuXHRcdFx0ejogdGlsZVBvaW50LnosXHJcblx0XHRcdHg6IHRpbGVQb2ludC54LFxyXG5cdFx0XHR5OiB0aWxlUG9pbnQueVxyXG5cdFx0fSwgdGhpcy5vcHRpb25zKSk7XHJcblx0fSxcclxuXHJcblx0X2dldFdyYXBUaWxlTnVtOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY3JzID0gdGhpcy5fbWFwLm9wdGlvbnMuY3JzLFxyXG5cdFx0ICAgIHNpemUgPSBjcnMuZ2V0U2l6ZSh0aGlzLl9tYXAuZ2V0Wm9vbSgpKTtcclxuXHRcdHJldHVybiBzaXplLmRpdmlkZUJ5KHRoaXMuX2dldFRpbGVTaXplKCkpLl9mbG9vcigpO1xyXG5cdH0sXHJcblxyXG5cdF9hZGp1c3RUaWxlUG9pbnQ6IGZ1bmN0aW9uICh0aWxlUG9pbnQpIHtcclxuXHJcblx0XHR2YXIgbGltaXQgPSB0aGlzLl9nZXRXcmFwVGlsZU51bSgpO1xyXG5cclxuXHRcdC8vIHdyYXAgdGlsZSBjb29yZGluYXRlc1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuY29udGludW91c1dvcmxkICYmICF0aGlzLm9wdGlvbnMubm9XcmFwKSB7XHJcblx0XHRcdHRpbGVQb2ludC54ID0gKCh0aWxlUG9pbnQueCAlIGxpbWl0LngpICsgbGltaXQueCkgJSBsaW1pdC54O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMudG1zKSB7XHJcblx0XHRcdHRpbGVQb2ludC55ID0gbGltaXQueSAtIHRpbGVQb2ludC55IC0gMTtcclxuXHRcdH1cclxuXHJcblx0XHR0aWxlUG9pbnQueiA9IHRoaXMuX2dldFpvb21Gb3JVcmwoKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0U3ViZG9tYWluOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7XHJcblx0XHR2YXIgaW5kZXggPSBNYXRoLmFicyh0aWxlUG9pbnQueCArIHRpbGVQb2ludC55KSAlIHRoaXMub3B0aW9ucy5zdWJkb21haW5zLmxlbmd0aDtcclxuXHRcdHJldHVybiB0aGlzLm9wdGlvbnMuc3ViZG9tYWluc1tpbmRleF07XHJcblx0fSxcclxuXHJcblx0X2dldFRpbGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmV1c2VUaWxlcyAmJiB0aGlzLl91bnVzZWRUaWxlcy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdHZhciB0aWxlID0gdGhpcy5fdW51c2VkVGlsZXMucG9wKCk7XHJcblx0XHRcdHRoaXMuX3Jlc2V0VGlsZSh0aWxlKTtcclxuXHRcdFx0cmV0dXJuIHRpbGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlVGlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdC8vIE92ZXJyaWRlIGlmIGRhdGEgc3RvcmVkIG9uIGEgdGlsZSBuZWVkcyB0byBiZSBjbGVhbmVkIHVwIGJlZm9yZSByZXVzZVxyXG5cdF9yZXNldFRpbGU6IGZ1bmN0aW9uICgvKnRpbGUqLykge30sXHJcblxyXG5cdF9jcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2ltZycsICdsZWFmbGV0LXRpbGUnKTtcclxuXHRcdHRpbGUuc3R5bGUud2lkdGggPSB0aWxlLnN0eWxlLmhlaWdodCA9IHRoaXMuX2dldFRpbGVTaXplKCkgKyAncHgnO1xyXG5cdFx0dGlsZS5nYWxsZXJ5aW1nID0gJ25vJztcclxuXHJcblx0XHR0aWxlLm9uc2VsZWN0c3RhcnQgPSB0aWxlLm9ubW91c2Vtb3ZlID0gTC5VdGlsLmZhbHNlRm47XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5pZWx0OSAmJiB0aGlzLm9wdGlvbnMub3BhY2l0eSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5zZXRPcGFjaXR5KHRpbGUsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHRcdC8vIHdpdGhvdXQgdGhpcyBoYWNrLCB0aWxlcyBkaXNhcHBlYXIgYWZ0ZXIgem9vbSBvbiBDaHJvbWUgZm9yIEFuZHJvaWRcclxuXHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFmbGV0L0xlYWZsZXQvaXNzdWVzLzIwNzhcclxuXHRcdGlmIChMLkJyb3dzZXIubW9iaWxlV2Via2l0M2QpIHtcclxuXHRcdFx0dGlsZS5zdHlsZS5XZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdF9sb2FkVGlsZTogZnVuY3Rpb24gKHRpbGUsIHRpbGVQb2ludCkge1xyXG5cdFx0dGlsZS5fbGF5ZXIgID0gdGhpcztcclxuXHRcdHRpbGUub25sb2FkICA9IHRoaXMuX3RpbGVPbkxvYWQ7XHJcblx0XHR0aWxlLm9uZXJyb3IgPSB0aGlzLl90aWxlT25FcnJvcjtcclxuXHJcblx0XHR0aGlzLl9hZGp1c3RUaWxlUG9pbnQodGlsZVBvaW50KTtcclxuXHRcdHRpbGUuc3JjICAgICA9IHRoaXMuZ2V0VGlsZVVybCh0aWxlUG9pbnQpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgndGlsZWxvYWRzdGFydCcsIHtcclxuXHRcdFx0dGlsZTogdGlsZSxcclxuXHRcdFx0dXJsOiB0aWxlLnNyY1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVMb2FkZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3RpbGVzVG9Mb2FkLS07XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl90aWxlQ29udGFpbmVyLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl90aWxlc1RvTG9hZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHJcblx0XHRcdGlmICh0aGlzLl9hbmltYXRlZCkge1xyXG5cdFx0XHRcdC8vIGNsZWFyIHNjYWxlZCB0aWxlcyBhZnRlciBhbGwgbmV3IHRpbGVzIGFyZSBsb2FkZWQgKGZvciBwZXJmb3JtYW5jZSlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fY2xlYXJCZ0J1ZmZlclRpbWVyKTtcclxuXHRcdFx0XHR0aGlzLl9jbGVhckJnQnVmZmVyVGltZXIgPSBzZXRUaW1lb3V0KEwuYmluZCh0aGlzLl9jbGVhckJnQnVmZmVyLCB0aGlzKSwgNTAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF90aWxlT25Mb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcjtcclxuXHJcblx0XHQvL09ubHkgaWYgd2UgYXJlIGxvYWRpbmcgYW4gYWN0dWFsIGltYWdlXHJcblx0XHRpZiAodGhpcy5zcmMgIT09IEwuVXRpbC5lbXB0eUltYWdlVXJsKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLCAnbGVhZmxldC10aWxlLWxvYWRlZCcpO1xyXG5cclxuXHRcdFx0bGF5ZXIuZmlyZSgndGlsZWxvYWQnLCB7XHJcblx0XHRcdFx0dGlsZTogdGhpcyxcclxuXHRcdFx0XHR1cmw6IHRoaXMuc3JjXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxheWVyLl90aWxlTG9hZGVkKCk7XHJcblx0fSxcclxuXHJcblx0X3RpbGVPbkVycm9yOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9sYXllcjtcclxuXHJcblx0XHRsYXllci5maXJlKCd0aWxlZXJyb3InLCB7XHJcblx0XHRcdHRpbGU6IHRoaXMsXHJcblx0XHRcdHVybDogdGhpcy5zcmNcclxuXHRcdH0pO1xyXG5cclxuXHRcdHZhciBuZXdVcmwgPSBsYXllci5vcHRpb25zLmVycm9yVGlsZVVybDtcclxuXHRcdGlmIChuZXdVcmwpIHtcclxuXHRcdFx0dGhpcy5zcmMgPSBuZXdVcmw7XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIuX3RpbGVMb2FkZWQoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC50aWxlTGF5ZXIgPSBmdW5jdGlvbiAodXJsLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLlRpbGVMYXllcih1cmwsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuVGlsZUxheWVyLldNUyBpcyB1c2VkIGZvciBwdXR0aW5nIFdNUyB0aWxlIGxheWVycyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuVGlsZUxheWVyLldNUyA9IEwuVGlsZUxheWVyLmV4dGVuZCh7XHJcblxyXG5cdGRlZmF1bHRXbXNQYXJhbXM6IHtcclxuXHRcdHNlcnZpY2U6ICdXTVMnLFxyXG5cdFx0cmVxdWVzdDogJ0dldE1hcCcsXHJcblx0XHR2ZXJzaW9uOiAnMS4xLjEnLFxyXG5cdFx0bGF5ZXJzOiAnJyxcclxuXHRcdHN0eWxlczogJycsXHJcblx0XHRmb3JtYXQ6ICdpbWFnZS9qcGVnJyxcclxuXHRcdHRyYW5zcGFyZW50OiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uICh1cmwsIG9wdGlvbnMpIHsgLy8gKFN0cmluZywgT2JqZWN0KVxyXG5cclxuXHRcdHRoaXMuX3VybCA9IHVybDtcclxuXHJcblx0XHR2YXIgd21zUGFyYW1zID0gTC5leHRlbmQoe30sIHRoaXMuZGVmYXVsdFdtc1BhcmFtcyksXHJcblx0XHQgICAgdGlsZVNpemUgPSBvcHRpb25zLnRpbGVTaXplIHx8IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5kZXRlY3RSZXRpbmEgJiYgTC5Ccm93c2VyLnJldGluYSkge1xyXG5cdFx0XHR3bXNQYXJhbXMud2lkdGggPSB3bXNQYXJhbXMuaGVpZ2h0ID0gdGlsZVNpemUgKiAyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d21zUGFyYW1zLndpZHRoID0gd21zUGFyYW1zLmhlaWdodCA9IHRpbGVTaXplO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gb3B0aW9ucykge1xyXG5cdFx0XHQvLyBhbGwga2V5cyB0aGF0IGFyZSBub3QgVGlsZUxheWVyIG9wdGlvbnMgZ28gdG8gV01TIHBhcmFtc1xyXG5cdFx0XHRpZiAoIXRoaXMub3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSAmJiBpICE9PSAnY3JzJykge1xyXG5cdFx0XHRcdHdtc1BhcmFtc1tpXSA9IG9wdGlvbnNbaV07XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLndtc1BhcmFtcyA9IHdtc1BhcmFtcztcclxuXHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHJcblx0XHR0aGlzLl9jcnMgPSB0aGlzLm9wdGlvbnMuY3JzIHx8IG1hcC5vcHRpb25zLmNycztcclxuXHJcblx0XHR0aGlzLl93bXNWZXJzaW9uID0gcGFyc2VGbG9hdCh0aGlzLndtc1BhcmFtcy52ZXJzaW9uKTtcclxuXHJcblx0XHR2YXIgcHJvamVjdGlvbktleSA9IHRoaXMuX3dtc1ZlcnNpb24gPj0gMS4zID8gJ2NycycgOiAnc3JzJztcclxuXHRcdHRoaXMud21zUGFyYW1zW3Byb2plY3Rpb25LZXldID0gdGhpcy5fY3JzLmNvZGU7XHJcblxyXG5cdFx0TC5UaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRnZXRUaWxlVXJsOiBmdW5jdGlvbiAodGlsZVBvaW50KSB7IC8vIChQb2ludCwgTnVtYmVyKSAtPiBTdHJpbmdcclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIHRpbGVTaXplID0gdGhpcy5vcHRpb25zLnRpbGVTaXplLFxyXG5cclxuXHRcdCAgICBud1BvaW50ID0gdGlsZVBvaW50Lm11bHRpcGx5QnkodGlsZVNpemUpLFxyXG5cdFx0ICAgIHNlUG9pbnQgPSBud1BvaW50LmFkZChbdGlsZVNpemUsIHRpbGVTaXplXSksXHJcblxyXG5cdFx0ICAgIG53ID0gdGhpcy5fY3JzLnByb2plY3QobWFwLnVucHJvamVjdChud1BvaW50LCB0aWxlUG9pbnQueikpLFxyXG5cdFx0ICAgIHNlID0gdGhpcy5fY3JzLnByb2plY3QobWFwLnVucHJvamVjdChzZVBvaW50LCB0aWxlUG9pbnQueikpLFxyXG5cdFx0ICAgIGJib3ggPSB0aGlzLl93bXNWZXJzaW9uID49IDEuMyAmJiB0aGlzLl9jcnMgPT09IEwuQ1JTLkVQU0c0MzI2ID9cclxuXHRcdCAgICAgICAgW3NlLnksIG53LngsIG53LnksIHNlLnhdLmpvaW4oJywnKSA6XHJcblx0XHQgICAgICAgIFtudy54LCBzZS55LCBzZS54LCBudy55XS5qb2luKCcsJyksXHJcblxyXG5cdFx0ICAgIHVybCA9IEwuVXRpbC50ZW1wbGF0ZSh0aGlzLl91cmwsIHtzOiB0aGlzLl9nZXRTdWJkb21haW4odGlsZVBvaW50KX0pO1xyXG5cclxuXHRcdHJldHVybiB1cmwgKyBMLlV0aWwuZ2V0UGFyYW1TdHJpbmcodGhpcy53bXNQYXJhbXMsIHVybCwgdHJ1ZSkgKyAnJkJCT1g9JyArIGJib3g7XHJcblx0fSxcclxuXHJcblx0c2V0UGFyYW1zOiBmdW5jdGlvbiAocGFyYW1zLCBub1JlZHJhdykge1xyXG5cclxuXHRcdEwuZXh0ZW5kKHRoaXMud21zUGFyYW1zLCBwYXJhbXMpO1xyXG5cclxuXHRcdGlmICghbm9SZWRyYXcpIHtcclxuXHRcdFx0dGhpcy5yZWRyYXcoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuTC50aWxlTGF5ZXIud21zID0gZnVuY3Rpb24gKHVybCwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5UaWxlTGF5ZXIuV01TKHVybCwgb3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5UaWxlTGF5ZXIuQ2FudmFzIGlzIGEgY2xhc3MgdGhhdCB5b3UgY2FuIHVzZSBhcyBhIGJhc2UgZm9yIGNyZWF0aW5nXHJcbiAqIGR5bmFtaWNhbGx5IGRyYXduIENhbnZhcy1iYXNlZCB0aWxlIGxheWVycy5cclxuICovXHJcblxyXG5MLlRpbGVMYXllci5DYW52YXMgPSBMLlRpbGVMYXllci5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGFzeW5jOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0cmVkcmF3OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3Jlc2V0KHtoYXJkOiB0cnVlfSk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fdGlsZXMpIHtcclxuXHRcdFx0dGhpcy5fcmVkcmF3VGlsZSh0aGlzLl90aWxlc1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfcmVkcmF3VGlsZTogZnVuY3Rpb24gKHRpbGUpIHtcclxuXHRcdHRoaXMuZHJhd1RpbGUodGlsZSwgdGlsZS5fdGlsZVBvaW50LCB0aGlzLl9tYXAuX3pvb20pO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVUaWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgdGlsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2NhbnZhcycsICdsZWFmbGV0LXRpbGUnKTtcclxuXHRcdHRpbGUud2lkdGggPSB0aWxlLmhlaWdodCA9IHRoaXMub3B0aW9ucy50aWxlU2l6ZTtcclxuXHRcdHRpbGUub25zZWxlY3RzdGFydCA9IHRpbGUub25tb3VzZW1vdmUgPSBMLlV0aWwuZmFsc2VGbjtcclxuXHRcdHJldHVybiB0aWxlO1xyXG5cdH0sXHJcblxyXG5cdF9sb2FkVGlsZTogZnVuY3Rpb24gKHRpbGUsIHRpbGVQb2ludCkge1xyXG5cdFx0dGlsZS5fbGF5ZXIgPSB0aGlzO1xyXG5cdFx0dGlsZS5fdGlsZVBvaW50ID0gdGlsZVBvaW50O1xyXG5cclxuXHRcdHRoaXMuX3JlZHJhd1RpbGUodGlsZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXN5bmMpIHtcclxuXHRcdFx0dGhpcy50aWxlRHJhd24odGlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0ZHJhd1RpbGU6IGZ1bmN0aW9uICgvKnRpbGUsIHRpbGVQb2ludCovKSB7XHJcblx0XHQvLyBvdmVycmlkZSB3aXRoIHJlbmRlcmluZyBjb2RlXHJcblx0fSxcclxuXHJcblx0dGlsZURyYXduOiBmdW5jdGlvbiAodGlsZSkge1xyXG5cdFx0dGhpcy5fdGlsZU9uTG9hZC5jYWxsKHRpbGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuTC50aWxlTGF5ZXIuY2FudmFzID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuVGlsZUxheWVyLkNhbnZhcyhvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkltYWdlT3ZlcmxheSBpcyB1c2VkIHRvIG92ZXJsYXkgaW1hZ2VzIG92ZXIgdGhlIG1hcCAodG8gc3BlY2lmaWMgZ2VvZ3JhcGhpY2FsIGJvdW5kcykuXHJcbiAqL1xyXG5cclxuTC5JbWFnZU92ZXJsYXkgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRvcGFjaXR5OiAxXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKHVybCwgYm91bmRzLCBvcHRpb25zKSB7IC8vIChTdHJpbmcsIExhdExuZ0JvdW5kcywgT2JqZWN0KVxyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5fYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX2luaXRJbWFnZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hcC5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cclxuXHRcdG1hcC5vbigndmlld3Jlc2V0JywgdGhpcy5fcmVzZXQsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChtYXAub3B0aW9ucy56b29tQW5pbWF0aW9uICYmIEwuQnJvd3Nlci5hbnkzZCkge1xyXG5cdFx0XHRtYXAub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVpvb20sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3Jlc2V0KCk7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5nZXRQYW5lcygpLm92ZXJsYXlQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2ltYWdlKTtcclxuXHJcblx0XHRtYXAub2ZmKCd2aWV3cmVzZXQnLCB0aGlzLl9yZXNldCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG1hcC5vcHRpb25zLnpvb21BbmltYXRpb24pIHtcclxuXHRcdFx0bWFwLm9mZignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIHJlbW92ZSBicmluZ1RvRnJvbnQvYnJpbmdUb0JhY2sgZHVwbGljYXRpb24gZnJvbSBUaWxlTGF5ZXIvUGF0aFxyXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ltYWdlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQodGhpcy5faW1hZ2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwYW5lID0gdGhpcy5fbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcclxuXHRcdGlmICh0aGlzLl9pbWFnZSkge1xyXG5cdFx0XHRwYW5lLmluc2VydEJlZm9yZSh0aGlzLl9pbWFnZSwgcGFuZS5maXJzdENoaWxkKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFVybDogZnVuY3Rpb24gKHVybCkge1xyXG5cdFx0dGhpcy5fdXJsID0gdXJsO1xyXG5cdFx0dGhpcy5faW1hZ2Uuc3JjID0gdGhpcy5fdXJsO1xyXG5cdH0sXHJcblxyXG5cdGdldEF0dHJpYnV0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW1hZ2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2ltYWdlID0gTC5Eb21VdGlsLmNyZWF0ZSgnaW1nJywgJ2xlYWZsZXQtaW1hZ2UtbGF5ZXInKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2ltYWdlLCAnbGVhZmxldC16b29tLWFuaW1hdGVkJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5faW1hZ2UsICdsZWFmbGV0LXpvb20taGlkZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHJcblx0XHQvL1RPRE8gY3JlYXRlSW1hZ2UgdXRpbCBtZXRob2QgdG8gcmVtb3ZlIGR1cGxpY2F0aW9uXHJcblx0XHRMLmV4dGVuZCh0aGlzLl9pbWFnZSwge1xyXG5cdFx0XHRnYWxsZXJ5aW1nOiAnbm8nLFxyXG5cdFx0XHRvbnNlbGVjdHN0YXJ0OiBMLlV0aWwuZmFsc2VGbixcclxuXHRcdFx0b25tb3VzZW1vdmU6IEwuVXRpbC5mYWxzZUZuLFxyXG5cdFx0XHRvbmxvYWQ6IEwuYmluZCh0aGlzLl9vbkltYWdlTG9hZCwgdGhpcyksXHJcblx0XHRcdHNyYzogdGhpcy5fdXJsXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGltYWdlID0gdGhpcy5faW1hZ2UsXHJcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKGUuem9vbSksXHJcblx0XHQgICAgbncgPSB0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCksXHJcblx0XHQgICAgc2UgPSB0aGlzLl9ib3VuZHMuZ2V0U291dGhFYXN0KCksXHJcblxyXG5cdFx0ICAgIHRvcExlZnQgPSBtYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludChudywgZS56b29tLCBlLmNlbnRlciksXHJcblx0XHQgICAgc2l6ZSA9IG1hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHNlLCBlLnpvb20sIGUuY2VudGVyKS5fc3VidHJhY3QodG9wTGVmdCksXHJcblx0XHQgICAgb3JpZ2luID0gdG9wTGVmdC5fYWRkKHNpemUuX211bHRpcGx5QnkoKDEgLyAyKSAqICgxIC0gMSAvIHNjYWxlKSkpO1xyXG5cclxuXHRcdGltYWdlLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID1cclxuXHRcdCAgICAgICAgTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhvcmlnaW4pICsgJyBzY2FsZSgnICsgc2NhbGUgKyAnKSAnO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGltYWdlICAgPSB0aGlzLl9pbWFnZSxcclxuXHRcdCAgICB0b3BMZWZ0ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9ib3VuZHMuZ2V0Tm9ydGhXZXN0KCkpLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KHRoaXMuX2JvdW5kcy5nZXRTb3V0aEVhc3QoKSkuX3N1YnRyYWN0KHRvcExlZnQpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihpbWFnZSwgdG9wTGVmdCk7XHJcblxyXG5cdFx0aW1hZ2Uuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdGltYWdlLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X29uSW1hZ2VMb2FkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmZpcmUoJ2xvYWQnKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faW1hZ2UsIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5pbWFnZU92ZXJsYXkgPSBmdW5jdGlvbiAodXJsLCBib3VuZHMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuSW1hZ2VPdmVybGF5KHVybCwgYm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkljb24gaXMgYW4gaW1hZ2UtYmFzZWQgaWNvbiBjbGFzcyB0aGF0IHlvdSBjYW4gdXNlIHdpdGggTC5NYXJrZXIgZm9yIGN1c3RvbSBtYXJrZXJzLlxyXG4gKi9cclxuXHJcbkwuSWNvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHQvKlxyXG5cdFx0aWNvblVybDogKFN0cmluZykgKHJlcXVpcmVkKVxyXG5cdFx0aWNvblJldGluYVVybDogKFN0cmluZykgKG9wdGlvbmFsLCB1c2VkIGZvciByZXRpbmEgZGV2aWNlcyBpZiBkZXRlY3RlZClcclxuXHRcdGljb25TaXplOiAoUG9pbnQpIChjYW4gYmUgc2V0IHRocm91Z2ggQ1NTKVxyXG5cdFx0aWNvbkFuY2hvcjogKFBvaW50KSAoY2VudGVyZWQgYnkgZGVmYXVsdCwgY2FuIGJlIHNldCBpbiBDU1Mgd2l0aCBuZWdhdGl2ZSBtYXJnaW5zKVxyXG5cdFx0cG9wdXBBbmNob3I6IChQb2ludCkgKGlmIG5vdCBzcGVjaWZpZWQsIHBvcHVwIG9wZW5zIGluIHRoZSBhbmNob3IgcG9pbnQpXHJcblx0XHRzaGFkb3dVcmw6IChTdHJpbmcpIChubyBzaGFkb3cgYnkgZGVmYXVsdClcclxuXHRcdHNoYWRvd1JldGluYVVybDogKFN0cmluZykgKG9wdGlvbmFsLCB1c2VkIGZvciByZXRpbmEgZGV2aWNlcyBpZiBkZXRlY3RlZClcclxuXHRcdHNoYWRvd1NpemU6IChQb2ludClcclxuXHRcdHNoYWRvd0FuY2hvcjogKFBvaW50KVxyXG5cdFx0Ki9cclxuXHRcdGNsYXNzTmFtZTogJydcclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZUljb246IGZ1bmN0aW9uIChvbGRJY29uKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fY3JlYXRlSWNvbignaWNvbicsIG9sZEljb24pO1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKG9sZEljb24pIHtcclxuXHRcdHJldHVybiB0aGlzLl9jcmVhdGVJY29uKCdzaGFkb3cnLCBvbGRJY29uKTtcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlSWNvbjogZnVuY3Rpb24gKG5hbWUsIG9sZEljb24pIHtcclxuXHRcdHZhciBzcmMgPSB0aGlzLl9nZXRJY29uVXJsKG5hbWUpO1xyXG5cclxuXHRcdGlmICghc3JjKSB7XHJcblx0XHRcdGlmIChuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ2ljb25Vcmwgbm90IHNldCBpbiBJY29uIG9wdGlvbnMgKHNlZSB0aGUgZG9jcykuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG51bGw7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGltZztcclxuXHRcdGlmICghb2xkSWNvbiB8fCBvbGRJY29uLnRhZ05hbWUgIT09ICdJTUcnKSB7XHJcblx0XHRcdGltZyA9IHRoaXMuX2NyZWF0ZUltZyhzcmMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0aW1nID0gdGhpcy5fY3JlYXRlSW1nKHNyYywgb2xkSWNvbik7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zZXRJY29uU3R5bGVzKGltZywgbmFtZSk7XHJcblxyXG5cdFx0cmV0dXJuIGltZztcclxuXHR9LFxyXG5cclxuXHRfc2V0SWNvblN0eWxlczogZnVuY3Rpb24gKGltZywgbmFtZSkge1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgc2l6ZSA9IEwucG9pbnQob3B0aW9uc1tuYW1lICsgJ1NpemUnXSksXHJcblx0XHQgICAgYW5jaG9yO1xyXG5cclxuXHRcdGlmIChuYW1lID09PSAnc2hhZG93Jykge1xyXG5cdFx0XHRhbmNob3IgPSBMLnBvaW50KG9wdGlvbnMuc2hhZG93QW5jaG9yIHx8IG9wdGlvbnMuaWNvbkFuY2hvcik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRhbmNob3IgPSBMLnBvaW50KG9wdGlvbnMuaWNvbkFuY2hvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCFhbmNob3IgJiYgc2l6ZSkge1xyXG5cdFx0XHRhbmNob3IgPSBzaXplLmRpdmlkZUJ5KDIsIHRydWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGltZy5jbGFzc05hbWUgPSAnbGVhZmxldC1tYXJrZXItJyArIG5hbWUgKyAnICcgKyBvcHRpb25zLmNsYXNzTmFtZTtcclxuXHJcblx0XHRpZiAoYW5jaG9yKSB7XHJcblx0XHRcdGltZy5zdHlsZS5tYXJnaW5MZWZ0ID0gKC1hbmNob3IueCkgKyAncHgnO1xyXG5cdFx0XHRpbWcuc3R5bGUubWFyZ2luVG9wICA9ICgtYW5jaG9yLnkpICsgJ3B4JztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoc2l6ZSkge1xyXG5cdFx0XHRpbWcuc3R5bGUud2lkdGggID0gc2l6ZS54ICsgJ3B4JztcclxuXHRcdFx0aW1nLnN0eWxlLmhlaWdodCA9IHNpemUueSArICdweCc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2NyZWF0ZUltZzogZnVuY3Rpb24gKHNyYywgZWwpIHtcclxuXHRcdGVsID0gZWwgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW1nJyk7XHJcblx0XHRlbC5zcmMgPSBzcmM7XHJcblx0XHRyZXR1cm4gZWw7XHJcblx0fSxcclxuXHJcblx0X2dldEljb25Vcmw6IGZ1bmN0aW9uIChuYW1lKSB7XHJcblx0XHRpZiAoTC5Ccm93c2VyLnJldGluYSAmJiB0aGlzLm9wdGlvbnNbbmFtZSArICdSZXRpbmFVcmwnXSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWUgKyAnUmV0aW5hVXJsJ107XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcy5vcHRpb25zW25hbWUgKyAnVXJsJ107XHJcblx0fVxyXG59KTtcclxuXHJcbkwuaWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkljb24ob3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5JY29uLkRlZmF1bHQgaXMgdGhlIGJsdWUgbWFya2VyIGljb24gdXNlZCBieSBkZWZhdWx0IGluIExlYWZsZXQuXHJcbiAqL1xyXG5cclxuTC5JY29uLkRlZmF1bHQgPSBMLkljb24uZXh0ZW5kKHtcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0aWNvblNpemU6IFsyNSwgNDFdLFxyXG5cdFx0aWNvbkFuY2hvcjogWzEyLCA0MV0sXHJcblx0XHRwb3B1cEFuY2hvcjogWzEsIC0zNF0sXHJcblxyXG5cdFx0c2hhZG93U2l6ZTogWzQxLCA0MV1cclxuXHR9LFxyXG5cclxuXHRfZ2V0SWNvblVybDogZnVuY3Rpb24gKG5hbWUpIHtcclxuXHRcdHZhciBrZXkgPSBuYW1lICsgJ1VybCc7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9uc1trZXldKSB7XHJcblx0XHRcdHJldHVybiB0aGlzLm9wdGlvbnNba2V5XTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnJldGluYSAmJiBuYW1lID09PSAnaWNvbicpIHtcclxuXHRcdFx0bmFtZSArPSAnLTJ4JztcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgcGF0aCA9IEwuSWNvbi5EZWZhdWx0LmltYWdlUGF0aDtcclxuXHJcblx0XHRpZiAoIXBhdGgpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZG5cXCd0IGF1dG9kZXRlY3QgTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoLCBzZXQgaXQgbWFudWFsbHkuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHBhdGggKyAnL21hcmtlci0nICsgbmFtZSArICcucG5nJztcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoID0gKGZ1bmN0aW9uICgpIHtcclxuXHR2YXIgc2NyaXB0cyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzY3JpcHQnKSxcclxuXHQgICAgbGVhZmxldFJlID0gL1tcXC9eXWxlYWZsZXRbXFwtXFwuX10/KFtcXHdcXC1cXC5fXSopXFwuanNcXD8/LztcclxuXHJcblx0dmFyIGksIGxlbiwgc3JjLCBtYXRjaGVzLCBwYXRoO1xyXG5cclxuXHRmb3IgKGkgPSAwLCBsZW4gPSBzY3JpcHRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRzcmMgPSBzY3JpcHRzW2ldLnNyYztcclxuXHRcdG1hdGNoZXMgPSBzcmMubWF0Y2gobGVhZmxldFJlKTtcclxuXHJcblx0XHRpZiAobWF0Y2hlcykge1xyXG5cdFx0XHRwYXRoID0gc3JjLnNwbGl0KGxlYWZsZXRSZSlbMF07XHJcblx0XHRcdHJldHVybiAocGF0aCA/IHBhdGggKyAnLycgOiAnJykgKyAnaW1hZ2VzJztcclxuXHRcdH1cclxuXHR9XHJcbn0oKSk7XHJcblxyXG5cclxuLypcclxuICogTC5NYXJrZXIgaXMgdXNlZCB0byBkaXNwbGF5IGNsaWNrYWJsZS9kcmFnZ2FibGUgaWNvbnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLk1hcmtlciA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRvcHRpb25zOiB7XHJcblx0XHRpY29uOiBuZXcgTC5JY29uLkRlZmF1bHQoKSxcclxuXHRcdHRpdGxlOiAnJyxcclxuXHRcdGFsdDogJycsXHJcblx0XHRjbGlja2FibGU6IHRydWUsXHJcblx0XHRkcmFnZ2FibGU6IGZhbHNlLFxyXG5cdFx0a2V5Ym9hcmQ6IHRydWUsXHJcblx0XHR6SW5kZXhPZmZzZXQ6IDAsXHJcblx0XHRvcGFjaXR5OiAxLFxyXG5cdFx0cmlzZU9uSG92ZXI6IGZhbHNlLFxyXG5cdFx0cmlzZU9mZnNldDogMjUwXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGxhdGxuZywgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdG1hcC5vbigndmlld3Jlc2V0JywgdGhpcy51cGRhdGUsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2luaXRJY29uKCk7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cdFx0dGhpcy5maXJlKCdhZGQnKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSB7XHJcblx0XHRcdG1hcC5vbignem9vbWFuaW0nLCB0aGlzLl9hbmltYXRlWm9vbSwgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRpZiAodGhpcy5kcmFnZ2luZykge1xyXG5cdFx0XHR0aGlzLmRyYWdnaW5nLmRpc2FibGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZW1vdmVJY29uKCk7XHJcblx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHJcblx0XHR0aGlzLmZpcmUoJ3JlbW92ZScpO1xyXG5cclxuXHRcdG1hcC5vZmYoe1xyXG5cdFx0XHQndmlld3Jlc2V0JzogdGhpcy51cGRhdGUsXHJcblx0XHRcdCd6b29tYW5pbSc6IHRoaXMuX2FuaW1hdGVab29tXHJcblx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhdGxuZztcclxuXHR9LFxyXG5cclxuXHRzZXRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZyA9IEwubGF0TG5nKGxhdGxuZyk7XHJcblxyXG5cdFx0dGhpcy51cGRhdGUoKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdtb3ZlJywgeyBsYXRsbmc6IHRoaXMuX2xhdGxuZyB9KTtcclxuXHR9LFxyXG5cclxuXHRzZXRaSW5kZXhPZmZzZXQ6IGZ1bmN0aW9uIChvZmZzZXQpIHtcclxuXHRcdHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQgPSBvZmZzZXQ7XHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldEljb246IGZ1bmN0aW9uIChpY29uKSB7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLmljb24gPSBpY29uO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5faW5pdEljb24oKTtcclxuXHRcdFx0dGhpcy51cGRhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5iaW5kUG9wdXAodGhpcy5fcG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2ljb24pIHtcclxuXHRcdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5fbGF0bG5nKS5yb3VuZCgpO1xyXG5cdFx0XHR0aGlzLl9zZXRQb3MocG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdEljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zLFxyXG5cdFx0ICAgIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBhbmltYXRpb24gPSAobWFwLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBtYXAub3B0aW9ucy5tYXJrZXJab29tQW5pbWF0aW9uKSxcclxuXHRcdCAgICBjbGFzc1RvQWRkID0gYW5pbWF0aW9uID8gJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcgOiAnbGVhZmxldC16b29tLWhpZGUnO1xyXG5cclxuXHRcdHZhciBpY29uID0gb3B0aW9ucy5pY29uLmNyZWF0ZUljb24odGhpcy5faWNvbiksXHJcblx0XHRcdGFkZEljb24gPSBmYWxzZTtcclxuXHJcblx0XHQvLyBpZiB3ZSdyZSBub3QgcmV1c2luZyB0aGUgaWNvbiwgcmVtb3ZlIHRoZSBvbGQgb25lIGFuZCBpbml0IG5ldyBvbmVcclxuXHRcdGlmIChpY29uICE9PSB0aGlzLl9pY29uKSB7XHJcblx0XHRcdGlmICh0aGlzLl9pY29uKSB7XHJcblx0XHRcdFx0dGhpcy5fcmVtb3ZlSWNvbigpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGFkZEljb24gPSB0cnVlO1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMudGl0bGUpIHtcclxuXHRcdFx0XHRpY29uLnRpdGxlID0gb3B0aW9ucy50aXRsZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRcclxuXHRcdFx0aWYgKG9wdGlvbnMuYWx0KSB7XHJcblx0XHRcdFx0aWNvbi5hbHQgPSBvcHRpb25zLmFsdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhpY29uLCBjbGFzc1RvQWRkKTtcclxuXHJcblx0XHRpZiAob3B0aW9ucy5rZXlib2FyZCkge1xyXG5cdFx0XHRpY29uLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBpY29uO1xyXG5cclxuXHRcdHRoaXMuX2luaXRJbnRlcmFjdGlvbigpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnJpc2VPbkhvdmVyKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQub24oaWNvbiwgJ21vdXNlb3ZlcicsIHRoaXMuX2JyaW5nVG9Gcm9udCwgdGhpcylcclxuXHRcdFx0XHQub24oaWNvbiwgJ21vdXNlb3V0JywgdGhpcy5fcmVzZXRaSW5kZXgsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBuZXdTaGFkb3cgPSBvcHRpb25zLmljb24uY3JlYXRlU2hhZG93KHRoaXMuX3NoYWRvdyksXHJcblx0XHRcdGFkZFNoYWRvdyA9IGZhbHNlO1xyXG5cclxuXHRcdGlmIChuZXdTaGFkb3cgIT09IHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHR0aGlzLl9yZW1vdmVTaGFkb3coKTtcclxuXHRcdFx0YWRkU2hhZG93ID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93KSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhuZXdTaGFkb3csIGNsYXNzVG9BZGQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fc2hhZG93ID0gbmV3U2hhZG93O1xyXG5cclxuXHJcblx0XHRpZiAob3B0aW9ucy5vcGFjaXR5IDwgMSkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVPcGFjaXR5KCk7XHJcblx0XHR9XHJcblxyXG5cclxuXHRcdHZhciBwYW5lcyA9IHRoaXMuX21hcC5fcGFuZXM7XHJcblxyXG5cdFx0aWYgKGFkZEljb24pIHtcclxuXHRcdFx0cGFuZXMubWFya2VyUGFuZS5hcHBlbmRDaGlsZCh0aGlzLl9pY29uKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAobmV3U2hhZG93ICYmIGFkZFNoYWRvdykge1xyXG5cdFx0XHRwYW5lcy5zaGFkb3dQYW5lLmFwcGVuZENoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3JlbW92ZUljb246IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLm9wdGlvbnMucmlzZU9uSG92ZXIpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQgICAgLm9mZih0aGlzLl9pY29uLCAnbW91c2VvdmVyJywgdGhpcy5fYnJpbmdUb0Zyb250KVxyXG5cdFx0XHQgICAgLm9mZih0aGlzLl9pY29uLCAnbW91c2VvdXQnLCB0aGlzLl9yZXNldFpJbmRleCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbWFwLl9wYW5lcy5tYXJrZXJQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2ljb24pO1xyXG5cclxuXHRcdHRoaXMuX2ljb24gPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9yZW1vdmVTaGFkb3c6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9wYW5lcy5zaGFkb3dQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX3NoYWRvdyk7XHJcblx0XHR9XHJcblx0XHR0aGlzLl9zaGFkb3cgPSBudWxsO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRQb3M6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9pY29uLCBwb3MpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX3NoYWRvdywgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl96SW5kZXggPSBwb3MueSArIHRoaXMub3B0aW9ucy56SW5kZXhPZmZzZXQ7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRaSW5kZXgoKTtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlWkluZGV4OiBmdW5jdGlvbiAob2Zmc2V0KSB7XHJcblx0XHR0aGlzLl9pY29uLnN0eWxlLnpJbmRleCA9IHRoaXMuX3pJbmRleCArIG9mZnNldDtcclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChvcHQpIHtcclxuXHRcdHZhciBwb3MgPSB0aGlzLl9tYXAuX2xhdExuZ1RvTmV3TGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcsIG9wdC56b29tLCBvcHQuY2VudGVyKS5yb3VuZCgpO1xyXG5cclxuXHRcdHRoaXMuX3NldFBvcyhwb3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0SW50ZXJhY3Rpb246IGZ1bmN0aW9uICgpIHtcclxuXHJcblx0XHRpZiAoIXRoaXMub3B0aW9ucy5jbGlja2FibGUpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gVE9ETyByZWZhY3RvciBpbnRvIHNvbWV0aGluZyBzaGFyZWQgd2l0aCBNYXAvUGF0aC9ldGMuIHRvIERSWSBpdCB1cFxyXG5cclxuXHRcdHZhciBpY29uID0gdGhpcy5faWNvbixcclxuXHRcdCAgICBldmVudHMgPSBbJ2RibGNsaWNrJywgJ21vdXNlZG93bicsICdtb3VzZW92ZXInLCAnbW91c2VvdXQnLCAnY29udGV4dG1lbnUnXTtcclxuXHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoaWNvbiwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKGljb24sICdjbGljaycsIHRoaXMuX29uTW91c2VDbGljaywgdGhpcyk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKGljb24sICdrZXlwcmVzcycsIHRoaXMuX29uS2V5UHJlc3MsIHRoaXMpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24oaWNvbiwgZXZlbnRzW2ldLCB0aGlzLl9maXJlTW91c2VFdmVudCwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuSGFuZGxlci5NYXJrZXJEcmFnKSB7XHJcblx0XHRcdHRoaXMuZHJhZ2dpbmcgPSBuZXcgTC5IYW5kbGVyLk1hcmtlckRyYWcodGhpcyk7XHJcblxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmRyYWdnYWJsZSkge1xyXG5cdFx0XHRcdHRoaXMuZHJhZ2dpbmcuZW5hYmxlKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZUNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHdhc0RyYWdnZWQgPSB0aGlzLmRyYWdnaW5nICYmIHRoaXMuZHJhZ2dpbmcubW92ZWQoKTtcclxuXHJcblx0XHRpZiAodGhpcy5oYXNFdmVudExpc3RlbmVycyhlLnR5cGUpIHx8IHdhc0RyYWdnZWQpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHdhc0RyYWdnZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCghdGhpcy5kcmFnZ2luZyB8fCAhdGhpcy5kcmFnZ2luZy5fZW5hYmxlZCkgJiYgdGhpcy5fbWFwLmRyYWdnaW5nICYmIHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZlZCgpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuZmlyZShlLnR5cGUsIHtcclxuXHRcdFx0b3JpZ2luYWxFdmVudDogZSxcclxuXHRcdFx0bGF0bG5nOiB0aGlzLl9sYXRsbmdcclxuXHRcdH0pO1xyXG5cdH0sXHJcblxyXG5cdF9vbktleVByZXNzOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMTMpIHtcclxuXHRcdFx0dGhpcy5maXJlKCdjbGljaycsIHtcclxuXHRcdFx0XHRvcmlnaW5hbEV2ZW50OiBlLFxyXG5cdFx0XHRcdGxhdGxuZzogdGhpcy5fbGF0bG5nXHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGUsXHJcblx0XHRcdGxhdGxuZzogdGhpcy5fbGF0bG5nXHJcblx0XHR9KTtcclxuXHJcblx0XHQvLyBUT0RPIHByb3BlciBjdXN0b20gZXZlbnQgcHJvcGFnYXRpb25cclxuXHRcdC8vIHRoaXMgbGluZSB3aWxsIGFsd2F5cyBiZSBjYWxsZWQgaWYgbWFya2VyIGlzIGluIGEgRmVhdHVyZUdyb3VwXHJcblx0XHRpZiAoZS50eXBlID09PSAnY29udGV4dG1lbnUnICYmIHRoaXMuaGFzRXZlbnRMaXN0ZW5lcnMoZS50eXBlKSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGUudHlwZSAhPT0gJ21vdXNlZG93bicpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdHNldE9wYWNpdHk6IGZ1bmN0aW9uIChvcGFjaXR5KSB7XHJcblx0XHR0aGlzLm9wdGlvbnMub3BhY2l0eSA9IG9wYWNpdHk7XHJcblx0XHRpZiAodGhpcy5fbWFwKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZU9wYWNpdHkoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlT3BhY2l0eTogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5faWNvbiwgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0aWYgKHRoaXMuX3NoYWRvdykge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9zaGFkb3csIHRoaXMub3B0aW9ucy5vcGFjaXR5KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl91cGRhdGVaSW5kZXgodGhpcy5vcHRpb25zLnJpc2VPZmZzZXQpO1xyXG5cdH0sXHJcblxyXG5cdF9yZXNldFpJbmRleDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fdXBkYXRlWkluZGV4KDApO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLm1hcmtlciA9IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTWFya2VyKGxhdGxuZywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5EaXZJY29uIGlzIGEgbGlnaHR3ZWlnaHQgSFRNTC1iYXNlZCBpY29uIGNsYXNzIChhcyBvcHBvc2VkIHRvIHRoZSBpbWFnZS1iYXNlZCBMLkljb24pXHJcbiAqIHRvIHVzZSB3aXRoIEwuTWFya2VyLlxyXG4gKi9cclxuXHJcbkwuRGl2SWNvbiA9IEwuSWNvbi5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdGljb25TaXplOiBbMTIsIDEyXSwgLy8gYWxzbyBjYW4gYmUgc2V0IHRocm91Z2ggQ1NTXHJcblx0XHQvKlxyXG5cdFx0aWNvbkFuY2hvcjogKFBvaW50KVxyXG5cdFx0cG9wdXBBbmNob3I6IChQb2ludClcclxuXHRcdGh0bWw6IChTdHJpbmcpXHJcblx0XHRiZ1BvczogKFBvaW50KVxyXG5cdFx0Ki9cclxuXHRcdGNsYXNzTmFtZTogJ2xlYWZsZXQtZGl2LWljb24nLFxyXG5cdFx0aHRtbDogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRjcmVhdGVJY29uOiBmdW5jdGlvbiAob2xkSWNvbikge1xyXG5cdFx0dmFyIGRpdiA9IChvbGRJY29uICYmIG9sZEljb24udGFnTmFtZSA9PT0gJ0RJVicpID8gb2xkSWNvbiA6IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuaHRtbCAhPT0gZmFsc2UpIHtcclxuXHRcdFx0ZGl2LmlubmVySFRNTCA9IG9wdGlvbnMuaHRtbDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRpdi5pbm5lckhUTUwgPSAnJztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAob3B0aW9ucy5iZ1Bvcykge1xyXG5cdFx0XHRkaXYuc3R5bGUuYmFja2dyb3VuZFBvc2l0aW9uID1cclxuXHRcdFx0ICAgICAgICAoLW9wdGlvbnMuYmdQb3MueCkgKyAncHggJyArICgtb3B0aW9ucy5iZ1Bvcy55KSArICdweCc7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2V0SWNvblN0eWxlcyhkaXYsICdpY29uJyk7XHJcblx0XHRyZXR1cm4gZGl2O1xyXG5cdH0sXHJcblxyXG5cdGNyZWF0ZVNoYWRvdzogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG51bGw7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuZGl2SWNvbiA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkRpdkljb24ob3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5Qb3B1cCBpcyB1c2VkIGZvciBkaXNwbGF5aW5nIHBvcHVwcyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0Y2xvc2VQb3B1cE9uQ2xpY2s6IHRydWVcclxufSk7XHJcblxyXG5MLlBvcHVwID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdGluY2x1ZGVzOiBMLk1peGluLkV2ZW50cyxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0bWluV2lkdGg6IDUwLFxyXG5cdFx0bWF4V2lkdGg6IDMwMCxcclxuXHRcdC8vIG1heEhlaWdodDogbnVsbCxcclxuXHRcdGF1dG9QYW46IHRydWUsXHJcblx0XHRjbG9zZUJ1dHRvbjogdHJ1ZSxcclxuXHRcdG9mZnNldDogWzAsIDddLFxyXG5cdFx0YXV0b1BhblBhZGRpbmc6IFs1LCA1XSxcclxuXHRcdC8vIGF1dG9QYW5QYWRkaW5nVG9wTGVmdDogbnVsbCxcclxuXHRcdC8vIGF1dG9QYW5QYWRkaW5nQm90dG9tUmlnaHQ6IG51bGwsXHJcblx0XHRrZWVwSW5WaWV3OiBmYWxzZSxcclxuXHRcdGNsYXNzTmFtZTogJycsXHJcblx0XHR6b29tQW5pbWF0aW9uOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcclxuXHRcdHRoaXMuX2FuaW1hdGVkID0gTC5Ccm93c2VyLmFueTNkICYmIHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uO1xyXG5cdFx0dGhpcy5faXNPcGVuID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHR0aGlzLl9pbml0TGF5b3V0KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGFuaW1GYWRlID0gbWFwLm9wdGlvbnMuZmFkZUFuaW1hdGlvbjtcclxuXHJcblx0XHRpZiAoYW5pbUZhZGUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHRcdG1hcC5fcGFuZXMucG9wdXBQYW5lLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0bWFwLm9uKHRoaXMuX2dldEV2ZW50cygpLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLnVwZGF0ZSgpO1xyXG5cclxuXHRcdGlmIChhbmltRmFkZSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0T3BhY2l0eSh0aGlzLl9jb250YWluZXIsIDEpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnb3BlbicpO1xyXG5cclxuXHRcdG1hcC5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHJcblx0XHRpZiAodGhpcy5fc291cmNlKSB7XHJcblx0XHRcdHRoaXMuX3NvdXJjZS5maXJlKCdwb3B1cG9wZW4nLCB7cG9wdXA6IHRoaXN9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b3Blbk9uOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAub3BlblBvcHVwKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5fcGFuZXMucG9wdXBQYW5lLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0TC5VdGlsLmZhbHNlRm4odGhpcy5fY29udGFpbmVyLm9mZnNldFdpZHRoKTsgLy8gZm9yY2UgcmVmbG93XHJcblxyXG5cdFx0bWFwLm9mZih0aGlzLl9nZXRFdmVudHMoKSwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKG1hcC5vcHRpb25zLmZhZGVBbmltYXRpb24pIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldE9wYWNpdHkodGhpcy5fY29udGFpbmVyLCAwKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXAgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnY2xvc2UnKTtcclxuXHJcblx0XHRtYXAuZmlyZSgncG9wdXBjbG9zZScsIHtwb3B1cDogdGhpc30pO1xyXG5cclxuXHRcdGlmICh0aGlzLl9zb3VyY2UpIHtcclxuXHRcdFx0dGhpcy5fc291cmNlLmZpcmUoJ3BvcHVwY2xvc2UnLCB7cG9wdXA6IHRoaXN9KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR0aGlzLl9sYXRsbmcgPSBMLmxhdExuZyhsYXRsbmcpO1xyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cdFx0XHR0aGlzLl9hZGp1c3RQYW4oKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xyXG5cdH0sXHJcblxyXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHR0aGlzLl9jb250ZW50ID0gY29udGVudDtcclxuXHRcdHRoaXMudXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHR1cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlQ29udGVudCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlTGF5b3V0KCk7XHJcblx0XHR0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XHJcblxyXG5cdFx0dGhpcy5fYWRqdXN0UGFuKCk7XHJcblx0fSxcclxuXHJcblx0X2dldEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGV2ZW50cyA9IHtcclxuXHRcdFx0dmlld3Jlc2V0OiB0aGlzLl91cGRhdGVQb3NpdGlvblxyXG5cdFx0fTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0ZXZlbnRzLnpvb21hbmltID0gdGhpcy5fem9vbUFuaW1hdGlvbjtcclxuXHRcdH1cclxuXHRcdGlmICgnY2xvc2VPbkNsaWNrJyBpbiB0aGlzLm9wdGlvbnMgPyB0aGlzLm9wdGlvbnMuY2xvc2VPbkNsaWNrIDogdGhpcy5fbWFwLm9wdGlvbnMuY2xvc2VQb3B1cE9uQ2xpY2spIHtcclxuXHRcdFx0ZXZlbnRzLnByZWNsaWNrID0gdGhpcy5fY2xvc2U7XHJcblx0XHR9XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmtlZXBJblZpZXcpIHtcclxuXHRcdFx0ZXZlbnRzLm1vdmVlbmQgPSB0aGlzLl9hZGp1c3RQYW47XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGV2ZW50cztcclxuXHR9LFxyXG5cclxuXHRfY2xvc2U6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmNsb3NlUG9wdXAodGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2luaXRMYXlvdXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwcmVmaXggPSAnbGVhZmxldC1wb3B1cCcsXHJcblx0XHRcdGNvbnRhaW5lckNsYXNzID0gcHJlZml4ICsgJyAnICsgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSArICcgbGVhZmxldC16b29tLScgK1xyXG5cdFx0XHQgICAgICAgICh0aGlzLl9hbmltYXRlZCA/ICdhbmltYXRlZCcgOiAnaGlkZScpLFxyXG5cdFx0XHRjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjb250YWluZXJDbGFzcyksXHJcblx0XHRcdGNsb3NlQnV0dG9uO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xvc2VCdXR0b24pIHtcclxuXHRcdFx0Y2xvc2VCdXR0b24gPSB0aGlzLl9jbG9zZUJ1dHRvbiA9XHJcblx0XHRcdCAgICAgICAgTC5Eb21VdGlsLmNyZWF0ZSgnYScsIHByZWZpeCArICctY2xvc2UtYnV0dG9uJywgY29udGFpbmVyKTtcclxuXHRcdFx0Y2xvc2VCdXR0b24uaHJlZiA9ICcjY2xvc2UnO1xyXG5cdFx0XHRjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSAnJiMyMTU7JztcclxuXHRcdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjbG9zZUJ1dHRvbik7XHJcblxyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKGNsb3NlQnV0dG9uLCAnY2xpY2snLCB0aGlzLl9vbkNsb3NlQnV0dG9uQ2xpY2ssIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB3cmFwcGVyID0gdGhpcy5fd3JhcHBlciA9XHJcblx0XHQgICAgICAgIEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIHByZWZpeCArICctY29udGVudC13cmFwcGVyJywgY29udGFpbmVyKTtcclxuXHRcdEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24od3JhcHBlcik7XHJcblxyXG5cdFx0dGhpcy5fY29udGVudE5vZGUgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLWNvbnRlbnQnLCB3cmFwcGVyKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbih0aGlzLl9jb250ZW50Tm9kZSk7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHdyYXBwZXIsICdjb250ZXh0bWVudScsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHJcblx0XHR0aGlzLl90aXBDb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBwcmVmaXggKyAnLXRpcC1jb250YWluZXInLCBjb250YWluZXIpO1xyXG5cdFx0dGhpcy5fdGlwID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgcHJlZml4ICsgJy10aXAnLCB0aGlzLl90aXBDb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVDb250ZW50OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRlbnQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKHR5cGVvZiB0aGlzLl9jb250ZW50ID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHR0aGlzLl9jb250ZW50Tm9kZS5pbm5lckhUTUwgPSB0aGlzLl9jb250ZW50O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0d2hpbGUgKHRoaXMuX2NvbnRlbnROb2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG5cdFx0XHRcdHRoaXMuX2NvbnRlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRlbnROb2RlLmZpcnN0Q2hpbGQpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX2NvbnRlbnROb2RlLmFwcGVuZENoaWxkKHRoaXMuX2NvbnRlbnQpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maXJlKCdjb250ZW50dXBkYXRlJyk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUxheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRlbnROb2RlLFxyXG5cdFx0ICAgIHN0eWxlID0gY29udGFpbmVyLnN0eWxlO1xyXG5cclxuXHRcdHN0eWxlLndpZHRoID0gJyc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJ25vd3JhcCc7XHJcblxyXG5cdFx0dmFyIHdpZHRoID0gY29udGFpbmVyLm9mZnNldFdpZHRoO1xyXG5cdFx0d2lkdGggPSBNYXRoLm1pbih3aWR0aCwgdGhpcy5vcHRpb25zLm1heFdpZHRoKTtcclxuXHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIHRoaXMub3B0aW9ucy5taW5XaWR0aCk7XHJcblxyXG5cdFx0c3R5bGUud2lkdGggPSAod2lkdGggKyAxKSArICdweCc7XHJcblx0XHRzdHlsZS53aGl0ZVNwYWNlID0gJyc7XHJcblxyXG5cdFx0c3R5bGUuaGVpZ2h0ID0gJyc7XHJcblxyXG5cdFx0dmFyIGhlaWdodCA9IGNvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgbWF4SGVpZ2h0ID0gdGhpcy5vcHRpb25zLm1heEhlaWdodCxcclxuXHRcdCAgICBzY3JvbGxlZENsYXNzID0gJ2xlYWZsZXQtcG9wdXAtc2Nyb2xsZWQnO1xyXG5cclxuXHRcdGlmIChtYXhIZWlnaHQgJiYgaGVpZ2h0ID4gbWF4SGVpZ2h0KSB7XHJcblx0XHRcdHN0eWxlLmhlaWdodCA9IG1heEhlaWdodCArICdweCc7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyhjb250YWluZXIsIHNjcm9sbGVkQ2xhc3MpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGNvbnRhaW5lciwgc2Nyb2xsZWRDbGFzcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXIub2Zmc2V0V2lkdGg7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVBvc2l0aW9uOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcG9zID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpLFxyXG5cdFx0ICAgIGFuaW1hdGVkID0gdGhpcy5fYW5pbWF0ZWQsXHJcblx0XHQgICAgb2Zmc2V0ID0gTC5wb2ludCh0aGlzLm9wdGlvbnMub2Zmc2V0KTtcclxuXHJcblx0XHRpZiAoYW5pbWF0ZWQpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHRoaXMuX2NvbnRhaW5lciwgcG9zKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9jb250YWluZXJCb3R0b20gPSAtb2Zmc2V0LnkgLSAoYW5pbWF0ZWQgPyAwIDogcG9zLnkpO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyTGVmdCA9IC1NYXRoLnJvdW5kKHRoaXMuX2NvbnRhaW5lcldpZHRoIC8gMikgKyBvZmZzZXQueCArIChhbmltYXRlZCA/IDAgOiBwb3MueCk7XHJcblxyXG5cdFx0Ly8gYm90dG9tIHBvc2l0aW9uIHRoZSBwb3B1cCBpbiBjYXNlIHRoZSBoZWlnaHQgb2YgdGhlIHBvcHVwIGNoYW5nZXMgKGltYWdlcyBsb2FkaW5nIGV0YylcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5zdHlsZS5ib3R0b20gPSB0aGlzLl9jb250YWluZXJCb3R0b20gKyAncHgnO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmxlZnQgPSB0aGlzLl9jb250YWluZXJMZWZ0ICsgJ3B4JztcclxuXHR9LFxyXG5cclxuXHRfem9vbUFuaW1hdGlvbjogZnVuY3Rpb24gKG9wdCkge1xyXG5cdFx0dmFyIHBvcyA9IHRoaXMuX21hcC5fbGF0TG5nVG9OZXdMYXllclBvaW50KHRoaXMuX2xhdGxuZywgb3B0Lnpvb20sIG9wdC5jZW50ZXIpO1xyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jb250YWluZXIsIHBvcyk7XHJcblx0fSxcclxuXHJcblx0X2FkanVzdFBhbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLm9wdGlvbnMuYXV0b1BhbikgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGNvbnRhaW5lckhlaWdodCA9IHRoaXMuX2NvbnRhaW5lci5vZmZzZXRIZWlnaHQsXHJcblx0XHQgICAgY29udGFpbmVyV2lkdGggPSB0aGlzLl9jb250YWluZXJXaWR0aCxcclxuXHJcblx0XHQgICAgbGF5ZXJQb3MgPSBuZXcgTC5Qb2ludCh0aGlzLl9jb250YWluZXJMZWZ0LCAtY29udGFpbmVySGVpZ2h0IC0gdGhpcy5fY29udGFpbmVyQm90dG9tKTtcclxuXHJcblx0XHRpZiAodGhpcy5fYW5pbWF0ZWQpIHtcclxuXHRcdFx0bGF5ZXJQb3MuX2FkZChMLkRvbVV0aWwuZ2V0UG9zaXRpb24odGhpcy5fY29udGFpbmVyKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lclBvcyA9IG1hcC5sYXllclBvaW50VG9Db250YWluZXJQb2ludChsYXllclBvcyksXHJcblx0XHQgICAgcGFkZGluZyA9IEwucG9pbnQodGhpcy5vcHRpb25zLmF1dG9QYW5QYWRkaW5nKSxcclxuXHRcdCAgICBwYWRkaW5nVEwgPSBMLnBvaW50KHRoaXMub3B0aW9ucy5hdXRvUGFuUGFkZGluZ1RvcExlZnQgfHwgcGFkZGluZyksXHJcblx0XHQgICAgcGFkZGluZ0JSID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuYXV0b1BhblBhZGRpbmdCb3R0b21SaWdodCB8fCBwYWRkaW5nKSxcclxuXHRcdCAgICBzaXplID0gbWFwLmdldFNpemUoKSxcclxuXHRcdCAgICBkeCA9IDAsXHJcblx0XHQgICAgZHkgPSAwO1xyXG5cclxuXHRcdGlmIChjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoICsgcGFkZGluZ0JSLnggPiBzaXplLngpIHsgLy8gcmlnaHRcclxuXHRcdFx0ZHggPSBjb250YWluZXJQb3MueCArIGNvbnRhaW5lcldpZHRoIC0gc2l6ZS54ICsgcGFkZGluZ0JSLng7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnggLSBkeCAtIHBhZGRpbmdUTC54IDwgMCkgeyAvLyBsZWZ0XHJcblx0XHRcdGR4ID0gY29udGFpbmVyUG9zLnggLSBwYWRkaW5nVEwueDtcclxuXHRcdH1cclxuXHRcdGlmIChjb250YWluZXJQb3MueSArIGNvbnRhaW5lckhlaWdodCArIHBhZGRpbmdCUi55ID4gc2l6ZS55KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRkeSA9IGNvbnRhaW5lclBvcy55ICsgY29udGFpbmVySGVpZ2h0IC0gc2l6ZS55ICsgcGFkZGluZ0JSLnk7XHJcblx0XHR9XHJcblx0XHRpZiAoY29udGFpbmVyUG9zLnkgLSBkeSAtIHBhZGRpbmdUTC55IDwgMCkgeyAvLyB0b3BcclxuXHRcdFx0ZHkgPSBjb250YWluZXJQb3MueSAtIHBhZGRpbmdUTC55O1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChkeCB8fCBkeSkge1xyXG5cdFx0XHRtYXBcclxuXHRcdFx0ICAgIC5maXJlKCdhdXRvcGFuc3RhcnQnKVxyXG5cdFx0XHQgICAgLnBhbkJ5KFtkeCwgZHldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25DbG9zZUJ1dHRvbkNsaWNrOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fY2xvc2UoKTtcclxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5wb3B1cCA9IGZ1bmN0aW9uIChvcHRpb25zLCBzb3VyY2UpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9wdXAob3B0aW9ucywgc291cmNlKTtcclxufTtcclxuXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCwgbGF0bG5nLCBvcHRpb25zKSB7IC8vIChQb3B1cCkgb3IgKFN0cmluZyB8fCBIVE1MRWxlbWVudCwgTGF0TG5nWywgT2JqZWN0XSlcclxuXHRcdHRoaXMuY2xvc2VQb3B1cCgpO1xyXG5cclxuXHRcdGlmICghKHBvcHVwIGluc3RhbmNlb2YgTC5Qb3B1cCkpIHtcclxuXHRcdFx0dmFyIGNvbnRlbnQgPSBwb3B1cDtcclxuXHJcblx0XHRcdHBvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucylcclxuXHRcdFx0ICAgIC5zZXRMYXRMbmcobGF0bG5nKVxyXG5cdFx0XHQgICAgLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblx0XHRwb3B1cC5faXNPcGVuID0gdHJ1ZTtcclxuXHJcblx0XHR0aGlzLl9wb3B1cCA9IHBvcHVwO1xyXG5cdFx0cmV0dXJuIHRoaXMuYWRkTGF5ZXIocG9wdXApO1xyXG5cdH0sXHJcblxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uIChwb3B1cCkge1xyXG5cdFx0aWYgKCFwb3B1cCB8fCBwb3B1cCA9PT0gdGhpcy5fcG9wdXApIHtcclxuXHRcdFx0cG9wdXAgPSB0aGlzLl9wb3B1cDtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHBvcHVwKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlTGF5ZXIocG9wdXApO1xyXG5cdFx0XHRwb3B1cC5faXNPcGVuID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIFBvcHVwIGV4dGVuc2lvbiB0byBMLk1hcmtlciwgYWRkaW5nIHBvcHVwLXJlbGF0ZWQgbWV0aG9kcy5cclxuICovXHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKHtcclxuXHRvcGVuUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCAmJiB0aGlzLl9tYXAgJiYgIXRoaXMuX21hcC5oYXNMYXllcih0aGlzLl9wb3B1cCkpIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0TGF0TG5nKHRoaXMuX2xhdGxuZyk7XHJcblx0XHRcdHRoaXMuX21hcC5vcGVuUG9wdXAodGhpcy5fcG9wdXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGNsb3NlUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5fY2xvc2UoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHRvZ2dsZVBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0aWYgKHRoaXMuX3BvcHVwLl9pc09wZW4pIHtcclxuXHRcdFx0XHR0aGlzLmNsb3NlUG9wdXAoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm9wZW5Qb3B1cCgpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR2YXIgYW5jaG9yID0gTC5wb2ludCh0aGlzLm9wdGlvbnMuaWNvbi5vcHRpb25zLnBvcHVwQW5jaG9yIHx8IFswLCAwXSk7XHJcblxyXG5cdFx0YW5jaG9yID0gYW5jaG9yLmFkZChMLlBvcHVwLnByb3RvdHlwZS5vcHRpb25zLm9mZnNldCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5vZmZzZXQpIHtcclxuXHRcdFx0YW5jaG9yID0gYW5jaG9yLmFkZChvcHRpb25zLm9mZnNldCk7XHJcblx0XHR9XHJcblxyXG5cdFx0b3B0aW9ucyA9IEwuZXh0ZW5kKHtvZmZzZXQ6IGFuY2hvcn0sIG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmICghdGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkKSB7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vbignY2xpY2snLCB0aGlzLnRvZ2dsZVBvcHVwLCB0aGlzKVxyXG5cdFx0XHQgICAgLm9uKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub24oJ21vdmUnLCB0aGlzLl9tb3ZlUG9wdXAsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Qb3B1cCkge1xyXG5cdFx0XHRMLnNldE9wdGlvbnMoY29udGVudCwgb3B0aW9ucyk7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gY29udGVudDtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwID0gbmV3IEwuUG9wdXAob3B0aW9ucywgdGhpcylcclxuXHRcdFx0XHQuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRQb3B1cENvbnRlbnQ6IGZ1bmN0aW9uIChjb250ZW50KSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAuc2V0Q29udGVudChjb250ZW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHVuYmluZFBvcHVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fcG9wdXApIHtcclxuXHRcdFx0dGhpcy5fcG9wdXAgPSBudWxsO1xyXG5cdFx0XHR0aGlzXHJcblx0XHRcdCAgICAub2ZmKCdjbGljaycsIHRoaXMudG9nZ2xlUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub2ZmKCdyZW1vdmUnLCB0aGlzLmNsb3NlUG9wdXAsIHRoaXMpXHJcblx0XHRcdCAgICAub2ZmKCdtb3ZlJywgdGhpcy5fbW92ZVBvcHVwLCB0aGlzKTtcclxuXHRcdFx0dGhpcy5fcG9wdXBIYW5kbGVyc0FkZGVkID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3BvcHVwO1xyXG5cdH0sXHJcblxyXG5cdF9tb3ZlUG9wdXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcoZS5sYXRsbmcpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuICogTC5MYXllckdyb3VwIGlzIGEgY2xhc3MgdG8gY29tYmluZSBzZXZlcmFsIGxheWVycyBpbnRvIG9uZSBzbyB0aGF0XHJcbiAqIHlvdSBjYW4gbWFuaXB1bGF0ZSB0aGUgZ3JvdXAgKGUuZy4gYWRkL3JlbW92ZSBpdCkgYXMgb25lIGxheWVyLlxyXG4gKi9cclxuXHJcbkwuTGF5ZXJHcm91cCA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF5ZXJzKSB7XHJcblx0XHR0aGlzLl9sYXllcnMgPSB7fTtcclxuXHJcblx0XHR2YXIgaSwgbGVuO1xyXG5cclxuXHRcdGlmIChsYXllcnMpIHtcclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRMYXllcihsYXllcnNbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0dmFyIGlkID0gdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0gbGF5ZXI7XHJcblxyXG5cdFx0aWYgKHRoaXMuX21hcCkge1xyXG5cdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIobGF5ZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUxheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdHZhciBpZCA9IGxheWVyIGluIHRoaXMuX2xheWVycyA/IGxheWVyIDogdGhpcy5nZXRMYXllcklkKGxheWVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbWFwICYmIHRoaXMuX2xheWVyc1tpZF0pIHtcclxuXHRcdFx0dGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2xheWVyc1tpZF0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGhhc0xheWVyOiBmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdGlmICghbGF5ZXIpIHsgcmV0dXJuIGZhbHNlOyB9XHJcblxyXG5cdFx0cmV0dXJuIChsYXllciBpbiB0aGlzLl9sYXllcnMgfHwgdGhpcy5nZXRMYXllcklkKGxheWVyKSBpbiB0aGlzLl9sYXllcnMpO1xyXG5cdH0sXHJcblxyXG5cdGNsZWFyTGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLmVhY2hMYXllcih0aGlzLnJlbW92ZUxheWVyLCB0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGludm9rZTogZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcclxuXHRcdCAgICBpLCBsYXllcjtcclxuXHJcblx0XHRmb3IgKGkgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cclxuXHRcdFx0aWYgKGxheWVyW21ldGhvZE5hbWVdKSB7XHJcblx0XHRcdFx0bGF5ZXJbbWV0aG9kTmFtZV0uYXBwbHkobGF5ZXIsIGFyZ3MpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHRcdHRoaXMuZWFjaExheWVyKG1hcC5hZGRMYXllciwgbWFwKTtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIobWFwLnJlbW92ZUxheWVyLCBtYXApO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRhZGRUbzogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLmFkZExheWVyKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0ZWFjaExheWVyOiBmdW5jdGlvbiAobWV0aG9kLCBjb250ZXh0KSB7XHJcblx0XHRmb3IgKHZhciBpIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRtZXRob2QuY2FsbChjb250ZXh0LCB0aGlzLl9sYXllcnNbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uIChpZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xheWVyc1tpZF07XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXJzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbGF5ZXJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0bGF5ZXJzLnB1c2godGhpcy5fbGF5ZXJzW2ldKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBsYXllcnM7XHJcblx0fSxcclxuXHJcblx0c2V0WkluZGV4OiBmdW5jdGlvbiAoekluZGV4KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5pbnZva2UoJ3NldFpJbmRleCcsIHpJbmRleCk7XHJcblx0fSxcclxuXHJcblx0Z2V0TGF5ZXJJZDogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRyZXR1cm4gTC5zdGFtcChsYXllcik7XHJcblx0fVxyXG59KTtcclxuXHJcbkwubGF5ZXJHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuTGF5ZXJHcm91cChsYXllcnMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuRmVhdHVyZUdyb3VwIGV4dGVuZHMgTC5MYXllckdyb3VwIGJ5IGludHJvZHVjaW5nIG1vdXNlIGV2ZW50cyBhbmQgYWRkaXRpb25hbCBtZXRob2RzXHJcbiAqIHNoYXJlZCBiZXR3ZWVuIGEgZ3JvdXAgb2YgaW50ZXJhY3RpdmUgbGF5ZXJzIChsaWtlIHZlY3RvcnMgb3IgbWFya2VycykuXHJcbiAqL1xyXG5cclxuTC5GZWF0dXJlR3JvdXAgPSBMLkxheWVyR3JvdXAuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdHN0YXRpY3M6IHtcclxuXHRcdEVWRU5UUzogJ2NsaWNrIGRibGNsaWNrIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZW1vdmUgY29udGV4dG1lbnUgcG9wdXBvcGVuIHBvcHVwY2xvc2UnXHJcblx0fSxcclxuXHJcblx0YWRkTGF5ZXI6IGZ1bmN0aW9uIChsYXllcikge1xyXG5cdFx0aWYgKHRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgnb24nIGluIGxheWVyKSB7XHJcblx0XHRcdGxheWVyLm9uKEwuRmVhdHVyZUdyb3VwLkVWRU5UUywgdGhpcy5fcHJvcGFnYXRlRXZlbnQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUuYWRkTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwQ29udGVudCAmJiBsYXllci5iaW5kUG9wdXApIHtcclxuXHRcdFx0bGF5ZXIuYmluZFBvcHVwKHRoaXMuX3BvcHVwQ29udGVudCwgdGhpcy5fcG9wdXBPcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcmFkZCcsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRpZiAoIXRoaXMuaGFzTGF5ZXIobGF5ZXIpKSB7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGxheWVyIGluIHRoaXMuX2xheWVycykge1xyXG5cdFx0XHRsYXllciA9IHRoaXMuX2xheWVyc1tsYXllcl07XHJcblx0XHR9XHJcblxyXG5cdFx0bGF5ZXIub2ZmKEwuRmVhdHVyZUdyb3VwLkVWRU5UUywgdGhpcy5fcHJvcGFnYXRlRXZlbnQsIHRoaXMpO1xyXG5cclxuXHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUucmVtb3ZlTGF5ZXIuY2FsbCh0aGlzLCBsYXllcik7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwQ29udGVudCkge1xyXG5cdFx0XHR0aGlzLmludm9rZSgndW5iaW5kUG9wdXAnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5maXJlKCdsYXllcnJlbW92ZScsIHtsYXllcjogbGF5ZXJ9KTtcclxuXHR9LFxyXG5cclxuXHRiaW5kUG9wdXA6IGZ1bmN0aW9uIChjb250ZW50LCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLl9wb3B1cENvbnRlbnQgPSBjb250ZW50O1xyXG5cdFx0dGhpcy5fcG9wdXBPcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYmluZFBvcHVwJywgY29udGVudCwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHQvLyBvcGVuIHBvcHVwIG9uIHRoZSBmaXJzdCBsYXllclxyXG5cdFx0Zm9yICh2YXIgaWQgaW4gdGhpcy5fbGF5ZXJzKSB7XHJcblx0XHRcdHRoaXMuX2xheWVyc1tpZF0ub3BlblBvcHVwKGxhdGxuZyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0cmV0dXJuIHRoaXMuaW52b2tlKCdzZXRTdHlsZScsIHN0eWxlKTtcclxuXHR9LFxyXG5cclxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0Zyb250Jyk7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLmludm9rZSgnYnJpbmdUb0JhY2snKTtcclxuXHR9LFxyXG5cclxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBib3VuZHMgPSBuZXcgTC5MYXRMbmdCb3VuZHMoKTtcclxuXHJcblx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0Ym91bmRzLmV4dGVuZChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyID8gbGF5ZXIuZ2V0TGF0TG5nKCkgOiBsYXllci5nZXRCb3VuZHMoKSk7XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gYm91bmRzO1xyXG5cdH0sXHJcblxyXG5cdF9wcm9wYWdhdGVFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGUgPSBMLmV4dGVuZCh7XHJcblx0XHRcdGxheWVyOiBlLnRhcmdldCxcclxuXHRcdFx0dGFyZ2V0OiB0aGlzXHJcblx0XHR9LCBlKTtcclxuXHRcdHRoaXMuZmlyZShlLnR5cGUsIGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmZlYXR1cmVHcm91cCA9IGZ1bmN0aW9uIChsYXllcnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuRmVhdHVyZUdyb3VwKGxheWVycyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5QYXRoIGlzIGEgYmFzZSBjbGFzcyBmb3IgcmVuZGVyaW5nIHZlY3RvciBwYXRocyBvbiBhIG1hcC4gSW5oZXJpdGVkIGJ5IFBvbHlsaW5lLCBDaXJjbGUsIGV0Yy5cclxuICovXHJcblxyXG5MLlBhdGggPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IFtMLk1peGluLkV2ZW50c10sXHJcblxyXG5cdHN0YXRpY3M6IHtcclxuXHRcdC8vIGhvdyBtdWNoIHRvIGV4dGVuZCB0aGUgY2xpcCBhcmVhIGFyb3VuZCB0aGUgbWFwIHZpZXdcclxuXHRcdC8vIChyZWxhdGl2ZSB0byBpdHMgc2l6ZSwgZS5nLiAwLjUgaXMgaGFsZiB0aGUgc2NyZWVuIGluIGVhY2ggZGlyZWN0aW9uKVxyXG5cdFx0Ly8gc2V0IGl0IHNvIHRoYXQgU1ZHIGVsZW1lbnQgZG9lc24ndCBleGNlZWQgMTI4MHB4ICh2ZWN0b3JzIGZsaWNrZXIgb24gZHJhZ2VuZCBpZiBpdCBpcylcclxuXHRcdENMSVBfUEFERElORzogKGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIG1heCA9IEwuQnJvd3Nlci5tb2JpbGUgPyAxMjgwIDogMjAwMCxcclxuXHRcdFx0ICAgIHRhcmdldCA9IChtYXggLyBNYXRoLm1heCh3aW5kb3cub3V0ZXJXaWR0aCwgd2luZG93Lm91dGVySGVpZ2h0KSAtIDEpIC8gMjtcclxuXHRcdFx0cmV0dXJuIE1hdGgubWF4KDAsIE1hdGgubWluKDAuNSwgdGFyZ2V0KSk7XHJcblx0XHR9KSgpXHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0c3Ryb2tlOiB0cnVlLFxyXG5cdFx0Y29sb3I6ICcjMDAzM2ZmJyxcclxuXHRcdGRhc2hBcnJheTogbnVsbCxcclxuXHRcdGxpbmVDYXA6IG51bGwsXHJcblx0XHRsaW5lSm9pbjogbnVsbCxcclxuXHRcdHdlaWdodDogNSxcclxuXHRcdG9wYWNpdHk6IDAuNSxcclxuXHJcblx0XHRmaWxsOiBmYWxzZSxcclxuXHRcdGZpbGxDb2xvcjogbnVsbCwgLy9zYW1lIGFzIGNvbG9yIGJ5IGRlZmF1bHRcclxuXHRcdGZpbGxPcGFjaXR5OiAwLjIsXHJcblxyXG5cdFx0Y2xpY2thYmxlOiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdGlmICghdGhpcy5fY29udGFpbmVyKSB7XHJcblx0XHRcdHRoaXMuX2luaXRFbGVtZW50cygpO1xyXG5cdFx0XHR0aGlzLl9pbml0RXZlbnRzKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0dGhpcy5fdXBkYXRlUGF0aCgpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fbWFwLl9wYXRoUm9vdC5hcHBlbmRDaGlsZCh0aGlzLl9jb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnYWRkJyk7XHJcblxyXG5cdFx0bWFwLm9uKHtcclxuXHRcdFx0J3ZpZXdyZXNldCc6IHRoaXMucHJvamVjdExhdGxuZ3MsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlUGF0aFxyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcC5hZGRMYXllcih0aGlzKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdG9uUmVtb3ZlOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHRtYXAuX3BhdGhSb290LnJlbW92ZUNoaWxkKHRoaXMuX2NvbnRhaW5lcik7XHJcblxyXG5cdFx0Ly8gTmVlZCB0byBmaXJlIHJlbW92ZSBldmVudCBiZWZvcmUgd2Ugc2V0IF9tYXAgdG8gbnVsbCBhcyB0aGUgZXZlbnQgaG9va3MgbWlnaHQgbmVlZCB0aGUgb2JqZWN0XHJcblx0XHR0aGlzLmZpcmUoJ3JlbW92ZScpO1xyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnZtbCkge1xyXG5cdFx0XHR0aGlzLl9jb250YWluZXIgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xyXG5cdFx0XHR0aGlzLl9maWxsID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHRtYXAub2ZmKHtcclxuXHRcdFx0J3ZpZXdyZXNldCc6IHRoaXMucHJvamVjdExhdGxuZ3MsXHJcblx0XHRcdCdtb3ZlZW5kJzogdGhpcy5fdXBkYXRlUGF0aFxyXG5cdFx0fSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGRvIGFsbCBwcm9qZWN0aW9uIHN0dWZmIGhlcmVcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jb250YWluZXIpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0XHR0aGlzLl91cGRhdGVQYXRoKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0X3VwZGF0ZVBhdGhWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHAgPSBMLlBhdGguQ0xJUF9QQURESU5HLFxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLmdldFNpemUoKSxcclxuXHRcdCAgICBwYW5lUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKHRoaXMuX21hcFBhbmUpLFxyXG5cdFx0ICAgIG1pbiA9IHBhbmVQb3MubXVsdGlwbHlCeSgtMSkuX3N1YnRyYWN0KHNpemUubXVsdGlwbHlCeShwKS5fcm91bmQoKSksXHJcblx0XHQgICAgbWF4ID0gbWluLmFkZChzaXplLm11bHRpcGx5QnkoMSArIHAgKiAyKS5fcm91bmQoKSk7XHJcblxyXG5cdFx0dGhpcy5fcGF0aFZpZXdwb3J0ID0gbmV3IEwuQm91bmRzKG1pbiwgbWF4KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgTC5QYXRoIHdpdGggU1ZHLXNwZWNpZmljIHJlbmRlcmluZyBjb2RlLlxyXG4gKi9cclxuXHJcbkwuUGF0aC5TVkdfTlMgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xyXG5cclxuTC5Ccm93c2VyLnN2ZyA9ICEhKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyAmJiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoTC5QYXRoLlNWR19OUywgJ3N2ZycpLmNyZWF0ZVNWR1JlY3QpO1xyXG5cclxuTC5QYXRoID0gTC5QYXRoLmV4dGVuZCh7XHJcblx0c3RhdGljczoge1xyXG5cdFx0U1ZHOiBMLkJyb3dzZXIuc3ZnXHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX21hcC5fcGF0aFJvb3QsXHJcblx0XHQgICAgcGF0aCA9IHRoaXMuX2NvbnRhaW5lcjtcclxuXHJcblx0XHRpZiAocGF0aCAmJiByb290Lmxhc3RDaGlsZCAhPT0gcGF0aCkge1xyXG5cdFx0XHRyb290LmFwcGVuZENoaWxkKHBhdGgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YnJpbmdUb0JhY2s6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciByb290ID0gdGhpcy5fbWFwLl9wYXRoUm9vdCxcclxuXHRcdCAgICBwYXRoID0gdGhpcy5fY29udGFpbmVyLFxyXG5cdFx0ICAgIGZpcnN0ID0gcm9vdC5maXJzdENoaWxkO1xyXG5cclxuXHRcdGlmIChwYXRoICYmIGZpcnN0ICE9PSBwYXRoKSB7XHJcblx0XHRcdHJvb3QuaW5zZXJ0QmVmb3JlKHBhdGgsIGZpcnN0KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGdldFBhdGhTdHJpbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGZvcm0gcGF0aCBzdHJpbmcgaGVyZVxyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVFbGVtZW50OiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0cmV0dXJuIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhMLlBhdGguU1ZHX05TLCBuYW1lKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEVsZW1lbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9tYXAuX2luaXRQYXRoUm9vdCgpO1xyXG5cdFx0dGhpcy5faW5pdFBhdGgoKTtcclxuXHRcdHRoaXMuX2luaXRTdHlsZSgpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gdGhpcy5fY3JlYXRlRWxlbWVudCgnZycpO1xyXG5cclxuXHRcdHRoaXMuX3BhdGggPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdwYXRoJyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGFzc05hbWUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGgsIHRoaXMub3B0aW9ucy5jbGFzc05hbWUpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5hcHBlbmRDaGlsZCh0aGlzLl9wYXRoKTtcclxuXHR9LFxyXG5cclxuXHRfaW5pdFN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSkge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgJ3JvdW5kJyk7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdmaWxsLXJ1bGUnLCAnZXZlbm9kZCcpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdwb2ludGVyLWV2ZW50cycsIHRoaXMub3B0aW9ucy5wb2ludGVyRXZlbnRzKTtcclxuXHRcdH1cclxuXHRcdGlmICghdGhpcy5vcHRpb25zLmNsaWNrYWJsZSAmJiAhdGhpcy5vcHRpb25zLnBvaW50ZXJFdmVudHMpIHtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3BvaW50ZXItZXZlbnRzJywgJ25vbmUnKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLnN0cm9rZSkge1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgdGhpcy5vcHRpb25zLmNvbG9yKTtcclxuXHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1vcGFjaXR5JywgdGhpcy5vcHRpb25zLm9wYWNpdHkpO1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgdGhpcy5vcHRpb25zLndlaWdodCk7XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuZGFzaEFycmF5KSB7XHJcblx0XHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCB0aGlzLm9wdGlvbnMuZGFzaEFycmF5KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLl9wYXRoLnJlbW92ZUF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMubGluZUNhcCkge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIHRoaXMub3B0aW9ucy5saW5lQ2FwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAodGhpcy5vcHRpb25zLmxpbmVKb2luKSB7XHJcblx0XHRcdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lam9pbicsIHRoaXMub3B0aW9ucy5saW5lSm9pbik7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnbm9uZScpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgdGhpcy5vcHRpb25zLmZpbGxDb2xvciB8fCB0aGlzLm9wdGlvbnMuY29sb3IpO1xyXG5cdFx0XHR0aGlzLl9wYXRoLnNldEF0dHJpYnV0ZSgnZmlsbC1vcGFjaXR5JywgdGhpcy5vcHRpb25zLmZpbGxPcGFjaXR5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3BhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHN0ciA9IHRoaXMuZ2V0UGF0aFN0cmluZygpO1xyXG5cdFx0aWYgKCFzdHIpIHtcclxuXHRcdFx0Ly8gZml4IHdlYmtpdCBlbXB0eSBzdHJpbmcgcGFyc2luZyBidWdcclxuXHRcdFx0c3RyID0gJ00wIDAnO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5fcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBzdHIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIFRPRE8gcmVtb3ZlIGR1cGxpY2F0aW9uIHdpdGggTC5NYXBcclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0aWYgKEwuQnJvd3Nlci5zdmcgfHwgIUwuQnJvd3Nlci52bWwpIHtcclxuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aCwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnY2xpY2snLCB0aGlzLl9vbk1vdXNlQ2xpY2ssIHRoaXMpO1xyXG5cclxuXHRcdFx0dmFyIGV2ZW50cyA9IFsnZGJsY2xpY2snLCAnbW91c2Vkb3duJywgJ21vdXNlb3ZlcicsXHJcblx0XHRcdCAgICAgICAgICAgICAgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsICdjb250ZXh0bWVudSddO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCBldmVudHNbaV0sIHRoaXMuX2ZpcmVNb3VzZUV2ZW50LCB0aGlzKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbk1vdXNlQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwLmRyYWdnaW5nICYmIHRoaXMuX21hcC5kcmFnZ2luZy5tb3ZlZCgpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2ZpcmVNb3VzZUV2ZW50KGUpO1xyXG5cdH0sXHJcblxyXG5cdF9maXJlTW91c2VFdmVudDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghdGhpcy5oYXNFdmVudExpc3RlbmVycyhlLnR5cGUpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgY29udGFpbmVyUG9pbnQgPSBtYXAubW91c2VFdmVudFRvQ29udGFpbmVyUG9pbnQoZSksXHJcblx0XHQgICAgbGF5ZXJQb2ludCA9IG1hcC5jb250YWluZXJQb2ludFRvTGF5ZXJQb2ludChjb250YWluZXJQb2ludCksXHJcblx0XHQgICAgbGF0bG5nID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhsYXllclBvaW50KTtcclxuXHJcblx0XHR0aGlzLmZpcmUoZS50eXBlLCB7XHJcblx0XHRcdGxhdGxuZzogbGF0bG5nLFxyXG5cdFx0XHRsYXllclBvaW50OiBsYXllclBvaW50LFxyXG5cdFx0XHRjb250YWluZXJQb2ludDogY29udGFpbmVyUG9pbnQsXHJcblx0XHRcdG9yaWdpbmFsRXZlbnQ6IGVcclxuXHRcdH0pO1xyXG5cclxuXHRcdGlmIChlLnR5cGUgPT09ICdjb250ZXh0bWVudScpIHtcclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHRcdH1cclxuXHRcdGlmIChlLnR5cGUgIT09ICdtb3VzZW1vdmUnKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX3BhdGhSb290KSB7XHJcblx0XHRcdHRoaXMuX3BhdGhSb290ID0gTC5QYXRoLnByb3RvdHlwZS5fY3JlYXRlRWxlbWVudCgnc3ZnJyk7XHJcblx0XHRcdHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lLmFwcGVuZENoaWxkKHRoaXMuX3BhdGhSb290KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkJyb3dzZXIuYW55M2QpIHtcclxuXHRcdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fcGF0aFJvb3QsICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnKTtcclxuXHJcblx0XHRcdFx0dGhpcy5vbih7XHJcblx0XHRcdFx0XHQnem9vbWFuaW0nOiB0aGlzLl9hbmltYXRlUGF0aFpvb20sXHJcblx0XHRcdFx0XHQnem9vbWVuZCc6IHRoaXMuX2VuZFBhdGhab29tXHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3BhdGhSb290LCAnbGVhZmxldC16b29tLWhpZGUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVN2Z1ZpZXdwb3J0KTtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3ZnVmlld3BvcnQoKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYW5pbWF0ZVBhdGhab29tOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIHNjYWxlID0gdGhpcy5nZXRab29tU2NhbGUoZS56b29tKSxcclxuXHRcdCAgICBvZmZzZXQgPSB0aGlzLl9nZXRDZW50ZXJPZmZzZXQoZS5jZW50ZXIpLl9tdWx0aXBseUJ5KC1zY2FsZSkuX2FkZCh0aGlzLl9wYXRoVmlld3BvcnQubWluKTtcclxuXHJcblx0XHR0aGlzLl9wYXRoUm9vdC5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9XHJcblx0XHQgICAgICAgIEwuRG9tVXRpbC5nZXRUcmFuc2xhdGVTdHJpbmcob2Zmc2V0KSArICcgc2NhbGUoJyArIHNjYWxlICsgJykgJztcclxuXHJcblx0XHR0aGlzLl9wYXRoWm9vbWluZyA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X2VuZFBhdGhab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9wYXRoWm9vbWluZyA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdmdWaWV3cG9ydDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdGlmICh0aGlzLl9wYXRoWm9vbWluZykge1xyXG5cdFx0XHQvLyBEbyBub3QgdXBkYXRlIFNWR3Mgd2hpbGUgYSB6b29tIGFuaW1hdGlvbiBpcyBnb2luZyBvbiBvdGhlcndpc2UgdGhlIGFuaW1hdGlvbiB3aWxsIGJyZWFrLlxyXG5cdFx0XHQvLyBXaGVuIHRoZSB6b29tIGFuaW1hdGlvbiBlbmRzIHdlIHdpbGwgYmUgdXBkYXRlZCBhZ2FpbiBhbnl3YXlcclxuXHRcdFx0Ly8gVGhpcyBmaXhlcyB0aGUgY2FzZSB3aGVyZSB5b3UgZG8gYSBtb21lbnR1bSBtb3ZlIGFuZCB6b29tIHdoaWxlIHRoZSBtb3ZlIGlzIHN0aWxsIG9uZ29pbmcuXHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHJcblx0XHR2YXIgdnAgPSB0aGlzLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbWluID0gdnAubWluLFxyXG5cdFx0ICAgIG1heCA9IHZwLm1heCxcclxuXHRcdCAgICB3aWR0aCA9IG1heC54IC0gbWluLngsXHJcblx0XHQgICAgaGVpZ2h0ID0gbWF4LnkgLSBtaW4ueSxcclxuXHRcdCAgICByb290ID0gdGhpcy5fcGF0aFJvb3QsXHJcblx0XHQgICAgcGFuZSA9IHRoaXMuX3BhbmVzLm92ZXJsYXlQYW5lO1xyXG5cclxuXHRcdC8vIEhhY2sgdG8gbWFrZSBmbGlja2VyIG9uIGRyYWcgZW5kIG9uIG1vYmlsZSB3ZWJraXQgbGVzcyBpcnJpdGF0aW5nXHJcblx0XHRpZiAoTC5Ccm93c2VyLm1vYmlsZVdlYmtpdCkge1xyXG5cdFx0XHRwYW5lLnJlbW92ZUNoaWxkKHJvb3QpO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbihyb290LCBtaW4pO1xyXG5cdFx0cm9vdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgd2lkdGgpO1xyXG5cdFx0cm9vdC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGhlaWdodCk7XHJcblx0XHRyb290LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIFttaW4ueCwgbWluLnksIHdpZHRoLCBoZWlnaHRdLmpvaW4oJyAnKSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5tb2JpbGVXZWJraXQpIHtcclxuXHRcdFx0cGFuZS5hcHBlbmRDaGlsZChyb290KTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIFBvcHVwIGV4dGVuc2lvbiB0byBMLlBhdGggKHBvbHlsaW5lcywgcG9seWdvbnMsIGNpcmNsZXMpLCBhZGRpbmcgcG9wdXAtcmVsYXRlZCBtZXRob2RzLlxyXG4gKi9cclxuXHJcbkwuUGF0aC5pbmNsdWRlKHtcclxuXHJcblx0YmluZFBvcHVwOiBmdW5jdGlvbiAoY29udGVudCwgb3B0aW9ucykge1xyXG5cclxuXHRcdGlmIChjb250ZW50IGluc3RhbmNlb2YgTC5Qb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IGNvbnRlbnQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpZiAoIXRoaXMuX3BvcHVwIHx8IG9wdGlvbnMpIHtcclxuXHRcdFx0XHR0aGlzLl9wb3B1cCA9IG5ldyBMLlBvcHVwKG9wdGlvbnMsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMuX3BvcHVwLnNldENvbnRlbnQoY29udGVudCk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9wb3B1cEhhbmRsZXJzQWRkZWQpIHtcclxuXHRcdFx0dGhpc1xyXG5cdFx0XHQgICAgLm9uKCdjbGljaycsIHRoaXMuX29wZW5Qb3B1cCwgdGhpcylcclxuXHRcdFx0ICAgIC5vbigncmVtb3ZlJywgdGhpcy5jbG9zZVBvcHVwLCB0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IHRydWU7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0dW5iaW5kUG9wdXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wb3B1cCkge1xyXG5cdFx0XHR0aGlzLl9wb3B1cCA9IG51bGw7XHJcblx0XHRcdHRoaXNcclxuXHRcdFx0ICAgIC5vZmYoJ2NsaWNrJywgdGhpcy5fb3BlblBvcHVwKVxyXG5cdFx0XHQgICAgLm9mZigncmVtb3ZlJywgdGhpcy5jbG9zZVBvcHVwKTtcclxuXHJcblx0XHRcdHRoaXMuX3BvcHVwSGFuZGxlcnNBZGRlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b3BlblBvcHVwOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdC8vIG9wZW4gdGhlIHBvcHVwIGZyb20gb25lIG9mIHRoZSBwYXRoJ3MgcG9pbnRzIGlmIG5vdCBzcGVjaWZpZWRcclxuXHRcdFx0bGF0bG5nID0gbGF0bG5nIHx8IHRoaXMuX2xhdGxuZyB8fFxyXG5cdFx0XHQgICAgICAgICB0aGlzLl9sYXRsbmdzW01hdGguZmxvb3IodGhpcy5fbGF0bG5ncy5sZW5ndGggLyAyKV07XHJcblxyXG5cdFx0XHR0aGlzLl9vcGVuUG9wdXAoe2xhdGxuZzogbGF0bG5nfSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0Y2xvc2VQb3B1cDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX3BvcHVwKSB7XHJcblx0XHRcdHRoaXMuX3BvcHVwLl9jbG9zZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X29wZW5Qb3B1cDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX3BvcHVwLnNldExhdExuZyhlLmxhdGxuZyk7XHJcblx0XHR0aGlzLl9tYXAub3BlblBvcHVwKHRoaXMuX3BvcHVwKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIFZlY3RvciByZW5kZXJpbmcgZm9yIElFNi04IHRocm91Z2ggVk1MLlxyXG4gKiBUaGFua3MgdG8gRG1pdHJ5IEJhcmFub3Zza3kgYW5kIGhpcyBSYXBoYWVsIGxpYnJhcnkgZm9yIGluc3BpcmF0aW9uIVxyXG4gKi9cclxuXHJcbkwuQnJvd3Nlci52bWwgPSAhTC5Ccm93c2VyLnN2ZyAmJiAoZnVuY3Rpb24gKCkge1xyXG5cdHRyeSB7XHJcblx0XHR2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRkaXYuaW5uZXJIVE1MID0gJzx2OnNoYXBlIGFkaj1cIjFcIi8+JztcclxuXHJcblx0XHR2YXIgc2hhcGUgPSBkaXYuZmlyc3RDaGlsZDtcclxuXHRcdHNoYXBlLnN0eWxlLmJlaGF2aW9yID0gJ3VybCgjZGVmYXVsdCNWTUwpJztcclxuXHJcblx0XHRyZXR1cm4gc2hhcGUgJiYgKHR5cGVvZiBzaGFwZS5hZGogPT09ICdvYmplY3QnKTtcclxuXHJcblx0fSBjYXRjaCAoZSkge1xyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSgpKTtcclxuXHJcbkwuUGF0aCA9IEwuQnJvd3Nlci5zdmcgfHwgIUwuQnJvd3Nlci52bWwgPyBMLlBhdGggOiBMLlBhdGguZXh0ZW5kKHtcclxuXHRzdGF0aWNzOiB7XHJcblx0XHRWTUw6IHRydWUsXHJcblx0XHRDTElQX1BBRERJTkc6IDAuMDJcclxuXHR9LFxyXG5cclxuXHRfY3JlYXRlRWxlbWVudDogKGZ1bmN0aW9uICgpIHtcclxuXHRcdHRyeSB7XHJcblx0XHRcdGRvY3VtZW50Lm5hbWVzcGFjZXMuYWRkKCdsdm1sJywgJ3VybjpzY2hlbWFzLW1pY3Jvc29mdC1jb206dm1sJyk7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCc8bHZtbDonICsgbmFtZSArICcgY2xhc3M9XCJsdm1sXCI+Jyk7XHJcblx0XHRcdH07XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdHJldHVybiBmdW5jdGlvbiAobmFtZSkge1xyXG5cdFx0XHRcdHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFxyXG5cdFx0XHRcdCAgICAgICAgJzwnICsgbmFtZSArICcgeG1sbnM9XCJ1cm46c2NoZW1hcy1taWNyb3NvZnQuY29tOnZtbFwiIGNsYXNzPVwibHZtbFwiPicpO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH0oKSksXHJcblxyXG5cdF9pbml0UGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3NoYXBlJyk7XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtdm1sLXNoYXBlJyArXHJcblx0XHRcdCh0aGlzLm9wdGlvbnMuY2xhc3NOYW1lID8gJyAnICsgdGhpcy5vcHRpb25zLmNsYXNzTmFtZSA6ICcnKSk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jbGlja2FibGUpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY2xpY2thYmxlJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29udGFpbmVyLmNvb3Jkc2l6ZSA9ICcxIDEnO1xyXG5cclxuXHRcdHRoaXMuX3BhdGggPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdwYXRoJyk7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQodGhpcy5fcGF0aCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwLl9wYXRoUm9vdC5hcHBlbmRDaGlsZChjb250YWluZXIpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0U3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKCk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZVN0eWxlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3Ryb2tlID0gdGhpcy5fc3Ryb2tlLFxyXG5cdFx0ICAgIGZpbGwgPSB0aGlzLl9maWxsLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyO1xyXG5cclxuXHRcdGNvbnRhaW5lci5zdHJva2VkID0gb3B0aW9ucy5zdHJva2U7XHJcblx0XHRjb250YWluZXIuZmlsbGVkID0gb3B0aW9ucy5maWxsO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xyXG5cdFx0XHRpZiAoIXN0cm9rZSkge1xyXG5cdFx0XHRcdHN0cm9rZSA9IHRoaXMuX3N0cm9rZSA9IHRoaXMuX2NyZWF0ZUVsZW1lbnQoJ3N0cm9rZScpO1xyXG5cdFx0XHRcdHN0cm9rZS5lbmRjYXAgPSAncm91bmQnO1xyXG5cdFx0XHRcdGNvbnRhaW5lci5hcHBlbmRDaGlsZChzdHJva2UpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0cm9rZS53ZWlnaHQgPSBvcHRpb25zLndlaWdodCArICdweCc7XHJcblx0XHRcdHN0cm9rZS5jb2xvciA9IG9wdGlvbnMuY29sb3I7XHJcblx0XHRcdHN0cm9rZS5vcGFjaXR5ID0gb3B0aW9ucy5vcGFjaXR5O1xyXG5cclxuXHRcdFx0aWYgKG9wdGlvbnMuZGFzaEFycmF5KSB7XHJcblx0XHRcdFx0c3Ryb2tlLmRhc2hTdHlsZSA9IEwuVXRpbC5pc0FycmF5KG9wdGlvbnMuZGFzaEFycmF5KSA/XHJcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LmpvaW4oJyAnKSA6XHJcblx0XHRcdFx0ICAgIG9wdGlvbnMuZGFzaEFycmF5LnJlcGxhY2UoLyggKiwgKikvZywgJyAnKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdHJva2UuZGFzaFN0eWxlID0gJyc7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnMubGluZUNhcCkge1xyXG5cdFx0XHRcdHN0cm9rZS5lbmRjYXAgPSBvcHRpb25zLmxpbmVDYXAucmVwbGFjZSgnYnV0dCcsICdmbGF0Jyk7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKG9wdGlvbnMubGluZUpvaW4pIHtcclxuXHRcdFx0XHRzdHJva2Uuam9pbnN0eWxlID0gb3B0aW9ucy5saW5lSm9pbjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdH0gZWxzZSBpZiAoc3Ryb2tlKSB7XHJcblx0XHRcdGNvbnRhaW5lci5yZW1vdmVDaGlsZChzdHJva2UpO1xyXG5cdFx0XHR0aGlzLl9zdHJva2UgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbGwpIHtcclxuXHRcdFx0aWYgKCFmaWxsKSB7XHJcblx0XHRcdFx0ZmlsbCA9IHRoaXMuX2ZpbGwgPSB0aGlzLl9jcmVhdGVFbGVtZW50KCdmaWxsJyk7XHJcblx0XHRcdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZpbGwpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZpbGwuY29sb3IgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xyXG5cdFx0XHRmaWxsLm9wYWNpdHkgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xyXG5cclxuXHRcdH0gZWxzZSBpZiAoZmlsbCkge1xyXG5cdFx0XHRjb250YWluZXIucmVtb3ZlQ2hpbGQoZmlsbCk7XHJcblx0XHRcdHRoaXMuX2ZpbGwgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQYXRoOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9jb250YWluZXIuc3R5bGU7XHJcblxyXG5cdFx0c3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuXHRcdHRoaXMuX3BhdGgudiA9IHRoaXMuZ2V0UGF0aFN0cmluZygpICsgJyAnOyAvLyB0aGUgc3BhY2UgZml4ZXMgSUUgZW1wdHkgcGF0aCBzdHJpbmcgYnVnXHJcblx0XHRzdHlsZS5kaXNwbGF5ID0gJyc7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLmluY2x1ZGUoTC5Ccm93c2VyLnN2ZyB8fCAhTC5Ccm93c2VyLnZtbCA/IHt9IDoge1xyXG5cdF9pbml0UGF0aFJvb3Q6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9wYXRoUm9vdCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX3BhdGhSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyb290LmNsYXNzTmFtZSA9ICdsZWFmbGV0LXZtbC1jb250YWluZXInO1xyXG5cdFx0dGhpcy5fcGFuZXMub3ZlcmxheVBhbmUuYXBwZW5kQ2hpbGQocm9vdCk7XHJcblxyXG5cdFx0dGhpcy5vbignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVBhdGhWaWV3cG9ydCk7XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIFZlY3RvciByZW5kZXJpbmcgZm9yIGFsbCBicm93c2VycyB0aGF0IHN1cHBvcnQgY2FudmFzLlxyXG4gKi9cclxuXHJcbkwuQnJvd3Nlci5jYW52YXMgPSAoZnVuY3Rpb24gKCkge1xyXG5cdHJldHVybiAhIWRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLmdldENvbnRleHQ7XHJcbn0oKSk7XHJcblxyXG5MLlBhdGggPSAoTC5QYXRoLlNWRyAmJiAhd2luZG93LkxfUFJFRkVSX0NBTlZBUykgfHwgIUwuQnJvd3Nlci5jYW52YXMgPyBMLlBhdGggOiBMLlBhdGguZXh0ZW5kKHtcclxuXHRzdGF0aWNzOiB7XHJcblx0XHQvL0NMSVBfUEFERElORzogMC4wMiwgLy8gbm90IHN1cmUgaWYgdGhlcmUncyBhIG5lZWQgdG8gc2V0IGl0IHRvIGEgc21hbGwgdmFsdWVcclxuXHRcdENBTlZBUzogdHJ1ZSxcclxuXHRcdFNWRzogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRyZWRyYXc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5wcm9qZWN0TGF0bG5ncygpO1xyXG5cdFx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzZXRTdHlsZTogZnVuY3Rpb24gKHN0eWxlKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgc3R5bGUpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlU3R5bGUoKTtcclxuXHRcdFx0dGhpcy5fcmVxdWVzdFVwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5vZmYoJ3ZpZXdyZXNldCcsIHRoaXMucHJvamVjdExhdGxuZ3MsIHRoaXMpXHJcblx0XHQgICAgLm9mZignbW92ZWVuZCcsIHRoaXMuX3VwZGF0ZVBhdGgsIHRoaXMpO1xyXG5cclxuXHRcdGlmICh0aGlzLm9wdGlvbnMuY2xpY2thYmxlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5vZmYoJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XHJcblx0XHRcdHRoaXMuX21hcC5vZmYoJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9yZXF1ZXN0VXBkYXRlKCk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbnVsbDtcclxuXHR9LFxyXG5cclxuXHRfcmVxdWVzdFVwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21hcCAmJiAhTC5QYXRoLl91cGRhdGVSZXF1ZXN0KSB7XHJcblx0XHRcdEwuUGF0aC5fdXBkYXRlUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX2ZpcmVNYXBNb3ZlRW5kLCB0aGlzLl9tYXApO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9maXJlTWFwTW92ZUVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5QYXRoLl91cGRhdGVSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdHRoaXMuZmlyZSgnbW92ZWVuZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0RWxlbWVudHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5faW5pdFBhdGhSb290KCk7XHJcblx0XHR0aGlzLl9jdHggPSB0aGlzLl9tYXAuX2NhbnZhc0N0eDtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xyXG5cdFx0XHR0aGlzLl9jdHgubGluZVdpZHRoID0gb3B0aW9ucy53ZWlnaHQ7XHJcblx0XHRcdHRoaXMuX2N0eC5zdHJva2VTdHlsZSA9IG9wdGlvbnMuY29sb3I7XHJcblx0XHR9XHJcblx0XHRpZiAob3B0aW9ucy5maWxsKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5maWxsU3R5bGUgPSBvcHRpb25zLmZpbGxDb2xvciB8fCBvcHRpb25zLmNvbG9yO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9kcmF3UGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGksIGosIGxlbiwgbGVuMiwgcG9pbnQsIGRyYXdNZXRob2Q7XHJcblxyXG5cdFx0dGhpcy5fY3R4LmJlZ2luUGF0aCgpO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGZvciAoaiA9IDAsIGxlbjIgPSB0aGlzLl9wYXJ0c1tpXS5sZW5ndGg7IGogPCBsZW4yOyBqKyspIHtcclxuXHRcdFx0XHRwb2ludCA9IHRoaXMuX3BhcnRzW2ldW2pdO1xyXG5cdFx0XHRcdGRyYXdNZXRob2QgPSAoaiA9PT0gMCA/ICdtb3ZlJyA6ICdsaW5lJykgKyAnVG8nO1xyXG5cclxuXHRcdFx0XHR0aGlzLl9jdHhbZHJhd01ldGhvZF0ocG9pbnQueCwgcG9pbnQueSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gVE9ETyByZWZhY3RvciB1Z2x5IGhhY2tcclxuXHRcdFx0aWYgKHRoaXMgaW5zdGFuY2VvZiBMLlBvbHlnb24pIHtcclxuXHRcdFx0XHR0aGlzLl9jdHguY2xvc2VQYXRoKCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gIXRoaXMuX3BhcnRzLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2NoZWNrSWZFbXB0eSgpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBjdHggPSB0aGlzLl9jdHgsXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcclxuXHJcblx0XHR0aGlzLl9kcmF3UGF0aCgpO1xyXG5cdFx0Y3R4LnNhdmUoKTtcclxuXHRcdHRoaXMuX3VwZGF0ZVN0eWxlKCk7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuZmlsbCkge1xyXG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLmZpbGxPcGFjaXR5O1xyXG5cdFx0XHRjdHguZmlsbCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChvcHRpb25zLnN0cm9rZSkge1xyXG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcHRpb25zLm9wYWNpdHk7XHJcblx0XHRcdGN0eC5zdHJva2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHRjdHgucmVzdG9yZSgpO1xyXG5cclxuXHRcdC8vIFRPRE8gb3B0aW1pemF0aW9uOiAxIGZpbGwvc3Ryb2tlIGZvciBhbGwgZmVhdHVyZXMgd2l0aCBlcXVhbCBzdHlsZSBpbnN0ZWFkIG9mIDEgZm9yIGVhY2ggZmVhdHVyZVxyXG5cdH0sXHJcblxyXG5cdF9pbml0RXZlbnRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5vcHRpb25zLmNsaWNrYWJsZSkge1xyXG5cdFx0XHQvLyBUT0RPIGRibGNsaWNrXHJcblx0XHRcdHRoaXMuX21hcC5vbignbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRoaXMpO1xyXG5cdFx0XHR0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fb25DbGljaywgdGhpcyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X29uQ2xpY2s6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAodGhpcy5fY29udGFpbnNQb2ludChlLmxheWVyUG9pbnQpKSB7XHJcblx0XHRcdHRoaXMuZmlyZSgnY2xpY2snLCBlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25Nb3VzZU1vdmU6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCB8fCB0aGlzLl9tYXAuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Ly8gVE9ETyBkb24ndCBkbyBvbiBlYWNoIG1vdmVcclxuXHRcdGlmICh0aGlzLl9jb250YWluc1BvaW50KGUubGF5ZXJQb2ludCkpIHtcclxuXHRcdFx0dGhpcy5fY3R4LmNhbnZhcy5zdHlsZS5jdXJzb3IgPSAncG9pbnRlcic7XHJcblx0XHRcdHRoaXMuX21vdXNlSW5zaWRlID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5maXJlKCdtb3VzZW92ZXInLCBlKTtcclxuXHJcblx0XHR9IGVsc2UgaWYgKHRoaXMuX21vdXNlSW5zaWRlKSB7XHJcblx0XHRcdHRoaXMuX2N0eC5jYW52YXMuc3R5bGUuY3Vyc29yID0gJyc7XHJcblx0XHRcdHRoaXMuX21vdXNlSW5zaWRlID0gZmFsc2U7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW91c2VvdXQnLCBlKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuaW5jbHVkZSgoTC5QYXRoLlNWRyAmJiAhd2luZG93LkxfUFJFRkVSX0NBTlZBUykgfHwgIUwuQnJvd3Nlci5jYW52YXMgPyB7fSA6IHtcclxuXHRfaW5pdFBhdGhSb290OiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgcm9vdCA9IHRoaXMuX3BhdGhSb290LFxyXG5cdFx0ICAgIGN0eDtcclxuXHJcblx0XHRpZiAoIXJvb3QpIHtcclxuXHRcdFx0cm9vdCA9IHRoaXMuX3BhdGhSb290ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XHJcblx0XHRcdHJvb3Quc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG5cdFx0XHRjdHggPSB0aGlzLl9jYW52YXNDdHggPSByb290LmdldENvbnRleHQoJzJkJyk7XHJcblxyXG5cdFx0XHRjdHgubGluZUNhcCA9ICdyb3VuZCc7XHJcblx0XHRcdGN0eC5saW5lSm9pbiA9ICdyb3VuZCc7XHJcblxyXG5cdFx0XHR0aGlzLl9wYW5lcy5vdmVybGF5UGFuZS5hcHBlbmRDaGlsZChyb290KTtcclxuXHJcblx0XHRcdGlmICh0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbikge1xyXG5cdFx0XHRcdHRoaXMuX3BhdGhSb290LmNsYXNzTmFtZSA9ICdsZWFmbGV0LXpvb20tYW5pbWF0ZWQnO1xyXG5cdFx0XHRcdHRoaXMub24oJ3pvb21hbmltJywgdGhpcy5fYW5pbWF0ZVBhdGhab29tKTtcclxuXHRcdFx0XHR0aGlzLm9uKCd6b29tZW5kJywgdGhpcy5fZW5kUGF0aFpvb20pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMub24oJ21vdmVlbmQnLCB0aGlzLl91cGRhdGVDYW52YXNWaWV3cG9ydCk7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZUNhbnZhc1ZpZXdwb3J0KCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZUNhbnZhc1ZpZXdwb3J0OiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBkb24ndCByZWRyYXcgd2hpbGUgem9vbWluZy4gU2VlIF91cGRhdGVTdmdWaWV3cG9ydCBmb3IgbW9yZSBkZXRhaWxzXHJcblx0XHRpZiAodGhpcy5fcGF0aFpvb21pbmcpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLl91cGRhdGVQYXRoVmlld3BvcnQoKTtcclxuXHJcblx0XHR2YXIgdnAgPSB0aGlzLl9wYXRoVmlld3BvcnQsXHJcblx0XHQgICAgbWluID0gdnAubWluLFxyXG5cdFx0ICAgIHNpemUgPSB2cC5tYXguc3VidHJhY3QobWluKSxcclxuXHRcdCAgICByb290ID0gdGhpcy5fcGF0aFJvb3Q7XHJcblxyXG5cdFx0Ly9UT0RPIGNoZWNrIGlmIHRoaXMgd29ya3MgcHJvcGVybHkgb24gbW9iaWxlIHdlYmtpdFxyXG5cdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHJvb3QsIG1pbik7XHJcblx0XHRyb290LndpZHRoID0gc2l6ZS54O1xyXG5cdFx0cm9vdC5oZWlnaHQgPSBzaXplLnk7XHJcblx0XHRyb290LmdldENvbnRleHQoJzJkJykudHJhbnNsYXRlKC1taW4ueCwgLW1pbi55KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuTGluZVV0aWwgY29udGFpbnMgZGlmZmVyZW50IHV0aWxpdHkgZnVuY3Rpb25zIGZvciBsaW5lIHNlZ21lbnRzXHJcbiAqIGFuZCBwb2x5bGluZXMgKGNsaXBwaW5nLCBzaW1wbGlmaWNhdGlvbiwgZGlzdGFuY2VzLCBldGMuKVxyXG4gKi9cclxuXHJcbi8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi8gLy8gYWxsb3cgYml0d2lzZSBvcGVyYXRpb25zIGZvciB0aGlzIGZpbGVcclxuXHJcbkwuTGluZVV0aWwgPSB7XHJcblxyXG5cdC8vIFNpbXBsaWZ5IHBvbHlsaW5lIHdpdGggdmVydGV4IHJlZHVjdGlvbiBhbmQgRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uLlxyXG5cdC8vIEltcHJvdmVzIHJlbmRlcmluZyBwZXJmb3JtYW5jZSBkcmFtYXRpY2FsbHkgYnkgbGVzc2VuaW5nIHRoZSBudW1iZXIgb2YgcG9pbnRzIHRvIGRyYXcuXHJcblxyXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbiAoLypQb2ludFtdKi8gcG9pbnRzLCAvKk51bWJlciovIHRvbGVyYW5jZSkge1xyXG5cdFx0aWYgKCF0b2xlcmFuY2UgfHwgIXBvaW50cy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuIHBvaW50cy5zbGljZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzcVRvbGVyYW5jZSA9IHRvbGVyYW5jZSAqIHRvbGVyYW5jZTtcclxuXHJcblx0XHQvLyBzdGFnZSAxOiB2ZXJ0ZXggcmVkdWN0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9yZWR1Y2VQb2ludHMocG9pbnRzLCBzcVRvbGVyYW5jZSk7XHJcblxyXG5cdFx0Ly8gc3RhZ2UgMjogRG91Z2xhcy1QZXVja2VyIHNpbXBsaWZpY2F0aW9uXHJcblx0XHRwb2ludHMgPSB0aGlzLl9zaW1wbGlmeURQKHBvaW50cywgc3FUb2xlcmFuY2UpO1xyXG5cclxuXHRcdHJldHVybiBwb2ludHM7XHJcblx0fSxcclxuXHJcblx0Ly8gZGlzdGFuY2UgZnJvbSBhIHBvaW50IHRvIGEgc2VnbWVudCBiZXR3ZWVuIHR3byBwb2ludHNcclxuXHRwb2ludFRvU2VnbWVudERpc3RhbmNlOiAgZnVuY3Rpb24gKC8qUG9pbnQqLyBwLCAvKlBvaW50Ki8gcDEsIC8qUG9pbnQqLyBwMikge1xyXG5cdFx0cmV0dXJuIE1hdGguc3FydCh0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpKTtcclxuXHR9LFxyXG5cclxuXHRjbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uICgvKlBvaW50Ki8gcCwgLypQb2ludCovIHAxLCAvKlBvaW50Ki8gcDIpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIpO1xyXG5cdH0sXHJcblxyXG5cdC8vIERvdWdsYXMtUGV1Y2tlciBzaW1wbGlmaWNhdGlvbiwgc2VlIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRG91Z2xhcy1QZXVja2VyX2FsZ29yaXRobVxyXG5cdF9zaW1wbGlmeURQOiBmdW5jdGlvbiAocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xyXG5cclxuXHRcdHZhciBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdFx0ICAgIEFycmF5Q29uc3RydWN0b3IgPSB0eXBlb2YgVWludDhBcnJheSAhPT0gdW5kZWZpbmVkICsgJycgPyBVaW50OEFycmF5IDogQXJyYXksXHJcblx0XHQgICAgbWFya2VycyA9IG5ldyBBcnJheUNvbnN0cnVjdG9yKGxlbik7XHJcblxyXG5cdFx0bWFya2Vyc1swXSA9IG1hcmtlcnNbbGVuIC0gMV0gPSAxO1xyXG5cclxuXHRcdHRoaXMuX3NpbXBsaWZ5RFBTdGVwKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIDAsIGxlbiAtIDEpO1xyXG5cclxuXHRcdHZhciBpLFxyXG5cdFx0ICAgIG5ld1BvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAobWFya2Vyc1tpXSkge1xyXG5cdFx0XHRcdG5ld1BvaW50cy5wdXNoKHBvaW50c1tpXSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gbmV3UG9pbnRzO1xyXG5cdH0sXHJcblxyXG5cdF9zaW1wbGlmeURQU3RlcDogZnVuY3Rpb24gKHBvaW50cywgbWFya2Vycywgc3FUb2xlcmFuY2UsIGZpcnN0LCBsYXN0KSB7XHJcblxyXG5cdFx0dmFyIG1heFNxRGlzdCA9IDAsXHJcblx0XHQgICAgaW5kZXgsIGksIHNxRGlzdDtcclxuXHJcblx0XHRmb3IgKGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdCAtIDE7IGkrKykge1xyXG5cdFx0XHRzcURpc3QgPSB0aGlzLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSwgdHJ1ZSk7XHJcblxyXG5cdFx0XHRpZiAoc3FEaXN0ID4gbWF4U3FEaXN0KSB7XHJcblx0XHRcdFx0aW5kZXggPSBpO1xyXG5cdFx0XHRcdG1heFNxRGlzdCA9IHNxRGlzdDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xyXG5cdFx0XHRtYXJrZXJzW2luZGV4XSA9IDE7XHJcblxyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBmaXJzdCwgaW5kZXgpO1xyXG5cdFx0XHR0aGlzLl9zaW1wbGlmeURQU3RlcChwb2ludHMsIG1hcmtlcnMsIHNxVG9sZXJhbmNlLCBpbmRleCwgbGFzdCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gcmVkdWNlIHBvaW50cyB0aGF0IGFyZSB0b28gY2xvc2UgdG8gZWFjaCBvdGhlciB0byBhIHNpbmdsZSBwb2ludFxyXG5cdF9yZWR1Y2VQb2ludHM6IGZ1bmN0aW9uIChwb2ludHMsIHNxVG9sZXJhbmNlKSB7XHJcblx0XHR2YXIgcmVkdWNlZFBvaW50cyA9IFtwb2ludHNbMF1dO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAxLCBwcmV2ID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmICh0aGlzLl9zcURpc3QocG9pbnRzW2ldLCBwb2ludHNbcHJldl0pID4gc3FUb2xlcmFuY2UpIHtcclxuXHRcdFx0XHRyZWR1Y2VkUG9pbnRzLnB1c2gocG9pbnRzW2ldKTtcclxuXHRcdFx0XHRwcmV2ID0gaTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0aWYgKHByZXYgPCBsZW4gLSAxKSB7XHJcblx0XHRcdHJlZHVjZWRQb2ludHMucHVzaChwb2ludHNbbGVuIC0gMV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlZHVjZWRQb2ludHM7XHJcblx0fSxcclxuXHJcblx0Ly8gQ29oZW4tU3V0aGVybGFuZCBsaW5lIGNsaXBwaW5nIGFsZ29yaXRobS5cclxuXHQvLyBVc2VkIHRvIGF2b2lkIHJlbmRlcmluZyBwYXJ0cyBvZiBhIHBvbHlsaW5lIHRoYXQgYXJlIG5vdCBjdXJyZW50bHkgdmlzaWJsZS5cclxuXHJcblx0Y2xpcFNlZ21lbnQ6IGZ1bmN0aW9uIChhLCBiLCBib3VuZHMsIHVzZUxhc3RDb2RlKSB7XHJcblx0XHR2YXIgY29kZUEgPSB1c2VMYXN0Q29kZSA/IHRoaXMuX2xhc3RDb2RlIDogdGhpcy5fZ2V0Qml0Q29kZShhLCBib3VuZHMpLFxyXG5cdFx0ICAgIGNvZGVCID0gdGhpcy5fZ2V0Qml0Q29kZShiLCBib3VuZHMpLFxyXG5cclxuXHRcdCAgICBjb2RlT3V0LCBwLCBuZXdDb2RlO1xyXG5cclxuXHRcdC8vIHNhdmUgMm5kIGNvZGUgdG8gYXZvaWQgY2FsY3VsYXRpbmcgaXQgb24gdGhlIG5leHQgc2VnbWVudFxyXG5cdFx0dGhpcy5fbGFzdENvZGUgPSBjb2RlQjtcclxuXHJcblx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHQvLyBpZiBhLGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAodHJpdmlhbCBhY2NlcHQpXHJcblx0XHRcdGlmICghKGNvZGVBIHwgY29kZUIpKSB7XHJcblx0XHRcdFx0cmV0dXJuIFthLCBiXTtcclxuXHRcdFx0Ly8gaWYgYSxiIGlzIG91dHNpZGUgdGhlIGNsaXAgd2luZG93ICh0cml2aWFsIHJlamVjdClcclxuXHRcdFx0fSBlbHNlIGlmIChjb2RlQSAmIGNvZGVCKSB7XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHQvLyBvdGhlciBjYXNlc1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGNvZGVPdXQgPSBjb2RlQSB8fCBjb2RlQjtcclxuXHRcdFx0XHRwID0gdGhpcy5fZ2V0RWRnZUludGVyc2VjdGlvbihhLCBiLCBjb2RlT3V0LCBib3VuZHMpO1xyXG5cdFx0XHRcdG5ld0NvZGUgPSB0aGlzLl9nZXRCaXRDb2RlKHAsIGJvdW5kcyk7XHJcblxyXG5cdFx0XHRcdGlmIChjb2RlT3V0ID09PSBjb2RlQSkge1xyXG5cdFx0XHRcdFx0YSA9IHA7XHJcblx0XHRcdFx0XHRjb2RlQSA9IG5ld0NvZGU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGIgPSBwO1xyXG5cdFx0XHRcdFx0Y29kZUIgPSBuZXdDb2RlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9nZXRFZGdlSW50ZXJzZWN0aW9uOiBmdW5jdGlvbiAoYSwgYiwgY29kZSwgYm91bmRzKSB7XHJcblx0XHR2YXIgZHggPSBiLnggLSBhLngsXHJcblx0XHQgICAgZHkgPSBiLnkgLSBhLnksXHJcblx0XHQgICAgbWluID0gYm91bmRzLm1pbixcclxuXHRcdCAgICBtYXggPSBib3VuZHMubWF4O1xyXG5cclxuXHRcdGlmIChjb2RlICYgOCkgeyAvLyB0b3BcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KGEueCArIGR4ICogKG1heC55IC0gYS55KSAvIGR5LCBtYXgueSk7XHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiA0KSB7IC8vIGJvdHRvbVxyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9pbnQoYS54ICsgZHggKiAobWluLnkgLSBhLnkpIC8gZHksIG1pbi55KTtcclxuXHRcdH0gZWxzZSBpZiAoY29kZSAmIDIpIHsgLy8gcmlnaHRcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KG1heC54LCBhLnkgKyBkeSAqIChtYXgueCAtIGEueCkgLyBkeCk7XHJcblx0XHR9IGVsc2UgaWYgKGNvZGUgJiAxKSB7IC8vIGxlZnRcclxuXHRcdFx0cmV0dXJuIG5ldyBMLlBvaW50KG1pbi54LCBhLnkgKyBkeSAqIChtaW4ueCAtIGEueCkgLyBkeCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X2dldEJpdENvZGU6IGZ1bmN0aW9uICgvKlBvaW50Ki8gcCwgYm91bmRzKSB7XHJcblx0XHR2YXIgY29kZSA9IDA7XHJcblxyXG5cdFx0aWYgKHAueCA8IGJvdW5kcy5taW4ueCkgeyAvLyBsZWZ0XHJcblx0XHRcdGNvZGUgfD0gMTtcclxuXHRcdH0gZWxzZSBpZiAocC54ID4gYm91bmRzLm1heC54KSB7IC8vIHJpZ2h0XHJcblx0XHRcdGNvZGUgfD0gMjtcclxuXHRcdH1cclxuXHRcdGlmIChwLnkgPCBib3VuZHMubWluLnkpIHsgLy8gYm90dG9tXHJcblx0XHRcdGNvZGUgfD0gNDtcclxuXHRcdH0gZWxzZSBpZiAocC55ID4gYm91bmRzLm1heC55KSB7IC8vIHRvcFxyXG5cdFx0XHRjb2RlIHw9IDg7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGNvZGU7XHJcblx0fSxcclxuXHJcblx0Ly8gc3F1YXJlIGRpc3RhbmNlICh0byBhdm9pZCB1bm5lY2Vzc2FyeSBNYXRoLnNxcnQgY2FsbHMpXHJcblx0X3NxRGlzdDogZnVuY3Rpb24gKHAxLCBwMikge1xyXG5cdFx0dmFyIGR4ID0gcDIueCAtIHAxLngsXHJcblx0XHQgICAgZHkgPSBwMi55IC0gcDEueTtcclxuXHRcdHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcclxuXHR9LFxyXG5cclxuXHQvLyByZXR1cm4gY2xvc2VzdCBwb2ludCBvbiBzZWdtZW50IG9yIGRpc3RhbmNlIHRvIHRoYXQgcG9pbnRcclxuXHRfc3FDbG9zZXN0UG9pbnRPblNlZ21lbnQ6IGZ1bmN0aW9uIChwLCBwMSwgcDIsIHNxRGlzdCkge1xyXG5cdFx0dmFyIHggPSBwMS54LFxyXG5cdFx0ICAgIHkgPSBwMS55LFxyXG5cdFx0ICAgIGR4ID0gcDIueCAtIHgsXHJcblx0XHQgICAgZHkgPSBwMi55IC0geSxcclxuXHRcdCAgICBkb3QgPSBkeCAqIGR4ICsgZHkgKiBkeSxcclxuXHRcdCAgICB0O1xyXG5cclxuXHRcdGlmIChkb3QgPiAwKSB7XHJcblx0XHRcdHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyBkb3Q7XHJcblxyXG5cdFx0XHRpZiAodCA+IDEpIHtcclxuXHRcdFx0XHR4ID0gcDIueDtcclxuXHRcdFx0XHR5ID0gcDIueTtcclxuXHRcdFx0fSBlbHNlIGlmICh0ID4gMCkge1xyXG5cdFx0XHRcdHggKz0gZHggKiB0O1xyXG5cdFx0XHRcdHkgKz0gZHkgKiB0O1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0ZHggPSBwLnggLSB4O1xyXG5cdFx0ZHkgPSBwLnkgLSB5O1xyXG5cclxuXHRcdHJldHVybiBzcURpc3QgPyBkeCAqIGR4ICsgZHkgKiBkeSA6IG5ldyBMLlBvaW50KHgsIHkpO1xyXG5cdH1cclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLlBvbHlsaW5lIGlzIHVzZWQgdG8gZGlzcGxheSBwb2x5bGluZXMgb24gYSBtYXAuXHJcbiAqL1xyXG5cclxuTC5Qb2x5bGluZSA9IEwuUGF0aC5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBhdGgucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0Ly8gaG93IG11Y2ggdG8gc2ltcGxpZnkgdGhlIHBvbHlsaW5lIG9uIGVhY2ggem9vbSBsZXZlbFxyXG5cdFx0Ly8gbW9yZSA9IGJldHRlciBwZXJmb3JtYW5jZSBhbmQgc21vb3RoZXIgbG9vaywgbGVzcyA9IG1vcmUgYWNjdXJhdGVcclxuXHRcdHNtb290aEZhY3RvcjogMS4wLFxyXG5cdFx0bm9DbGlwOiBmYWxzZVxyXG5cdH0sXHJcblxyXG5cdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9vcmlnaW5hbFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9sYXRsbmdzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRoaXMuX29yaWdpbmFsUG9pbnRzW2ldID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmdzW2ldKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRnZXRQYXRoU3RyaW5nOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gdGhpcy5fcGFydHMubGVuZ3RoLCBzdHIgPSAnJzsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHN0ciArPSB0aGlzLl9nZXRQYXRoUGFydFN0cih0aGlzLl9wYXJ0c1tpXSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyO1xyXG5cdH0sXHJcblxyXG5cdGdldExhdExuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmdzO1xyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XHJcblx0XHR0aGlzLl9sYXRsbmdzID0gdGhpcy5fY29udmVydExhdExuZ3MobGF0bG5ncyk7XHJcblx0XHRyZXR1cm4gdGhpcy5yZWRyYXcoKTtcclxuXHR9LFxyXG5cclxuXHRhZGRMYXRMbmc6IGZ1bmN0aW9uIChsYXRsbmcpIHtcclxuXHRcdHRoaXMuX2xhdGxuZ3MucHVzaChMLmxhdExuZyhsYXRsbmcpKTtcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdHNwbGljZUxhdExuZ3M6IGZ1bmN0aW9uICgpIHsgLy8gKE51bWJlciBpbmRleCwgTnVtYmVyIGhvd01hbnkpXHJcblx0XHR2YXIgcmVtb3ZlZCA9IFtdLnNwbGljZS5hcHBseSh0aGlzLl9sYXRsbmdzLCBhcmd1bWVudHMpO1xyXG5cdFx0dGhpcy5fY29udmVydExhdExuZ3ModGhpcy5fbGF0bG5ncywgdHJ1ZSk7XHJcblx0XHR0aGlzLnJlZHJhdygpO1xyXG5cdFx0cmV0dXJuIHJlbW92ZWQ7XHJcblx0fSxcclxuXHJcblx0Y2xvc2VzdExheWVyUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XHJcblx0XHR2YXIgbWluRGlzdGFuY2UgPSBJbmZpbml0eSwgcGFydHMgPSB0aGlzLl9wYXJ0cywgcDEsIHAyLCBtaW5Qb2ludCA9IG51bGw7XHJcblxyXG5cdFx0Zm9yICh2YXIgaiA9IDAsIGpMZW4gPSBwYXJ0cy5sZW5ndGg7IGogPCBqTGVuOyBqKyspIHtcclxuXHRcdFx0dmFyIHBvaW50cyA9IHBhcnRzW2pdO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0cDEgPSBwb2ludHNbaSAtIDFdO1xyXG5cdFx0XHRcdHAyID0gcG9pbnRzW2ldO1xyXG5cdFx0XHRcdHZhciBzcURpc3QgPSBMLkxpbmVVdGlsLl9zcUNsb3Nlc3RQb2ludE9uU2VnbWVudChwLCBwMSwgcDIsIHRydWUpO1xyXG5cdFx0XHRcdGlmIChzcURpc3QgPCBtaW5EaXN0YW5jZSkge1xyXG5cdFx0XHRcdFx0bWluRGlzdGFuY2UgPSBzcURpc3Q7XHJcblx0XHRcdFx0XHRtaW5Qb2ludCA9IEwuTGluZVV0aWwuX3NxQ2xvc2VzdFBvaW50T25TZWdtZW50KHAsIHAxLCBwMik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRpZiAobWluUG9pbnQpIHtcclxuXHRcdFx0bWluUG9pbnQuZGlzdGFuY2UgPSBNYXRoLnNxcnQobWluRGlzdGFuY2UpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG1pblBvaW50O1xyXG5cdH0sXHJcblxyXG5cdGdldEJvdW5kczogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZ0JvdW5kcyh0aGlzLmdldExhdExuZ3MoKSk7XHJcblx0fSxcclxuXHJcblx0X2NvbnZlcnRMYXRMbmdzOiBmdW5jdGlvbiAobGF0bG5ncywgb3ZlcndyaXRlKSB7XHJcblx0XHR2YXIgaSwgbGVuLCB0YXJnZXQgPSBvdmVyd3JpdGUgPyBsYXRsbmdzIDogW107XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gbGF0bG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRpZiAoTC5VdGlsLmlzQXJyYXkobGF0bG5nc1tpXSkgJiYgdHlwZW9mIGxhdGxuZ3NbaV1bMF0gIT09ICdudW1iZXInKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRhcmdldFtpXSA9IEwubGF0TG5nKGxhdGxuZ3NbaV0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRhcmdldDtcclxuXHR9LFxyXG5cclxuXHRfaW5pdEV2ZW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5faW5pdEV2ZW50cy5jYWxsKHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRQYXRoUGFydFN0cjogZnVuY3Rpb24gKHBvaW50cykge1xyXG5cdFx0dmFyIHJvdW5kID0gTC5QYXRoLlZNTDtcclxuXHJcblx0XHRmb3IgKHZhciBqID0gMCwgbGVuMiA9IHBvaW50cy5sZW5ndGgsIHN0ciA9ICcnLCBwOyBqIDwgbGVuMjsgaisrKSB7XHJcblx0XHRcdHAgPSBwb2ludHNbal07XHJcblx0XHRcdGlmIChyb3VuZCkge1xyXG5cdFx0XHRcdHAuX3JvdW5kKCk7XHJcblx0XHRcdH1cclxuXHRcdFx0c3RyICs9IChqID8gJ0wnIDogJ00nKSArIHAueCArICcgJyArIHAueTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdHI7XHJcblx0fSxcclxuXHJcblx0X2NsaXBQb2ludHM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwb2ludHMgPSB0aGlzLl9vcmlnaW5hbFBvaW50cyxcclxuXHRcdCAgICBsZW4gPSBwb2ludHMubGVuZ3RoLFxyXG5cdFx0ICAgIGksIGssIHNlZ21lbnQ7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHtcclxuXHRcdFx0dGhpcy5fcGFydHMgPSBbcG9pbnRzXTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3BhcnRzID0gW107XHJcblxyXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXHJcblx0XHQgICAgdnAgPSB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCxcclxuXHRcdCAgICBsdSA9IEwuTGluZVV0aWw7XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgayA9IDA7IGkgPCBsZW4gLSAxOyBpKyspIHtcclxuXHRcdFx0c2VnbWVudCA9IGx1LmNsaXBTZWdtZW50KHBvaW50c1tpXSwgcG9pbnRzW2kgKyAxXSwgdnAsIGkpO1xyXG5cdFx0XHRpZiAoIXNlZ21lbnQpIHtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cGFydHNba10gPSBwYXJ0c1trXSB8fCBbXTtcclxuXHRcdFx0cGFydHNba10ucHVzaChzZWdtZW50WzBdKTtcclxuXHJcblx0XHRcdC8vIGlmIHNlZ21lbnQgZ29lcyBvdXQgb2Ygc2NyZWVuLCBvciBpdCdzIHRoZSBsYXN0IG9uZSwgaXQncyB0aGUgZW5kIG9mIHRoZSBsaW5lIHBhcnRcclxuXHRcdFx0aWYgKChzZWdtZW50WzFdICE9PSBwb2ludHNbaSArIDFdKSB8fCAoaSA9PT0gbGVuIC0gMikpIHtcclxuXHRcdFx0XHRwYXJ0c1trXS5wdXNoKHNlZ21lbnRbMV0pO1xyXG5cdFx0XHRcdGsrKztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdC8vIHNpbXBsaWZ5IGVhY2ggY2xpcHBlZCBwYXJ0IG9mIHRoZSBwb2x5bGluZVxyXG5cdF9zaW1wbGlmeVBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBhcnRzID0gdGhpcy5fcGFydHMsXHJcblx0XHQgICAgbHUgPSBMLkxpbmVVdGlsO1xyXG5cclxuXHRcdGZvciAodmFyIGkgPSAwLCBsZW4gPSBwYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwYXJ0c1tpXSA9IGx1LnNpbXBsaWZ5KHBhcnRzW2ldLCB0aGlzLm9wdGlvbnMuc21vb3RoRmFjdG9yKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlUGF0aDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9tYXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fY2xpcFBvaW50cygpO1xyXG5cdFx0dGhpcy5fc2ltcGxpZnlQb2ludHMoKTtcclxuXHJcblx0XHRMLlBhdGgucHJvdG90eXBlLl91cGRhdGVQYXRoLmNhbGwodGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwucG9seWxpbmUgPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLlBvbHlVdGlsIGNvbnRhaW5zIHV0aWxpdHkgZnVuY3Rpb25zIGZvciBwb2x5Z29ucyAoY2xpcHBpbmcsIGV0Yy4pLlxyXG4gKi9cclxuXHJcbi8qanNoaW50IGJpdHdpc2U6ZmFsc2UgKi8gLy8gYWxsb3cgYml0d2lzZSBvcGVyYXRpb25zIGhlcmVcclxuXHJcbkwuUG9seVV0aWwgPSB7fTtcclxuXHJcbi8qXHJcbiAqIFN1dGhlcmxhbmQtSG9kZ2VtYW4gcG9seWdvbiBjbGlwcGluZyBhbGdvcml0aG0uXHJcbiAqIFVzZWQgdG8gYXZvaWQgcmVuZGVyaW5nIHBhcnRzIG9mIGEgcG9seWdvbiB0aGF0IGFyZSBub3QgY3VycmVudGx5IHZpc2libGUuXHJcbiAqL1xyXG5MLlBvbHlVdGlsLmNsaXBQb2x5Z29uID0gZnVuY3Rpb24gKHBvaW50cywgYm91bmRzKSB7XHJcblx0dmFyIGNsaXBwZWRQb2ludHMsXHJcblx0ICAgIGVkZ2VzID0gWzEsIDQsIDIsIDhdLFxyXG5cdCAgICBpLCBqLCBrLFxyXG5cdCAgICBhLCBiLFxyXG5cdCAgICBsZW4sIGVkZ2UsIHAsXHJcblx0ICAgIGx1ID0gTC5MaW5lVXRpbDtcclxuXHJcblx0Zm9yIChpID0gMCwgbGVuID0gcG9pbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRwb2ludHNbaV0uX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwb2ludHNbaV0sIGJvdW5kcyk7XHJcblx0fVxyXG5cclxuXHQvLyBmb3IgZWFjaCBlZGdlIChsZWZ0LCBib3R0b20sIHJpZ2h0LCB0b3ApXHJcblx0Zm9yIChrID0gMDsgayA8IDQ7IGsrKykge1xyXG5cdFx0ZWRnZSA9IGVkZ2VzW2tdO1xyXG5cdFx0Y2xpcHBlZFBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHBvaW50cy5sZW5ndGgsIGogPSBsZW4gLSAxOyBpIDwgbGVuOyBqID0gaSsrKSB7XHJcblx0XHRcdGEgPSBwb2ludHNbaV07XHJcblx0XHRcdGIgPSBwb2ludHNbal07XHJcblxyXG5cdFx0XHQvLyBpZiBhIGlzIGluc2lkZSB0aGUgY2xpcCB3aW5kb3dcclxuXHRcdFx0aWYgKCEoYS5fY29kZSAmIGVkZ2UpKSB7XHJcblx0XHRcdFx0Ly8gaWYgYiBpcyBvdXRzaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBnb2VzIG91dCBvZiBzY3JlZW4pXHJcblx0XHRcdFx0aWYgKGIuX2NvZGUgJiBlZGdlKSB7XHJcblx0XHRcdFx0XHRwID0gbHUuX2dldEVkZ2VJbnRlcnNlY3Rpb24oYiwgYSwgZWRnZSwgYm91bmRzKTtcclxuXHRcdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdFx0Y2xpcHBlZFBvaW50cy5wdXNoKHApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjbGlwcGVkUG9pbnRzLnB1c2goYSk7XHJcblxyXG5cdFx0XHQvLyBlbHNlIGlmIGIgaXMgaW5zaWRlIHRoZSBjbGlwIHdpbmRvdyAoYS0+YiBlbnRlcnMgdGhlIHNjcmVlbilcclxuXHRcdFx0fSBlbHNlIGlmICghKGIuX2NvZGUgJiBlZGdlKSkge1xyXG5cdFx0XHRcdHAgPSBsdS5fZ2V0RWRnZUludGVyc2VjdGlvbihiLCBhLCBlZGdlLCBib3VuZHMpO1xyXG5cdFx0XHRcdHAuX2NvZGUgPSBsdS5fZ2V0Qml0Q29kZShwLCBib3VuZHMpO1xyXG5cdFx0XHRcdGNsaXBwZWRQb2ludHMucHVzaChwKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cG9pbnRzID0gY2xpcHBlZFBvaW50cztcclxuXHR9XHJcblxyXG5cdHJldHVybiBwb2ludHM7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5Qb2x5Z29uIGlzIHVzZWQgdG8gZGlzcGxheSBwb2x5Z29ucyBvbiBhIG1hcC5cclxuICovXHJcblxyXG5MLlBvbHlnb24gPSBMLlBvbHlsaW5lLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0ZmlsbDogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmdzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBvbHlsaW5lLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbGF0bG5ncywgb3B0aW9ucyk7XHJcblx0XHR0aGlzLl9pbml0V2l0aEhvbGVzKGxhdGxuZ3MpO1xyXG5cdH0sXHJcblxyXG5cdF9pbml0V2l0aEhvbGVzOiBmdW5jdGlvbiAobGF0bG5ncykge1xyXG5cdFx0dmFyIGksIGxlbiwgaG9sZTtcclxuXHRcdGlmIChsYXRsbmdzICYmIEwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pICYmICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ251bWJlcicpKSB7XHJcblx0XHRcdHRoaXMuX2xhdGxuZ3MgPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyhsYXRsbmdzWzBdKTtcclxuXHRcdFx0dGhpcy5faG9sZXMgPSBsYXRsbmdzLnNsaWNlKDEpO1xyXG5cclxuXHRcdFx0Zm9yIChpID0gMCwgbGVuID0gdGhpcy5faG9sZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRob2xlID0gdGhpcy5faG9sZXNbaV0gPSB0aGlzLl9jb252ZXJ0TGF0TG5ncyh0aGlzLl9ob2xlc1tpXSk7XHJcblx0XHRcdFx0aWYgKGhvbGVbMF0uZXF1YWxzKGhvbGVbaG9sZS5sZW5ndGggLSAxXSkpIHtcclxuXHRcdFx0XHRcdGhvbGUucG9wKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZmlsdGVyIG91dCBsYXN0IHBvaW50IGlmIGl0cyBlcXVhbCB0byB0aGUgZmlyc3Qgb25lXHJcblx0XHRsYXRsbmdzID0gdGhpcy5fbGF0bG5ncztcclxuXHJcblx0XHRpZiAobGF0bG5ncy5sZW5ndGggPj0gMiAmJiBsYXRsbmdzWzBdLmVxdWFscyhsYXRsbmdzW2xhdGxuZ3MubGVuZ3RoIC0gMV0pKSB7XHJcblx0XHRcdGxhdGxuZ3MucG9wKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuUG9seWxpbmUucHJvdG90eXBlLnByb2plY3RMYXRsbmdzLmNhbGwodGhpcyk7XHJcblxyXG5cdFx0Ly8gcHJvamVjdCBwb2x5Z29uIGhvbGVzIHBvaW50c1xyXG5cdFx0Ly8gVE9ETyBtb3ZlIHRoaXMgbG9naWMgdG8gUG9seWxpbmUgdG8gZ2V0IHJpZCBvZiBkdXBsaWNhdGlvblxyXG5cdFx0dGhpcy5faG9sZVBvaW50cyA9IFtdO1xyXG5cclxuXHRcdGlmICghdGhpcy5faG9sZXMpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGksIGosIGxlbiwgbGVuMjtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9ob2xlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHR0aGlzLl9ob2xlUG9pbnRzW2ldID0gW107XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gdGhpcy5faG9sZXNbaV0ubGVuZ3RoOyBqIDwgbGVuMjsgaisrKSB7XHJcblx0XHRcdFx0dGhpcy5faG9sZVBvaW50c1tpXVtqXSA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQodGhpcy5faG9sZXNbaV1bal0pO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0TGF0TG5nczogZnVuY3Rpb24gKGxhdGxuZ3MpIHtcclxuXHRcdGlmIChsYXRsbmdzICYmIEwuVXRpbC5pc0FycmF5KGxhdGxuZ3NbMF0pICYmICh0eXBlb2YgbGF0bG5nc1swXVswXSAhPT0gJ251bWJlcicpKSB7XHJcblx0XHRcdHRoaXMuX2luaXRXaXRoSG9sZXMobGF0bG5ncyk7XHJcblx0XHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIEwuUG9seWxpbmUucHJvdG90eXBlLnNldExhdExuZ3MuY2FsbCh0aGlzLCBsYXRsbmdzKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfY2xpcFBvaW50czogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHBvaW50cyA9IHRoaXMuX29yaWdpbmFsUG9pbnRzLFxyXG5cdFx0ICAgIG5ld1BhcnRzID0gW107XHJcblxyXG5cdFx0dGhpcy5fcGFydHMgPSBbcG9pbnRzXS5jb25jYXQodGhpcy5faG9sZVBvaW50cyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5ub0NsaXApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHZhciBjbGlwcGVkID0gTC5Qb2x5VXRpbC5jbGlwUG9seWdvbih0aGlzLl9wYXJ0c1tpXSwgdGhpcy5fbWFwLl9wYXRoVmlld3BvcnQpO1xyXG5cdFx0XHRpZiAoY2xpcHBlZC5sZW5ndGgpIHtcclxuXHRcdFx0XHRuZXdQYXJ0cy5wdXNoKGNsaXBwZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fcGFydHMgPSBuZXdQYXJ0cztcclxuXHR9LFxyXG5cclxuXHRfZ2V0UGF0aFBhcnRTdHI6IGZ1bmN0aW9uIChwb2ludHMpIHtcclxuXHRcdHZhciBzdHIgPSBMLlBvbHlsaW5lLnByb3RvdHlwZS5fZ2V0UGF0aFBhcnRTdHIuY2FsbCh0aGlzLCBwb2ludHMpO1xyXG5cdFx0cmV0dXJuIHN0ciArIChMLkJyb3dzZXIuc3ZnID8gJ3onIDogJ3gnKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5wb2x5Z29uID0gZnVuY3Rpb24gKGxhdGxuZ3MsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBDb250YWlucyBMLk11bHRpUG9seWxpbmUgYW5kIEwuTXVsdGlQb2x5Z29uIGxheWVycy5cclxuICovXHJcblxyXG4oZnVuY3Rpb24gKCkge1xyXG5cdGZ1bmN0aW9uIGNyZWF0ZU11bHRpKEtsYXNzKSB7XHJcblxyXG5cdFx0cmV0dXJuIEwuRmVhdHVyZUdyb3VwLmV4dGVuZCh7XHJcblxyXG5cdFx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdFx0XHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cdFx0XHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xyXG5cdFx0XHRcdHRoaXMuc2V0TGF0TG5ncyhsYXRsbmdzKTtcclxuXHRcdFx0fSxcclxuXHJcblx0XHRcdHNldExhdExuZ3M6IGZ1bmN0aW9uIChsYXRsbmdzKSB7XHJcblx0XHRcdFx0dmFyIGkgPSAwLFxyXG5cdFx0XHRcdCAgICBsZW4gPSBsYXRsbmdzLmxlbmd0aDtcclxuXHJcblx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdFx0XHRpZiAoaSA8IGxlbikge1xyXG5cdFx0XHRcdFx0XHRsYXllci5zZXRMYXRMbmdzKGxhdGxuZ3NbaSsrXSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHR0aGlzLnJlbW92ZUxheWVyKGxheWVyKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdFx0d2hpbGUgKGkgPCBsZW4pIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkTGF5ZXIobmV3IEtsYXNzKGxhdGxuZ3NbaSsrXSwgdGhpcy5fb3B0aW9ucykpO1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0cmV0dXJuIHRoaXM7XHJcblx0XHRcdH0sXHJcblxyXG5cdFx0XHRnZXRMYXRMbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRcdFx0dmFyIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0XHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdFx0XHRsYXRsbmdzLnB1c2gobGF5ZXIuZ2V0TGF0TG5ncygpKTtcclxuXHRcdFx0XHR9KTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIGxhdGxuZ3M7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0TC5NdWx0aVBvbHlsaW5lID0gY3JlYXRlTXVsdGkoTC5Qb2x5bGluZSk7XHJcblx0TC5NdWx0aVBvbHlnb24gPSBjcmVhdGVNdWx0aShMLlBvbHlnb24pO1xyXG5cclxuXHRMLm11bHRpUG9seWxpbmUgPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWxpbmUobGF0bG5ncywgb3B0aW9ucyk7XHJcblx0fTtcclxuXHJcblx0TC5tdWx0aVBvbHlnb24gPSBmdW5jdGlvbiAobGF0bG5ncywgb3B0aW9ucykge1xyXG5cdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWdvbihsYXRsbmdzLCBvcHRpb25zKTtcclxuXHR9O1xyXG59KCkpO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuUmVjdGFuZ2xlIGV4dGVuZHMgUG9seWdvbiBhbmQgY3JlYXRlcyBhIHJlY3RhbmdsZSB3aGVuIHBhc3NlZCBhIExhdExuZ0JvdW5kcyBvYmplY3QuXHJcbiAqL1xyXG5cclxuTC5SZWN0YW5nbGUgPSBMLlBvbHlnb24uZXh0ZW5kKHtcclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzLCBvcHRpb25zKSB7XHJcblx0XHRMLlBvbHlnb24ucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCB0aGlzLl9ib3VuZHNUb0xhdExuZ3MobGF0TG5nQm91bmRzKSwgb3B0aW9ucyk7XHJcblx0fSxcclxuXHJcblx0c2V0Qm91bmRzOiBmdW5jdGlvbiAobGF0TG5nQm91bmRzKSB7XHJcblx0XHR0aGlzLnNldExhdExuZ3ModGhpcy5fYm91bmRzVG9MYXRMbmdzKGxhdExuZ0JvdW5kcykpO1xyXG5cdH0sXHJcblxyXG5cdF9ib3VuZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChsYXRMbmdCb3VuZHMpIHtcclxuXHRcdGxhdExuZ0JvdW5kcyA9IEwubGF0TG5nQm91bmRzKGxhdExuZ0JvdW5kcyk7XHJcblx0XHRyZXR1cm4gW1xyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhXZXN0KCksXHJcblx0XHRcdGxhdExuZ0JvdW5kcy5nZXROb3J0aFdlc3QoKSxcclxuXHRcdFx0bGF0TG5nQm91bmRzLmdldE5vcnRoRWFzdCgpLFxyXG5cdFx0XHRsYXRMbmdCb3VuZHMuZ2V0U291dGhFYXN0KClcclxuXHRcdF07XHJcblx0fVxyXG59KTtcclxuXHJcbkwucmVjdGFuZ2xlID0gZnVuY3Rpb24gKGxhdExuZ0JvdW5kcywgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5SZWN0YW5nbGUobGF0TG5nQm91bmRzLCBvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkNpcmNsZSBpcyBhIGNpcmNsZSBvdmVybGF5ICh3aXRoIGEgY2VydGFpbiByYWRpdXMgaW4gbWV0ZXJzKS5cclxuICovXHJcblxyXG5MLkNpcmNsZSA9IEwuUGF0aC5leHRlbmQoe1xyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIHJhZGl1cywgb3B0aW9ucykge1xyXG5cdFx0TC5QYXRoLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdHRoaXMuX21SYWRpdXMgPSByYWRpdXM7XHJcblx0fSxcclxuXHJcblx0b3B0aW9uczoge1xyXG5cdFx0ZmlsbDogdHJ1ZVxyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0dGhpcy5fbGF0bG5nID0gTC5sYXRMbmcobGF0bG5nKTtcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xyXG5cdFx0dGhpcy5fbVJhZGl1cyA9IHJhZGl1cztcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdHByb2plY3RMYXRsbmdzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbG5nUmFkaXVzID0gdGhpcy5fZ2V0TG5nUmFkaXVzKCksXHJcblx0XHQgICAgbGF0bG5nID0gdGhpcy5fbGF0bG5nLFxyXG5cdFx0ICAgIHBvaW50TGVmdCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQoW2xhdGxuZy5sYXQsIGxhdGxuZy5sbmcgLSBsbmdSYWRpdXNdKTtcclxuXHJcblx0XHR0aGlzLl9wb2ludCA9IHRoaXMuX21hcC5sYXRMbmdUb0xheWVyUG9pbnQobGF0bG5nKTtcclxuXHRcdHRoaXMuX3JhZGl1cyA9IE1hdGgubWF4KHRoaXMuX3BvaW50LnggLSBwb2ludExlZnQueCwgMSk7XHJcblx0fSxcclxuXHJcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbG5nUmFkaXVzID0gdGhpcy5fZ2V0TG5nUmFkaXVzKCksXHJcblx0XHQgICAgbGF0UmFkaXVzID0gKHRoaXMuX21SYWRpdXMgLyA0MDA3NTAxNykgKiAzNjAsXHJcblx0XHQgICAgbGF0bG5nID0gdGhpcy5fbGF0bG5nO1xyXG5cclxuXHRcdHJldHVybiBuZXcgTC5MYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgIFtsYXRsbmcubGF0IC0gbGF0UmFkaXVzLCBsYXRsbmcubG5nIC0gbG5nUmFkaXVzXSxcclxuXHRcdCAgICAgICAgW2xhdGxuZy5sYXQgKyBsYXRSYWRpdXMsIGxhdGxuZy5sbmcgKyBsbmdSYWRpdXNdKTtcclxuXHR9LFxyXG5cclxuXHRnZXRMYXRMbmc6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9sYXRsbmc7XHJcblx0fSxcclxuXHJcblx0Z2V0UGF0aFN0cmluZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIHAgPSB0aGlzLl9wb2ludCxcclxuXHRcdCAgICByID0gdGhpcy5fcmFkaXVzO1xyXG5cclxuXHRcdGlmICh0aGlzLl9jaGVja0lmRW1wdHkoKSkge1xyXG5cdFx0XHRyZXR1cm4gJyc7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5zdmcpIHtcclxuXHRcdFx0cmV0dXJuICdNJyArIHAueCArICcsJyArIChwLnkgLSByKSArXHJcblx0XHRcdCAgICAgICAnQScgKyByICsgJywnICsgciArICcsMCwxLDEsJyArXHJcblx0XHRcdCAgICAgICAocC54IC0gMC4xKSArICcsJyArIChwLnkgLSByKSArICcgeic7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRwLl9yb3VuZCgpO1xyXG5cdFx0XHRyID0gTWF0aC5yb3VuZChyKTtcclxuXHRcdFx0cmV0dXJuICdBTCAnICsgcC54ICsgJywnICsgcC55ICsgJyAnICsgciArICcsJyArIHIgKyAnIDAsJyArICg2NTUzNSAqIDM2MCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Z2V0UmFkaXVzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbVJhZGl1cztcclxuXHR9LFxyXG5cclxuXHQvLyBUT0RPIEVhcnRoIGhhcmRjb2RlZCwgbW92ZSBpbnRvIHByb2plY3Rpb24gY29kZSFcclxuXHJcblx0X2dldExhdFJhZGl1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuICh0aGlzLl9tUmFkaXVzIC8gNDAwNzUwMTcpICogMzYwO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRMbmdSYWRpdXM6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9nZXRMYXRSYWRpdXMoKSAvIE1hdGguY29zKEwuTGF0TG5nLkRFR19UT19SQUQgKiB0aGlzLl9sYXRsbmcubGF0KTtcclxuXHR9LFxyXG5cclxuXHRfY2hlY2tJZkVtcHR5OiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21hcCkge1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR2YXIgdnAgPSB0aGlzLl9tYXAuX3BhdGhWaWV3cG9ydCxcclxuXHRcdCAgICByID0gdGhpcy5fcmFkaXVzLFxyXG5cdFx0ICAgIHAgPSB0aGlzLl9wb2ludDtcclxuXHJcblx0XHRyZXR1cm4gcC54IC0gciA+IHZwLm1heC54IHx8IHAueSAtIHIgPiB2cC5tYXgueSB8fFxyXG5cdFx0ICAgICAgIHAueCArIHIgPCB2cC5taW4ueCB8fCBwLnkgKyByIDwgdnAubWluLnk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY2lyY2xlID0gZnVuY3Rpb24gKGxhdGxuZywgcmFkaXVzLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNpcmNsZShsYXRsbmcsIHJhZGl1cywgb3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLypcclxuICogTC5DaXJjbGVNYXJrZXIgaXMgYSBjaXJjbGUgb3ZlcmxheSB3aXRoIGEgcGVybWFuZW50IHBpeGVsIHJhZGl1cy5cclxuICovXHJcblxyXG5MLkNpcmNsZU1hcmtlciA9IEwuQ2lyY2xlLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0cmFkaXVzOiAxMCxcclxuXHRcdHdlaWdodDogMlxyXG5cdH0sXHJcblxyXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIChsYXRsbmcsIG9wdGlvbnMpIHtcclxuXHRcdEwuQ2lyY2xlLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgbGF0bG5nLCBudWxsLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuX3JhZGl1cyA9IHRoaXMub3B0aW9ucy5yYWRpdXM7XHJcblx0fSxcclxuXHJcblx0cHJvamVjdExhdGxuZ3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX3BvaW50ID0gdGhpcy5fbWFwLmxhdExuZ1RvTGF5ZXJQb2ludCh0aGlzLl9sYXRsbmcpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTdHlsZSA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuQ2lyY2xlLnByb3RvdHlwZS5fdXBkYXRlU3R5bGUuY2FsbCh0aGlzKTtcclxuXHRcdHRoaXMuc2V0UmFkaXVzKHRoaXMub3B0aW9ucy5yYWRpdXMpO1xyXG5cdH0sXHJcblxyXG5cdHNldExhdExuZzogZnVuY3Rpb24gKGxhdGxuZykge1xyXG5cdFx0TC5DaXJjbGUucHJvdG90eXBlLnNldExhdExuZy5jYWxsKHRoaXMsIGxhdGxuZyk7XHJcblx0XHRpZiAodGhpcy5fcG9wdXAgJiYgdGhpcy5fcG9wdXAuX2lzT3Blbikge1xyXG5cdFx0XHR0aGlzLl9wb3B1cC5zZXRMYXRMbmcobGF0bG5nKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHNldFJhZGl1czogZnVuY3Rpb24gKHJhZGl1cykge1xyXG5cdFx0dGhpcy5vcHRpb25zLnJhZGl1cyA9IHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcclxuXHRcdHJldHVybiB0aGlzLnJlZHJhdygpO1xyXG5cdH0sXHJcblxyXG5cdGdldFJhZGl1czogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3JhZGl1cztcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jaXJjbGVNYXJrZXIgPSBmdW5jdGlvbiAobGF0bG5nLCBvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNpcmNsZU1hcmtlcihsYXRsbmcsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgTC5Qb2x5bGluZSB0byBiZSBhYmxlIHRvIG1hbnVhbGx5IGRldGVjdCBjbGlja3Mgb24gQ2FudmFzLXJlbmRlcmVkIHBvbHlsaW5lcy5cclxuICovXHJcblxyXG5MLlBvbHlsaW5lLmluY2x1ZGUoIUwuUGF0aC5DQU5WQVMgPyB7fSA6IHtcclxuXHRfY29udGFpbnNQb2ludDogZnVuY3Rpb24gKHAsIGNsb3NlZCkge1xyXG5cdFx0dmFyIGksIGosIGssIGxlbiwgbGVuMiwgZGlzdCwgcGFydCxcclxuXHRcdCAgICB3ID0gdGhpcy5vcHRpb25zLndlaWdodCAvIDI7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHR3ICs9IDEwOyAvLyBwb2x5bGluZSBjbGljayB0b2xlcmFuY2Ugb24gdG91Y2ggZGV2aWNlc1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX3BhcnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHBhcnQgPSB0aGlzLl9wYXJ0c1tpXTtcclxuXHRcdFx0Zm9yIChqID0gMCwgbGVuMiA9IHBhcnQubGVuZ3RoLCBrID0gbGVuMiAtIDE7IGogPCBsZW4yOyBrID0gaisrKSB7XHJcblx0XHRcdFx0aWYgKCFjbG9zZWQgJiYgKGogPT09IDApKSB7XHJcblx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGRpc3QgPSBMLkxpbmVVdGlsLnBvaW50VG9TZWdtZW50RGlzdGFuY2UocCwgcGFydFtrXSwgcGFydFtqXSk7XHJcblxyXG5cdFx0XHRcdGlmIChkaXN0IDw9IHcpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuICogRXh0ZW5kcyBMLlBvbHlnb24gdG8gYmUgYWJsZSB0byBtYW51YWxseSBkZXRlY3QgY2xpY2tzIG9uIENhbnZhcy1yZW5kZXJlZCBwb2x5Z29ucy5cclxuICovXHJcblxyXG5MLlBvbHlnb24uaW5jbHVkZSghTC5QYXRoLkNBTlZBUyA/IHt9IDoge1xyXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbiAocCkge1xyXG5cdFx0dmFyIGluc2lkZSA9IGZhbHNlLFxyXG5cdFx0ICAgIHBhcnQsIHAxLCBwMixcclxuXHRcdCAgICBpLCBqLCBrLFxyXG5cdFx0ICAgIGxlbiwgbGVuMjtcclxuXHJcblx0XHQvLyBUT0RPIG9wdGltaXphdGlvbjogY2hlY2sgaWYgd2l0aGluIGJvdW5kcyBmaXJzdFxyXG5cclxuXHRcdGlmIChMLlBvbHlsaW5lLnByb3RvdHlwZS5fY29udGFpbnNQb2ludC5jYWxsKHRoaXMsIHAsIHRydWUpKSB7XHJcblx0XHRcdC8vIGNsaWNrIG9uIHBvbHlnb24gYm9yZGVyXHJcblx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHJheSBjYXN0aW5nIGFsZ29yaXRobSBmb3IgZGV0ZWN0aW5nIGlmIHBvaW50IGlzIGluIHBvbHlnb25cclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSB0aGlzLl9wYXJ0cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRwYXJ0ID0gdGhpcy5fcGFydHNbaV07XHJcblxyXG5cdFx0XHRmb3IgKGogPSAwLCBsZW4yID0gcGFydC5sZW5ndGgsIGsgPSBsZW4yIC0gMTsgaiA8IGxlbjI7IGsgPSBqKyspIHtcclxuXHRcdFx0XHRwMSA9IHBhcnRbal07XHJcblx0XHRcdFx0cDIgPSBwYXJ0W2tdO1xyXG5cclxuXHRcdFx0XHRpZiAoKChwMS55ID4gcC55KSAhPT0gKHAyLnkgPiBwLnkpKSAmJlxyXG5cdFx0XHRcdFx0XHQocC54IDwgKHAyLnggLSBwMS54KSAqIChwLnkgLSBwMS55KSAvIChwMi55IC0gcDEueSkgKyBwMS54KSkge1xyXG5cdFx0XHRcdFx0aW5zaWRlID0gIWluc2lkZTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gaW5zaWRlO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuICogRXh0ZW5kcyBMLkNpcmNsZSB3aXRoIENhbnZhcy1zcGVjaWZpYyBjb2RlLlxyXG4gKi9cclxuXHJcbkwuQ2lyY2xlLmluY2x1ZGUoIUwuUGF0aC5DQU5WQVMgPyB7fSA6IHtcclxuXHRfZHJhd1BhdGg6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBwID0gdGhpcy5fcG9pbnQ7XHJcblx0XHR0aGlzLl9jdHguYmVnaW5QYXRoKCk7XHJcblx0XHR0aGlzLl9jdHguYXJjKHAueCwgcC55LCB0aGlzLl9yYWRpdXMsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSk7XHJcblx0fSxcclxuXHJcblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uIChwKSB7XHJcblx0XHR2YXIgY2VudGVyID0gdGhpcy5fcG9pbnQsXHJcblx0XHQgICAgdzIgPSB0aGlzLm9wdGlvbnMuc3Ryb2tlID8gdGhpcy5vcHRpb25zLndlaWdodCAvIDIgOiAwO1xyXG5cclxuXHRcdHJldHVybiAocC5kaXN0YW5jZVRvKGNlbnRlcikgPD0gdGhpcy5fcmFkaXVzICsgdzIpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuICogQ2lyY2xlTWFya2VyIGNhbnZhcyBzcGVjaWZpYyBkcmF3aW5nIHBhcnRzLlxyXG4gKi9cclxuXHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoIUwuUGF0aC5DQU5WQVMgPyB7fSA6IHtcclxuXHRfdXBkYXRlU3R5bGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuUGF0aC5wcm90b3R5cGUuX3VwZGF0ZVN0eWxlLmNhbGwodGhpcyk7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkdlb0pTT04gdHVybnMgYW55IEdlb0pTT04gZGF0YSBpbnRvIGEgTGVhZmxldCBsYXllci5cclxuICovXHJcblxyXG5MLkdlb0pTT04gPSBMLkZlYXR1cmVHcm91cC5leHRlbmQoe1xyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdFx0TC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xyXG5cclxuXHRcdHRoaXMuX2xheWVycyA9IHt9O1xyXG5cclxuXHRcdGlmIChnZW9qc29uKSB7XHJcblx0XHRcdHRoaXMuYWRkRGF0YShnZW9qc29uKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRhZGREYXRhOiBmdW5jdGlvbiAoZ2VvanNvbikge1xyXG5cdFx0dmFyIGZlYXR1cmVzID0gTC5VdGlsLmlzQXJyYXkoZ2VvanNvbikgPyBnZW9qc29uIDogZ2VvanNvbi5mZWF0dXJlcyxcclxuXHRcdCAgICBpLCBsZW4sIGZlYXR1cmU7XHJcblxyXG5cdFx0aWYgKGZlYXR1cmVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGZlYXR1cmVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Ly8gT25seSBhZGQgdGhpcyBpZiBnZW9tZXRyeSBvciBnZW9tZXRyaWVzIGFyZSBzZXQgYW5kIG5vdCBudWxsXHJcblx0XHRcdFx0ZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xyXG5cdFx0XHRcdGlmIChmZWF0dXJlLmdlb21ldHJpZXMgfHwgZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmZlYXR1cmVzIHx8IGZlYXR1cmUuY29vcmRpbmF0ZXMpIHtcclxuXHRcdFx0XHRcdHRoaXMuYWRkRGF0YShmZWF0dXJlc1tpXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLmZpbHRlciAmJiAhb3B0aW9ucy5maWx0ZXIoZ2VvanNvbikpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGxheWVyID0gTC5HZW9KU09OLmdlb21ldHJ5VG9MYXllcihnZW9qc29uLCBvcHRpb25zLnBvaW50VG9MYXllciwgb3B0aW9ucy5jb29yZHNUb0xhdExuZywgb3B0aW9ucyk7XHJcblx0XHRsYXllci5mZWF0dXJlID0gTC5HZW9KU09OLmFzRmVhdHVyZShnZW9qc29uKTtcclxuXHJcblx0XHRsYXllci5kZWZhdWx0T3B0aW9ucyA9IGxheWVyLm9wdGlvbnM7XHJcblx0XHR0aGlzLnJlc2V0U3R5bGUobGF5ZXIpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLm9uRWFjaEZlYXR1cmUpIHtcclxuXHRcdFx0b3B0aW9ucy5vbkVhY2hGZWF0dXJlKGdlb2pzb24sIGxheWVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcy5hZGRMYXllcihsYXllcik7XHJcblx0fSxcclxuXHJcblx0cmVzZXRTdHlsZTogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgc3R5bGUgPSB0aGlzLm9wdGlvbnMuc3R5bGU7XHJcblx0XHRpZiAoc3R5bGUpIHtcclxuXHRcdFx0Ly8gcmVzZXQgYW55IGN1c3RvbSBzdHlsZXNcclxuXHRcdFx0TC5VdGlsLmV4dGVuZChsYXllci5vcHRpb25zLCBsYXllci5kZWZhdWx0T3B0aW9ucyk7XHJcblxyXG5cdFx0XHR0aGlzLl9zZXRMYXllclN0eWxlKGxheWVyLCBzdHlsZSk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0c2V0U3R5bGU6IGZ1bmN0aW9uIChzdHlsZSkge1xyXG5cdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdHRoaXMuX3NldExheWVyU3R5bGUobGF5ZXIsIHN0eWxlKTtcclxuXHRcdH0sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF9zZXRMYXllclN0eWxlOiBmdW5jdGlvbiAobGF5ZXIsIHN0eWxlKSB7XHJcblx0XHRpZiAodHlwZW9mIHN0eWxlID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHN0eWxlID0gc3R5bGUobGF5ZXIuZmVhdHVyZSk7XHJcblx0XHR9XHJcblx0XHRpZiAobGF5ZXIuc2V0U3R5bGUpIHtcclxuXHRcdFx0bGF5ZXIuc2V0U3R5bGUoc3R5bGUpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLmV4dGVuZChMLkdlb0pTT04sIHtcclxuXHRnZW9tZXRyeVRvTGF5ZXI6IGZ1bmN0aW9uIChnZW9qc29uLCBwb2ludFRvTGF5ZXIsIGNvb3Jkc1RvTGF0TG5nLCB2ZWN0b3JPcHRpb25zKSB7XHJcblx0XHR2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLnR5cGUgPT09ICdGZWF0dXJlJyA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uLFxyXG5cdFx0ICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzLFxyXG5cdFx0ICAgIGxheWVycyA9IFtdLFxyXG5cdFx0ICAgIGxhdGxuZywgbGF0bG5ncywgaSwgbGVuO1xyXG5cclxuXHRcdGNvb3Jkc1RvTGF0TG5nID0gY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZztcclxuXHJcblx0XHRzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcclxuXHRcdGNhc2UgJ1BvaW50JzpcclxuXHRcdFx0bGF0bG5nID0gY29vcmRzVG9MYXRMbmcoY29vcmRzKTtcclxuXHRcdFx0cmV0dXJuIHBvaW50VG9MYXllciA/IHBvaW50VG9MYXllcihnZW9qc29uLCBsYXRsbmcpIDogbmV3IEwuTWFya2VyKGxhdGxuZyk7XHJcblxyXG5cdFx0Y2FzZSAnTXVsdGlQb2ludCc6XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdGxhdGxuZyA9IGNvb3Jkc1RvTGF0TG5nKGNvb3Jkc1tpXSk7XHJcblx0XHRcdFx0bGF5ZXJzLnB1c2gocG9pbnRUb0xheWVyID8gcG9pbnRUb0xheWVyKGdlb2pzb24sIGxhdGxuZykgOiBuZXcgTC5NYXJrZXIobGF0bG5nKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIG5ldyBMLkZlYXR1cmVHcm91cChsYXllcnMpO1xyXG5cclxuXHRcdGNhc2UgJ0xpbmVTdHJpbmcnOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCAwLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2x5bGluZShsYXRsbmdzLCB2ZWN0b3JPcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdQb2x5Z29uJzpcclxuXHRcdFx0aWYgKGNvb3Jkcy5sZW5ndGggPT09IDIgJiYgIWNvb3Jkc1sxXS5sZW5ndGgpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0XHRcdH1cclxuXHRcdFx0bGF0bG5ncyA9IHRoaXMuY29vcmRzVG9MYXRMbmdzKGNvb3JkcywgMSwgY29vcmRzVG9MYXRMbmcpO1xyXG5cdFx0XHRyZXR1cm4gbmV3IEwuUG9seWdvbihsYXRsbmdzLCB2ZWN0b3JPcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxyXG5cdFx0XHRsYXRsbmdzID0gdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzLCAxLCBjb29yZHNUb0xhdExuZyk7XHJcblx0XHRcdHJldHVybiBuZXcgTC5NdWx0aVBvbHlsaW5lKGxhdGxuZ3MsIHZlY3Rvck9wdGlvbnMpO1xyXG5cclxuXHRcdGNhc2UgJ011bHRpUG9seWdvbic6XHJcblx0XHRcdGxhdGxuZ3MgPSB0aGlzLmNvb3Jkc1RvTGF0TG5ncyhjb29yZHMsIDIsIGNvb3Jkc1RvTGF0TG5nKTtcclxuXHRcdFx0cmV0dXJuIG5ldyBMLk11bHRpUG9seWdvbihsYXRsbmdzLCB2ZWN0b3JPcHRpb25zKTtcclxuXHJcblx0XHRjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOlxyXG5cdFx0XHRmb3IgKGkgPSAwLCBsZW4gPSBnZW9tZXRyeS5nZW9tZXRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblxyXG5cdFx0XHRcdGxheWVycy5wdXNoKHRoaXMuZ2VvbWV0cnlUb0xheWVyKHtcclxuXHRcdFx0XHRcdGdlb21ldHJ5OiBnZW9tZXRyeS5nZW9tZXRyaWVzW2ldLFxyXG5cdFx0XHRcdFx0dHlwZTogJ0ZlYXR1cmUnLFxyXG5cdFx0XHRcdFx0cHJvcGVydGllczogZ2VvanNvbi5wcm9wZXJ0aWVzXHJcblx0XHRcdFx0fSwgcG9pbnRUb0xheWVyLCBjb29yZHNUb0xhdExuZywgdmVjdG9yT3B0aW9ucykpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBuZXcgTC5GZWF0dXJlR3JvdXAobGF5ZXJzKTtcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgR2VvSlNPTiBvYmplY3QuJyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Y29vcmRzVG9MYXRMbmc6IGZ1bmN0aW9uIChjb29yZHMpIHsgLy8gKEFycmF5WywgQm9vbGVhbl0pIC0+IExhdExuZ1xyXG5cdFx0cmV0dXJuIG5ldyBMLkxhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSwgY29vcmRzWzJdKTtcclxuXHR9LFxyXG5cclxuXHRjb29yZHNUb0xhdExuZ3M6IGZ1bmN0aW9uIChjb29yZHMsIGxldmVsc0RlZXAsIGNvb3Jkc1RvTGF0TG5nKSB7IC8vIChBcnJheVssIE51bWJlciwgRnVuY3Rpb25dKSAtPiBBcnJheVxyXG5cdFx0dmFyIGxhdGxuZywgaSwgbGVuLFxyXG5cdFx0ICAgIGxhdGxuZ3MgPSBbXTtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb29yZHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0bGF0bG5nID0gbGV2ZWxzRGVlcCA/XHJcblx0XHRcdCAgICAgICAgdGhpcy5jb29yZHNUb0xhdExuZ3MoY29vcmRzW2ldLCBsZXZlbHNEZWVwIC0gMSwgY29vcmRzVG9MYXRMbmcpIDpcclxuXHRcdFx0ICAgICAgICAoY29vcmRzVG9MYXRMbmcgfHwgdGhpcy5jb29yZHNUb0xhdExuZykoY29vcmRzW2ldKTtcclxuXHJcblx0XHRcdGxhdGxuZ3MucHVzaChsYXRsbmcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBsYXRsbmdzO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ1RvQ29vcmRzOiBmdW5jdGlvbiAobGF0bG5nKSB7XHJcblx0XHR2YXIgY29vcmRzID0gW2xhdGxuZy5sbmcsIGxhdGxuZy5sYXRdO1xyXG5cclxuXHRcdGlmIChsYXRsbmcuYWx0ICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0Y29vcmRzLnB1c2gobGF0bG5nLmFsdCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gY29vcmRzO1xyXG5cdH0sXHJcblxyXG5cdGxhdExuZ3NUb0Nvb3JkczogZnVuY3Rpb24gKGxhdExuZ3MpIHtcclxuXHRcdHZhciBjb29yZHMgPSBbXTtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gMCwgbGVuID0gbGF0TG5ncy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRjb29yZHMucHVzaChMLkdlb0pTT04ubGF0TG5nVG9Db29yZHMobGF0TG5nc1tpXSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBjb29yZHM7XHJcblx0fSxcclxuXHJcblx0Z2V0RmVhdHVyZTogZnVuY3Rpb24gKGxheWVyLCBuZXdHZW9tZXRyeSkge1xyXG5cdFx0cmV0dXJuIGxheWVyLmZlYXR1cmUgPyBMLmV4dGVuZCh7fSwgbGF5ZXIuZmVhdHVyZSwge2dlb21ldHJ5OiBuZXdHZW9tZXRyeX0pIDogTC5HZW9KU09OLmFzRmVhdHVyZShuZXdHZW9tZXRyeSk7XHJcblx0fSxcclxuXHJcblx0YXNGZWF0dXJlOiBmdW5jdGlvbiAoZ2VvSlNPTikge1xyXG5cdFx0aWYgKGdlb0pTT04udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XHJcblx0XHRcdHJldHVybiBnZW9KU09OO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB7XHJcblx0XHRcdHR5cGU6ICdGZWF0dXJlJyxcclxuXHRcdFx0cHJvcGVydGllczoge30sXHJcblx0XHRcdGdlb21ldHJ5OiBnZW9KU09OXHJcblx0XHR9O1xyXG5cdH1cclxufSk7XHJcblxyXG52YXIgUG9pbnRUb0dlb0pTT04gPSB7XHJcblx0dG9HZW9KU09OOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHR0eXBlOiAnUG9pbnQnLFxyXG5cdFx0XHRjb29yZGluYXRlczogTC5HZW9KU09OLmxhdExuZ1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5nKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn07XHJcblxyXG5MLk1hcmtlci5pbmNsdWRlKFBvaW50VG9HZW9KU09OKTtcclxuTC5DaXJjbGUuaW5jbHVkZShQb2ludFRvR2VvSlNPTik7XHJcbkwuQ2lyY2xlTWFya2VyLmluY2x1ZGUoUG9pbnRUb0dlb0pTT04pO1xyXG5cclxuTC5Qb2x5bGluZS5pbmNsdWRlKHtcclxuXHR0b0dlb0pTT046IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdMaW5lU3RyaW5nJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5nZXRMYXRMbmdzKCkpXHJcblx0XHR9KTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5Qb2x5Z29uLmluY2x1ZGUoe1xyXG5cdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvb3JkcyA9IFtMLkdlb0pTT04ubGF0TG5nc1RvQ29vcmRzKHRoaXMuZ2V0TGF0TG5ncygpKV0sXHJcblx0XHQgICAgaSwgbGVuLCBob2xlO1xyXG5cclxuXHRcdGNvb3Jkc1swXS5wdXNoKGNvb3Jkc1swXVswXSk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2hvbGVzKSB7XHJcblx0XHRcdGZvciAoaSA9IDAsIGxlbiA9IHRoaXMuX2hvbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0aG9sZSA9IEwuR2VvSlNPTi5sYXRMbmdzVG9Db29yZHModGhpcy5faG9sZXNbaV0pO1xyXG5cdFx0XHRcdGhvbGUucHVzaChob2xlWzBdKTtcclxuXHRcdFx0XHRjb29yZHMucHVzaChob2xlKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdHR5cGU6ICdQb2x5Z29uJyxcclxuXHRcdFx0Y29vcmRpbmF0ZXM6IGNvb3Jkc1xyXG5cdFx0fSk7XHJcblx0fVxyXG59KTtcclxuXHJcbihmdW5jdGlvbiAoKSB7XHJcblx0ZnVuY3Rpb24gbXVsdGlUb0dlb0pTT04odHlwZSkge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0dmFyIGNvb3JkcyA9IFtdO1xyXG5cclxuXHRcdFx0dGhpcy5lYWNoTGF5ZXIoZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHRcdFx0Y29vcmRzLnB1c2gobGF5ZXIudG9HZW9KU09OKCkuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xyXG5cdFx0XHR9KTtcclxuXHJcblx0XHRcdHJldHVybiBMLkdlb0pTT04uZ2V0RmVhdHVyZSh0aGlzLCB7XHJcblx0XHRcdFx0dHlwZTogdHlwZSxcclxuXHRcdFx0XHRjb29yZGluYXRlczogY29vcmRzXHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdEwuTXVsdGlQb2x5bGluZS5pbmNsdWRlKHt0b0dlb0pTT046IG11bHRpVG9HZW9KU09OKCdNdWx0aUxpbmVTdHJpbmcnKX0pO1xyXG5cdEwuTXVsdGlQb2x5Z29uLmluY2x1ZGUoe3RvR2VvSlNPTjogbXVsdGlUb0dlb0pTT04oJ011bHRpUG9seWdvbicpfSk7XHJcblxyXG5cdEwuTGF5ZXJHcm91cC5pbmNsdWRlKHtcclxuXHRcdHRvR2VvSlNPTjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdFx0dmFyIGdlb21ldHJ5ID0gdGhpcy5mZWF0dXJlICYmIHRoaXMuZmVhdHVyZS5nZW9tZXRyeSxcclxuXHRcdFx0XHRqc29ucyA9IFtdLFxyXG5cdFx0XHRcdGpzb247XHJcblxyXG5cdFx0XHRpZiAoZ2VvbWV0cnkgJiYgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XHJcblx0XHRcdFx0cmV0dXJuIG11bHRpVG9HZW9KU09OKCdNdWx0aVBvaW50JykuY2FsbCh0aGlzKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnkgJiYgZ2VvbWV0cnkudHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XHJcblxyXG5cdFx0XHR0aGlzLmVhY2hMYXllcihmdW5jdGlvbiAobGF5ZXIpIHtcclxuXHRcdFx0XHRpZiAobGF5ZXIudG9HZW9KU09OKSB7XHJcblx0XHRcdFx0XHRqc29uID0gbGF5ZXIudG9HZW9KU09OKCk7XHJcblx0XHRcdFx0XHRqc29ucy5wdXNoKGlzR2VvbWV0cnlDb2xsZWN0aW9uID8ganNvbi5nZW9tZXRyeSA6IEwuR2VvSlNPTi5hc0ZlYXR1cmUoanNvbikpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblxyXG5cdFx0XHRpZiAoaXNHZW9tZXRyeUNvbGxlY3Rpb24pIHtcclxuXHRcdFx0XHRyZXR1cm4gTC5HZW9KU09OLmdldEZlYXR1cmUodGhpcywge1xyXG5cdFx0XHRcdFx0Z2VvbWV0cmllczoganNvbnMsXHJcblx0XHRcdFx0XHR0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJ1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXHJcblx0XHRcdFx0ZmVhdHVyZXM6IGpzb25zXHJcblx0XHRcdH07XHJcblx0XHR9XHJcblx0fSk7XHJcbn0oKSk7XHJcblxyXG5MLmdlb0pzb24gPSBmdW5jdGlvbiAoZ2VvanNvbiwgb3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5HZW9KU09OKGdlb2pzb24sIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuRG9tRXZlbnQgY29udGFpbnMgZnVuY3Rpb25zIGZvciB3b3JraW5nIHdpdGggRE9NIGV2ZW50cy5cclxuICovXHJcblxyXG5MLkRvbUV2ZW50ID0ge1xyXG5cdC8qIGluc3BpcmVkIGJ5IEpvaG4gUmVzaWcsIERlYW4gRWR3YXJkcyBhbmQgWVVJIGFkZEV2ZW50IGltcGxlbWVudGF0aW9ucyAqL1xyXG5cdGFkZExpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBmbiwgY29udGV4dCkgeyAvLyAoSFRNTEVsZW1lbnQsIFN0cmluZywgRnVuY3Rpb25bLCBPYmplY3RdKVxyXG5cclxuXHRcdHZhciBpZCA9IEwuc3RhbXAoZm4pLFxyXG5cdFx0ICAgIGtleSA9ICdfbGVhZmxldF8nICsgdHlwZSArIGlkLFxyXG5cdFx0ICAgIGhhbmRsZXIsIG9yaWdpbmFsSGFuZGxlciwgbmV3VHlwZTtcclxuXHJcblx0XHRpZiAob2JqW2tleV0pIHsgcmV0dXJuIHRoaXM7IH1cclxuXHJcblx0XHRoYW5kbGVyID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0cmV0dXJuIGZuLmNhbGwoY29udGV4dCB8fCBvYmosIGUgfHwgTC5Eb21FdmVudC5fZ2V0RXZlbnQoKSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdGlmIChMLkJyb3dzZXIucG9pbnRlciAmJiB0eXBlLmluZGV4T2YoJ3RvdWNoJykgPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHRoaXMuYWRkUG9pbnRlckxpc3RlbmVyKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKEwuQnJvd3Nlci50b3VjaCAmJiAodHlwZSA9PT0gJ2RibGNsaWNrJykgJiYgdGhpcy5hZGREb3VibGVUYXBMaXN0ZW5lcikge1xyXG5cdFx0XHR0aGlzLmFkZERvdWJsZVRhcExpc3RlbmVyKG9iaiwgaGFuZGxlciwgaWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmICgnYWRkRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHJcblx0XHRcdFx0b3JpZ2luYWxIYW5kbGVyID0gaGFuZGxlcjtcclxuXHRcdFx0XHRuZXdUeXBlID0gKHR5cGUgPT09ICdtb3VzZWVudGVyJyA/ICdtb3VzZW92ZXInIDogJ21vdXNlb3V0Jyk7XHJcblxyXG5cdFx0XHRcdGhhbmRsZXIgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdFx0aWYgKCFMLkRvbUV2ZW50Ll9jaGVja01vdXNlKG9iaiwgZSkpIHsgcmV0dXJuOyB9XHJcblx0XHRcdFx0XHRyZXR1cm4gb3JpZ2luYWxIYW5kbGVyKGUpO1xyXG5cdFx0XHRcdH07XHJcblxyXG5cdFx0XHRcdG9iai5hZGRFdmVudExpc3RlbmVyKG5ld1R5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NsaWNrJyAmJiBMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdG9yaWdpbmFsSGFuZGxlciA9IGhhbmRsZXI7XHJcblx0XHRcdFx0aGFuZGxlciA9IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gTC5Eb21FdmVudC5fZmlsdGVyQ2xpY2soZSwgb3JpZ2luYWxIYW5kbGVyKTtcclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyLCBmYWxzZSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0fSBlbHNlIGlmICgnYXR0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0XHRvYmouYXR0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9ialtrZXldID0gaGFuZGxlcjtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgZm4pIHsgIC8vIChIVE1MRWxlbWVudCwgU3RyaW5nLCBGdW5jdGlvbilcclxuXHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGZuKSxcclxuXHRcdCAgICBrZXkgPSAnX2xlYWZsZXRfJyArIHR5cGUgKyBpZCxcclxuXHRcdCAgICBoYW5kbGVyID0gb2JqW2tleV07XHJcblxyXG5cdFx0aWYgKCFoYW5kbGVyKSB7IHJldHVybiB0aGlzOyB9XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyICYmIHR5cGUuaW5kZXhPZigndG91Y2gnKSA9PT0gMCkge1xyXG5cdFx0XHR0aGlzLnJlbW92ZVBvaW50ZXJMaXN0ZW5lcihvYmosIHR5cGUsIGlkKTtcclxuXHRcdH0gZWxzZSBpZiAoTC5Ccm93c2VyLnRvdWNoICYmICh0eXBlID09PSAnZGJsY2xpY2snKSAmJiB0aGlzLnJlbW92ZURvdWJsZVRhcExpc3RlbmVyKSB7XHJcblx0XHRcdHRoaXMucmVtb3ZlRG91YmxlVGFwTGlzdGVuZXIob2JqLCBpZCk7XHJcblxyXG5cdFx0fSBlbHNlIGlmICgncmVtb3ZlRXZlbnRMaXN0ZW5lcicgaW4gb2JqKSB7XHJcblxyXG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNld2hlZWwnKSB7XHJcblx0XHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTU1vdXNlU2Nyb2xsJywgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoKHR5cGUgPT09ICdtb3VzZWVudGVyJykgfHwgKHR5cGUgPT09ICdtb3VzZWxlYXZlJykpIHtcclxuXHRcdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcigodHlwZSA9PT0gJ21vdXNlZW50ZXInID8gJ21vdXNlb3ZlcicgOiAnbW91c2VvdXQnKSwgaGFuZGxlciwgZmFsc2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIGZhbHNlKTtcclxuXHRcdFx0fVxyXG5cdFx0fSBlbHNlIGlmICgnZGV0YWNoRXZlbnQnIGluIG9iaikge1xyXG5cdFx0XHRvYmouZGV0YWNoRXZlbnQoJ29uJyArIHR5cGUsIGhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG9ialtrZXldID0gbnVsbDtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUuc3RvcFByb3BhZ2F0aW9uKSB7XHJcblx0XHRcdGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcblx0XHR9XHJcblx0XHRMLkRvbUV2ZW50Ll9za2lwcGVkKGUpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbjogZnVuY3Rpb24gKGVsKSB7XHJcblx0XHR2YXIgc3RvcCA9IEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uO1xyXG5cclxuXHRcdHJldHVybiBMLkRvbUV2ZW50XHJcblx0XHRcdC5vbihlbCwgJ21vdXNld2hlZWwnLCBzdG9wKVxyXG5cdFx0XHQub24oZWwsICdNb3pNb3VzZVBpeGVsU2Nyb2xsJywgc3RvcCk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZUNsaWNrUHJvcGFnYXRpb246IGZ1bmN0aW9uIChlbCkge1xyXG5cdFx0dmFyIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcclxuXHJcblx0XHRmb3IgKHZhciBpID0gTC5EcmFnZ2FibGUuU1RBUlQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbihlbCwgTC5EcmFnZ2FibGUuU1RBUlRbaV0sIHN0b3ApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiBMLkRvbUV2ZW50XHJcblx0XHRcdC5vbihlbCwgJ2NsaWNrJywgTC5Eb21FdmVudC5fZmFrZVN0b3ApXHJcblx0XHRcdC5vbihlbCwgJ2RibGNsaWNrJywgc3RvcCk7XHJcblx0fSxcclxuXHJcblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uIChlKSB7XHJcblxyXG5cdFx0aWYgKGUucHJldmVudERlZmF1bHQpIHtcclxuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZS5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHJldHVybiBMLkRvbUV2ZW50XHJcblx0XHRcdC5wcmV2ZW50RGVmYXVsdChlKVxyXG5cdFx0XHQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cdH0sXHJcblxyXG5cdGdldE1vdXNlUG9zaXRpb246IGZ1bmN0aW9uIChlLCBjb250YWluZXIpIHtcclxuXHRcdGlmICghY29udGFpbmVyKSB7XHJcblx0XHRcdHJldHVybiBuZXcgTC5Qb2ludChlLmNsaWVudFgsIGUuY2xpZW50WSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KFxyXG5cdFx0XHRlLmNsaWVudFggLSByZWN0LmxlZnQgLSBjb250YWluZXIuY2xpZW50TGVmdCxcclxuXHRcdFx0ZS5jbGllbnRZIC0gcmVjdC50b3AgLSBjb250YWluZXIuY2xpZW50VG9wKTtcclxuXHR9LFxyXG5cclxuXHRnZXRXaGVlbERlbHRhOiBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdHZhciBkZWx0YSA9IDA7XHJcblxyXG5cdFx0aWYgKGUud2hlZWxEZWx0YSkge1xyXG5cdFx0XHRkZWx0YSA9IGUud2hlZWxEZWx0YSAvIDEyMDtcclxuXHRcdH1cclxuXHRcdGlmIChlLmRldGFpbCkge1xyXG5cdFx0XHRkZWx0YSA9IC1lLmRldGFpbCAvIDM7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZGVsdGE7XHJcblx0fSxcclxuXHJcblx0X3NraXBFdmVudHM6IHt9LFxyXG5cclxuXHRfZmFrZVN0b3A6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHQvLyBmYWtlcyBzdG9wUHJvcGFnYXRpb24gYnkgc2V0dGluZyBhIHNwZWNpYWwgZXZlbnQgZmxhZywgY2hlY2tlZC9yZXNldCB3aXRoIEwuRG9tRXZlbnQuX3NraXBwZWQoZSlcclxuXHRcdEwuRG9tRXZlbnQuX3NraXBFdmVudHNbZS50eXBlXSA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0X3NraXBwZWQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgc2tpcHBlZCA9IHRoaXMuX3NraXBFdmVudHNbZS50eXBlXTtcclxuXHRcdC8vIHJlc2V0IHdoZW4gY2hlY2tpbmcsIGFzIGl0J3Mgb25seSB1c2VkIGluIG1hcCBjb250YWluZXIgYW5kIHByb3BhZ2F0ZXMgb3V0c2lkZSBvZiB0aGUgbWFwXHJcblx0XHR0aGlzLl9za2lwRXZlbnRzW2UudHlwZV0gPSBmYWxzZTtcclxuXHRcdHJldHVybiBza2lwcGVkO1xyXG5cdH0sXHJcblxyXG5cdC8vIGNoZWNrIGlmIGVsZW1lbnQgcmVhbGx5IGxlZnQvZW50ZXJlZCB0aGUgZXZlbnQgdGFyZ2V0IChmb3IgbW91c2VlbnRlci9tb3VzZWxlYXZlKVxyXG5cdF9jaGVja01vdXNlOiBmdW5jdGlvbiAoZWwsIGUpIHtcclxuXHJcblx0XHR2YXIgcmVsYXRlZCA9IGUucmVsYXRlZFRhcmdldDtcclxuXHJcblx0XHRpZiAoIXJlbGF0ZWQpIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHR0cnkge1xyXG5cdFx0XHR3aGlsZSAocmVsYXRlZCAmJiAocmVsYXRlZCAhPT0gZWwpKSB7XHJcblx0XHRcdFx0cmVsYXRlZCA9IHJlbGF0ZWQucGFyZW50Tm9kZTtcclxuXHRcdFx0fVxyXG5cdFx0fSBjYXRjaCAoZXJyKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiAocmVsYXRlZCAhPT0gZWwpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRFdmVudDogZnVuY3Rpb24gKCkgeyAvLyBldmlsIG1hZ2ljIGZvciBJRVxyXG5cdFx0Lypqc2hpbnQgbm9hcmc6ZmFsc2UgKi9cclxuXHRcdHZhciBlID0gd2luZG93LmV2ZW50O1xyXG5cdFx0aWYgKCFlKSB7XHJcblx0XHRcdHZhciBjYWxsZXIgPSBhcmd1bWVudHMuY2FsbGVlLmNhbGxlcjtcclxuXHRcdFx0d2hpbGUgKGNhbGxlcikge1xyXG5cdFx0XHRcdGUgPSBjYWxsZXJbJ2FyZ3VtZW50cyddWzBdO1xyXG5cdFx0XHRcdGlmIChlICYmIHdpbmRvdy5FdmVudCA9PT0gZS5jb25zdHJ1Y3Rvcikge1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxlciA9IGNhbGxlci5jYWxsZXI7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBlO1xyXG5cdH0sXHJcblxyXG5cdC8vIHRoaXMgaXMgYSBob3JyaWJsZSB3b3JrYXJvdW5kIGZvciBhIGJ1ZyBpbiBBbmRyb2lkIHdoZXJlIGEgc2luZ2xlIHRvdWNoIHRyaWdnZXJzIHR3byBjbGljayBldmVudHNcclxuXHRfZmlsdGVyQ2xpY2s6IGZ1bmN0aW9uIChlLCBoYW5kbGVyKSB7XHJcblx0XHR2YXIgdGltZVN0YW1wID0gKGUudGltZVN0YW1wIHx8IGUub3JpZ2luYWxFdmVudC50aW1lU3RhbXApLFxyXG5cdFx0XHRlbGFwc2VkID0gTC5Eb21FdmVudC5fbGFzdENsaWNrICYmICh0aW1lU3RhbXAgLSBMLkRvbUV2ZW50Ll9sYXN0Q2xpY2spO1xyXG5cclxuXHRcdC8vIGFyZSB0aGV5IGNsb3NlciB0b2dldGhlciB0aGFuIDEwMDBtcyB5ZXQgbW9yZSB0aGFuIDEwMG1zP1xyXG5cdFx0Ly8gQW5kcm9pZCB0eXBpY2FsbHkgdHJpZ2dlcnMgdGhlbSB+MzAwbXMgYXBhcnQgd2hpbGUgbXVsdGlwbGUgbGlzdGVuZXJzXHJcblx0XHQvLyBvbiB0aGUgc2FtZSBldmVudCBzaG91bGQgYmUgdHJpZ2dlcmVkIGZhciBmYXN0ZXI7XHJcblx0XHQvLyBvciBjaGVjayBpZiBjbGljayBpcyBzaW11bGF0ZWQgb24gdGhlIGVsZW1lbnQsIGFuZCBpZiBpdCBpcywgcmVqZWN0IGFueSBub24tc2ltdWxhdGVkIGV2ZW50c1xyXG5cclxuXHRcdGlmICgoZWxhcHNlZCAmJiBlbGFwc2VkID4gMTAwICYmIGVsYXBzZWQgPCAxMDAwKSB8fCAoZS50YXJnZXQuX3NpbXVsYXRlZENsaWNrICYmICFlLl9zaW11bGF0ZWQpKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0TC5Eb21FdmVudC5fbGFzdENsaWNrID0gdGltZVN0YW1wO1xyXG5cclxuXHRcdHJldHVybiBoYW5kbGVyKGUpO1xyXG5cdH1cclxufTtcclxuXHJcbkwuRG9tRXZlbnQub24gPSBMLkRvbUV2ZW50LmFkZExpc3RlbmVyO1xyXG5MLkRvbUV2ZW50Lm9mZiA9IEwuRG9tRXZlbnQucmVtb3ZlTGlzdGVuZXI7XHJcblxyXG5cclxuLypcclxuICogTC5EcmFnZ2FibGUgYWxsb3dzIHlvdSB0byBhZGQgZHJhZ2dpbmcgY2FwYWJpbGl0aWVzIHRvIGFueSBlbGVtZW50LiBTdXBwb3J0cyBtb2JpbGUgZGV2aWNlcyB0b28uXHJcbiAqL1xyXG5cclxuTC5EcmFnZ2FibGUgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5jbHVkZXM6IEwuTWl4aW4uRXZlbnRzLFxyXG5cclxuXHRzdGF0aWNzOiB7XHJcblx0XHRTVEFSVDogTC5Ccm93c2VyLnRvdWNoID8gWyd0b3VjaHN0YXJ0JywgJ21vdXNlZG93biddIDogWydtb3VzZWRvd24nXSxcclxuXHRcdEVORDoge1xyXG5cdFx0XHRtb3VzZWRvd246ICdtb3VzZXVwJyxcclxuXHRcdFx0dG91Y2hzdGFydDogJ3RvdWNoZW5kJyxcclxuXHRcdFx0cG9pbnRlcmRvd246ICd0b3VjaGVuZCcsXHJcblx0XHRcdE1TUG9pbnRlckRvd246ICd0b3VjaGVuZCdcclxuXHRcdH0sXHJcblx0XHRNT1ZFOiB7XHJcblx0XHRcdG1vdXNlZG93bjogJ21vdXNlbW92ZScsXHJcblx0XHRcdHRvdWNoc3RhcnQ6ICd0b3VjaG1vdmUnLFxyXG5cdFx0XHRwb2ludGVyZG93bjogJ3RvdWNobW92ZScsXHJcblx0XHRcdE1TUG9pbnRlckRvd246ICd0b3VjaG1vdmUnXHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGVsZW1lbnQsIGRyYWdTdGFydFRhcmdldCkge1xyXG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9kcmFnU3RhcnRUYXJnZXQgPSBkcmFnU3RhcnRUYXJnZXQgfHwgZWxlbWVudDtcclxuXHR9LFxyXG5cclxuXHRlbmFibGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSBMLkRyYWdnYWJsZS5TVEFSVC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX2RyYWdTdGFydFRhcmdldCwgTC5EcmFnZ2FibGUuU1RBUlRbaV0sIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGZvciAodmFyIGkgPSBMLkRyYWdnYWJsZS5TVEFSVC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xyXG5cdFx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9kcmFnU3RhcnRUYXJnZXQsIEwuRHJhZ2dhYmxlLlNUQVJUW2ldLCB0aGlzLl9vbkRvd24sIHRoaXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblxyXG5cdFx0aWYgKGUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpICYmICFlLnRvdWNoZXMpKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKGUpO1xyXG5cclxuXHRcdGlmIChMLkRyYWdnYWJsZS5fZGlzYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmRpc2FibGVJbWFnZURyYWcoKTtcclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlVGV4dFNlbGVjdGlvbigpO1xyXG5cclxuXHRcdGlmICh0aGlzLl9tb3ZpbmcpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvaW50ID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KTtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCBMLkRyYWdnYWJsZS5NT1ZFW2UudHlwZV0sIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdCAgICAub24oZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtlLnR5cGVdLCB0aGlzLl9vblVwLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUudG91Y2hlcyAmJiBlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9tb3ZlZCA9IHRydWU7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZmlyc3QgPSAoZS50b3VjaGVzICYmIGUudG91Y2hlcy5sZW5ndGggPT09IDEgPyBlLnRvdWNoZXNbMF0gOiBlKSxcclxuXHRcdCAgICBuZXdQb2ludCA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpLFxyXG5cdFx0ICAgIG9mZnNldCA9IG5ld1BvaW50LnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9pbnQpO1xyXG5cclxuXHRcdGlmICghb2Zmc2V0LnggJiYgIW9mZnNldC55KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ2RyYWdzdGFydCcpO1xyXG5cclxuXHRcdFx0dGhpcy5fbW92ZWQgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9zdGFydFBvcyA9IEwuRG9tVXRpbC5nZXRQb3NpdGlvbih0aGlzLl9lbGVtZW50KS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcygoZS50YXJnZXQgfHwgZS5zcmNFbGVtZW50KSwgJ2xlYWZsZXQtZHJhZy10YXJnZXQnKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9uZXdQb3MgPSB0aGlzLl9zdGFydFBvcy5hZGQob2Zmc2V0KTtcclxuXHRcdHRoaXMuX21vdmluZyA9IHRydWU7XHJcblxyXG5cdFx0TC5VdGlsLmNhbmNlbEFuaW1GcmFtZSh0aGlzLl9hbmltUmVxdWVzdCk7XHJcblx0XHR0aGlzLl9hbmltUmVxdWVzdCA9IEwuVXRpbC5yZXF1ZXN0QW5pbUZyYW1lKHRoaXMuX3VwZGF0ZVBvc2l0aW9uLCB0aGlzLCB0cnVlLCB0aGlzLl9kcmFnU3RhcnRUYXJnZXQpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdwcmVkcmFnJyk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWxlbWVudCwgdGhpcy5fbmV3UG9zKTtcclxuXHRcdHRoaXMuZmlyZSgnZHJhZycpO1xyXG5cdH0sXHJcblxyXG5cdF9vblVwOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGRvY3VtZW50LmJvZHksICdsZWFmbGV0LWRyYWdnaW5nJyk7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3MoKGUudGFyZ2V0IHx8IGUuc3JjRWxlbWVudCksICdsZWFmbGV0LWRyYWctdGFyZ2V0Jyk7XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBMLkRyYWdnYWJsZS5NT1ZFKSB7XHJcblx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLk1PVkVbaV0sIHRoaXMuX29uTW92ZSlcclxuXHRcdFx0ICAgIC5vZmYoZG9jdW1lbnQsIEwuRHJhZ2dhYmxlLkVORFtpXSwgdGhpcy5fb25VcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZUltYWdlRHJhZygpO1xyXG5cdFx0TC5Eb21VdGlsLmVuYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbW92ZWQgJiYgdGhpcy5fbW92aW5nKSB7XHJcblx0XHRcdC8vIGVuc3VyZSBkcmFnIGlzIG5vdCBmaXJlZCBhZnRlciBkcmFnZW5kXHJcblx0XHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdFx0dGhpcy5maXJlKCdkcmFnZW5kJywge1xyXG5cdFx0XHRcdGRpc3RhbmNlOiB0aGlzLl9uZXdQb3MuZGlzdGFuY2VUbyh0aGlzLl9zdGFydFBvcylcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fbW92aW5nID0gZmFsc2U7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG5cdEwuSGFuZGxlciBpcyBhIGJhc2UgY2xhc3MgZm9yIGhhbmRsZXIgY2xhc3NlcyB0aGF0IGFyZSB1c2VkIGludGVybmFsbHkgdG8gaW5qZWN0XHJcblx0aW50ZXJhY3Rpb24gZmVhdHVyZXMgbGlrZSBkcmFnZ2luZyB0byBjbGFzc2VzIGxpa2UgTWFwIGFuZCBNYXJrZXIuXHJcbiovXHJcblxyXG5MLkhhbmRsZXIgPSBMLkNsYXNzLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdH0sXHJcblxyXG5cdGVuYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX2VuYWJsZWQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0dGhpcy5fZW5hYmxlZCA9IHRydWU7XHJcblx0XHR0aGlzLmFkZEhvb2tzKCk7XHJcblx0fSxcclxuXHJcblx0ZGlzYWJsZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9lbmFibGVkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMucmVtb3ZlSG9va3MoKTtcclxuXHR9LFxyXG5cclxuXHRlbmFibGVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9lbmFibGVkO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuICogTC5IYW5kbGVyLk1hcERyYWcgaXMgdXNlZCB0byBtYWtlIHRoZSBtYXAgZHJhZ2dhYmxlICh3aXRoIHBhbm5pbmcgaW5lcnRpYSksIGVuYWJsZWQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGRyYWdnaW5nOiB0cnVlLFxyXG5cclxuXHRpbmVydGlhOiAhTC5Ccm93c2VyLmFuZHJvaWQyMyxcclxuXHRpbmVydGlhRGVjZWxlcmF0aW9uOiAzNDAwLCAvLyBweC9zXjJcclxuXHRpbmVydGlhTWF4U3BlZWQ6IEluZmluaXR5LCAvLyBweC9zXHJcblx0aW5lcnRpYVRocmVzaG9sZDogTC5Ccm93c2VyLnRvdWNoID8gMzIgOiAxOCwgLy8gbXNcclxuXHRlYXNlTGluZWFyaXR5OiAwLjI1LFxyXG5cclxuXHQvLyBUT0RPIHJlZmFjdG9yLCBtb3ZlIHRvIENSU1xyXG5cdHdvcmxkQ29weUp1bXA6IGZhbHNlXHJcbn0pO1xyXG5cclxuTC5NYXAuRHJhZyA9IEwuSGFuZGxlci5leHRlbmQoe1xyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2RyYWdnYWJsZSkge1xyXG5cdFx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlID0gbmV3IEwuRHJhZ2dhYmxlKG1hcC5fbWFwUGFuZSwgbWFwLl9jb250YWluZXIpO1xyXG5cclxuXHRcdFx0dGhpcy5fZHJhZ2dhYmxlLm9uKHtcclxuXHRcdFx0XHQnZHJhZ3N0YXJ0JzogdGhpcy5fb25EcmFnU3RhcnQsXHJcblx0XHRcdFx0J2RyYWcnOiB0aGlzLl9vbkRyYWcsXHJcblx0XHRcdFx0J2RyYWdlbmQnOiB0aGlzLl9vbkRyYWdFbmRcclxuXHRcdFx0fSwgdGhpcyk7XHJcblxyXG5cdFx0XHRpZiAobWFwLm9wdGlvbnMud29ybGRDb3B5SnVtcCkge1xyXG5cdFx0XHRcdHRoaXMuX2RyYWdnYWJsZS5vbigncHJlZHJhZycsIHRoaXMuX29uUHJlRHJhZywgdGhpcyk7XHJcblx0XHRcdFx0bWFwLm9uKCd2aWV3cmVzZXQnLCB0aGlzLl9vblZpZXdSZXNldCwgdGhpcyk7XHJcblxyXG5cdFx0XHRcdG1hcC53aGVuUmVhZHkodGhpcy5fb25WaWV3UmVzZXQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHR0aGlzLl9kcmFnZ2FibGUuZW5hYmxlKCk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XHJcblx0fSxcclxuXHJcblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcclxuXHR9LFxyXG5cclxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKG1hcC5fcGFuQW5pbSkge1xyXG5cdFx0XHRtYXAuX3BhbkFuaW0uc3RvcCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5maXJlKCdtb3Zlc3RhcnQnKVxyXG5cdFx0ICAgIC5maXJlKCdkcmFnc3RhcnQnKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuaW5lcnRpYSkge1xyXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMgPSBbXTtcclxuXHRcdFx0dGhpcy5fdGltZXMgPSBbXTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfb25EcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fbWFwLm9wdGlvbnMuaW5lcnRpYSkge1xyXG5cdFx0XHR2YXIgdGltZSA9IHRoaXMuX2xhc3RUaW1lID0gK25ldyBEYXRlKCksXHJcblx0XHRcdCAgICBwb3MgPSB0aGlzLl9sYXN0UG9zID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3M7XHJcblxyXG5cdFx0XHR0aGlzLl9wb3NpdGlvbnMucHVzaChwb3MpO1xyXG5cdFx0XHR0aGlzLl90aW1lcy5wdXNoKHRpbWUpO1xyXG5cclxuXHRcdFx0aWYgKHRpbWUgLSB0aGlzLl90aW1lc1swXSA+IDIwMCkge1xyXG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9ucy5zaGlmdCgpO1xyXG5cdFx0XHRcdHRoaXMuX3RpbWVzLnNoaWZ0KCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9tYXBcclxuXHRcdCAgICAuZmlyZSgnbW92ZScpXHJcblx0XHQgICAgLmZpcmUoJ2RyYWcnKTtcclxuXHR9LFxyXG5cclxuXHRfb25WaWV3UmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIFRPRE8gZml4IGhhcmRjb2RlZCBFYXJ0aCB2YWx1ZXNcclxuXHRcdHZhciBweENlbnRlciA9IHRoaXMuX21hcC5nZXRTaXplKCkuX2RpdmlkZUJ5KDIpLFxyXG5cdFx0ICAgIHB4V29ybGRDZW50ZXIgPSB0aGlzLl9tYXAubGF0TG5nVG9MYXllclBvaW50KFswLCAwXSk7XHJcblxyXG5cdFx0dGhpcy5faW5pdGlhbFdvcmxkT2Zmc2V0ID0gcHhXb3JsZENlbnRlci5zdWJ0cmFjdChweENlbnRlcikueDtcclxuXHRcdHRoaXMuX3dvcmxkV2lkdGggPSB0aGlzLl9tYXAucHJvamVjdChbMCwgMTgwXSkueDtcclxuXHR9LFxyXG5cclxuXHRfb25QcmVEcmFnOiBmdW5jdGlvbiAoKSB7XHJcblx0XHQvLyBUT0RPIHJlZmFjdG9yIHRvIGJlIGFibGUgdG8gYWRqdXN0IG1hcCBwYW5lIHBvc2l0aW9uIGFmdGVyIHpvb21cclxuXHRcdHZhciB3b3JsZFdpZHRoID0gdGhpcy5fd29ybGRXaWR0aCxcclxuXHRcdCAgICBoYWxmV2lkdGggPSBNYXRoLnJvdW5kKHdvcmxkV2lkdGggLyAyKSxcclxuXHRcdCAgICBkeCA9IHRoaXMuX2luaXRpYWxXb3JsZE9mZnNldCxcclxuXHRcdCAgICB4ID0gdGhpcy5fZHJhZ2dhYmxlLl9uZXdQb3MueCxcclxuXHRcdCAgICBuZXdYMSA9ICh4IC0gaGFsZldpZHRoICsgZHgpICUgd29ybGRXaWR0aCArIGhhbGZXaWR0aCAtIGR4LFxyXG5cdFx0ICAgIG5ld1gyID0gKHggKyBoYWxmV2lkdGggKyBkeCkgJSB3b3JsZFdpZHRoIC0gaGFsZldpZHRoIC0gZHgsXHJcblx0XHQgICAgbmV3WCA9IE1hdGguYWJzKG5ld1gxICsgZHgpIDwgTWF0aC5hYnMobmV3WDIgKyBkeCkgPyBuZXdYMSA6IG5ld1gyO1xyXG5cclxuXHRcdHRoaXMuX2RyYWdnYWJsZS5fbmV3UG9zLnggPSBuZXdYO1xyXG5cdH0sXHJcblxyXG5cdF9vbkRyYWdFbmQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSBtYXAub3B0aW9ucyxcclxuXHRcdCAgICBkZWxheSA9ICtuZXcgRGF0ZSgpIC0gdGhpcy5fbGFzdFRpbWUsXHJcblxyXG5cdFx0ICAgIG5vSW5lcnRpYSA9ICFvcHRpb25zLmluZXJ0aWEgfHwgZGVsYXkgPiBvcHRpb25zLmluZXJ0aWFUaHJlc2hvbGQgfHwgIXRoaXMuX3Bvc2l0aW9uc1swXTtcclxuXHJcblx0XHRtYXAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xyXG5cclxuXHRcdGlmIChub0luZXJ0aWEpIHtcclxuXHRcdFx0bWFwLmZpcmUoJ21vdmVlbmQnKTtcclxuXHJcblx0XHR9IGVsc2Uge1xyXG5cclxuXHRcdFx0dmFyIGRpcmVjdGlvbiA9IHRoaXMuX2xhc3RQb3Muc3VidHJhY3QodGhpcy5fcG9zaXRpb25zWzBdKSxcclxuXHRcdFx0ICAgIGR1cmF0aW9uID0gKHRoaXMuX2xhc3RUaW1lICsgZGVsYXkgLSB0aGlzLl90aW1lc1swXSkgLyAxMDAwLFxyXG5cdFx0XHQgICAgZWFzZSA9IG9wdGlvbnMuZWFzZUxpbmVhcml0eSxcclxuXHJcblx0XHRcdCAgICBzcGVlZFZlY3RvciA9IGRpcmVjdGlvbi5tdWx0aXBseUJ5KGVhc2UgLyBkdXJhdGlvbiksXHJcblx0XHRcdCAgICBzcGVlZCA9IHNwZWVkVmVjdG9yLmRpc3RhbmNlVG8oWzAsIDBdKSxcclxuXHJcblx0XHRcdCAgICBsaW1pdGVkU3BlZWQgPSBNYXRoLm1pbihvcHRpb25zLmluZXJ0aWFNYXhTcGVlZCwgc3BlZWQpLFxyXG5cdFx0XHQgICAgbGltaXRlZFNwZWVkVmVjdG9yID0gc3BlZWRWZWN0b3IubXVsdGlwbHlCeShsaW1pdGVkU3BlZWQgLyBzcGVlZCksXHJcblxyXG5cdFx0XHQgICAgZGVjZWxlcmF0aW9uRHVyYXRpb24gPSBsaW1pdGVkU3BlZWQgLyAob3B0aW9ucy5pbmVydGlhRGVjZWxlcmF0aW9uICogZWFzZSksXHJcblx0XHRcdCAgICBvZmZzZXQgPSBsaW1pdGVkU3BlZWRWZWN0b3IubXVsdGlwbHlCeSgtZGVjZWxlcmF0aW9uRHVyYXRpb24gLyAyKS5yb3VuZCgpO1xyXG5cclxuXHRcdFx0aWYgKCFvZmZzZXQueCB8fCAhb2Zmc2V0LnkpIHtcclxuXHRcdFx0XHRtYXAuZmlyZSgnbW92ZWVuZCcpO1xyXG5cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRvZmZzZXQgPSBtYXAuX2xpbWl0T2Zmc2V0KG9mZnNldCwgbWFwLm9wdGlvbnMubWF4Qm91bmRzKTtcclxuXHJcblx0XHRcdFx0TC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdFx0bWFwLnBhbkJ5KG9mZnNldCwge1xyXG5cdFx0XHRcdFx0XHRkdXJhdGlvbjogZGVjZWxlcmF0aW9uRHVyYXRpb24sXHJcblx0XHRcdFx0XHRcdGVhc2VMaW5lYXJpdHk6IGVhc2UsXHJcblx0XHRcdFx0XHRcdG5vTW92ZVN0YXJ0OiB0cnVlXHJcblx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkcmFnZ2luZycsIEwuTWFwLkRyYWcpO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuSGFuZGxlci5Eb3VibGVDbGlja1pvb20gaXMgdXNlZCB0byBoYW5kbGUgZG91YmxlLWNsaWNrIHpvb20gb24gdGhlIG1hcCwgZW5hYmxlZCBieSBkZWZhdWx0LlxyXG4gKi9cclxuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0ZG91YmxlQ2xpY2tab29tOiB0cnVlXHJcbn0pO1xyXG5cclxuTC5NYXAuRG91YmxlQ2xpY2tab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XHJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcC5vbignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fbWFwLm9mZignZGJsY2xpY2snLCB0aGlzLl9vbkRvdWJsZUNsaWNrLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Eb3VibGVDbGljazogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCkgKyAoZS5vcmlnaW5hbEV2ZW50LnNoaWZ0S2V5ID8gLTEgOiAxKTtcclxuXHJcblx0XHRpZiAobWFwLm9wdGlvbnMuZG91YmxlQ2xpY2tab29tID09PSAnY2VudGVyJykge1xyXG5cdFx0XHRtYXAuc2V0Wm9vbSh6b29tKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKGUuY29udGFpbmVyUG9pbnQsIHpvb20pO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICdkb3VibGVDbGlja1pvb20nLCBMLk1hcC5Eb3VibGVDbGlja1pvb20pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuSGFuZGxlci5TY3JvbGxXaGVlbFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBlbmFibGUgbW91c2Ugc2Nyb2xsIHdoZWVsIHpvb20gb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdHNjcm9sbFdoZWVsWm9vbTogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLlNjcm9sbFdoZWVsWm9vbSA9IEwuSGFuZGxlci5leHRlbmQoe1xyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAnbW91c2V3aGVlbCcsIHRoaXMuX29uV2hlZWxTY3JvbGwsIHRoaXMpO1xyXG5cdFx0TC5Eb21FdmVudC5vbih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHRcdHRoaXMuX2RlbHRhID0gMDtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICdtb3VzZXdoZWVsJywgdGhpcy5fb25XaGVlbFNjcm9sbCk7XHJcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9tYXAuX2NvbnRhaW5lciwgJ01vek1vdXNlUGl4ZWxTY3JvbGwnLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KTtcclxuXHR9LFxyXG5cclxuXHRfb25XaGVlbFNjcm9sbDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBkZWx0YSA9IEwuRG9tRXZlbnQuZ2V0V2hlZWxEZWx0YShlKTtcclxuXHJcblx0XHR0aGlzLl9kZWx0YSArPSBkZWx0YTtcclxuXHRcdHRoaXMuX2xhc3RNb3VzZVBvcyA9IHRoaXMuX21hcC5tb3VzZUV2ZW50VG9Db250YWluZXJQb2ludChlKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX3N0YXJ0VGltZSkge1xyXG5cdFx0XHR0aGlzLl9zdGFydFRpbWUgPSArbmV3IERhdGUoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgbGVmdCA9IE1hdGgubWF4KDQwIC0gKCtuZXcgRGF0ZSgpIC0gdGhpcy5fc3RhcnRUaW1lKSwgMCk7XHJcblxyXG5cdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVyKTtcclxuXHRcdHRoaXMuX3RpbWVyID0gc2V0VGltZW91dChMLmJpbmQodGhpcy5fcGVyZm9ybVpvb20sIHRoaXMpLCBsZWZ0KTtcclxuXHJcblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdFx0TC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XHJcblx0fSxcclxuXHJcblx0X3BlcmZvcm1ab29tOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGRlbHRhID0gdGhpcy5fZGVsdGEsXHJcblx0XHQgICAgem9vbSA9IG1hcC5nZXRab29tKCk7XHJcblxyXG5cdFx0ZGVsdGEgPSBkZWx0YSA+IDAgPyBNYXRoLmNlaWwoZGVsdGEpIDogTWF0aC5mbG9vcihkZWx0YSk7XHJcblx0XHRkZWx0YSA9IE1hdGgubWF4KE1hdGgubWluKGRlbHRhLCA0KSwgLTQpO1xyXG5cdFx0ZGVsdGEgPSBtYXAuX2xpbWl0Wm9vbSh6b29tICsgZGVsdGEpIC0gem9vbTtcclxuXHJcblx0XHR0aGlzLl9kZWx0YSA9IDA7XHJcblx0XHR0aGlzLl9zdGFydFRpbWUgPSBudWxsO1xyXG5cclxuXHRcdGlmICghZGVsdGEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKG1hcC5vcHRpb25zLnNjcm9sbFdoZWVsWm9vbSA9PT0gJ2NlbnRlcicpIHtcclxuXHRcdFx0bWFwLnNldFpvb20oem9vbSArIGRlbHRhKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG1hcC5zZXRab29tQXJvdW5kKHRoaXMuX2xhc3RNb3VzZVBvcywgem9vbSArIGRlbHRhKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAnc2Nyb2xsV2hlZWxab29tJywgTC5NYXAuU2Nyb2xsV2hlZWxab29tKTtcclxuXHJcblxyXG4vKlxyXG4gKiBFeHRlbmRzIHRoZSBldmVudCBoYW5kbGluZyBjb2RlIHdpdGggZG91YmxlIHRhcCBzdXBwb3J0IGZvciBtb2JpbGUgYnJvd3NlcnMuXHJcbiAqL1xyXG5cclxuTC5leHRlbmQoTC5Eb21FdmVudCwge1xyXG5cclxuXHRfdG91Y2hzdGFydDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJEb3duJyA6IEwuQnJvd3Nlci5wb2ludGVyID8gJ3BvaW50ZXJkb3duJyA6ICd0b3VjaHN0YXJ0JyxcclxuXHRfdG91Y2hlbmQ6IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyVXAnIDogTC5Ccm93c2VyLnBvaW50ZXIgPyAncG9pbnRlcnVwJyA6ICd0b3VjaGVuZCcsXHJcblxyXG5cdC8vIGluc3BpcmVkIGJ5IFplcHRvIHRvdWNoIGNvZGUgYnkgVGhvbWFzIEZ1Y2hzXHJcblx0YWRkRG91YmxlVGFwTGlzdGVuZXI6IGZ1bmN0aW9uIChvYmosIGhhbmRsZXIsIGlkKSB7XHJcblx0XHR2YXIgbGFzdCxcclxuXHRcdCAgICBkb3VibGVUYXAgPSBmYWxzZSxcclxuXHRcdCAgICBkZWxheSA9IDI1MCxcclxuXHRcdCAgICB0b3VjaCxcclxuXHRcdCAgICBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaHN0YXJ0ID0gdGhpcy5fdG91Y2hzdGFydCxcclxuXHRcdCAgICB0b3VjaGVuZCA9IHRoaXMuX3RvdWNoZW5kLFxyXG5cdFx0ICAgIHRyYWNrZWRUb3VjaGVzID0gW107XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaFN0YXJ0KGUpIHtcclxuXHRcdFx0dmFyIGNvdW50O1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdFx0dHJhY2tlZFRvdWNoZXMucHVzaChlLnBvaW50ZXJJZCk7XHJcblx0XHRcdFx0Y291bnQgPSB0cmFja2VkVG91Y2hlcy5sZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y291bnQgPSBlLnRvdWNoZXMubGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjb3VudCA+IDEpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHZhciBub3cgPSBEYXRlLm5vdygpLFxyXG5cdFx0XHRcdGRlbHRhID0gbm93IC0gKGxhc3QgfHwgbm93KTtcclxuXHJcblx0XHRcdHRvdWNoID0gZS50b3VjaGVzID8gZS50b3VjaGVzWzBdIDogZTtcclxuXHRcdFx0ZG91YmxlVGFwID0gKGRlbHRhID4gMCAmJiBkZWx0YSA8PSBkZWxheSk7XHJcblx0XHRcdGxhc3QgPSBub3c7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25Ub3VjaEVuZChlKSB7XHJcblx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdHZhciBpZHggPSB0cmFja2VkVG91Y2hlcy5pbmRleE9mKGUucG9pbnRlcklkKTtcclxuXHRcdFx0XHRpZiAoaWR4ID09PSAtMSkge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0cmFja2VkVG91Y2hlcy5zcGxpY2UoaWR4LCAxKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYgKGRvdWJsZVRhcCkge1xyXG5cdFx0XHRcdGlmIChMLkJyb3dzZXIucG9pbnRlcikge1xyXG5cdFx0XHRcdFx0Ly8gd29yayBhcm91bmQgLnR5cGUgYmVpbmcgcmVhZG9ubHkgd2l0aCBNU1BvaW50ZXIqIGV2ZW50c1xyXG5cdFx0XHRcdFx0dmFyIG5ld1RvdWNoID0geyB9LFxyXG5cdFx0XHRcdFx0XHRwcm9wO1xyXG5cclxuXHRcdFx0XHRcdC8vIGpzaGludCBmb3JpbjpmYWxzZVxyXG5cdFx0XHRcdFx0Zm9yICh2YXIgaSBpbiB0b3VjaCkge1xyXG5cdFx0XHRcdFx0XHRwcm9wID0gdG91Y2hbaV07XHJcblx0XHRcdFx0XHRcdGlmICh0eXBlb2YgcHJvcCA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdFx0XHRcdG5ld1RvdWNoW2ldID0gcHJvcC5iaW5kKHRvdWNoKTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRuZXdUb3VjaFtpXSA9IHByb3A7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHRvdWNoID0gbmV3VG91Y2g7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHRvdWNoLnR5cGUgPSAnZGJsY2xpY2snO1xyXG5cdFx0XHRcdGhhbmRsZXIodG91Y2gpO1xyXG5cdFx0XHRcdGxhc3QgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRvYmpbcHJlICsgdG91Y2hzdGFydCArIGlkXSA9IG9uVG91Y2hTdGFydDtcclxuXHRcdG9ialtwcmUgKyB0b3VjaGVuZCArIGlkXSA9IG9uVG91Y2hFbmQ7XHJcblxyXG5cdFx0Ly8gb24gcG9pbnRlciB3ZSBuZWVkIHRvIGxpc3RlbiBvbiB0aGUgZG9jdW1lbnQsIG90aGVyd2lzZSBhIGRyYWcgc3RhcnRpbmcgb24gdGhlIG1hcCBhbmQgbW92aW5nIG9mZiBzY3JlZW5cclxuXHRcdC8vIHdpbGwgbm90IGNvbWUgdGhyb3VnaCB0byB1cywgc28gd2Ugd2lsbCBsb3NlIHRyYWNrIG9mIGhvdyBtYW55IHRvdWNoZXMgYXJlIG9uZ29pbmdcclxuXHRcdHZhciBlbmRFbGVtZW50ID0gTC5Ccm93c2VyLnBvaW50ZXIgPyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgOiBvYmo7XHJcblxyXG5cdFx0b2JqLmFkZEV2ZW50TGlzdGVuZXIodG91Y2hzdGFydCwgb25Ub3VjaFN0YXJ0LCBmYWxzZSk7XHJcblx0XHRlbmRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodG91Y2hlbmQsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLnBvaW50ZXIpIHtcclxuXHRcdFx0ZW5kRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKEwuRG9tRXZlbnQuUE9JTlRFUl9DQU5DRUwsIG9uVG91Y2hFbmQsIGZhbHNlKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVEb3VibGVUYXBMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJztcclxuXHJcblx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLl90b3VjaHN0YXJ0LCBvYmpbcHJlICsgdGhpcy5fdG91Y2hzdGFydCArIGlkXSwgZmFsc2UpO1xyXG5cdFx0KEwuQnJvd3Nlci5wb2ludGVyID8gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IDogb2JqKS5yZW1vdmVFdmVudExpc3RlbmVyKFxyXG5cdFx0ICAgICAgICB0aGlzLl90b3VjaGVuZCwgb2JqW3ByZSArIHRoaXMuX3RvdWNoZW5kICsgaWRdLCBmYWxzZSk7XHJcblxyXG5cdFx0aWYgKEwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0XHRcdGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKEwuRG9tRXZlbnQuUE9JTlRFUl9DQU5DRUwsIG9ialtwcmUgKyB0aGlzLl90b3VjaGVuZCArIGlkXSxcclxuXHRcdFx0XHRmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBFeHRlbmRzIEwuRG9tRXZlbnQgdG8gcHJvdmlkZSB0b3VjaCBzdXBwb3J0IGZvciBJbnRlcm5ldCBFeHBsb3JlciBhbmQgV2luZG93cy1iYXNlZCBkZXZpY2VzLlxyXG4gKi9cclxuXHJcbkwuZXh0ZW5kKEwuRG9tRXZlbnQsIHtcclxuXHJcblx0Ly9zdGF0aWNcclxuXHRQT0lOVEVSX0RPV046IEwuQnJvd3Nlci5tc1BvaW50ZXIgPyAnTVNQb2ludGVyRG93bicgOiAncG9pbnRlcmRvd24nLFxyXG5cdFBPSU5URVJfTU9WRTogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJNb3ZlJyA6ICdwb2ludGVybW92ZScsXHJcblx0UE9JTlRFUl9VUDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJVcCcgOiAncG9pbnRlcnVwJyxcclxuXHRQT0lOVEVSX0NBTkNFTDogTC5Ccm93c2VyLm1zUG9pbnRlciA/ICdNU1BvaW50ZXJDYW5jZWwnIDogJ3BvaW50ZXJjYW5jZWwnLFxyXG5cclxuXHRfcG9pbnRlcnM6IFtdLFxyXG5cdF9wb2ludGVyRG9jdW1lbnRMaXN0ZW5lcjogZmFsc2UsXHJcblxyXG5cdC8vIFByb3ZpZGVzIGEgdG91Y2ggZXZlbnRzIHdyYXBwZXIgZm9yIChtcylwb2ludGVyIGV2ZW50cy5cclxuXHQvLyBCYXNlZCBvbiBjaGFuZ2VzIGJ5IHZlcHJvemEgaHR0cHM6Ly9naXRodWIuY29tL0Nsb3VkTWFkZS9MZWFmbGV0L3B1bGwvMTAxOVxyXG5cdC8vcmVmIGh0dHA6Ly93d3cudzMub3JnL1RSL3BvaW50ZXJldmVudHMvIGh0dHBzOi8vd3d3LnczLm9yZy9CdWdzL1B1YmxpYy9zaG93X2J1Zy5jZ2k/aWQ9MjI4OTBcclxuXHJcblx0YWRkUG9pbnRlckxpc3RlbmVyOiBmdW5jdGlvbiAob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCkge1xyXG5cclxuXHRcdHN3aXRjaCAodHlwZSkge1xyXG5cdFx0Y2FzZSAndG91Y2hzdGFydCc6XHJcblx0XHRcdHJldHVybiB0aGlzLmFkZFBvaW50ZXJMaXN0ZW5lclN0YXJ0KG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cdFx0Y2FzZSAndG91Y2hlbmQnOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJFbmQob2JqLCB0eXBlLCBoYW5kbGVyLCBpZCk7XHJcblx0XHRjYXNlICd0b3VjaG1vdmUnOlxyXG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRQb2ludGVyTGlzdGVuZXJNb3ZlKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0dGhyb3cgJ1Vua25vd24gdG91Y2ggZXZlbnQgdHlwZSc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0YWRkUG9pbnRlckxpc3RlbmVyU3RhcnQ6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgcG9pbnRlcnMgPSB0aGlzLl9wb2ludGVycztcclxuXHJcblx0XHR2YXIgY2IgPSBmdW5jdGlvbiAoZSkge1xyXG5cclxuXHRcdFx0TC5Eb21FdmVudC5wcmV2ZW50RGVmYXVsdChlKTtcclxuXHJcblx0XHRcdHZhciBhbHJlYWR5SW5BcnJheSA9IGZhbHNlO1xyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50ZXJzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHBvaW50ZXJzW2ldLnBvaW50ZXJJZCA9PT0gZS5wb2ludGVySWQpIHtcclxuXHRcdFx0XHRcdGFscmVhZHlJbkFycmF5ID0gdHJ1ZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoIWFscmVhZHlJbkFycmF5KSB7XHJcblx0XHRcdFx0cG9pbnRlcnMucHVzaChlKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZS50b3VjaGVzID0gcG9pbnRlcnMuc2xpY2UoKTtcclxuXHRcdFx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcclxuXHJcblx0XHRcdGhhbmRsZXIoZSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdG9ialtwcmUgKyAndG91Y2hzdGFydCcgKyBpZF0gPSBjYjtcclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBjYiwgZmFsc2UpO1xyXG5cclxuXHRcdC8vIG5lZWQgdG8gYWxzbyBsaXN0ZW4gZm9yIGVuZCBldmVudHMgdG8ga2VlcCB0aGUgX3BvaW50ZXJzIGxpc3QgYWNjdXJhdGVcclxuXHRcdC8vIHRoaXMgbmVlZHMgdG8gYmUgb24gdGhlIGJvZHkgYW5kIG5ldmVyIGdvIGF3YXlcclxuXHRcdGlmICghdGhpcy5fcG9pbnRlckRvY3VtZW50TGlzdGVuZXIpIHtcclxuXHRcdFx0dmFyIGludGVybmFsQ2IgPSBmdW5jdGlvbiAoZSkge1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGlmIChwb2ludGVyc1tpXS5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XHJcblx0XHRcdFx0XHRcdHBvaW50ZXJzLnNwbGljZShpLCAxKTtcclxuXHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cdFx0XHQvL1dlIGxpc3RlbiBvbiB0aGUgZG9jdW1lbnRFbGVtZW50IGFzIGFueSBkcmFncyB0aGF0IGVuZCBieSBtb3ZpbmcgdGhlIHRvdWNoIG9mZiB0aGUgc2NyZWVuIGdldCBmaXJlZCB0aGVyZVxyXG5cdFx0XHRkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGludGVybmFsQ2IsIGZhbHNlKTtcclxuXHRcdFx0ZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX0NBTkNFTCwgaW50ZXJuYWxDYiwgZmFsc2UpO1xyXG5cclxuXHRcdFx0dGhpcy5fcG9pbnRlckRvY3VtZW50TGlzdGVuZXIgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZFBvaW50ZXJMaXN0ZW5lck1vdmU6IGZ1bmN0aW9uIChvYmosIHR5cGUsIGhhbmRsZXIsIGlkKSB7XHJcblx0XHR2YXIgcHJlID0gJ19sZWFmbGV0XycsXHJcblx0XHQgICAgdG91Y2hlcyA9IHRoaXMuX3BvaW50ZXJzO1xyXG5cclxuXHRcdGZ1bmN0aW9uIGNiKGUpIHtcclxuXHJcblx0XHRcdC8vIGRvbid0IGZpcmUgdG91Y2ggbW92ZXMgd2hlbiBtb3VzZSBpc24ndCBkb3duXHJcblx0XHRcdGlmICgoZS5wb2ludGVyVHlwZSA9PT0gZS5NU1BPSU5URVJfVFlQRV9NT1VTRSB8fCBlLnBvaW50ZXJUeXBlID09PSAnbW91c2UnKSAmJiBlLmJ1dHRvbnMgPT09IDApIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRvdWNoZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRpZiAodG91Y2hlc1tpXS5wb2ludGVySWQgPT09IGUucG9pbnRlcklkKSB7XHJcblx0XHRcdFx0XHR0b3VjaGVzW2ldID0gZTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0ZS50b3VjaGVzID0gdG91Y2hlcy5zbGljZSgpO1xyXG5cdFx0XHRlLmNoYW5nZWRUb3VjaGVzID0gW2VdO1xyXG5cclxuXHRcdFx0aGFuZGxlcihlKTtcclxuXHRcdH1cclxuXHJcblx0XHRvYmpbcHJlICsgJ3RvdWNobW92ZScgKyBpZF0gPSBjYjtcclxuXHRcdG9iai5hZGRFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBjYiwgZmFsc2UpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZFBvaW50ZXJMaXN0ZW5lckVuZDogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaGFuZGxlciwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICB0b3VjaGVzID0gdGhpcy5fcG9pbnRlcnM7XHJcblxyXG5cdFx0dmFyIGNiID0gZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCB0b3VjaGVzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0aWYgKHRvdWNoZXNbaV0ucG9pbnRlcklkID09PSBlLnBvaW50ZXJJZCkge1xyXG5cdFx0XHRcdFx0dG91Y2hlcy5zcGxpY2UoaSwgMSk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGUudG91Y2hlcyA9IHRvdWNoZXMuc2xpY2UoKTtcclxuXHRcdFx0ZS5jaGFuZ2VkVG91Y2hlcyA9IFtlXTtcclxuXHJcblx0XHRcdGhhbmRsZXIoZSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdG9ialtwcmUgKyAndG91Y2hlbmQnICsgaWRdID0gY2I7XHJcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfVVAsIGNiLCBmYWxzZSk7XHJcblx0XHRvYmouYWRkRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBjYiwgZmFsc2UpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZVBvaW50ZXJMaXN0ZW5lcjogZnVuY3Rpb24gKG9iaiwgdHlwZSwgaWQpIHtcclxuXHRcdHZhciBwcmUgPSAnX2xlYWZsZXRfJyxcclxuXHRcdCAgICBjYiA9IG9ialtwcmUgKyB0eXBlICsgaWRdO1xyXG5cclxuXHRcdHN3aXRjaCAodHlwZSkge1xyXG5cdFx0Y2FzZSAndG91Y2hzdGFydCc6XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9ET1dOLCBjYiwgZmFsc2UpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3RvdWNobW92ZSc6XHJcblx0XHRcdG9iai5yZW1vdmVFdmVudExpc3RlbmVyKHRoaXMuUE9JTlRFUl9NT1ZFLCBjYiwgZmFsc2UpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgJ3RvdWNoZW5kJzpcclxuXHRcdFx0b2JqLnJlbW92ZUV2ZW50TGlzdGVuZXIodGhpcy5QT0lOVEVSX1VQLCBjYiwgZmFsc2UpO1xyXG5cdFx0XHRvYmoucmVtb3ZlRXZlbnRMaXN0ZW5lcih0aGlzLlBPSU5URVJfQ0FOQ0VMLCBjYiwgZmFsc2UpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuSGFuZGxlci5Ub3VjaFpvb20gaXMgdXNlZCBieSBMLk1hcCB0byBhZGQgcGluY2ggem9vbSBvbiBzdXBwb3J0ZWQgbW9iaWxlIGJyb3dzZXJzLlxyXG4gKi9cclxuXHJcbkwuTWFwLm1lcmdlT3B0aW9ucyh7XHJcblx0dG91Y2hab29tOiBMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5hbmRyb2lkMjMsXHJcblx0Ym91bmNlQXRab29tTGltaXRzOiB0cnVlXHJcbn0pO1xyXG5cclxuTC5NYXAuVG91Y2hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XHJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fbWFwLl9jb250YWluZXIsICd0b3VjaHN0YXJ0JywgdGhpcy5fb25Ub3VjaFN0YXJ0LCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfb25Ub3VjaFN0YXJ0OiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAoIWUudG91Y2hlcyB8fCBlLnRvdWNoZXMubGVuZ3RoICE9PSAyIHx8IG1hcC5fYW5pbWF0aW5nWm9vbSB8fCB0aGlzLl96b29taW5nKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBwMSA9IG1hcC5tb3VzZUV2ZW50VG9MYXllclBvaW50KGUudG91Y2hlc1swXSksXHJcblx0XHQgICAgcDIgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMV0pLFxyXG5cdFx0ICAgIHZpZXdDZW50ZXIgPSBtYXAuX2dldENlbnRlckxheWVyUG9pbnQoKTtcclxuXHJcblx0XHR0aGlzLl9zdGFydENlbnRlciA9IHAxLmFkZChwMikuX2RpdmlkZUJ5KDIpO1xyXG5cdFx0dGhpcy5fc3RhcnREaXN0ID0gcDEuZGlzdGFuY2VUbyhwMik7XHJcblxyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX3pvb21pbmcgPSB0cnVlO1xyXG5cclxuXHRcdHRoaXMuX2NlbnRlck9mZnNldCA9IHZpZXdDZW50ZXIuc3VidHJhY3QodGhpcy5fc3RhcnRDZW50ZXIpO1xyXG5cclxuXHRcdGlmIChtYXAuX3BhbkFuaW0pIHtcclxuXHRcdFx0bWFwLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRoaXMpXHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCAndG91Y2hlbmQnLCB0aGlzLl9vblRvdWNoRW5kLCB0aGlzKTtcclxuXHJcblx0XHRMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRvdWNoTW92ZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0aWYgKCFlLnRvdWNoZXMgfHwgZS50b3VjaGVzLmxlbmd0aCAhPT0gMiB8fCAhdGhpcy5fem9vbWluZykgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgcDEgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlLnRvdWNoZXNbMF0pLFxyXG5cdFx0ICAgIHAyID0gbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZS50b3VjaGVzWzFdKTtcclxuXHJcblx0XHR0aGlzLl9zY2FsZSA9IHAxLmRpc3RhbmNlVG8ocDIpIC8gdGhpcy5fc3RhcnREaXN0O1xyXG5cdFx0dGhpcy5fZGVsdGEgPSBwMS5fYWRkKHAyKS5fZGl2aWRlQnkoMikuX3N1YnRyYWN0KHRoaXMuX3N0YXJ0Q2VudGVyKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc2NhbGUgPT09IDEpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCFtYXAub3B0aW9ucy5ib3VuY2VBdFpvb21MaW1pdHMpIHtcclxuXHRcdFx0aWYgKChtYXAuZ2V0Wm9vbSgpID09PSBtYXAuZ2V0TWluWm9vbSgpICYmIHRoaXMuX3NjYWxlIDwgMSkgfHxcclxuXHRcdFx0ICAgIChtYXAuZ2V0Wm9vbSgpID09PSBtYXAuZ2V0TWF4Wm9vbSgpICYmIHRoaXMuX3NjYWxlID4gMSkpIHsgcmV0dXJuOyB9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MobWFwLl9tYXBQYW5lLCAnbGVhZmxldC10b3VjaGluZycpO1xyXG5cclxuXHRcdFx0bWFwXHJcblx0XHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0JylcclxuXHRcdFx0ICAgIC5maXJlKCd6b29tc3RhcnQnKTtcclxuXHJcblx0XHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1SZXF1ZXN0KTtcclxuXHRcdHRoaXMuX2FuaW1SZXF1ZXN0ID0gTC5VdGlsLnJlcXVlc3RBbmltRnJhbWUoXHJcblx0XHQgICAgICAgIHRoaXMuX3VwZGF0ZU9uTW92ZSwgdGhpcywgdHJ1ZSwgdGhpcy5fbWFwLl9jb250YWluZXIpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU9uTW92ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcCxcclxuXHRcdCAgICBvcmlnaW4gPSB0aGlzLl9nZXRTY2FsZU9yaWdpbigpLFxyXG5cdFx0ICAgIGNlbnRlciA9IG1hcC5sYXllclBvaW50VG9MYXRMbmcob3JpZ2luKSxcclxuXHRcdCAgICB6b29tID0gbWFwLmdldFNjYWxlWm9vbSh0aGlzLl9zY2FsZSk7XHJcblxyXG5cdFx0bWFwLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIHRoaXMuX3N0YXJ0Q2VudGVyLCB0aGlzLl9zY2FsZSwgdGhpcy5fZGVsdGEpO1xyXG5cdH0sXHJcblxyXG5cdF9vblRvdWNoRW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX21vdmVkIHx8ICF0aGlzLl96b29taW5nKSB7XHJcblx0XHRcdHRoaXMuX3pvb21pbmcgPSBmYWxzZTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXA7XHJcblxyXG5cdFx0dGhpcy5fem9vbWluZyA9IGZhbHNlO1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKG1hcC5fbWFwUGFuZSwgJ2xlYWZsZXQtdG91Y2hpbmcnKTtcclxuXHRcdEwuVXRpbC5jYW5jZWxBbmltRnJhbWUodGhpcy5fYW5pbVJlcXVlc3QpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUpXHJcblx0XHQgICAgLm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25Ub3VjaEVuZCk7XHJcblxyXG5cdFx0dmFyIG9yaWdpbiA9IHRoaXMuX2dldFNjYWxlT3JpZ2luKCksXHJcblx0XHQgICAgY2VudGVyID0gbWFwLmxheWVyUG9pbnRUb0xhdExuZyhvcmlnaW4pLFxyXG5cclxuXHRcdCAgICBvbGRab29tID0gbWFwLmdldFpvb20oKSxcclxuXHRcdCAgICBmbG9hdFpvb21EZWx0YSA9IG1hcC5nZXRTY2FsZVpvb20odGhpcy5fc2NhbGUpIC0gb2xkWm9vbSxcclxuXHRcdCAgICByb3VuZFpvb21EZWx0YSA9IChmbG9hdFpvb21EZWx0YSA+IDAgP1xyXG5cdFx0ICAgICAgICAgICAgTWF0aC5jZWlsKGZsb2F0Wm9vbURlbHRhKSA6IE1hdGguZmxvb3IoZmxvYXRab29tRGVsdGEpKSxcclxuXHJcblx0XHQgICAgem9vbSA9IG1hcC5fbGltaXRab29tKG9sZFpvb20gKyByb3VuZFpvb21EZWx0YSksXHJcblx0XHQgICAgc2NhbGUgPSBtYXAuZ2V0Wm9vbVNjYWxlKHpvb20pIC8gdGhpcy5fc2NhbGU7XHJcblxyXG5cdFx0bWFwLl9hbmltYXRlWm9vbShjZW50ZXIsIHpvb20sIG9yaWdpbiwgc2NhbGUpO1xyXG5cdH0sXHJcblxyXG5cdF9nZXRTY2FsZU9yaWdpbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNlbnRlck9mZnNldCA9IHRoaXMuX2NlbnRlck9mZnNldC5zdWJ0cmFjdCh0aGlzLl9kZWx0YSkuZGl2aWRlQnkodGhpcy5fc2NhbGUpO1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N0YXJ0Q2VudGVyLmFkZChjZW50ZXJPZmZzZXQpO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5hZGRJbml0SG9vaygnYWRkSGFuZGxlcicsICd0b3VjaFpvb20nLCBMLk1hcC5Ub3VjaFpvb20pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuTWFwLlRhcCBpcyB1c2VkIHRvIGVuYWJsZSBtb2JpbGUgaGFja3MgbGlrZSBxdWljayB0YXBzIGFuZCBsb25nIGhvbGQuXHJcbiAqL1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR0YXA6IHRydWUsXHJcblx0dGFwVG9sZXJhbmNlOiAxNVxyXG59KTtcclxuXHJcbkwuTWFwLlRhcCA9IEwuSGFuZGxlci5leHRlbmQoe1xyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbUV2ZW50Lm9uKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0cmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKHRoaXMuX21hcC5fY29udGFpbmVyLCAndG91Y2hzdGFydCcsIHRoaXMuX29uRG93biwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uRG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdGlmICghZS50b3VjaGVzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdEwuRG9tRXZlbnQucHJldmVudERlZmF1bHQoZSk7XHJcblxyXG5cdFx0dGhpcy5fZmlyZUNsaWNrID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBkb24ndCBzaW11bGF0ZSBjbGljayBvciB0cmFjayBsb25ncHJlc3MgaWYgbW9yZSB0aGFuIDEgdG91Y2hcclxuXHRcdGlmIChlLnRvdWNoZXMubGVuZ3RoID4gMSkge1xyXG5cdFx0XHR0aGlzLl9maXJlQ2xpY2sgPSBmYWxzZTtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuX2hvbGRUaW1lb3V0KTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBmaXJzdCA9IGUudG91Y2hlc1swXSxcclxuXHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcclxuXHJcblx0XHR0aGlzLl9zdGFydFBvcyA9IHRoaXMuX25ld1BvcyA9IG5ldyBMLlBvaW50KGZpcnN0LmNsaWVudFgsIGZpcnN0LmNsaWVudFkpO1xyXG5cclxuXHRcdC8vIGlmIHRvdWNoaW5nIGEgbGluaywgaGlnaGxpZ2h0IGl0XHJcblx0XHRpZiAoZWwudGFnTmFtZSAmJiBlbC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdhJykge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3MoZWwsICdsZWFmbGV0LWFjdGl2ZScpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIHNpbXVsYXRlIGxvbmcgaG9sZCBidXQgc2V0dGluZyBhIHRpbWVvdXRcclxuXHRcdHRoaXMuX2hvbGRUaW1lb3V0ID0gc2V0VGltZW91dChMLmJpbmQoZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRpZiAodGhpcy5faXNUYXBWYWxpZCgpKSB7XHJcblx0XHRcdFx0dGhpcy5fZmlyZUNsaWNrID0gZmFsc2U7XHJcblx0XHRcdFx0dGhpcy5fb25VcCgpO1xyXG5cdFx0XHRcdHRoaXMuX3NpbXVsYXRlRXZlbnQoJ2NvbnRleHRtZW51JywgZmlyc3QpO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0aGlzKSwgMTAwMCk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0XHQub24oZG9jdW1lbnQsICd0b3VjaG1vdmUnLCB0aGlzLl9vbk1vdmUsIHRoaXMpXHJcblx0XHRcdC5vbihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uVXA6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5faG9sZFRpbWVvdXQpO1xyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0Lm9mZihkb2N1bWVudCwgJ3RvdWNobW92ZScsIHRoaXMuX29uTW92ZSwgdGhpcylcclxuXHRcdFx0Lm9mZihkb2N1bWVudCwgJ3RvdWNoZW5kJywgdGhpcy5fb25VcCwgdGhpcyk7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2ZpcmVDbGljayAmJiBlICYmIGUuY2hhbmdlZFRvdWNoZXMpIHtcclxuXHJcblx0XHRcdHZhciBmaXJzdCA9IGUuY2hhbmdlZFRvdWNoZXNbMF0sXHJcblx0XHRcdCAgICBlbCA9IGZpcnN0LnRhcmdldDtcclxuXHJcblx0XHRcdGlmIChlbCAmJiBlbC50YWdOYW1lICYmIGVsLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ2EnKSB7XHJcblx0XHRcdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKGVsLCAnbGVhZmxldC1hY3RpdmUnKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc2ltdWxhdGUgY2xpY2sgaWYgdGhlIHRvdWNoIGRpZG4ndCBtb3ZlIHRvbyBtdWNoXHJcblx0XHRcdGlmICh0aGlzLl9pc1RhcFZhbGlkKCkpIHtcclxuXHRcdFx0XHR0aGlzLl9zaW11bGF0ZUV2ZW50KCdjbGljaycsIGZpcnN0KTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9pc1RhcFZhbGlkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbmV3UG9zLmRpc3RhbmNlVG8odGhpcy5fc3RhcnRQb3MpIDw9IHRoaXMuX21hcC5vcHRpb25zLnRhcFRvbGVyYW5jZTtcclxuXHR9LFxyXG5cclxuXHRfb25Nb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dmFyIGZpcnN0ID0gZS50b3VjaGVzWzBdO1xyXG5cdFx0dGhpcy5fbmV3UG9zID0gbmV3IEwuUG9pbnQoZmlyc3QuY2xpZW50WCwgZmlyc3QuY2xpZW50WSk7XHJcblx0fSxcclxuXHJcblx0X3NpbXVsYXRlRXZlbnQ6IGZ1bmN0aW9uICh0eXBlLCBlKSB7XHJcblx0XHR2YXIgc2ltdWxhdGVkRXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcclxuXHJcblx0XHRzaW11bGF0ZWRFdmVudC5fc2ltdWxhdGVkID0gdHJ1ZTtcclxuXHRcdGUudGFyZ2V0Ll9zaW11bGF0ZWRDbGljayA9IHRydWU7XHJcblxyXG5cdFx0c2ltdWxhdGVkRXZlbnQuaW5pdE1vdXNlRXZlbnQoXHJcblx0XHQgICAgICAgIHR5cGUsIHRydWUsIHRydWUsIHdpbmRvdywgMSxcclxuXHRcdCAgICAgICAgZS5zY3JlZW5YLCBlLnNjcmVlblksXHJcblx0XHQgICAgICAgIGUuY2xpZW50WCwgZS5jbGllbnRZLFxyXG5cdFx0ICAgICAgICBmYWxzZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSwgMCwgbnVsbCk7XHJcblxyXG5cdFx0ZS50YXJnZXQuZGlzcGF0Y2hFdmVudChzaW11bGF0ZWRFdmVudCk7XHJcblx0fVxyXG59KTtcclxuXHJcbmlmIChMLkJyb3dzZXIudG91Y2ggJiYgIUwuQnJvd3Nlci5wb2ludGVyKSB7XHJcblx0TC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAndGFwJywgTC5NYXAuVGFwKTtcclxufVxyXG5cclxuXHJcbi8qXHJcbiAqIEwuSGFuZGxlci5TaGlmdERyYWdab29tIGlzIHVzZWQgdG8gYWRkIHNoaWZ0LWRyYWcgem9vbSBpbnRlcmFjdGlvbiB0byB0aGUgbWFwXHJcbiAgKiAoem9vbSB0byBhIHNlbGVjdGVkIGJvdW5kaW5nIGJveCksIGVuYWJsZWQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGJveFpvb206IHRydWVcclxufSk7XHJcblxyXG5MLk1hcC5Cb3hab29tID0gTC5IYW5kbGVyLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gbWFwLl9jb250YWluZXI7XHJcblx0XHR0aGlzLl9wYW5lID0gbWFwLl9wYW5lcy5vdmVybGF5UGFuZTtcclxuXHRcdHRoaXMuX21vdmVkID0gZmFsc2U7XHJcblx0fSxcclxuXHJcblx0YWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24odGhpcy5fY29udGFpbmVyLCAnbW91c2Vkb3duJywgdGhpcy5fb25Nb3VzZURvd24sIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbUV2ZW50Lm9mZih0aGlzLl9jb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93bik7XHJcblx0XHR0aGlzLl9tb3ZlZCA9IGZhbHNlO1xyXG5cdH0sXHJcblxyXG5cdG1vdmVkOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fbW92ZWQ7XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0dGhpcy5fbW92ZWQgPSBmYWxzZTtcclxuXHJcblx0XHRpZiAoIWUuc2hpZnRLZXkgfHwgKChlLndoaWNoICE9PSAxKSAmJiAoZS5idXR0b24gIT09IDEpKSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHRMLkRvbVV0aWwuZGlzYWJsZVRleHRTZWxlY3Rpb24oKTtcclxuXHRcdEwuRG9tVXRpbC5kaXNhYmxlSW1hZ2VEcmFnKCk7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRMYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ21vdXNlbW92ZScsIHRoaXMuX29uTW91c2VNb3ZlLCB0aGlzKVxyXG5cdFx0ICAgIC5vbihkb2N1bWVudCwgJ21vdXNldXAnLCB0aGlzLl9vbk1vdXNlVXAsIHRoaXMpXHJcblx0XHQgICAgLm9uKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VNb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKCF0aGlzLl9tb3ZlZCkge1xyXG5cdFx0XHR0aGlzLl9ib3ggPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCAnbGVhZmxldC16b29tLWJveCcsIHRoaXMuX3BhbmUpO1xyXG5cdFx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fYm94LCB0aGlzLl9zdGFydExheWVyUG9pbnQpO1xyXG5cclxuXHRcdFx0Ly9UT0RPIHJlZmFjdG9yOiBtb3ZlIGN1cnNvciB0byBzdHlsZXNcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICdjcm9zc2hhaXInO1xyXG5cdFx0XHR0aGlzLl9tYXAuZmlyZSgnYm94em9vbXN0YXJ0Jyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHN0YXJ0UG9pbnQgPSB0aGlzLl9zdGFydExheWVyUG9pbnQsXHJcblx0XHQgICAgYm94ID0gdGhpcy5fYm94LFxyXG5cclxuXHRcdCAgICBsYXllclBvaW50ID0gdGhpcy5fbWFwLm1vdXNlRXZlbnRUb0xheWVyUG9pbnQoZSksXHJcblx0XHQgICAgb2Zmc2V0ID0gbGF5ZXJQb2ludC5zdWJ0cmFjdChzdGFydFBvaW50KSxcclxuXHJcblx0XHQgICAgbmV3UG9zID0gbmV3IEwuUG9pbnQoXHJcblx0XHQgICAgICAgIE1hdGgubWluKGxheWVyUG9pbnQueCwgc3RhcnRQb2ludC54KSxcclxuXHRcdCAgICAgICAgTWF0aC5taW4obGF5ZXJQb2ludC55LCBzdGFydFBvaW50LnkpKTtcclxuXHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oYm94LCBuZXdQb3MpO1xyXG5cclxuXHRcdHRoaXMuX21vdmVkID0gdHJ1ZTtcclxuXHJcblx0XHQvLyBUT0RPIHJlZmFjdG9yOiByZW1vdmUgaGFyZGNvZGVkIDQgcGl4ZWxzXHJcblx0XHRib3guc3R5bGUud2lkdGggID0gKE1hdGgubWF4KDAsIE1hdGguYWJzKG9mZnNldC54KSAtIDQpKSArICdweCc7XHJcblx0XHRib3guc3R5bGUuaGVpZ2h0ID0gKE1hdGgubWF4KDAsIE1hdGguYWJzKG9mZnNldC55KSAtIDQpKSArICdweCc7XHJcblx0fSxcclxuXHJcblx0X2ZpbmlzaDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKHRoaXMuX21vdmVkKSB7XHJcblx0XHRcdHRoaXMuX3BhbmUucmVtb3ZlQ2hpbGQodGhpcy5fYm94KTtcclxuXHRcdFx0dGhpcy5fY29udGFpbmVyLnN0eWxlLmN1cnNvciA9ICcnO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tVXRpbC5lbmFibGVUZXh0U2VsZWN0aW9uKCk7XHJcblx0XHRMLkRvbVV0aWwuZW5hYmxlSW1hZ2VEcmFnKCk7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vZmYoZG9jdW1lbnQsICdtb3VzZW1vdmUnLCB0aGlzLl9vbk1vdXNlTW92ZSlcclxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAnbW91c2V1cCcsIHRoaXMuX29uTW91c2VVcClcclxuXHRcdCAgICAub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93bik7XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VVcDogZnVuY3Rpb24gKGUpIHtcclxuXHJcblx0XHR0aGlzLl9maW5pc2goKTtcclxuXHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwLFxyXG5cdFx0ICAgIGxheWVyUG9pbnQgPSBtYXAubW91c2VFdmVudFRvTGF5ZXJQb2ludChlKTtcclxuXHJcblx0XHRpZiAodGhpcy5fc3RhcnRMYXllclBvaW50LmVxdWFscyhsYXllclBvaW50KSkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYm91bmRzID0gbmV3IEwuTGF0TG5nQm91bmRzKFxyXG5cdFx0ICAgICAgICBtYXAubGF5ZXJQb2ludFRvTGF0TG5nKHRoaXMuX3N0YXJ0TGF5ZXJQb2ludCksXHJcblx0XHQgICAgICAgIG1hcC5sYXllclBvaW50VG9MYXRMbmcobGF5ZXJQb2ludCkpO1xyXG5cclxuXHRcdG1hcC5maXRCb3VuZHMoYm91bmRzKTtcclxuXHJcblx0XHRtYXAuZmlyZSgnYm94em9vbWVuZCcsIHtcclxuXHRcdFx0Ym94Wm9vbUJvdW5kczogYm91bmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfb25LZXlEb3duOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUua2V5Q29kZSA9PT0gMjcpIHtcclxuXHRcdFx0dGhpcy5fZmluaXNoKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKCdhZGRIYW5kbGVyJywgJ2JveFpvb20nLCBMLk1hcC5Cb3hab29tKTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLk1hcC5LZXlib2FyZCBpcyBoYW5kbGluZyBrZXlib2FyZCBpbnRlcmFjdGlvbiB3aXRoIHRoZSBtYXAsIGVuYWJsZWQgYnkgZGVmYXVsdC5cclxuICovXHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGtleWJvYXJkOiB0cnVlLFxyXG5cdGtleWJvYXJkUGFuT2Zmc2V0OiA4MCxcclxuXHRrZXlib2FyZFpvb21PZmZzZXQ6IDFcclxufSk7XHJcblxyXG5MLk1hcC5LZXlib2FyZCA9IEwuSGFuZGxlci5leHRlbmQoe1xyXG5cclxuXHRrZXlDb2Rlczoge1xyXG5cdFx0bGVmdDogICAgWzM3XSxcclxuXHRcdHJpZ2h0OiAgIFszOV0sXHJcblx0XHRkb3duOiAgICBbNDBdLFxyXG5cdFx0dXA6ICAgICAgWzM4XSxcclxuXHRcdHpvb21JbjogIFsxODcsIDEwNywgNjEsIDE3MV0sXHJcblx0XHR6b29tT3V0OiBbMTg5LCAxMDksIDE3M11cclxuXHR9LFxyXG5cclxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR0aGlzLl9tYXAgPSBtYXA7XHJcblxyXG5cdFx0dGhpcy5fc2V0UGFuT2Zmc2V0KG1hcC5vcHRpb25zLmtleWJvYXJkUGFuT2Zmc2V0KTtcclxuXHRcdHRoaXMuX3NldFpvb21PZmZzZXQobWFwLm9wdGlvbnMua2V5Ym9hcmRab29tT2Zmc2V0KTtcclxuXHR9LFxyXG5cclxuXHRhZGRIb29rczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX21hcC5fY29udGFpbmVyO1xyXG5cclxuXHRcdC8vIG1ha2UgdGhlIGNvbnRhaW5lciBmb2N1c2FibGUgYnkgdGFiYmluZ1xyXG5cdFx0aWYgKGNvbnRhaW5lci50YWJJbmRleCA9PT0gLTEpIHtcclxuXHRcdFx0Y29udGFpbmVyLnRhYkluZGV4ID0gJzAnO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tRXZlbnRcclxuXHRcdCAgICAub24oY29udGFpbmVyLCAnZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB0aGlzKVxyXG5cdFx0ICAgIC5vbihjb250YWluZXIsICdibHVyJywgdGhpcy5fb25CbHVyLCB0aGlzKVxyXG5cdFx0ICAgIC5vbihjb250YWluZXIsICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fbWFwXHJcblx0XHQgICAgLm9uKCdmb2N1cycsIHRoaXMuX2FkZEhvb2tzLCB0aGlzKVxyXG5cdFx0ICAgIC5vbignYmx1cicsIHRoaXMuX3JlbW92ZUhvb2tzLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVIb29rczogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fcmVtb3ZlSG9va3MoKTtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fbWFwLl9jb250YWluZXI7XHJcblxyXG5cdFx0TC5Eb21FdmVudFxyXG5cdFx0ICAgIC5vZmYoY29udGFpbmVyLCAnZm9jdXMnLCB0aGlzLl9vbkZvY3VzLCB0aGlzKVxyXG5cdFx0ICAgIC5vZmYoY29udGFpbmVyLCAnYmx1cicsIHRoaXMuX29uQmx1ciwgdGhpcylcclxuXHRcdCAgICAub2ZmKGNvbnRhaW5lciwgJ21vdXNlZG93bicsIHRoaXMuX29uTW91c2VEb3duLCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl9tYXBcclxuXHRcdCAgICAub2ZmKCdmb2N1cycsIHRoaXMuX2FkZEhvb2tzLCB0aGlzKVxyXG5cdFx0ICAgIC5vZmYoJ2JsdXInLCB0aGlzLl9yZW1vdmVIb29rcywgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uTW91c2VEb3duOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAodGhpcy5fZm9jdXNlZCkgeyByZXR1cm47IH1cclxuXHJcblx0XHR2YXIgYm9keSA9IGRvY3VtZW50LmJvZHksXHJcblx0XHQgICAgZG9jRWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXHJcblx0XHQgICAgdG9wID0gYm9keS5zY3JvbGxUb3AgfHwgZG9jRWwuc2Nyb2xsVG9wLFxyXG5cdFx0ICAgIGxlZnQgPSBib2R5LnNjcm9sbExlZnQgfHwgZG9jRWwuc2Nyb2xsTGVmdDtcclxuXHJcblx0XHR0aGlzLl9tYXAuX2NvbnRhaW5lci5mb2N1cygpO1xyXG5cclxuXHRcdHdpbmRvdy5zY3JvbGxUbyhsZWZ0LCB0b3ApO1xyXG5cdH0sXHJcblxyXG5cdF9vbkZvY3VzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9mb2N1c2VkID0gdHJ1ZTtcclxuXHRcdHRoaXMuX21hcC5maXJlKCdmb2N1cycpO1xyXG5cdH0sXHJcblxyXG5cdF9vbkJsdXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2ZvY3VzZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuX21hcC5maXJlKCdibHVyJyk7XHJcblx0fSxcclxuXHJcblx0X3NldFBhbk9mZnNldDogZnVuY3Rpb24gKHBhbikge1xyXG5cdFx0dmFyIGtleXMgPSB0aGlzLl9wYW5LZXlzID0ge30sXHJcblx0XHQgICAgY29kZXMgPSB0aGlzLmtleUNvZGVzLFxyXG5cdFx0ICAgIGksIGxlbjtcclxuXHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy5sZWZ0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGtleXNbY29kZXMubGVmdFtpXV0gPSBbLTEgKiBwYW4sIDBdO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMucmlnaHQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0a2V5c1tjb2Rlcy5yaWdodFtpXV0gPSBbcGFuLCAwXTtcclxuXHRcdH1cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNvZGVzLmRvd24ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0a2V5c1tjb2Rlcy5kb3duW2ldXSA9IFswLCBwYW5dO1xyXG5cdFx0fVxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMudXAubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0a2V5c1tjb2Rlcy51cFtpXV0gPSBbMCwgLTEgKiBwYW5dO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9zZXRab29tT2Zmc2V0OiBmdW5jdGlvbiAoem9vbSkge1xyXG5cdFx0dmFyIGtleXMgPSB0aGlzLl96b29tS2V5cyA9IHt9LFxyXG5cdFx0ICAgIGNvZGVzID0gdGhpcy5rZXlDb2RlcyxcclxuXHRcdCAgICBpLCBsZW47XHJcblxyXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY29kZXMuem9vbUluLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGtleXNbY29kZXMuem9vbUluW2ldXSA9IHpvb207XHJcblx0XHR9XHJcblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjb2Rlcy56b29tT3V0Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGtleXNbY29kZXMuem9vbU91dFtpXV0gPSAtem9vbTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfYWRkSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub24oZG9jdW1lbnQsICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0aGlzKTtcclxuXHR9LFxyXG5cclxuXHRfcmVtb3ZlSG9va3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdEwuRG9tRXZlbnQub2ZmKGRvY3VtZW50LCAna2V5ZG93bicsIHRoaXMuX29uS2V5RG93biwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X29uS2V5RG93bjogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBrZXkgPSBlLmtleUNvZGUsXHJcblx0XHQgICAgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChrZXkgaW4gdGhpcy5fcGFuS2V5cykge1xyXG5cclxuXHRcdFx0aWYgKG1hcC5fcGFuQW5pbSAmJiBtYXAuX3BhbkFuaW0uX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0XHRtYXAucGFuQnkodGhpcy5fcGFuS2V5c1trZXldKTtcclxuXHJcblx0XHRcdGlmIChtYXAub3B0aW9ucy5tYXhCb3VuZHMpIHtcclxuXHRcdFx0XHRtYXAucGFuSW5zaWRlQm91bmRzKG1hcC5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHR9IGVsc2UgaWYgKGtleSBpbiB0aGlzLl96b29tS2V5cykge1xyXG5cdFx0XHRtYXAuc2V0Wm9vbShtYXAuZ2V0Wm9vbSgpICsgdGhpcy5fem9vbUtleXNba2V5XSk7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdEwuRG9tRXZlbnQuc3RvcChlKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAuYWRkSW5pdEhvb2soJ2FkZEhhbmRsZXInLCAna2V5Ym9hcmQnLCBMLk1hcC5LZXlib2FyZCk7XHJcblxyXG5cclxuLypcclxuICogTC5IYW5kbGVyLk1hcmtlckRyYWcgaXMgdXNlZCBpbnRlcm5hbGx5IGJ5IEwuTWFya2VyIHRvIG1ha2UgdGhlIG1hcmtlcnMgZHJhZ2dhYmxlLlxyXG4gKi9cclxuXHJcbkwuSGFuZGxlci5NYXJrZXJEcmFnID0gTC5IYW5kbGVyLmV4dGVuZCh7XHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcmtlcikge1xyXG5cdFx0dGhpcy5fbWFya2VyID0gbWFya2VyO1xyXG5cdH0sXHJcblxyXG5cdGFkZEhvb2tzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaWNvbiA9IHRoaXMuX21hcmtlci5faWNvbjtcclxuXHRcdGlmICghdGhpcy5fZHJhZ2dhYmxlKSB7XHJcblx0XHRcdHRoaXMuX2RyYWdnYWJsZSA9IG5ldyBMLkRyYWdnYWJsZShpY29uLCBpY29uKTtcclxuXHRcdH1cclxuXHJcblx0XHR0aGlzLl9kcmFnZ2FibGVcclxuXHRcdFx0Lm9uKCdkcmFnc3RhcnQnLCB0aGlzLl9vbkRyYWdTdGFydCwgdGhpcylcclxuXHRcdFx0Lm9uKCdkcmFnJywgdGhpcy5fb25EcmFnLCB0aGlzKVxyXG5cdFx0XHQub24oJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQsIHRoaXMpO1xyXG5cdFx0dGhpcy5fZHJhZ2dhYmxlLmVuYWJsZSgpO1xyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX21hcmtlci5faWNvbiwgJ2xlYWZsZXQtbWFya2VyLWRyYWdnYWJsZScpO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUhvb2tzOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR0aGlzLl9kcmFnZ2FibGVcclxuXHRcdFx0Lm9mZignZHJhZ3N0YXJ0JywgdGhpcy5fb25EcmFnU3RhcnQsIHRoaXMpXHJcblx0XHRcdC5vZmYoJ2RyYWcnLCB0aGlzLl9vbkRyYWcsIHRoaXMpXHJcblx0XHRcdC5vZmYoJ2RyYWdlbmQnLCB0aGlzLl9vbkRyYWdFbmQsIHRoaXMpO1xyXG5cclxuXHRcdHRoaXMuX2RyYWdnYWJsZS5kaXNhYmxlKCk7XHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFya2VyLl9pY29uLCAnbGVhZmxldC1tYXJrZXItZHJhZ2dhYmxlJyk7XHJcblx0fSxcclxuXHJcblx0bW92ZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9kcmFnZ2FibGUgJiYgdGhpcy5fZHJhZ2dhYmxlLl9tb3ZlZDtcclxuXHR9LFxyXG5cclxuXHRfb25EcmFnU3RhcnQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX21hcmtlclxyXG5cdFx0ICAgIC5jbG9zZVBvcHVwKClcclxuXHRcdCAgICAuZmlyZSgnbW92ZXN0YXJ0JylcclxuXHRcdCAgICAuZmlyZSgnZHJhZ3N0YXJ0Jyk7XHJcblx0fSxcclxuXHJcblx0X29uRHJhZzogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcmtlciA9IHRoaXMuX21hcmtlcixcclxuXHRcdCAgICBzaGFkb3cgPSBtYXJrZXIuX3NoYWRvdyxcclxuXHRcdCAgICBpY29uUG9zID0gTC5Eb21VdGlsLmdldFBvc2l0aW9uKG1hcmtlci5faWNvbiksXHJcblx0XHQgICAgbGF0bG5nID0gbWFya2VyLl9tYXAubGF5ZXJQb2ludFRvTGF0TG5nKGljb25Qb3MpO1xyXG5cclxuXHRcdC8vIHVwZGF0ZSBzaGFkb3cgcG9zaXRpb25cclxuXHRcdGlmIChzaGFkb3cpIHtcclxuXHRcdFx0TC5Eb21VdGlsLnNldFBvc2l0aW9uKHNoYWRvdywgaWNvblBvcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0bWFya2VyLl9sYXRsbmcgPSBsYXRsbmc7XHJcblxyXG5cdFx0bWFya2VyXHJcblx0XHQgICAgLmZpcmUoJ21vdmUnLCB7bGF0bG5nOiBsYXRsbmd9KVxyXG5cdFx0ICAgIC5maXJlKCdkcmFnJyk7XHJcblx0fSxcclxuXHJcblx0X29uRHJhZ0VuZDogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHRoaXMuX21hcmtlclxyXG5cdFx0ICAgIC5maXJlKCdtb3ZlZW5kJylcclxuXHRcdCAgICAuZmlyZSgnZHJhZ2VuZCcsIGUpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuICogTC5Db250cm9sIGlzIGEgYmFzZSBjbGFzcyBmb3IgaW1wbGVtZW50aW5nIG1hcCBjb250cm9scy4gSGFuZGxlcyBwb3NpdGlvbmluZy5cclxuICogQWxsIG90aGVyIGNvbnRyb2xzIGV4dGVuZCBmcm9tIHRoaXMgY2xhc3MuXHJcbiAqL1xyXG5cclxuTC5Db250cm9sID0gTC5DbGFzcy5leHRlbmQoe1xyXG5cdG9wdGlvbnM6IHtcclxuXHRcdHBvc2l0aW9uOiAndG9wcmlnaHQnXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHR9LFxyXG5cclxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24gKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMub3B0aW9ucy5wb3NpdGlvbjtcclxuXHR9LFxyXG5cclxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24gKHBvc2l0aW9uKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5fbWFwO1xyXG5cclxuXHRcdGlmIChtYXApIHtcclxuXHRcdFx0bWFwLnJlbW92ZUNvbnRyb2wodGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zLnBvc2l0aW9uID0gcG9zaXRpb247XHJcblxyXG5cdFx0aWYgKG1hcCkge1xyXG5cdFx0XHRtYXAuYWRkQ29udHJvbCh0aGlzKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRnZXRDb250YWluZXI6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0YWRkVG86IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY29udGFpbmVyID0gdGhpcy5fY29udGFpbmVyID0gdGhpcy5vbkFkZChtYXApLFxyXG5cdFx0ICAgIHBvcyA9IHRoaXMuZ2V0UG9zaXRpb24oKSxcclxuXHRcdCAgICBjb3JuZXIgPSBtYXAuX2NvbnRyb2xDb3JuZXJzW3Bvc107XHJcblxyXG5cdFx0TC5Eb21VdGlsLmFkZENsYXNzKGNvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbCcpO1xyXG5cclxuXHRcdGlmIChwb3MuaW5kZXhPZignYm90dG9tJykgIT09IC0xKSB7XHJcblx0XHRcdGNvcm5lci5pbnNlcnRCZWZvcmUoY29udGFpbmVyLCBjb3JuZXIuZmlyc3RDaGlsZCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjb3JuZXIuYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVGcm9tOiBmdW5jdGlvbiAobWFwKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5nZXRQb3NpdGlvbigpLFxyXG5cdFx0ICAgIGNvcm5lciA9IG1hcC5fY29udHJvbENvcm5lcnNbcG9zXTtcclxuXHJcblx0XHRjb3JuZXIucmVtb3ZlQ2hpbGQodGhpcy5fY29udGFpbmVyKTtcclxuXHRcdHRoaXMuX21hcCA9IG51bGw7XHJcblxyXG5cdFx0aWYgKHRoaXMub25SZW1vdmUpIHtcclxuXHRcdFx0dGhpcy5vblJlbW92ZShtYXApO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF9yZWZvY3VzT25NYXA6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICh0aGlzLl9tYXApIHtcclxuXHRcdFx0dGhpcy5fbWFwLmdldENvbnRhaW5lcigpLmZvY3VzKCk7XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcblx0cmV0dXJuIG5ldyBMLkNvbnRyb2wob3B0aW9ucyk7XHJcbn07XHJcblxyXG5cclxuLy8gYWRkcyBjb250cm9sLXJlbGF0ZWQgbWV0aG9kcyB0byBMLk1hcFxyXG5cclxuTC5NYXAuaW5jbHVkZSh7XHJcblx0YWRkQ29udHJvbDogZnVuY3Rpb24gKGNvbnRyb2wpIHtcclxuXHRcdGNvbnRyb2wuYWRkVG8odGhpcyk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVDb250cm9sOiBmdW5jdGlvbiAoY29udHJvbCkge1xyXG5cdFx0Y29udHJvbC5yZW1vdmVGcm9tKHRoaXMpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0X2luaXRDb250cm9sUG9zOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgY29ybmVycyA9IHRoaXMuX2NvbnRyb2xDb3JuZXJzID0ge30sXHJcblx0XHQgICAgbCA9ICdsZWFmbGV0LScsXHJcblx0XHQgICAgY29udGFpbmVyID0gdGhpcy5fY29udHJvbENvbnRhaW5lciA9XHJcblx0XHQgICAgICAgICAgICBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBsICsgJ2NvbnRyb2wtY29udGFpbmVyJywgdGhpcy5fY29udGFpbmVyKTtcclxuXHJcblx0XHRmdW5jdGlvbiBjcmVhdGVDb3JuZXIodlNpZGUsIGhTaWRlKSB7XHJcblx0XHRcdHZhciBjbGFzc05hbWUgPSBsICsgdlNpZGUgKyAnICcgKyBsICsgaFNpZGU7XHJcblxyXG5cdFx0XHRjb3JuZXJzW3ZTaWRlICsgaFNpZGVdID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lLCBjb250YWluZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ2xlZnQnKTtcclxuXHRcdGNyZWF0ZUNvcm5lcigndG9wJywgJ3JpZ2h0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdsZWZ0Jyk7XHJcblx0XHRjcmVhdGVDb3JuZXIoJ2JvdHRvbScsICdyaWdodCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jbGVhckNvbnRyb2xQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHRoaXMuX2NvbnRhaW5lci5yZW1vdmVDaGlsZCh0aGlzLl9jb250cm9sQ29udGFpbmVyKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuQ29udHJvbC5ab29tIGlzIHVzZWQgZm9yIHRoZSBkZWZhdWx0IHpvb20gYnV0dG9ucyBvbiB0aGUgbWFwLlxyXG4gKi9cclxuXHJcbkwuQ29udHJvbC5ab29tID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0cG9zaXRpb246ICd0b3BsZWZ0JyxcclxuXHRcdHpvb21JblRleHQ6ICcrJyxcclxuXHRcdHpvb21JblRpdGxlOiAnWm9vbSBpbicsXHJcblx0XHR6b29tT3V0VGV4dDogJy0nLFxyXG5cdFx0em9vbU91dFRpdGxlOiAnWm9vbSBvdXQnXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHZhciB6b29tTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtem9vbScsXHJcblx0XHQgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2Jywgem9vbU5hbWUgKyAnIGxlYWZsZXQtYmFyJyk7XHJcblxyXG5cdFx0dGhpcy5fbWFwID0gbWFwO1xyXG5cclxuXHRcdHRoaXMuX3pvb21JbkJ1dHRvbiAgPSB0aGlzLl9jcmVhdGVCdXR0b24oXHJcblx0XHQgICAgICAgIHRoaXMub3B0aW9ucy56b29tSW5UZXh0LCB0aGlzLm9wdGlvbnMuem9vbUluVGl0bGUsXHJcblx0XHQgICAgICAgIHpvb21OYW1lICsgJy1pbicsICBjb250YWluZXIsIHRoaXMuX3pvb21JbiwgIHRoaXMpO1xyXG5cdFx0dGhpcy5fem9vbU91dEJ1dHRvbiA9IHRoaXMuX2NyZWF0ZUJ1dHRvbihcclxuXHRcdCAgICAgICAgdGhpcy5vcHRpb25zLnpvb21PdXRUZXh0LCB0aGlzLm9wdGlvbnMuem9vbU91dFRpdGxlLFxyXG5cdFx0ICAgICAgICB6b29tTmFtZSArICctb3V0JywgY29udGFpbmVyLCB0aGlzLl96b29tT3V0LCB0aGlzKTtcclxuXHJcblx0XHR0aGlzLl91cGRhdGVEaXNhYmxlZCgpO1xyXG5cdFx0bWFwLm9uKCd6b29tZW5kIHpvb21sZXZlbHNjaGFuZ2UnLCB0aGlzLl91cGRhdGVEaXNhYmxlZCwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZignem9vbWVuZCB6b29tbGV2ZWxzY2hhbmdlJywgdGhpcy5fdXBkYXRlRGlzYWJsZWQsIHRoaXMpO1xyXG5cdH0sXHJcblxyXG5cdF96b29tSW46IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9tYXAuem9vbUluKGUuc2hpZnRLZXkgPyAzIDogMSk7XHJcblx0fSxcclxuXHJcblx0X3pvb21PdXQ6IGZ1bmN0aW9uIChlKSB7XHJcblx0XHR0aGlzLl9tYXAuem9vbU91dChlLnNoaWZ0S2V5ID8gMyA6IDEpO1xyXG5cdH0sXHJcblxyXG5cdF9jcmVhdGVCdXR0b246IGZ1bmN0aW9uIChodG1sLCB0aXRsZSwgY2xhc3NOYW1lLCBjb250YWluZXIsIGZuLCBjb250ZXh0KSB7XHJcblx0XHR2YXIgbGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblx0XHRsaW5rLmlubmVySFRNTCA9IGh0bWw7XHJcblx0XHRsaW5rLmhyZWYgPSAnIyc7XHJcblx0XHRsaW5rLnRpdGxlID0gdGl0bGU7XHJcblxyXG5cdFx0dmFyIHN0b3AgPSBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbjtcclxuXHJcblx0XHRMLkRvbUV2ZW50XHJcblx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHN0b3ApXHJcblx0XHQgICAgLm9uKGxpbmssICdtb3VzZWRvd24nLCBzdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnZGJsY2xpY2snLCBzdG9wKVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KVxyXG5cdFx0ICAgIC5vbihsaW5rLCAnY2xpY2snLCBmbiwgY29udGV4dClcclxuXHRcdCAgICAub24obGluaywgJ2NsaWNrJywgdGhpcy5fcmVmb2N1c09uTWFwLCBjb250ZXh0KTtcclxuXHJcblx0XHRyZXR1cm4gbGluaztcclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlRGlzYWJsZWQ6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLl9tYXAsXHJcblx0XHRcdGNsYXNzTmFtZSA9ICdsZWFmbGV0LWRpc2FibGVkJztcclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fem9vbUluQnV0dG9uLCBjbGFzc05hbWUpO1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX3pvb21PdXRCdXR0b24sIGNsYXNzTmFtZSk7XHJcblxyXG5cdFx0aWYgKG1hcC5fem9vbSA9PT0gbWFwLmdldE1pblpvb20oKSkge1xyXG5cdFx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fem9vbU91dEJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHRcdGlmIChtYXAuX3pvb20gPT09IG1hcC5nZXRNYXhab29tKCkpIHtcclxuXHRcdFx0TC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX3pvb21JbkJ1dHRvbiwgY2xhc3NOYW1lKTtcclxuXHRcdH1cclxuXHR9XHJcbn0pO1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLnpvb21Db250cm9sKSB7XHJcblx0XHR0aGlzLnpvb21Db250cm9sID0gbmV3IEwuQ29udHJvbC5ab29tKCk7XHJcblx0XHR0aGlzLmFkZENvbnRyb2wodGhpcy56b29tQ29udHJvbCk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbC56b29tID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5ab29tKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcblxyXG4vKlxyXG4gKiBMLkNvbnRyb2wuQXR0cmlidXRpb24gaXMgdXNlZCBmb3IgZGlzcGxheWluZyBhdHRyaWJ1dGlvbiBvbiB0aGUgbWFwIChhZGRlZCBieSBkZWZhdWx0KS5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuQXR0cmlidXRpb24gPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbXJpZ2h0JyxcclxuXHRcdHByZWZpeDogJzxhIGhyZWY9XCJodHRwOi8vbGVhZmxldGpzLmNvbVwiIHRpdGxlPVwiQSBKUyBsaWJyYXJ5IGZvciBpbnRlcmFjdGl2ZSBtYXBzXCI+TGVhZmxldDwvYT4nXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRcdEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9hdHRyaWJ1dGlvbnMgPSB7fTtcclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgJ2xlYWZsZXQtY29udHJvbC1hdHRyaWJ1dGlvbicpO1xyXG5cdFx0TC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbih0aGlzLl9jb250YWluZXIpO1xyXG5cclxuXHRcdGZvciAodmFyIGkgaW4gbWFwLl9sYXllcnMpIHtcclxuXHRcdFx0aWYgKG1hcC5fbGF5ZXJzW2ldLmdldEF0dHJpYnV0aW9uKSB7XHJcblx0XHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihtYXAuX2xheWVyc1tpXS5nZXRBdHRyaWJ1dGlvbigpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0XHJcblx0XHRtYXBcclxuXHRcdCAgICAub24oJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckFkZCwgdGhpcylcclxuXHRcdCAgICAub24oJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllclJlbW92ZSwgdGhpcyk7XHJcblxyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQWRkKVxyXG5cdFx0ICAgIC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllclJlbW92ZSk7XHJcblxyXG5cdH0sXHJcblxyXG5cdHNldFByZWZpeDogZnVuY3Rpb24gKHByZWZpeCkge1xyXG5cdFx0dGhpcy5vcHRpb25zLnByZWZpeCA9IHByZWZpeDtcclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0YWRkQXR0cmlidXRpb246IGZ1bmN0aW9uICh0ZXh0KSB7XHJcblx0XHRpZiAoIXRleHQpIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdID0gMDtcclxuXHRcdH1cclxuXHRcdHRoaXMuX2F0dHJpYnV0aW9uc1t0ZXh0XSsrO1xyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdHJlbW92ZUF0dHJpYnV0aW9uOiBmdW5jdGlvbiAodGV4dCkge1xyXG5cdFx0aWYgKCF0ZXh0KSB7IHJldHVybjsgfVxyXG5cclxuXHRcdGlmICh0aGlzLl9hdHRyaWJ1dGlvbnNbdGV4dF0pIHtcclxuXHRcdFx0dGhpcy5fYXR0cmlidXRpb25zW3RleHRdLS07XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdGlmICghdGhpcy5fbWFwKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBhdHRyaWJzID0gW107XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9hdHRyaWJ1dGlvbnMpIHtcclxuXHRcdFx0aWYgKHRoaXMuX2F0dHJpYnV0aW9uc1tpXSkge1xyXG5cdFx0XHRcdGF0dHJpYnMucHVzaChpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBwcmVmaXhBbmRBdHRyaWJzID0gW107XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5wcmVmaXgpIHtcclxuXHRcdFx0cHJlZml4QW5kQXR0cmlicy5wdXNoKHRoaXMub3B0aW9ucy5wcmVmaXgpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKGF0dHJpYnMubGVuZ3RoKSB7XHJcblx0XHRcdHByZWZpeEFuZEF0dHJpYnMucHVzaChhdHRyaWJzLmpvaW4oJywgJykpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2NvbnRhaW5lci5pbm5lckhUTUwgPSBwcmVmaXhBbmRBdHRyaWJzLmpvaW4oJyB8ICcpO1xyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyQWRkOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5hZGRBdHRyaWJ1dGlvbihlLmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9vbkxheWVyUmVtb3ZlOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKGUubGF5ZXIuZ2V0QXR0cmlidXRpb24pIHtcclxuXHRcdFx0dGhpcy5yZW1vdmVBdHRyaWJ1dGlvbihlLmxheWVyLmdldEF0dHJpYnV0aW9uKCkpO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5MLk1hcC5tZXJnZU9wdGlvbnMoe1xyXG5cdGF0dHJpYnV0aW9uQ29udHJvbDogdHJ1ZVxyXG59KTtcclxuXHJcbkwuTWFwLmFkZEluaXRIb29rKGZ1bmN0aW9uICgpIHtcclxuXHRpZiAodGhpcy5vcHRpb25zLmF0dHJpYnV0aW9uQ29udHJvbCkge1xyXG5cdFx0dGhpcy5hdHRyaWJ1dGlvbkNvbnRyb2wgPSAobmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbigpKS5hZGRUbyh0aGlzKTtcclxuXHR9XHJcbn0pO1xyXG5cclxuTC5jb250cm9sLmF0dHJpYnV0aW9uID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5BdHRyaWJ1dGlvbihvcHRpb25zKTtcclxufTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLkNvbnRyb2wuU2NhbGUgaXMgdXNlZCBmb3IgZGlzcGxheWluZyBtZXRyaWMvaW1wZXJpYWwgc2NhbGUgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuU2NhbGUgPSBMLkNvbnRyb2wuZXh0ZW5kKHtcclxuXHRvcHRpb25zOiB7XHJcblx0XHRwb3NpdGlvbjogJ2JvdHRvbWxlZnQnLFxyXG5cdFx0bWF4V2lkdGg6IDEwMCxcclxuXHRcdG1ldHJpYzogdHJ1ZSxcclxuXHRcdGltcGVyaWFsOiB0cnVlLFxyXG5cdFx0dXBkYXRlV2hlbklkbGU6IGZhbHNlXHJcblx0fSxcclxuXHJcblx0b25BZGQ6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdHRoaXMuX21hcCA9IG1hcDtcclxuXHJcblx0XHR2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1zY2FsZScsXHJcblx0XHQgICAgY29udGFpbmVyID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lKSxcclxuXHRcdCAgICBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xyXG5cclxuXHRcdHRoaXMuX2FkZFNjYWxlcyhvcHRpb25zLCBjbGFzc05hbWUsIGNvbnRhaW5lcik7XHJcblxyXG5cdFx0bWFwLm9uKG9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XHJcblx0XHRtYXAud2hlblJlYWR5KHRoaXMuX3VwZGF0ZSwgdGhpcyk7XHJcblxyXG5cdFx0cmV0dXJuIGNvbnRhaW5lcjtcclxuXHR9LFxyXG5cclxuXHRvblJlbW92ZTogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0bWFwLm9mZih0aGlzLm9wdGlvbnMudXBkYXRlV2hlbklkbGUgPyAnbW92ZWVuZCcgOiAnbW92ZScsIHRoaXMuX3VwZGF0ZSwgdGhpcyk7XHJcblx0fSxcclxuXHJcblx0X2FkZFNjYWxlczogZnVuY3Rpb24gKG9wdGlvbnMsIGNsYXNzTmFtZSwgY29udGFpbmVyKSB7XHJcblx0XHRpZiAob3B0aW9ucy5tZXRyaWMpIHtcclxuXHRcdFx0dGhpcy5fbVNjYWxlID0gTC5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1saW5lJywgY29udGFpbmVyKTtcclxuXHRcdH1cclxuXHRcdGlmIChvcHRpb25zLmltcGVyaWFsKSB7XHJcblx0XHRcdHRoaXMuX2lTY2FsZSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctbGluZScsIGNvbnRhaW5lcik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX21hcC5nZXRCb3VuZHMoKSxcclxuXHRcdCAgICBjZW50ZXJMYXQgPSBib3VuZHMuZ2V0Q2VudGVyKCkubGF0LFxyXG5cdFx0ICAgIGhhbGZXb3JsZE1ldGVycyA9IDYzNzgxMzcgKiBNYXRoLlBJICogTWF0aC5jb3MoY2VudGVyTGF0ICogTWF0aC5QSSAvIDE4MCksXHJcblx0XHQgICAgZGlzdCA9IGhhbGZXb3JsZE1ldGVycyAqIChib3VuZHMuZ2V0Tm9ydGhFYXN0KCkubG5nIC0gYm91bmRzLmdldFNvdXRoV2VzdCgpLmxuZykgLyAxODAsXHJcblxyXG5cdFx0ICAgIHNpemUgPSB0aGlzLl9tYXAuZ2V0U2l6ZSgpLFxyXG5cdFx0ICAgIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnMsXHJcblx0XHQgICAgbWF4TWV0ZXJzID0gMDtcclxuXHJcblx0XHRpZiAoc2l6ZS54ID4gMCkge1xyXG5cdFx0XHRtYXhNZXRlcnMgPSBkaXN0ICogKG9wdGlvbnMubWF4V2lkdGggLyBzaXplLngpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX3VwZGF0ZVNjYWxlcyhvcHRpb25zLCBtYXhNZXRlcnMpO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVTY2FsZXM6IGZ1bmN0aW9uIChvcHRpb25zLCBtYXhNZXRlcnMpIHtcclxuXHRcdGlmIChvcHRpb25zLm1ldHJpYyAmJiBtYXhNZXRlcnMpIHtcclxuXHRcdFx0dGhpcy5fdXBkYXRlTWV0cmljKG1heE1ldGVycyk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuaW1wZXJpYWwgJiYgbWF4TWV0ZXJzKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZUltcGVyaWFsKG1heE1ldGVycyk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3VwZGF0ZU1ldHJpYzogZnVuY3Rpb24gKG1heE1ldGVycykge1xyXG5cdFx0dmFyIG1ldGVycyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1ldGVycyk7XHJcblxyXG5cdFx0dGhpcy5fbVNjYWxlLnN0eWxlLndpZHRoID0gdGhpcy5fZ2V0U2NhbGVXaWR0aChtZXRlcnMgLyBtYXhNZXRlcnMpICsgJ3B4JztcclxuXHRcdHRoaXMuX21TY2FsZS5pbm5lckhUTUwgPSBtZXRlcnMgPCAxMDAwID8gbWV0ZXJzICsgJyBtJyA6IChtZXRlcnMgLyAxMDAwKSArICcga20nO1xyXG5cdH0sXHJcblxyXG5cdF91cGRhdGVJbXBlcmlhbDogZnVuY3Rpb24gKG1heE1ldGVycykge1xyXG5cdFx0dmFyIG1heEZlZXQgPSBtYXhNZXRlcnMgKiAzLjI4MDgzOTksXHJcblx0XHQgICAgc2NhbGUgPSB0aGlzLl9pU2NhbGUsXHJcblx0XHQgICAgbWF4TWlsZXMsIG1pbGVzLCBmZWV0O1xyXG5cclxuXHRcdGlmIChtYXhGZWV0ID4gNTI4MCkge1xyXG5cdFx0XHRtYXhNaWxlcyA9IG1heEZlZXQgLyA1MjgwO1xyXG5cdFx0XHRtaWxlcyA9IHRoaXMuX2dldFJvdW5kTnVtKG1heE1pbGVzKTtcclxuXHJcblx0XHRcdHNjYWxlLnN0eWxlLndpZHRoID0gdGhpcy5fZ2V0U2NhbGVXaWR0aChtaWxlcyAvIG1heE1pbGVzKSArICdweCc7XHJcblx0XHRcdHNjYWxlLmlubmVySFRNTCA9IG1pbGVzICsgJyBtaSc7XHJcblxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZmVldCA9IHRoaXMuX2dldFJvdW5kTnVtKG1heEZlZXQpO1xyXG5cclxuXHRcdFx0c2NhbGUuc3R5bGUud2lkdGggPSB0aGlzLl9nZXRTY2FsZVdpZHRoKGZlZXQgLyBtYXhGZWV0KSArICdweCc7XHJcblx0XHRcdHNjYWxlLmlubmVySFRNTCA9IGZlZXQgKyAnIGZ0JztcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfZ2V0U2NhbGVXaWR0aDogZnVuY3Rpb24gKHJhdGlvKSB7XHJcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCh0aGlzLm9wdGlvbnMubWF4V2lkdGggKiByYXRpbykgLSAxMDtcclxuXHR9LFxyXG5cclxuXHRfZ2V0Um91bmROdW06IGZ1bmN0aW9uIChudW0pIHtcclxuXHRcdHZhciBwb3cxMCA9IE1hdGgucG93KDEwLCAoTWF0aC5mbG9vcihudW0pICsgJycpLmxlbmd0aCAtIDEpLFxyXG5cdFx0ICAgIGQgPSBudW0gLyBwb3cxMDtcclxuXHJcblx0XHRkID0gZCA+PSAxMCA/IDEwIDogZCA+PSA1ID8gNSA6IGQgPj0gMyA/IDMgOiBkID49IDIgPyAyIDogMTtcclxuXHJcblx0XHRyZXR1cm4gcG93MTAgKiBkO1xyXG5cdH1cclxufSk7XHJcblxyXG5MLmNvbnRyb2wuc2NhbGUgPSBmdW5jdGlvbiAob3B0aW9ucykge1xyXG5cdHJldHVybiBuZXcgTC5Db250cm9sLlNjYWxlKG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuQ29udHJvbC5MYXllcnMgaXMgYSBjb250cm9sIHRvIGFsbG93IHVzZXJzIHRvIHN3aXRjaCBiZXR3ZWVuIGRpZmZlcmVudCBsYXllcnMgb24gdGhlIG1hcC5cclxuICovXHJcblxyXG5MLkNvbnRyb2wuTGF5ZXJzID0gTC5Db250cm9sLmV4dGVuZCh7XHJcblx0b3B0aW9uczoge1xyXG5cdFx0Y29sbGFwc2VkOiB0cnVlLFxyXG5cdFx0cG9zaXRpb246ICd0b3ByaWdodCcsXHJcblx0XHRhdXRvWkluZGV4OiB0cnVlXHJcblx0fSxcclxuXHJcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XHJcblx0XHRMLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XHJcblxyXG5cdFx0dGhpcy5fbGF5ZXJzID0ge307XHJcblx0XHR0aGlzLl9sYXN0WkluZGV4ID0gMDtcclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHRmb3IgKHZhciBpIGluIGJhc2VMYXllcnMpIHtcclxuXHRcdFx0dGhpcy5fYWRkTGF5ZXIoYmFzZUxheWVyc1tpXSwgaSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Zm9yIChpIGluIG92ZXJsYXlzKSB7XHJcblx0XHRcdHRoaXMuX2FkZExheWVyKG92ZXJsYXlzW2ldLCBpLCB0cnVlKTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRvbkFkZDogZnVuY3Rpb24gKG1hcCkge1xyXG5cdFx0dGhpcy5faW5pdExheW91dCgpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblxyXG5cdFx0bWFwXHJcblx0XHQgICAgLm9uKCdsYXllcmFkZCcsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpXHJcblx0XHQgICAgLm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLl9jb250YWluZXI7XHJcblx0fSxcclxuXHJcblx0b25SZW1vdmU6IGZ1bmN0aW9uIChtYXApIHtcclxuXHRcdG1hcFxyXG5cdFx0ICAgIC5vZmYoJ2xheWVyYWRkJywgdGhpcy5fb25MYXllckNoYW5nZSlcclxuXHRcdCAgICAub2ZmKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UpO1xyXG5cdH0sXHJcblxyXG5cdGFkZEJhc2VMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lKSB7XHJcblx0XHR0aGlzLl9hZGRMYXllcihsYXllciwgbmFtZSk7XHJcblx0XHR0aGlzLl91cGRhdGUoKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH0sXHJcblxyXG5cdGFkZE92ZXJsYXk6IGZ1bmN0aW9uIChsYXllciwgbmFtZSkge1xyXG5cdFx0dGhpcy5fYWRkTGF5ZXIobGF5ZXIsIG5hbWUsIHRydWUpO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRyZW1vdmVMYXllcjogZnVuY3Rpb24gKGxheWVyKSB7XHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHRcdGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xyXG5cdFx0dGhpcy5fdXBkYXRlKCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaW5pdExheW91dDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzJyxcclxuXHRcdCAgICBjb250YWluZXIgPSB0aGlzLl9jb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUpO1xyXG5cclxuXHRcdC8vTWFrZXMgdGhpcyB3b3JrIG9uIElFMTAgVG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXHJcblx0XHRjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKCFMLkJyb3dzZXIudG91Y2gpIHtcclxuXHRcdFx0TC5Eb21FdmVudFxyXG5cdFx0XHRcdC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpXHJcblx0XHRcdFx0LmRpc2FibGVTY3JvbGxQcm9wYWdhdGlvbihjb250YWluZXIpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0TC5Eb21FdmVudC5vbihjb250YWluZXIsICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZm9ybSA9IHRoaXMuX2Zvcm0gPSBMLkRvbVV0aWwuY3JlYXRlKCdmb3JtJywgY2xhc3NOYW1lICsgJy1saXN0Jyk7XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcclxuXHRcdFx0aWYgKCFMLkJyb3dzZXIuYW5kcm9pZCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHRoaXMuX2V4cGFuZCwgdGhpcylcclxuXHRcdFx0XHQgICAgLm9uKGNvbnRhaW5lciwgJ21vdXNlb3V0JywgdGhpcy5fY29sbGFwc2UsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XHJcblx0XHRcdGxpbmsuaHJlZiA9ICcjJztcclxuXHRcdFx0bGluay50aXRsZSA9ICdMYXllcnMnO1xyXG5cclxuXHRcdFx0aWYgKEwuQnJvd3Nlci50b3VjaCkge1xyXG5cdFx0XHRcdEwuRG9tRXZlbnRcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcclxuXHRcdFx0XHQgICAgLm9uKGxpbmssICdjbGljaycsIHRoaXMuX2V4cGFuZCwgdGhpcyk7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZSB7XHJcblx0XHRcdFx0TC5Eb21FdmVudC5vbihsaW5rLCAnZm9jdXMnLCB0aGlzLl9leHBhbmQsIHRoaXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vV29yayBhcm91bmQgZm9yIEZpcmVmb3ggYW5kcm9pZCBpc3N1ZSBodHRwczovL2dpdGh1Yi5jb20vTGVhZmxldC9MZWFmbGV0L2lzc3Vlcy8yMDMzXHJcblx0XHRcdEwuRG9tRXZlbnQub24oZm9ybSwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xyXG5cdFx0XHRcdHNldFRpbWVvdXQoTC5iaW5kKHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyksIDApO1xyXG5cdFx0XHR9LCB0aGlzKTtcclxuXHJcblx0XHRcdHRoaXMuX21hcC5vbignY2xpY2snLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XHJcblx0XHRcdC8vIFRPRE8ga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fZXhwYW5kKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcclxuXHRcdHRoaXMuX3NlcGFyYXRvciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgZm9ybSk7XHJcblxyXG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKGZvcm0pO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRMYXllcjogZnVuY3Rpb24gKGxheWVyLCBuYW1lLCBvdmVybGF5KSB7XHJcblx0XHR2YXIgaWQgPSBMLnN0YW1wKGxheWVyKTtcclxuXHJcblx0XHR0aGlzLl9sYXllcnNbaWRdID0ge1xyXG5cdFx0XHRsYXllcjogbGF5ZXIsXHJcblx0XHRcdG5hbWU6IG5hbWUsXHJcblx0XHRcdG92ZXJsYXk6IG92ZXJsYXlcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKHRoaXMub3B0aW9ucy5hdXRvWkluZGV4ICYmIGxheWVyLnNldFpJbmRleCkge1xyXG5cdFx0XHR0aGlzLl9sYXN0WkluZGV4Kys7XHJcblx0XHRcdGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcclxuXHRcdH1cclxuXHR9LFxyXG5cclxuXHRfdXBkYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRpZiAoIXRoaXMuX2NvbnRhaW5lcikge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYmFzZUxheWVyc0xpc3QuaW5uZXJIVE1MID0gJyc7XHJcblx0XHR0aGlzLl9vdmVybGF5c0xpc3QuaW5uZXJIVE1MID0gJyc7XHJcblxyXG5cdFx0dmFyIGJhc2VMYXllcnNQcmVzZW50ID0gZmFsc2UsXHJcblx0XHQgICAgb3ZlcmxheXNQcmVzZW50ID0gZmFsc2UsXHJcblx0XHQgICAgaSwgb2JqO1xyXG5cclxuXHRcdGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcclxuXHRcdFx0b2JqID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG5cdFx0XHR0aGlzLl9hZGRJdGVtKG9iaik7XHJcblx0XHRcdG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcclxuXHRcdFx0YmFzZUxheWVyc1ByZXNlbnQgPSBiYXNlTGF5ZXJzUHJlc2VudCB8fCAhb2JqLm92ZXJsYXk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcclxuXHR9LFxyXG5cclxuXHRfb25MYXllckNoYW5nZTogZnVuY3Rpb24gKGUpIHtcclxuXHRcdHZhciBvYmogPSB0aGlzLl9sYXllcnNbTC5zdGFtcChlLmxheWVyKV07XHJcblxyXG5cdFx0aWYgKCFvYmopIHsgcmV0dXJuOyB9XHJcblxyXG5cdFx0aWYgKCF0aGlzLl9oYW5kbGluZ0NsaWNrKSB7XHJcblx0XHRcdHRoaXMuX3VwZGF0ZSgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciB0eXBlID0gb2JqLm92ZXJsYXkgP1xyXG5cdFx0XHQoZS50eXBlID09PSAnbGF5ZXJhZGQnID8gJ292ZXJsYXlhZGQnIDogJ292ZXJsYXlyZW1vdmUnKSA6XHJcblx0XHRcdChlLnR5cGUgPT09ICdsYXllcmFkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xyXG5cclxuXHRcdGlmICh0eXBlKSB7XHJcblx0XHRcdHRoaXMuX21hcC5maXJlKHR5cGUsIG9iaik7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0Ly8gSUU3IGJ1Z3Mgb3V0IGlmIHlvdSBjcmVhdGUgYSByYWRpbyBkeW5hbWljYWxseSwgc28geW91IGhhdmUgdG8gZG8gaXQgdGhpcyBoYWNreSB3YXkgKHNlZSBodHRwOi8vYml0Lmx5L1BxWUxCZSlcclxuXHRfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbiAobmFtZSwgY2hlY2tlZCkge1xyXG5cclxuXHRcdHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICsgbmFtZSArICdcIic7XHJcblx0XHRpZiAoY2hlY2tlZCkge1xyXG5cdFx0XHRyYWRpb0h0bWwgKz0gJyBjaGVja2VkPVwiY2hlY2tlZFwiJztcclxuXHRcdH1cclxuXHRcdHJhZGlvSHRtbCArPSAnLz4nO1xyXG5cclxuXHRcdHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XHJcblx0XHRyYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcclxuXHJcblx0XHRyZXR1cm4gcmFkaW9GcmFnbWVudC5maXJzdENoaWxkO1xyXG5cdH0sXHJcblxyXG5cdF9hZGRJdGVtOiBmdW5jdGlvbiAob2JqKSB7XHJcblx0XHR2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsYWJlbCcpLFxyXG5cdFx0ICAgIGlucHV0LFxyXG5cdFx0ICAgIGNoZWNrZWQgPSB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKTtcclxuXHJcblx0XHRpZiAob2JqLm92ZXJsYXkpIHtcclxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xyXG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcclxuXHRcdFx0aW5wdXQuY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtc2VsZWN0b3InO1xyXG5cdFx0XHRpbnB1dC5kZWZhdWx0Q2hlY2tlZCA9IGNoZWNrZWQ7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRpbnB1dCA9IHRoaXMuX2NyZWF0ZVJhZGlvRWxlbWVudCgnbGVhZmxldC1iYXNlLWxheWVycycsIGNoZWNrZWQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlucHV0LmxheWVySWQgPSBMLnN0YW1wKG9iai5sYXllcik7XHJcblxyXG5cdFx0TC5Eb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25JbnB1dENsaWNrLCB0aGlzKTtcclxuXHJcblx0XHR2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcclxuXHRcdG5hbWUuaW5uZXJIVE1MID0gJyAnICsgb2JqLm5hbWU7XHJcblxyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xyXG5cdFx0bGFiZWwuYXBwZW5kQ2hpbGQobmFtZSk7XHJcblxyXG5cdFx0dmFyIGNvbnRhaW5lciA9IG9iai5vdmVybGF5ID8gdGhpcy5fb3ZlcmxheXNMaXN0IDogdGhpcy5fYmFzZUxheWVyc0xpc3Q7XHJcblx0XHRjb250YWluZXIuYXBwZW5kQ2hpbGQobGFiZWwpO1xyXG5cclxuXHRcdHJldHVybiBsYWJlbDtcclxuXHR9LFxyXG5cclxuXHRfb25JbnB1dENsaWNrOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgaSwgaW5wdXQsIG9iaixcclxuXHRcdCAgICBpbnB1dHMgPSB0aGlzLl9mb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbnB1dCcpLFxyXG5cdFx0ICAgIGlucHV0c0xlbiA9IGlucHV0cy5sZW5ndGg7XHJcblxyXG5cdFx0dGhpcy5faGFuZGxpbmdDbGljayA9IHRydWU7XHJcblxyXG5cdFx0Zm9yIChpID0gMDsgaSA8IGlucHV0c0xlbjsgaSsrKSB7XHJcblx0XHRcdGlucHV0ID0gaW5wdXRzW2ldO1xyXG5cdFx0XHRvYmogPSB0aGlzLl9sYXllcnNbaW5wdXQubGF5ZXJJZF07XHJcblxyXG5cdFx0XHRpZiAoaW5wdXQuY2hlY2tlZCAmJiAhdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllcikpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAuYWRkTGF5ZXIob2JqLmxheWVyKTtcclxuXHJcblx0XHRcdH0gZWxzZSBpZiAoIWlucHV0LmNoZWNrZWQgJiYgdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllcikpIHtcclxuXHRcdFx0XHR0aGlzLl9tYXAucmVtb3ZlTGF5ZXIob2JqLmxheWVyKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcclxuXHJcblx0XHR0aGlzLl9yZWZvY3VzT25NYXAoKTtcclxuXHR9LFxyXG5cclxuXHRfZXhwYW5kOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWxheWVycy1leHBhbmRlZCcpO1xyXG5cdH0sXHJcblxyXG5cdF9jb2xsYXBzZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5fY29udGFpbmVyLmNsYXNzTmFtZSA9IHRoaXMuX2NvbnRhaW5lci5jbGFzc05hbWUucmVwbGFjZSgnIGxlYWZsZXQtY29udHJvbC1sYXllcnMtZXhwYW5kZWQnLCAnJyk7XHJcblx0fVxyXG59KTtcclxuXHJcbkwuY29udHJvbC5sYXllcnMgPSBmdW5jdGlvbiAoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gbmV3IEwuQ29udHJvbC5MYXllcnMoYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xyXG59O1xyXG5cclxuXHJcbi8qXHJcbiAqIEwuUG9zQW5pbWF0aW9uIGlzIHVzZWQgYnkgTGVhZmxldCBpbnRlcm5hbGx5IGZvciBwYW4gYW5pbWF0aW9ucy5cclxuICovXHJcblxyXG5MLlBvc0FuaW1hdGlvbiA9IEwuQ2xhc3MuZXh0ZW5kKHtcclxuXHRpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXHJcblxyXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBOdW1iZXIsIE51bWJlcl0pXHJcblx0XHR0aGlzLnN0b3AoKTtcclxuXHJcblx0XHR0aGlzLl9lbCA9IGVsO1xyXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XHJcblx0XHR0aGlzLl9uZXdQb3MgPSBuZXdQb3M7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdzdGFydCcpO1xyXG5cclxuXHRcdGVsLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0lUSU9OXSA9ICdhbGwgJyArIChkdXJhdGlvbiB8fCAwLjI1KSArXHJcblx0XHQgICAgICAgICdzIGN1YmljLWJlemllcigwLDAsJyArIChlYXNlTGluZWFyaXR5IHx8IDAuNSkgKyAnLDEpJztcclxuXHJcblx0XHRMLkRvbUV2ZW50Lm9uKGVsLCBMLkRvbVV0aWwuVFJBTlNJVElPTl9FTkQsIHRoaXMuX29uVHJhbnNpdGlvbkVuZCwgdGhpcyk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24oZWwsIG5ld1Bvcyk7XHJcblxyXG5cdFx0Ly8gdG9nZ2xlIHJlZmxvdywgQ2hyb21lIGZsaWNrZXJzIGZvciBzb21lIHJlYXNvbiBpZiB5b3UgZG9uJ3QgZG8gdGhpc1xyXG5cdFx0TC5VdGlsLmZhbHNlRm4oZWwub2Zmc2V0V2lkdGgpO1xyXG5cclxuXHRcdC8vIHRoZXJlJ3Mgbm8gbmF0aXZlIHdheSB0byB0cmFjayB2YWx1ZSB1cGRhdGVzIG9mIHRyYW5zaXRpb25lZCBwcm9wZXJ0aWVzLCBzbyB3ZSBpbWl0YXRlIHRoaXNcclxuXHRcdHRoaXMuX3N0ZXBUaW1lciA9IHNldEludGVydmFsKEwuYmluZCh0aGlzLl9vblN0ZXAsIHRoaXMpLCA1MCk7XHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdC8vIGlmIHdlIGp1c3QgcmVtb3ZlZCB0aGUgdHJhbnNpdGlvbiBwcm9wZXJ0eSwgdGhlIGVsZW1lbnQgd291bGQganVtcCB0byBpdHMgZmluYWwgcG9zaXRpb24sXHJcblx0XHQvLyBzbyB3ZSBuZWVkIHRvIG1ha2UgaXQgc3RheSBhdCB0aGUgY3VycmVudCBwb3NpdGlvblxyXG5cclxuXHRcdEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9lbCwgdGhpcy5fZ2V0UG9zKCkpO1xyXG5cdFx0dGhpcy5fb25UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHRMLlV0aWwuZmFsc2VGbih0aGlzLl9lbC5vZmZzZXRXaWR0aCk7IC8vIGZvcmNlIHJlZmxvdyBpbiBjYXNlIHdlIGFyZSBhYm91dCB0byBzdGFydCBhIG5ldyBhbmltYXRpb25cclxuXHR9LFxyXG5cclxuXHRfb25TdGVwOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgc3RlcFBvcyA9IHRoaXMuX2dldFBvcygpO1xyXG5cdFx0aWYgKCFzdGVwUG9zKSB7XHJcblx0XHRcdHRoaXMuX29uVHJhbnNpdGlvbkVuZCgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHQvLyBqc2hpbnQgY2FtZWxjYXNlOiBmYWxzZVxyXG5cdFx0Ly8gbWFrZSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24gcmV0dXJuIGludGVybWVkaWF0ZSBwb3NpdGlvbiB2YWx1ZSBkdXJpbmcgYW5pbWF0aW9uXHJcblx0XHR0aGlzLl9lbC5fbGVhZmxldF9wb3MgPSBzdGVwUG9zO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpO1xyXG5cdH0sXHJcblxyXG5cdC8vIHlvdSBjYW4ndCBlYXNpbHkgZ2V0IGludGVybWVkaWF0ZSB2YWx1ZXMgb2YgcHJvcGVydGllcyBhbmltYXRlZCB3aXRoIENTUzMgVHJhbnNpdGlvbnMsXHJcblx0Ly8gd2UgbmVlZCB0byBwYXJzZSBjb21wdXRlZCBzdHlsZSAoaW4gY2FzZSBvZiB0cmFuc2Zvcm0gaXQgcmV0dXJucyBtYXRyaXggc3RyaW5nKVxyXG5cclxuXHRfdHJhbnNmb3JtUmU6IC8oWy0rXT8oPzpcXGQqXFwuKT9cXGQrKVxcRCosIChbLStdPyg/OlxcZCpcXC4pP1xcZCspXFxEKlxcKS8sXHJcblxyXG5cdF9nZXRQb3M6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHZhciBsZWZ0LCB0b3AsIG1hdGNoZXMsXHJcblx0XHQgICAgZWwgPSB0aGlzLl9lbCxcclxuXHRcdCAgICBzdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGVsKTtcclxuXHJcblx0XHRpZiAoTC5Ccm93c2VyLmFueTNkKSB7XHJcblx0XHRcdG1hdGNoZXMgPSBzdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXS5tYXRjaCh0aGlzLl90cmFuc2Zvcm1SZSk7XHJcblx0XHRcdGlmICghbWF0Y2hlcykgeyByZXR1cm47IH1cclxuXHRcdFx0bGVmdCA9IHBhcnNlRmxvYXQobWF0Y2hlc1sxXSk7XHJcblx0XHRcdHRvcCAgPSBwYXJzZUZsb2F0KG1hdGNoZXNbMl0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGVmdCA9IHBhcnNlRmxvYXQoc3R5bGUubGVmdCk7XHJcblx0XHRcdHRvcCAgPSBwYXJzZUZsb2F0KHN0eWxlLnRvcCk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIG5ldyBMLlBvaW50KGxlZnQsIHRvcCwgdHJ1ZSk7XHJcblx0fSxcclxuXHJcblx0X29uVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21FdmVudC5vZmYodGhpcy5fZWwsIEwuRG9tVXRpbC5UUkFOU0lUSU9OX0VORCwgdGhpcy5fb25UcmFuc2l0aW9uRW5kLCB0aGlzKTtcclxuXHJcblx0XHRpZiAoIXRoaXMuX2luUHJvZ3Jlc3MpIHsgcmV0dXJuOyB9XHJcblx0XHR0aGlzLl9pblByb2dyZXNzID0gZmFsc2U7XHJcblxyXG5cdFx0dGhpcy5fZWwuc3R5bGVbTC5Eb21VdGlsLlRSQU5TSVRJT05dID0gJyc7XHJcblxyXG5cdFx0Ly8ganNoaW50IGNhbWVsY2FzZTogZmFsc2VcclxuXHRcdC8vIG1ha2Ugc3VyZSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24gcmV0dXJucyB0aGUgZmluYWwgcG9zaXRpb24gdmFsdWUgYWZ0ZXIgYW5pbWF0aW9uXHJcblx0XHR0aGlzLl9lbC5fbGVhZmxldF9wb3MgPSB0aGlzLl9uZXdQb3M7XHJcblxyXG5cdFx0Y2xlYXJJbnRlcnZhbCh0aGlzLl9zdGVwVGltZXIpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnc3RlcCcpLmZpcmUoJ2VuZCcpO1xyXG5cdH1cclxuXHJcbn0pO1xyXG5cclxuXHJcbi8qXHJcbiAqIEV4dGVuZHMgTC5NYXAgdG8gaGFuZGxlIHBhbm5pbmcgYW5pbWF0aW9ucy5cclxuICovXHJcblxyXG5MLk1hcC5pbmNsdWRlKHtcclxuXHJcblx0c2V0VmlldzogZnVuY3Rpb24gKGNlbnRlciwgem9vbSwgb3B0aW9ucykge1xyXG5cclxuXHRcdHpvb20gPSB6b29tID09PSB1bmRlZmluZWQgPyB0aGlzLl96b29tIDogdGhpcy5fbGltaXRab29tKHpvb20pO1xyXG5cdFx0Y2VudGVyID0gdGhpcy5fbGltaXRDZW50ZXIoTC5sYXRMbmcoY2VudGVyKSwgem9vbSwgdGhpcy5vcHRpb25zLm1heEJvdW5kcyk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRpZiAodGhpcy5fcGFuQW5pbSkge1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnN0b3AoKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodGhpcy5fbG9hZGVkICYmICFvcHRpb25zLnJlc2V0ICYmIG9wdGlvbnMgIT09IHRydWUpIHtcclxuXHJcblx0XHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdG9wdGlvbnMuem9vbSA9IEwuZXh0ZW5kKHthbmltYXRlOiBvcHRpb25zLmFuaW1hdGV9LCBvcHRpb25zLnpvb20pO1xyXG5cdFx0XHRcdG9wdGlvbnMucGFuID0gTC5leHRlbmQoe2FuaW1hdGU6IG9wdGlvbnMuYW5pbWF0ZX0sIG9wdGlvbnMucGFuKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gdHJ5IGFuaW1hdGluZyBwYW4gb3Igem9vbVxyXG5cdFx0XHR2YXIgYW5pbWF0ZWQgPSAodGhpcy5fem9vbSAhPT0gem9vbSkgP1xyXG5cdFx0XHRcdHRoaXMuX3RyeUFuaW1hdGVkWm9vbSAmJiB0aGlzLl90cnlBbmltYXRlZFpvb20oY2VudGVyLCB6b29tLCBvcHRpb25zLnpvb20pIDpcclxuXHRcdFx0XHR0aGlzLl90cnlBbmltYXRlZFBhbihjZW50ZXIsIG9wdGlvbnMucGFuKTtcclxuXHJcblx0XHRcdGlmIChhbmltYXRlZCkge1xyXG5cdFx0XHRcdC8vIHByZXZlbnQgcmVzaXplIGhhbmRsZXIgY2FsbCwgdGhlIHZpZXcgd2lsbCByZWZyZXNoIGFmdGVyIGFuaW1hdGlvbiBhbnl3YXlcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGhpcy5fc2l6ZVRpbWVyKTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGlvbiBkaWRuJ3Qgc3RhcnQsIGp1c3QgcmVzZXQgdGhlIG1hcCB2aWV3XHJcblx0XHR0aGlzLl9yZXNldFZpZXcoY2VudGVyLCB6b29tKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRwYW5CeTogZnVuY3Rpb24gKG9mZnNldCwgb3B0aW9ucykge1xyXG5cdFx0b2Zmc2V0ID0gTC5wb2ludChvZmZzZXQpLnJvdW5kKCk7XHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHRpZiAoIW9mZnNldC54ICYmICFvZmZzZXQueSkge1xyXG5cdFx0XHRyZXR1cm4gdGhpcztcclxuXHRcdH1cclxuXHJcblx0XHRpZiAoIXRoaXMuX3BhbkFuaW0pIHtcclxuXHRcdFx0dGhpcy5fcGFuQW5pbSA9IG5ldyBMLlBvc0FuaW1hdGlvbigpO1xyXG5cclxuXHRcdFx0dGhpcy5fcGFuQW5pbS5vbih7XHJcblx0XHRcdFx0J3N0ZXAnOiB0aGlzLl9vblBhblRyYW5zaXRpb25TdGVwLFxyXG5cdFx0XHRcdCdlbmQnOiB0aGlzLl9vblBhblRyYW5zaXRpb25FbmRcclxuXHRcdFx0fSwgdGhpcyk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gZG9uJ3QgZmlyZSBtb3Zlc3RhcnQgaWYgYW5pbWF0aW5nIGluZXJ0aWFcclxuXHRcdGlmICghb3B0aW9ucy5ub01vdmVTdGFydCkge1xyXG5cdFx0XHR0aGlzLmZpcmUoJ21vdmVzdGFydCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGFuaW1hdGUgcGFuIHVubGVzcyBhbmltYXRlOiBmYWxzZSBzcGVjaWZpZWRcclxuXHRcdGlmIChvcHRpb25zLmFuaW1hdGUgIT09IGZhbHNlKSB7XHJcblx0XHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC1wYW4tYW5pbScpO1xyXG5cclxuXHRcdFx0dmFyIG5ld1BvcyA9IHRoaXMuX2dldE1hcFBhbmVQb3MoKS5zdWJ0cmFjdChvZmZzZXQpO1xyXG5cdFx0XHR0aGlzLl9wYW5BbmltLnJ1bih0aGlzLl9tYXBQYW5lLCBuZXdQb3MsIG9wdGlvbnMuZHVyYXRpb24gfHwgMC4yNSwgb3B0aW9ucy5lYXNlTGluZWFyaXR5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3Jhd1BhbkJ5KG9mZnNldCk7XHJcblx0XHRcdHRoaXMuZmlyZSgnbW92ZScpLmZpcmUoJ21vdmVlbmQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfb25QYW5UcmFuc2l0aW9uU3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dGhpcy5maXJlKCdtb3ZlJyk7XHJcblx0fSxcclxuXHJcblx0X29uUGFuVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cdFx0TC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX21hcFBhbmUsICdsZWFmbGV0LXBhbi1hbmltJyk7XHJcblx0XHR0aGlzLmZpcmUoJ21vdmVlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRQYW46IGZ1bmN0aW9uIChjZW50ZXIsIG9wdGlvbnMpIHtcclxuXHRcdC8vIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgbmV3IGFuZCBjdXJyZW50IGNlbnRlcnMgaW4gcGl4ZWxzXHJcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fZ2V0Q2VudGVyT2Zmc2V0KGNlbnRlcikuX2Zsb29yKCk7XHJcblxyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSB0b28gZmFyIHVubGVzcyBhbmltYXRlOiB0cnVlIHNwZWNpZmllZCBpbiBvcHRpb25zXHJcblx0XHRpZiAoKG9wdGlvbnMgJiYgb3B0aW9ucy5hbmltYXRlKSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzLnBhbkJ5KG9mZnNldCwgb3B0aW9ucyk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBMLlBvc0FuaW1hdGlvbiBmYWxsYmFjayBpbXBsZW1lbnRhdGlvbiB0aGF0IHBvd2VycyBMZWFmbGV0IHBhbiBhbmltYXRpb25zXHJcbiAqIGluIGJyb3dzZXJzIHRoYXQgZG9uJ3Qgc3VwcG9ydCBDU1MzIFRyYW5zaXRpb25zLlxyXG4gKi9cclxuXHJcbkwuUG9zQW5pbWF0aW9uID0gTC5Eb21VdGlsLlRSQU5TSVRJT04gPyBMLlBvc0FuaW1hdGlvbiA6IEwuUG9zQW5pbWF0aW9uLmV4dGVuZCh7XHJcblxyXG5cdHJ1bjogZnVuY3Rpb24gKGVsLCBuZXdQb3MsIGR1cmF0aW9uLCBlYXNlTGluZWFyaXR5KSB7IC8vIChIVE1MRWxlbWVudCwgUG9pbnRbLCBOdW1iZXIsIE51bWJlcl0pXHJcblx0XHR0aGlzLnN0b3AoKTtcclxuXHJcblx0XHR0aGlzLl9lbCA9IGVsO1xyXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IHRydWU7XHJcblx0XHR0aGlzLl9kdXJhdGlvbiA9IGR1cmF0aW9uIHx8IDAuMjU7XHJcblx0XHR0aGlzLl9lYXNlT3V0UG93ZXIgPSAxIC8gTWF0aC5tYXgoZWFzZUxpbmVhcml0eSB8fCAwLjUsIDAuMik7XHJcblxyXG5cdFx0dGhpcy5fc3RhcnRQb3MgPSBMLkRvbVV0aWwuZ2V0UG9zaXRpb24oZWwpO1xyXG5cdFx0dGhpcy5fb2Zmc2V0ID0gbmV3UG9zLnN1YnRyYWN0KHRoaXMuX3N0YXJ0UG9zKTtcclxuXHRcdHRoaXMuX3N0YXJ0VGltZSA9ICtuZXcgRGF0ZSgpO1xyXG5cclxuXHRcdHRoaXMuZmlyZSgnc3RhcnQnKTtcclxuXHJcblx0XHR0aGlzLl9hbmltYXRlKCk7XHJcblx0fSxcclxuXHJcblx0c3RvcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKCF0aGlzLl9pblByb2dyZXNzKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHRoaXMuX3N0ZXAoKTtcclxuXHRcdHRoaXMuX2NvbXBsZXRlKCk7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdC8vIGFuaW1hdGlvbiBsb29wXHJcblx0XHR0aGlzLl9hbmltSWQgPSBMLlV0aWwucmVxdWVzdEFuaW1GcmFtZSh0aGlzLl9hbmltYXRlLCB0aGlzKTtcclxuXHRcdHRoaXMuX3N0ZXAoKTtcclxuXHR9LFxyXG5cclxuXHRfc3RlcDogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIGVsYXBzZWQgPSAoK25ldyBEYXRlKCkpIC0gdGhpcy5fc3RhcnRUaW1lLFxyXG5cdFx0ICAgIGR1cmF0aW9uID0gdGhpcy5fZHVyYXRpb24gKiAxMDAwO1xyXG5cclxuXHRcdGlmIChlbGFwc2VkIDwgZHVyYXRpb24pIHtcclxuXHRcdFx0dGhpcy5fcnVuRnJhbWUodGhpcy5fZWFzZU91dChlbGFwc2VkIC8gZHVyYXRpb24pKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuX3J1bkZyYW1lKDEpO1xyXG5cdFx0XHR0aGlzLl9jb21wbGV0ZSgpO1xyXG5cdFx0fVxyXG5cdH0sXHJcblxyXG5cdF9ydW5GcmFtZTogZnVuY3Rpb24gKHByb2dyZXNzKSB7XHJcblx0XHR2YXIgcG9zID0gdGhpcy5fc3RhcnRQb3MuYWRkKHRoaXMuX29mZnNldC5tdWx0aXBseUJ5KHByb2dyZXNzKSk7XHJcblx0XHRMLkRvbVV0aWwuc2V0UG9zaXRpb24odGhpcy5fZWwsIHBvcyk7XHJcblxyXG5cdFx0dGhpcy5maXJlKCdzdGVwJyk7XHJcblx0fSxcclxuXHJcblx0X2NvbXBsZXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0XHRMLlV0aWwuY2FuY2VsQW5pbUZyYW1lKHRoaXMuX2FuaW1JZCk7XHJcblxyXG5cdFx0dGhpcy5faW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5maXJlKCdlbmQnKTtcclxuXHR9LFxyXG5cclxuXHRfZWFzZU91dDogZnVuY3Rpb24gKHQpIHtcclxuXHRcdHJldHVybiAxIC0gTWF0aC5wb3coMSAtIHQsIHRoaXMuX2Vhc2VPdXRQb3dlcik7XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBFeHRlbmRzIEwuTWFwIHRvIGhhbmRsZSB6b29tIGFuaW1hdGlvbnMuXHJcbiAqL1xyXG5cclxuTC5NYXAubWVyZ2VPcHRpb25zKHtcclxuXHR6b29tQW5pbWF0aW9uOiB0cnVlLFxyXG5cdHpvb21BbmltYXRpb25UaHJlc2hvbGQ6IDRcclxufSk7XHJcblxyXG5pZiAoTC5Eb21VdGlsLlRSQU5TSVRJT04pIHtcclxuXHJcblx0TC5NYXAuYWRkSW5pdEhvb2soZnVuY3Rpb24gKCkge1xyXG5cdFx0Ly8gZG9uJ3QgYW5pbWF0ZSBvbiBicm93c2VycyB3aXRob3V0IGhhcmR3YXJlLWFjY2VsZXJhdGVkIHRyYW5zaXRpb25zIG9yIG9sZCBBbmRyb2lkL09wZXJhXHJcblx0XHR0aGlzLl96b29tQW5pbWF0ZWQgPSB0aGlzLm9wdGlvbnMuem9vbUFuaW1hdGlvbiAmJiBMLkRvbVV0aWwuVFJBTlNJVElPTiAmJlxyXG5cdFx0XHRcdEwuQnJvd3Nlci5hbnkzZCAmJiAhTC5Ccm93c2VyLmFuZHJvaWQyMyAmJiAhTC5Ccm93c2VyLm1vYmlsZU9wZXJhO1xyXG5cclxuXHRcdC8vIHpvb20gdHJhbnNpdGlvbnMgcnVuIHdpdGggdGhlIHNhbWUgZHVyYXRpb24gZm9yIGFsbCBsYXllcnMsIHNvIGlmIG9uZSBvZiB0cmFuc2l0aW9uZW5kIGV2ZW50c1xyXG5cdFx0Ly8gaGFwcGVucyBhZnRlciBzdGFydGluZyB6b29tIGFuaW1hdGlvbiAocHJvcGFnYXRpbmcgdG8gdGhlIG1hcCBwYW5lKSwgd2Uga25vdyB0aGF0IGl0IGVuZGVkIGdsb2JhbGx5XHJcblx0XHRpZiAodGhpcy5fem9vbUFuaW1hdGVkKSB7XHJcblx0XHRcdEwuRG9tRXZlbnQub24odGhpcy5fbWFwUGFuZSwgTC5Eb21VdGlsLlRSQU5TSVRJT05fRU5ELCB0aGlzLl9jYXRjaFRyYW5zaXRpb25FbmQsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH0pO1xyXG59XHJcblxyXG5MLk1hcC5pbmNsdWRlKCFMLkRvbVV0aWwuVFJBTlNJVElPTiA/IHt9IDoge1xyXG5cclxuXHRfY2F0Y2hUcmFuc2l0aW9uRW5kOiBmdW5jdGlvbiAoZSkge1xyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20gJiYgZS5wcm9wZXJ0eU5hbWUuaW5kZXhPZigndHJhbnNmb3JtJykgPj0gMCkge1xyXG5cdFx0XHR0aGlzLl9vblpvb21UcmFuc2l0aW9uRW5kKCk7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X25vdGhpbmdUb0FuaW1hdGU6IGZ1bmN0aW9uICgpIHtcclxuXHRcdHJldHVybiAhdGhpcy5fY29udGFpbmVyLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xlYWZsZXQtem9vbS1hbmltYXRlZCcpLmxlbmd0aDtcclxuXHR9LFxyXG5cclxuXHRfdHJ5QW5pbWF0ZWRab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcHRpb25zKSB7XHJcblxyXG5cdFx0aWYgKHRoaXMuX2FuaW1hdGluZ1pvb20pIHsgcmV0dXJuIHRydWU7IH1cclxuXHJcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIGRpc2FibGVkLCBub3Qgc3VwcG9ydGVkIG9yIHpvb20gZGlmZmVyZW5jZSBpcyB0b28gbGFyZ2VcclxuXHRcdGlmICghdGhpcy5fem9vbUFuaW1hdGVkIHx8IG9wdGlvbnMuYW5pbWF0ZSA9PT0gZmFsc2UgfHwgdGhpcy5fbm90aGluZ1RvQW5pbWF0ZSgpIHx8XHJcblx0XHQgICAgICAgIE1hdGguYWJzKHpvb20gLSB0aGlzLl96b29tKSA+IHRoaXMub3B0aW9ucy56b29tQW5pbWF0aW9uVGhyZXNob2xkKSB7IHJldHVybiBmYWxzZTsgfVxyXG5cclxuXHRcdC8vIG9mZnNldCBpcyB0aGUgcGl4ZWwgY29vcmRzIG9mIHRoZSB6b29tIG9yaWdpbiByZWxhdGl2ZSB0byB0aGUgY3VycmVudCBjZW50ZXJcclxuXHRcdHZhciBzY2FsZSA9IHRoaXMuZ2V0Wm9vbVNjYWxlKHpvb20pLFxyXG5cdFx0ICAgIG9mZnNldCA9IHRoaXMuX2dldENlbnRlck9mZnNldChjZW50ZXIpLl9kaXZpZGVCeSgxIC0gMSAvIHNjYWxlKSxcclxuXHRcdFx0b3JpZ2luID0gdGhpcy5fZ2V0Q2VudGVyTGF5ZXJQb2ludCgpLl9hZGQob2Zmc2V0KTtcclxuXHJcblx0XHQvLyBkb24ndCBhbmltYXRlIGlmIHRoZSB6b29tIG9yaWdpbiBpc24ndCB3aXRoaW4gb25lIHNjcmVlbiBmcm9tIHRoZSBjdXJyZW50IGNlbnRlciwgdW5sZXNzIGZvcmNlZFxyXG5cdFx0aWYgKG9wdGlvbnMuYW5pbWF0ZSAhPT0gdHJ1ZSAmJiAhdGhpcy5nZXRTaXplKCkuY29udGFpbnMob2Zmc2V0KSkgeyByZXR1cm4gZmFsc2U7IH1cclxuXHJcblx0XHR0aGlzXHJcblx0XHQgICAgLmZpcmUoJ21vdmVzdGFydCcpXHJcblx0XHQgICAgLmZpcmUoJ3pvb21zdGFydCcpO1xyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGVab29tKGNlbnRlciwgem9vbSwgb3JpZ2luLCBzY2FsZSwgbnVsbCwgdHJ1ZSk7XHJcblxyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fSxcclxuXHJcblx0X2FuaW1hdGVab29tOiBmdW5jdGlvbiAoY2VudGVyLCB6b29tLCBvcmlnaW4sIHNjYWxlLCBkZWx0YSwgYmFja3dhcmRzKSB7XHJcblxyXG5cdFx0dGhpcy5fYW5pbWF0aW5nWm9vbSA9IHRydWU7XHJcblxyXG5cdFx0Ly8gcHV0IHRyYW5zZm9ybSB0cmFuc2l0aW9uIG9uIGFsbCBsYXllcnMgd2l0aCBsZWFmbGV0LXpvb20tYW5pbWF0ZWQgY2xhc3NcclxuXHRcdEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9tYXBQYW5lLCAnbGVhZmxldC16b29tLWFuaW0nKTtcclxuXHJcblx0XHQvLyByZW1lbWJlciB3aGF0IGNlbnRlci96b29tIHRvIHNldCBhZnRlciBhbmltYXRpb25cclxuXHRcdHRoaXMuX2FuaW1hdGVUb0NlbnRlciA9IGNlbnRlcjtcclxuXHRcdHRoaXMuX2FuaW1hdGVUb1pvb20gPSB6b29tO1xyXG5cclxuXHRcdC8vIGRpc2FibGUgYW55IGRyYWdnaW5nIGR1cmluZyBhbmltYXRpb25cclxuXHRcdGlmIChMLkRyYWdnYWJsZSkge1xyXG5cdFx0XHRMLkRyYWdnYWJsZS5fZGlzYWJsZWQgPSB0cnVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnem9vbWFuaW0nLCB7XHJcblx0XHRcdGNlbnRlcjogY2VudGVyLFxyXG5cdFx0XHR6b29tOiB6b29tLFxyXG5cdFx0XHRvcmlnaW46IG9yaWdpbixcclxuXHRcdFx0c2NhbGU6IHNjYWxlLFxyXG5cdFx0XHRkZWx0YTogZGVsdGEsXHJcblx0XHRcdGJhY2t3YXJkczogYmFja3dhcmRzXHJcblx0XHR9KTtcclxuXHR9LFxyXG5cclxuXHRfb25ab29tVHJhbnNpdGlvbkVuZDogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHRoaXMuX2FuaW1hdGluZ1pvb20gPSBmYWxzZTtcclxuXHJcblx0XHRMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fbWFwUGFuZSwgJ2xlYWZsZXQtem9vbS1hbmltJyk7XHJcblxyXG5cdFx0dGhpcy5fcmVzZXRWaWV3KHRoaXMuX2FuaW1hdGVUb0NlbnRlciwgdGhpcy5fYW5pbWF0ZVRvWm9vbSwgdHJ1ZSwgdHJ1ZSk7XHJcblxyXG5cdFx0aWYgKEwuRHJhZ2dhYmxlKSB7XHJcblx0XHRcdEwuRHJhZ2dhYmxlLl9kaXNhYmxlZCA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cdH1cclxufSk7XHJcblxyXG5cclxuLypcclxuXHRab29tIGFuaW1hdGlvbiBsb2dpYyBmb3IgTC5UaWxlTGF5ZXIuXHJcbiovXHJcblxyXG5MLlRpbGVMYXllci5pbmNsdWRlKHtcclxuXHRfYW5pbWF0ZVpvb206IGZ1bmN0aW9uIChlKSB7XHJcblx0XHRpZiAoIXRoaXMuX2FuaW1hdGluZykge1xyXG5cdFx0XHR0aGlzLl9hbmltYXRpbmcgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9wcmVwYXJlQmdCdWZmZXIoKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgYmcgPSB0aGlzLl9iZ0J1ZmZlcixcclxuXHRcdCAgICB0cmFuc2Zvcm0gPSBMLkRvbVV0aWwuVFJBTlNGT1JNLFxyXG5cdFx0ICAgIGluaXRpYWxUcmFuc2Zvcm0gPSBlLmRlbHRhID8gTC5Eb21VdGlsLmdldFRyYW5zbGF0ZVN0cmluZyhlLmRlbHRhKSA6IGJnLnN0eWxlW3RyYW5zZm9ybV0sXHJcblx0XHQgICAgc2NhbGVTdHIgPSBMLkRvbVV0aWwuZ2V0U2NhbGVTdHJpbmcoZS5zY2FsZSwgZS5vcmlnaW4pO1xyXG5cclxuXHRcdGJnLnN0eWxlW3RyYW5zZm9ybV0gPSBlLmJhY2t3YXJkcyA/XHJcblx0XHRcdFx0c2NhbGVTdHIgKyAnICcgKyBpbml0aWFsVHJhbnNmb3JtIDpcclxuXHRcdFx0XHRpbml0aWFsVHJhbnNmb3JtICsgJyAnICsgc2NhbGVTdHI7XHJcblx0fSxcclxuXHJcblx0X2VuZFpvb21BbmltOiBmdW5jdGlvbiAoKSB7XHJcblx0XHR2YXIgZnJvbnQgPSB0aGlzLl90aWxlQ29udGFpbmVyLFxyXG5cdFx0ICAgIGJnID0gdGhpcy5fYmdCdWZmZXI7XHJcblxyXG5cdFx0ZnJvbnQuc3R5bGUudmlzaWJpbGl0eSA9ICcnO1xyXG5cdFx0ZnJvbnQucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChmcm9udCk7IC8vIEJyaW5nIHRvIGZvcmVcclxuXHJcblx0XHQvLyBmb3JjZSByZWZsb3dcclxuXHRcdEwuVXRpbC5mYWxzZUZuKGJnLm9mZnNldFdpZHRoKTtcclxuXHJcblx0XHR0aGlzLl9hbmltYXRpbmcgPSBmYWxzZTtcclxuXHR9LFxyXG5cclxuXHRfY2xlYXJCZ0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cdFx0dmFyIG1hcCA9IHRoaXMuX21hcDtcclxuXHJcblx0XHRpZiAobWFwICYmICFtYXAuX2FuaW1hdGluZ1pvb20gJiYgIW1hcC50b3VjaFpvb20uX3pvb21pbmcpIHtcclxuXHRcdFx0dGhpcy5fYmdCdWZmZXIuaW5uZXJIVE1MID0gJyc7XHJcblx0XHRcdHRoaXMuX2JnQnVmZmVyLnN0eWxlW0wuRG9tVXRpbC5UUkFOU0ZPUk1dID0gJyc7XHJcblx0XHR9XHJcblx0fSxcclxuXHJcblx0X3ByZXBhcmVCZ0J1ZmZlcjogZnVuY3Rpb24gKCkge1xyXG5cclxuXHRcdHZhciBmcm9udCA9IHRoaXMuX3RpbGVDb250YWluZXIsXHJcblx0XHQgICAgYmcgPSB0aGlzLl9iZ0J1ZmZlcjtcclxuXHJcblx0XHQvLyBpZiBmb3JlZ3JvdW5kIGxheWVyIGRvZXNuJ3QgaGF2ZSBtYW55IHRpbGVzIGJ1dCBiZyBsYXllciBkb2VzLFxyXG5cdFx0Ly8ga2VlcCB0aGUgZXhpc3RpbmcgYmcgbGF5ZXIgYW5kIGp1c3Qgem9vbSBpdCBzb21lIG1vcmVcclxuXHJcblx0XHR2YXIgYmdMb2FkZWQgPSB0aGlzLl9nZXRMb2FkZWRUaWxlc1BlcmNlbnRhZ2UoYmcpLFxyXG5cdFx0ICAgIGZyb250TG9hZGVkID0gdGhpcy5fZ2V0TG9hZGVkVGlsZXNQZXJjZW50YWdlKGZyb250KTtcclxuXHJcblx0XHRpZiAoYmcgJiYgYmdMb2FkZWQgPiAwLjUgJiYgZnJvbnRMb2FkZWQgPCAwLjUpIHtcclxuXHJcblx0XHRcdGZyb250LnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcclxuXHRcdFx0dGhpcy5fc3RvcExvYWRpbmdJbWFnZXMoZnJvbnQpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gcHJlcGFyZSB0aGUgYnVmZmVyIHRvIGJlY29tZSB0aGUgZnJvbnQgdGlsZSBwYW5lXHJcblx0XHRiZy5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XHJcblx0XHRiZy5zdHlsZVtMLkRvbVV0aWwuVFJBTlNGT1JNXSA9ICcnO1xyXG5cclxuXHRcdC8vIHN3aXRjaCBvdXQgdGhlIGN1cnJlbnQgbGF5ZXIgdG8gYmUgdGhlIG5ldyBiZyBsYXllciAoYW5kIHZpY2UtdmVyc2EpXHJcblx0XHR0aGlzLl90aWxlQ29udGFpbmVyID0gYmc7XHJcblx0XHRiZyA9IHRoaXMuX2JnQnVmZmVyID0gZnJvbnQ7XHJcblxyXG5cdFx0dGhpcy5fc3RvcExvYWRpbmdJbWFnZXMoYmcpO1xyXG5cclxuXHRcdC8vcHJldmVudCBiZyBidWZmZXIgZnJvbSBjbGVhcmluZyByaWdodCBhZnRlciB6b29tXHJcblx0XHRjbGVhclRpbWVvdXQodGhpcy5fY2xlYXJCZ0J1ZmZlclRpbWVyKTtcclxuXHR9LFxyXG5cclxuXHRfZ2V0TG9hZGVkVGlsZXNQZXJjZW50YWdlOiBmdW5jdGlvbiAoY29udGFpbmVyKSB7XHJcblx0XHR2YXIgdGlsZXMgPSBjb250YWluZXIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpLFxyXG5cdFx0ICAgIGksIGxlbiwgY291bnQgPSAwO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdGlmICh0aWxlc1tpXS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdGNvdW50Kys7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBjb3VudCAvIGxlbjtcclxuXHR9LFxyXG5cclxuXHQvLyBzdG9wcyBsb2FkaW5nIGFsbCB0aWxlcyBpbiB0aGUgYmFja2dyb3VuZCBsYXllclxyXG5cdF9zdG9wTG9hZGluZ0ltYWdlczogZnVuY3Rpb24gKGNvbnRhaW5lcikge1xyXG5cdFx0dmFyIHRpbGVzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoY29udGFpbmVyLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdpbWcnKSksXHJcblx0XHQgICAgaSwgbGVuLCB0aWxlO1xyXG5cclxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IHRpbGVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdHRpbGUgPSB0aWxlc1tpXTtcclxuXHJcblx0XHRcdGlmICghdGlsZS5jb21wbGV0ZSkge1xyXG5cdFx0XHRcdHRpbGUub25sb2FkID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5vbmVycm9yID0gTC5VdGlsLmZhbHNlRm47XHJcblx0XHRcdFx0dGlsZS5zcmMgPSBMLlV0aWwuZW1wdHlJbWFnZVVybDtcclxuXHJcblx0XHRcdFx0dGlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRpbGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59KTtcclxuXHJcblxyXG4vKlxyXG4gKiBQcm92aWRlcyBMLk1hcCB3aXRoIGNvbnZlbmllbnQgc2hvcnRjdXRzIGZvciB1c2luZyBicm93c2VyIGdlb2xvY2F0aW9uIGZlYXR1cmVzLlxyXG4gKi9cclxuXHJcbkwuTWFwLmluY2x1ZGUoe1xyXG5cdF9kZWZhdWx0TG9jYXRlT3B0aW9uczoge1xyXG5cdFx0d2F0Y2g6IGZhbHNlLFxyXG5cdFx0c2V0VmlldzogZmFsc2UsXHJcblx0XHRtYXhab29tOiBJbmZpbml0eSxcclxuXHRcdHRpbWVvdXQ6IDEwMDAwLFxyXG5cdFx0bWF4aW11bUFnZTogMCxcclxuXHRcdGVuYWJsZUhpZ2hBY2N1cmFjeTogZmFsc2VcclxuXHR9LFxyXG5cclxuXHRsb2NhdGU6IGZ1bmN0aW9uICgvKk9iamVjdCovIG9wdGlvbnMpIHtcclxuXHJcblx0XHRvcHRpb25zID0gdGhpcy5fbG9jYXRlT3B0aW9ucyA9IEwuZXh0ZW5kKHRoaXMuX2RlZmF1bHRMb2NhdGVPcHRpb25zLCBvcHRpb25zKTtcclxuXHJcblx0XHRpZiAoIW5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHR0aGlzLl9oYW5kbGVHZW9sb2NhdGlvbkVycm9yKHtcclxuXHRcdFx0XHRjb2RlOiAwLFxyXG5cdFx0XHRcdG1lc3NhZ2U6ICdHZW9sb2NhdGlvbiBub3Qgc3VwcG9ydGVkLidcclxuXHRcdFx0fSk7XHJcblx0XHRcdHJldHVybiB0aGlzO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBvblJlc3BvbnNlID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2UsIHRoaXMpLFxyXG5cdFx0XHRvbkVycm9yID0gTC5iaW5kKHRoaXMuX2hhbmRsZUdlb2xvY2F0aW9uRXJyb3IsIHRoaXMpO1xyXG5cclxuXHRcdGlmIChvcHRpb25zLndhdGNoKSB7XHJcblx0XHRcdHRoaXMuX2xvY2F0aW9uV2F0Y2hJZCA9XHJcblx0XHRcdCAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLndhdGNoUG9zaXRpb24ob25SZXNwb25zZSwgb25FcnJvciwgb3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uZ2V0Q3VycmVudFBvc2l0aW9uKG9uUmVzcG9uc2UsIG9uRXJyb3IsIG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fSxcclxuXHJcblx0c3RvcExvY2F0ZTogZnVuY3Rpb24gKCkge1xyXG5cdFx0aWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikge1xyXG5cdFx0XHRuYXZpZ2F0b3IuZ2VvbG9jYXRpb24uY2xlYXJXYXRjaCh0aGlzLl9sb2NhdGlvbldhdGNoSWQpO1xyXG5cdFx0fVxyXG5cdFx0aWYgKHRoaXMuX2xvY2F0ZU9wdGlvbnMpIHtcclxuXHRcdFx0dGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ID0gZmFsc2U7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9LFxyXG5cclxuXHRfaGFuZGxlR2VvbG9jYXRpb25FcnJvcjogZnVuY3Rpb24gKGVycm9yKSB7XHJcblx0XHR2YXIgYyA9IGVycm9yLmNvZGUsXHJcblx0XHQgICAgbWVzc2FnZSA9IGVycm9yLm1lc3NhZ2UgfHxcclxuXHRcdCAgICAgICAgICAgIChjID09PSAxID8gJ3Blcm1pc3Npb24gZGVuaWVkJyA6XHJcblx0XHQgICAgICAgICAgICAoYyA9PT0gMiA/ICdwb3NpdGlvbiB1bmF2YWlsYWJsZScgOiAndGltZW91dCcpKTtcclxuXHJcblx0XHRpZiAodGhpcy5fbG9jYXRlT3B0aW9ucy5zZXRWaWV3ICYmICF0aGlzLl9sb2FkZWQpIHtcclxuXHRcdFx0dGhpcy5maXRXb3JsZCgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25lcnJvcicsIHtcclxuXHRcdFx0Y29kZTogYyxcclxuXHRcdFx0bWVzc2FnZTogJ0dlb2xvY2F0aW9uIGVycm9yOiAnICsgbWVzc2FnZSArICcuJ1xyXG5cdFx0fSk7XHJcblx0fSxcclxuXHJcblx0X2hhbmRsZUdlb2xvY2F0aW9uUmVzcG9uc2U6IGZ1bmN0aW9uIChwb3MpIHtcclxuXHRcdHZhciBsYXQgPSBwb3MuY29vcmRzLmxhdGl0dWRlLFxyXG5cdFx0ICAgIGxuZyA9IHBvcy5jb29yZHMubG9uZ2l0dWRlLFxyXG5cdFx0ICAgIGxhdGxuZyA9IG5ldyBMLkxhdExuZyhsYXQsIGxuZyksXHJcblxyXG5cdFx0ICAgIGxhdEFjY3VyYWN5ID0gMTgwICogcG9zLmNvb3Jkcy5hY2N1cmFjeSAvIDQwMDc1MDE3LFxyXG5cdFx0ICAgIGxuZ0FjY3VyYWN5ID0gbGF0QWNjdXJhY3kgLyBNYXRoLmNvcyhMLkxhdExuZy5ERUdfVE9fUkFEICogbGF0KSxcclxuXHJcblx0XHQgICAgYm91bmRzID0gTC5sYXRMbmdCb3VuZHMoXHJcblx0XHQgICAgICAgICAgICBbbGF0IC0gbGF0QWNjdXJhY3ksIGxuZyAtIGxuZ0FjY3VyYWN5XSxcclxuXHRcdCAgICAgICAgICAgIFtsYXQgKyBsYXRBY2N1cmFjeSwgbG5nICsgbG5nQWNjdXJhY3ldKSxcclxuXHJcblx0XHQgICAgb3B0aW9ucyA9IHRoaXMuX2xvY2F0ZU9wdGlvbnM7XHJcblxyXG5cdFx0aWYgKG9wdGlvbnMuc2V0Vmlldykge1xyXG5cdFx0XHR2YXIgem9vbSA9IE1hdGgubWluKHRoaXMuZ2V0Qm91bmRzWm9vbShib3VuZHMpLCBvcHRpb25zLm1heFpvb20pO1xyXG5cdFx0XHR0aGlzLnNldFZpZXcobGF0bG5nLCB6b29tKTtcclxuXHRcdH1cclxuXHJcblx0XHR2YXIgZGF0YSA9IHtcclxuXHRcdFx0bGF0bG5nOiBsYXRsbmcsXHJcblx0XHRcdGJvdW5kczogYm91bmRzLFxyXG5cdFx0XHR0aW1lc3RhbXA6IHBvcy50aW1lc3RhbXBcclxuXHRcdH07XHJcblxyXG5cdFx0Zm9yICh2YXIgaSBpbiBwb3MuY29vcmRzKSB7XHJcblx0XHRcdGlmICh0eXBlb2YgcG9zLmNvb3Jkc1tpXSA9PT0gJ251bWJlcicpIHtcclxuXHRcdFx0XHRkYXRhW2ldID0gcG9zLmNvb3Jkc1tpXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZmlyZSgnbG9jYXRpb25mb3VuZCcsIGRhdGEpO1xyXG5cdH1cclxufSk7XHJcblxyXG5cclxufSh3aW5kb3csIGRvY3VtZW50KSk7IiwiLyohXG4gKiBtdXN0YWNoZS5qcyAtIExvZ2ljLWxlc3Mge3ttdXN0YWNoZX19IHRlbXBsYXRlcyB3aXRoIEphdmFTY3JpcHRcbiAqIGh0dHA6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanNcbiAqL1xuXG4vKmdsb2JhbCBkZWZpbmU6IGZhbHNlKi9cblxuKGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gXCJvYmplY3RcIiAmJiBleHBvcnRzKSB7XG4gICAgZmFjdG9yeShleHBvcnRzKTsgLy8gQ29tbW9uSlNcbiAgfSBlbHNlIHtcbiAgICB2YXIgbXVzdGFjaGUgPSB7fTtcbiAgICBmYWN0b3J5KG11c3RhY2hlKTtcbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICAgIGRlZmluZShtdXN0YWNoZSk7IC8vIEFNRFxuICAgIH0gZWxzZSB7XG4gICAgICByb290Lk11c3RhY2hlID0gbXVzdGFjaGU7IC8vIDxzY3JpcHQ+XG4gICAgfVxuICB9XG59KHRoaXMsIGZ1bmN0aW9uIChtdXN0YWNoZSkge1xuXG4gIC8vIFdvcmthcm91bmQgZm9yIGh0dHBzOi8vaXNzdWVzLmFwYWNoZS5vcmcvamlyYS9icm93c2UvQ09VQ0hEQi01NzdcbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8xODlcbiAgdmFyIFJlZ0V4cF90ZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xuICBmdW5jdGlvbiB0ZXN0UmVnRXhwKHJlLCBzdHJpbmcpIHtcbiAgICByZXR1cm4gUmVnRXhwX3Rlc3QuY2FsbChyZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBub25TcGFjZVJlID0gL1xcUy87XG4gIGZ1bmN0aW9uIGlzV2hpdGVzcGFjZShzdHJpbmcpIHtcbiAgICByZXR1cm4gIXRlc3RSZWdFeHAobm9uU3BhY2VSZSwgc3RyaW5nKTtcbiAgfVxuXG4gIHZhciBPYmplY3RfdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKG9iamVjdCkge1xuICAgIHJldHVybiBPYmplY3RfdG9TdHJpbmcuY2FsbChvYmplY3QpID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICBmdW5jdGlvbiBlc2NhcGVSZWdFeHAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgXCJcXFxcJCZcIik7XG4gIH1cblxuICB2YXIgZW50aXR5TWFwID0ge1xuICAgIFwiJlwiOiBcIiZhbXA7XCIsXG4gICAgXCI8XCI6IFwiJmx0O1wiLFxuICAgIFwiPlwiOiBcIiZndDtcIixcbiAgICAnXCInOiAnJnF1b3Q7JyxcbiAgICBcIidcIjogJyYjMzk7JyxcbiAgICBcIi9cIjogJyYjeDJGOydcbiAgfTtcblxuICBmdW5jdGlvbiBlc2NhcGVIdG1sKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInXFwvXS9nLCBmdW5jdGlvbiAocykge1xuICAgICAgcmV0dXJuIGVudGl0eU1hcFtzXTtcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzY2FwZVRhZ3ModGFncykge1xuICAgIGlmICghaXNBcnJheSh0YWdzKSB8fCB0YWdzLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHRhZ3M6ICcgKyB0YWdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gW1xuICAgICAgbmV3IFJlZ0V4cChlc2NhcGVSZWdFeHAodGFnc1swXSkgKyBcIlxcXFxzKlwiKSxcbiAgICAgIG5ldyBSZWdFeHAoXCJcXFxccypcIiArIGVzY2FwZVJlZ0V4cCh0YWdzWzFdKSlcbiAgICBdO1xuICB9XG5cbiAgdmFyIHdoaXRlUmUgPSAvXFxzKi87XG4gIHZhciBzcGFjZVJlID0gL1xccysvO1xuICB2YXIgZXF1YWxzUmUgPSAvXFxzKj0vO1xuICB2YXIgY3VybHlSZSA9IC9cXHMqXFx9LztcbiAgdmFyIHRhZ1JlID0gLyN8XFxefFxcL3w+fFxce3wmfD18IS87XG5cbiAgLyoqXG4gICAqIEJyZWFrcyB1cCB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBzdHJpbmcgaW50byBhIHRyZWUgb2YgdG9rZW5zLiBJZiB0aGUgYHRhZ3NgXG4gICAqIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGVcbiAgICogb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIE9mXG4gICAqIGNvdXJzZSwgdGhlIGRlZmF1bHQgaXMgdG8gdXNlIG11c3RhY2hlcyAoaS5lLiBtdXN0YWNoZS50YWdzKS5cbiAgICpcbiAgICogQSB0b2tlbiBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IDQgZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICAgKiBtdXN0YWNoZSBzeW1ib2wgdGhhdCB3YXMgdXNlZCBpbnNpZGUgdGhlIHRhZywgZS5nLiBcIiNcIiBvciBcIiZcIi4gSWYgdGhlIHRhZ1xuICAgKiBkaWQgbm90IGNvbnRhaW4gYSBzeW1ib2wgKGkuZS4ge3tteVZhbHVlfX0pIHRoaXMgZWxlbWVudCBpcyBcIm5hbWVcIi4gRm9yXG4gICAqIGFsbCB0ZXh0IHRoYXQgYXBwZWFycyBvdXRzaWRlIGEgc3ltYm9sIHRoaXMgZWxlbWVudCBpcyBcInRleHRcIi5cbiAgICpcbiAgICogVGhlIHNlY29uZCBlbGVtZW50IG9mIGEgdG9rZW4gaXMgaXRzIFwidmFsdWVcIi4gRm9yIG11c3RhY2hlIHRhZ3MgdGhpcyBpc1xuICAgKiB3aGF0ZXZlciBlbHNlIHdhcyBpbnNpZGUgdGhlIHRhZyBiZXNpZGVzIHRoZSBvcGVuaW5nIHN5bWJvbC4gRm9yIHRleHQgdG9rZW5zXG4gICAqIHRoaXMgaXMgdGhlIHRleHQgaXRzZWxmLlxuICAgKlxuICAgKiBUaGUgdGhpcmQgYW5kIGZvdXJ0aCBlbGVtZW50cyBvZiB0aGUgdG9rZW4gYXJlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMsXG4gICAqIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogVG9rZW5zIHRoYXQgYXJlIHRoZSByb290IG5vZGUgb2YgYSBzdWJ0cmVlIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGFuXG4gICAqIGFycmF5IG9mIHRva2VucyBpbiB0aGUgc3VidHJlZSBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBhdFxuICAgKiB3aGljaCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoYXQgc2VjdGlvbiBiZWdpbnMuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgdGFncyA9IHRhZ3MgfHwgbXVzdGFjaGUudGFncztcbiAgICB0ZW1wbGF0ZSA9IHRlbXBsYXRlIHx8ICcnO1xuXG4gICAgaWYgKHR5cGVvZiB0YWdzID09PSAnc3RyaW5nJykge1xuICAgICAgdGFncyA9IHRhZ3Muc3BsaXQoc3BhY2VSZSk7XG4gICAgfVxuXG4gICAgdmFyIHRhZ1JlcyA9IGVzY2FwZVRhZ3ModGFncyk7XG4gICAgdmFyIHNjYW5uZXIgPSBuZXcgU2Nhbm5lcih0ZW1wbGF0ZSk7XG5cbiAgICB2YXIgc2VjdGlvbnMgPSBbXTsgICAgIC8vIFN0YWNrIHRvIGhvbGQgc2VjdGlvbiB0b2tlbnNcbiAgICB2YXIgdG9rZW5zID0gW107ICAgICAgIC8vIEJ1ZmZlciB0byBob2xkIHRoZSB0b2tlbnNcbiAgICB2YXIgc3BhY2VzID0gW107ICAgICAgIC8vIEluZGljZXMgb2Ygd2hpdGVzcGFjZSB0b2tlbnMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgIHZhciBoYXNUYWcgPSBmYWxzZTsgICAgLy8gSXMgdGhlcmUgYSB7e3RhZ319IG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gICAgdmFyIG5vblNwYWNlID0gZmFsc2U7ICAvLyBJcyB0aGVyZSBhIG5vbi1zcGFjZSBjaGFyIG9uIHRoZSBjdXJyZW50IGxpbmU/XG5cbiAgICAvLyBTdHJpcHMgYWxsIHdoaXRlc3BhY2UgdG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBsaW5lXG4gICAgLy8gaWYgdGhlcmUgd2FzIGEge3sjdGFnfX0gb24gaXQgYW5kIG90aGVyd2lzZSBvbmx5IHNwYWNlLlxuICAgIGZ1bmN0aW9uIHN0cmlwU3BhY2UoKSB7XG4gICAgICBpZiAoaGFzVGFnICYmICFub25TcGFjZSkge1xuICAgICAgICB3aGlsZSAoc3BhY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGRlbGV0ZSB0b2tlbnNbc3BhY2VzLnBvcCgpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VzID0gW107XG4gICAgICB9XG5cbiAgICAgIGhhc1RhZyA9IGZhbHNlO1xuICAgICAgbm9uU3BhY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQsIHR5cGUsIHZhbHVlLCBjaHIsIHRva2VuLCBvcGVuU2VjdGlvbjtcbiAgICB3aGlsZSAoIXNjYW5uZXIuZW9zKCkpIHtcbiAgICAgIHN0YXJ0ID0gc2Nhbm5lci5wb3M7XG5cbiAgICAgIC8vIE1hdGNoIGFueSB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwodGFnUmVzWzBdKTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgICAgICBjaHIgPSB2YWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNocikpIHtcbiAgICAgICAgICAgIHNwYWNlcy5wdXNoKHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2goWyd0ZXh0JywgY2hyLCBzdGFydCwgc3RhcnQgKyAxXSk7XG4gICAgICAgICAgc3RhcnQgKz0gMTtcblxuICAgICAgICAgIC8vIENoZWNrIGZvciB3aGl0ZXNwYWNlIG9uIHRoZSBjdXJyZW50IGxpbmUuXG4gICAgICAgICAgaWYgKGNociA9PT0gJ1xcbicpIHtcbiAgICAgICAgICAgIHN0cmlwU3BhY2UoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIG9wZW5pbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4odGFnUmVzWzBdKSkgYnJlYWs7XG4gICAgICBoYXNUYWcgPSB0cnVlO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB0eXBlLlxuICAgICAgdHlwZSA9IHNjYW5uZXIuc2Nhbih0YWdSZSkgfHwgJ25hbWUnO1xuICAgICAgc2Nhbm5lci5zY2FuKHdoaXRlUmUpO1xuXG4gICAgICAvLyBHZXQgdGhlIHRhZyB2YWx1ZS5cbiAgICAgIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihlcXVhbHNSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhblVudGlsKHRhZ1Jlc1sxXSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICd7Jykge1xuICAgICAgICB2YWx1ZSA9IHNjYW5uZXIuc2NhblVudGlsKG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAoJ30nICsgdGFnc1sxXSkpKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuKGN1cmx5UmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbCh0YWdSZXNbMV0pO1xuICAgICAgICB0eXBlID0gJyYnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbCh0YWdSZXNbMV0pO1xuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgY2xvc2luZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2Nhbih0YWdSZXNbMV0pKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgdGFnIGF0ICcgKyBzY2FubmVyLnBvcyk7XG4gICAgICB9XG5cbiAgICAgIHRva2VuID0gWyB0eXBlLCB2YWx1ZSwgc3RhcnQsIHNjYW5uZXIucG9zIF07XG4gICAgICB0b2tlbnMucHVzaCh0b2tlbik7XG5cbiAgICAgIGlmICh0eXBlID09PSAnIycgfHwgdHlwZSA9PT0gJ14nKSB7XG4gICAgICAgIHNlY3Rpb25zLnB1c2godG9rZW4pO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnLycpIHtcbiAgICAgICAgLy8gQ2hlY2sgc2VjdGlvbiBuZXN0aW5nLlxuICAgICAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgICAgIGlmICghb3BlblNlY3Rpb24pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vub3BlbmVkIHNlY3Rpb24gXCInICsgdmFsdWUgKyAnXCIgYXQgJyArIHN0YXJ0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3BlblNlY3Rpb25bMV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzdGFydCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ25hbWUnIHx8IHR5cGUgPT09ICd7JyB8fCB0eXBlID09PSAnJicpIHtcbiAgICAgICAgbm9uU3BhY2UgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnPScpIHtcbiAgICAgICAgLy8gU2V0IHRoZSB0YWdzIGZvciB0aGUgbmV4dCB0aW1lIGFyb3VuZC5cbiAgICAgICAgdGFnUmVzID0gZXNjYXBlVGFncyh0YWdzID0gdmFsdWUuc3BsaXQoc3BhY2VSZSkpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBhcmUgbm8gb3BlbiBzZWN0aW9ucyB3aGVuIHdlJ3JlIGRvbmUuXG4gICAgb3BlblNlY3Rpb24gPSBzZWN0aW9ucy5wb3AoKTtcbiAgICBpZiAob3BlblNlY3Rpb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc2Nhbm5lci5wb3MpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXN0VG9rZW5zKHNxdWFzaFRva2Vucyh0b2tlbnMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21iaW5lcyB0aGUgdmFsdWVzIG9mIGNvbnNlY3V0aXZlIHRleHQgdG9rZW5zIGluIHRoZSBnaXZlbiBgdG9rZW5zYCBhcnJheVxuICAgKiB0byBhIHNpbmdsZSB0b2tlbi5cbiAgICovXG4gIGZ1bmN0aW9uIHNxdWFzaFRva2Vucyh0b2tlbnMpIHtcbiAgICB2YXIgc3F1YXNoZWRUb2tlbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgbGFzdFRva2VuO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0b2tlbnMubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgaWYgKHRva2VuWzBdID09PSAndGV4dCcgJiYgbGFzdFRva2VuICYmIGxhc3RUb2tlblswXSA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgbGFzdFRva2VuWzFdICs9IHRva2VuWzFdO1xuICAgICAgICAgIGxhc3RUb2tlblszXSA9IHRva2VuWzNdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNxdWFzaGVkVG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgIGxhc3RUb2tlbiA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHNxdWFzaGVkVG9rZW5zO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1zIHRoZSBnaXZlbiBhcnJheSBvZiBgdG9rZW5zYCBpbnRvIGEgbmVzdGVkIHRyZWUgc3RydWN0dXJlIHdoZXJlXG4gICAqIHRva2VucyB0aGF0IHJlcHJlc2VudCBhIHNlY3Rpb24gaGF2ZSB0d28gYWRkaXRpb25hbCBpdGVtczogMSkgYW4gYXJyYXkgb2ZcbiAgICogYWxsIHRva2VucyB0aGF0IGFwcGVhciBpbiB0aGF0IHNlY3Rpb24gYW5kIDIpIHRoZSBpbmRleCBpbiB0aGUgb3JpZ2luYWxcbiAgICogdGVtcGxhdGUgdGhhdCByZXByZXNlbnRzIHRoZSBlbmQgb2YgdGhhdCBzZWN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gbmVzdFRva2Vucyh0b2tlbnMpIHtcbiAgICB2YXIgbmVzdGVkVG9rZW5zID0gW107XG4gICAgdmFyIGNvbGxlY3RvciA9IG5lc3RlZFRva2VucztcbiAgICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgc2VjdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gdG9rZW5zLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgY2FzZSAnIyc6XG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICBzZWN0aW9uWzVdID0gdG9rZW5bMl07XG4gICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lc3RlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gICAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Nhbm5lcihzdHJpbmcpIHtcbiAgICB0aGlzLnN0cmluZyA9IHN0cmluZztcbiAgICB0aGlzLnRhaWwgPSBzdHJpbmc7XG4gICAgdGhpcy5wb3MgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSB0YWlsIGlzIGVtcHR5IChlbmQgb2Ygc3RyaW5nKS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLmVvcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy50YWlsID09PSBcIlwiO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiAocmUpIHtcbiAgICB2YXIgbWF0Y2ggPSB0aGlzLnRhaWwubWF0Y2gocmUpO1xuXG4gICAgaWYgKG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwKSB7XG4gICAgICB2YXIgc3RyaW5nID0gbWF0Y2hbMF07XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKHN0cmluZy5sZW5ndGgpO1xuICAgICAgdGhpcy5wb3MgKz0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIFwiXCI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFNraXBzIGFsbCB0ZXh0IHVudGlsIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gY2FuIGJlIG1hdGNoZWQuIFJldHVybnNcbiAgICogdGhlIHNraXBwZWQgc3RyaW5nLCB3aGljaCBpcyB0aGUgZW50aXJlIHRhaWwgaWYgbm8gbWF0Y2ggY2FuIGJlIG1hZGUuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5zY2FuVW50aWwgPSBmdW5jdGlvbiAocmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsO1xuICAgICAgdGhpcy50YWlsID0gXCJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgMDpcbiAgICAgIG1hdGNoID0gXCJcIjtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBtYXRjaCA9IHRoaXMudGFpbC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhpbmRleCk7XG4gICAgfVxuXG4gICAgdGhpcy5wb3MgKz0gbWF0Y2gubGVuZ3RoO1xuXG4gICAgcmV0dXJuIG1hdGNoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXByZXNlbnRzIGEgcmVuZGVyaW5nIGNvbnRleHQgYnkgd3JhcHBpbmcgYSB2aWV3IG9iamVjdCBhbmRcbiAgICogbWFpbnRhaW5pbmcgYSByZWZlcmVuY2UgdG8gdGhlIHBhcmVudCBjb250ZXh0LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29udGV4dCh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy52aWV3ID0gdmlldyA9PSBudWxsID8ge30gOiB2aWV3O1xuICAgIHRoaXMuY2FjaGUgPSB7ICcuJzogdGhpcy52aWV3IH07XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnRDb250ZXh0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgY29udGV4dCB1c2luZyB0aGUgZ2l2ZW4gdmlldyB3aXRoIHRoaXMgY29udGV4dFxuICAgKiBhcyB0aGUgcGFyZW50LlxuICAgKi9cbiAgQ29udGV4dC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAgICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIHZhbHVlO1xuICAgIGlmIChuYW1lIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIHZhbHVlID0gdGhpcy5jYWNoZVtuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuXG4gICAgICB3aGlsZSAoY29udGV4dCkge1xuICAgICAgICBpZiAobmFtZS5pbmRleE9mKCcuJykgPiAwKSB7XG4gICAgICAgICAgdmFsdWUgPSBjb250ZXh0LnZpZXc7XG5cbiAgICAgICAgICB2YXIgbmFtZXMgPSBuYW1lLnNwbGl0KCcuJyksIGkgPSAwO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZSAhPSBudWxsICYmIGkgPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbmFtZXNbaSsrXV07XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gY29udGV4dC52aWV3W25hbWVdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIGJyZWFrO1xuXG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0LnBhcmVudDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jYWNoZVtuYW1lXSA9IHZhbHVlO1xuICAgIH1cblxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBBIFdyaXRlciBrbm93cyBob3cgdG8gdGFrZSBhIHN0cmVhbSBvZiB0b2tlbnMgYW5kIHJlbmRlciB0aGVtIHRvIGFcbiAgICogc3RyaW5nLCBnaXZlbiBhIGNvbnRleHQuIEl0IGFsc28gbWFpbnRhaW5zIGEgY2FjaGUgb2YgdGVtcGxhdGVzIHRvXG4gICAqIGF2b2lkIHRoZSBuZWVkIHRvIHBhcnNlIHRoZSBzYW1lIHRlbXBsYXRlIHR3aWNlLlxuICAgKi9cbiAgZnVuY3Rpb24gV3JpdGVyKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYWNoZSA9IHt9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBQYXJzZXMgYW5kIGNhY2hlcyB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBhbmQgcmV0dXJucyB0aGUgYXJyYXkgb2YgdG9rZW5zXG4gICAqIHRoYXQgaXMgZ2VuZXJhdGVkIGZyb20gdGhlIHBhcnNlLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG4gICAgdmFyIHRva2VucyA9IGNhY2hlW3RlbXBsYXRlXTtcblxuICAgIGlmICh0b2tlbnMgPT0gbnVsbCkge1xuICAgICAgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRva2VucztcbiAgfTtcblxuICAvKipcbiAgICogSGlnaC1sZXZlbCBtZXRob2QgdGhhdCBpcyB1c2VkIHRvIHJlbmRlciB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCB3aXRoXG4gICAqIHRoZSBnaXZlbiBgdmlld2AuXG4gICAqXG4gICAqIFRoZSBvcHRpb25hbCBgcGFydGlhbHNgIGFyZ3VtZW50IG1heSBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyB0aGVcbiAgICogbmFtZXMgYW5kIHRlbXBsYXRlcyBvZiBwYXJ0aWFscyB0aGF0IGFyZSB1c2VkIGluIHRoZSB0ZW1wbGF0ZS4gSXQgbWF5XG4gICAqIGFsc28gYmUgYSBmdW5jdGlvbiB0aGF0IGlzIHVzZWQgdG8gbG9hZCBwYXJ0aWFsIHRlbXBsYXRlcyBvbiB0aGUgZmx5XG4gICAqIHRoYXQgdGFrZXMgYSBzaW5nbGUgYXJndW1lbnQ6IHRoZSBuYW1lIG9mIHRoZSBwYXJ0aWFsLlxuICAgKi9cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUpO1xuICAgIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAgICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAgICpcbiAgICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gICAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAgICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAgICogYmUgb21pdHRlZC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gKHRva2VucywgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpIHtcbiAgICB2YXIgYnVmZmVyID0gJyc7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBzdWJSZW5kZXIodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpO1xuICAgIH1cblxuICAgIHZhciB0b2tlbiwgdmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHRva2Vucy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIHN3aXRjaCAodG9rZW5bMF0pIHtcbiAgICAgIGNhc2UgJyMnOlxuICAgICAgICB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICAgICAgaWYgKCF2YWx1ZSkgY29udGludWU7XG5cbiAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGpsZW4gPSB2YWx1ZS5sZW5ndGg7IGogPCBqbGVuOyArK2opIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dC5wdXNoKHZhbHVlW2pdKSwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUZW1wbGF0ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHVzZSBoaWdoZXItb3JkZXIgc2VjdGlvbnMgd2l0aG91dCB0aGUgb3JpZ2luYWwgdGVtcGxhdGUnKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBFeHRyYWN0IHRoZSBwb3J0aW9uIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHRoZSBzZWN0aW9uIGNvbnRhaW5zLlxuICAgICAgICAgIHZhbHVlID0gdmFsdWUuY2FsbChjb250ZXh0LnZpZXcsIG9yaWdpbmFsVGVtcGxhdGUuc2xpY2UodG9rZW5bM10sIHRva2VuWzVdKSwgc3ViUmVuZGVyKTtcblxuICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSBidWZmZXIgKz0gdmFsdWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ14nOlxuICAgICAgICB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcblxuICAgICAgICAvLyBVc2UgSmF2YVNjcmlwdCdzIGRlZmluaXRpb24gb2YgZmFsc3kuIEluY2x1ZGUgZW1wdHkgYXJyYXlzLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICAgICAgICBpZiAoIXZhbHVlIHx8IChpc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDApKSB7XG4gICAgICAgICAgYnVmZmVyICs9IHRoaXMucmVuZGVyVG9rZW5zKHRva2VuWzRdLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJz4nOlxuICAgICAgICBpZiAoIXBhcnRpYWxzKSBjb250aW51ZTtcbiAgICAgICAgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgICAgICAgaWYgKHZhbHVlICE9IG51bGwpIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0aGlzLnBhcnNlKHZhbHVlKSwgY29udGV4dCwgcGFydGlhbHMsIHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcmJzpcbiAgICAgICAgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG4gICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSBidWZmZXIgKz0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbmFtZSc6XG4gICAgICAgIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkgYnVmZmVyICs9IG11c3RhY2hlLmVzY2FwZSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGV4dCc6XG4gICAgICAgIGJ1ZmZlciArPSB0b2tlblsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGJ1ZmZlcjtcbiAgfTtcblxuICBtdXN0YWNoZS5uYW1lID0gXCJtdXN0YWNoZS5qc1wiO1xuICBtdXN0YWNoZS52ZXJzaW9uID0gXCIwLjguMVwiO1xuICBtdXN0YWNoZS50YWdzID0gWyBcInt7XCIsIFwifX1cIiBdO1xuXG4gIC8vIEFsbCBoaWdoLWxldmVsIG11c3RhY2hlLiogZnVuY3Rpb25zIHVzZSB0aGlzIHdyaXRlci5cbiAgdmFyIGRlZmF1bHRXcml0ZXIgPSBuZXcgV3JpdGVyKCk7XG5cbiAgLyoqXG4gICAqIENsZWFycyBhbGwgY2FjaGVkIHRlbXBsYXRlcyBpbiB0aGUgZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkZWZhdWx0V3JpdGVyLmNsZWFyQ2FjaGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogUGFyc2VzIGFuZCBjYWNoZXMgdGhlIGdpdmVuIHRlbXBsYXRlIGluIHRoZSBkZWZhdWx0IHdyaXRlciBhbmQgcmV0dXJucyB0aGVcbiAgICogYXJyYXkgb2YgdG9rZW5zIGl0IGNvbnRhaW5zLiBEb2luZyB0aGlzIGFoZWFkIG9mIHRpbWUgYXZvaWRzIHRoZSBuZWVkIHRvXG4gICAqIHBhcnNlIHRlbXBsYXRlcyBvbiB0aGUgZmx5IGFzIHRoZXkgYXJlIHJlbmRlcmVkLlxuICAgKi9cbiAgbXVzdGFjaGUucGFyc2UgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHRhZ3MpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5wYXJzZSh0ZW1wbGF0ZSwgdGFncyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlbmRlcnMgdGhlIGB0ZW1wbGF0ZWAgd2l0aCB0aGUgZ2l2ZW4gYHZpZXdgIGFuZCBgcGFydGlhbHNgIHVzaW5nIHRoZVxuICAgKiBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLnJlbmRlciA9IGZ1bmN0aW9uICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC40LnguXG4gIG11c3RhY2hlLnRvX2h0bWwgPSBmdW5jdGlvbiAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzLCBzZW5kKSB7XG4gICAgdmFyIHJlc3VsdCA9IG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VuZCkpIHtcbiAgICAgIHNlbmQocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbiAgbXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuICAvLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG4gIG11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xuICBtdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbiAgbXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG59KSk7XG4iLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjkuMTggLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMTQsIEp1ZXJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tLyAmIGh0dHA6Ly9qb25hdGhhbnB1Y2tleS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGF0ZTogTW9uIEFwciA3IDExOjI0OjM4IDIwMTQgKzAyMDBcbiAqXG4gKioqXG4gKlxuICogU3RyYXBzLmpzIC0gQ2xhc3MgaW5oZXJpdGFuY2UgbGlicmFyeSB3aXRoIHN1cHBvcnQgZm9yIGJlYW4tc3R5bGUgYWNjZXNzb3JzXG4gKlxuICogQ29weXJpZ2h0IChjKSAyMDA2IC0gMjAxMyBKdWVyZyBMZWhuaVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS9cbiAqXG4gKiBEaXN0cmlidXRlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuXG4gKlxuICoqKlxuICpcbiAqIEFjb3JuLmpzXG4gKiBodHRwOi8vbWFyaWpuaGF2ZXJiZWtlLm5sL2Fjb3JuL1xuICpcbiAqIEFjb3JuIGlzIGEgdGlueSwgZmFzdCBKYXZhU2NyaXB0IHBhcnNlciB3cml0dGVuIGluIEphdmFTY3JpcHQsXG4gKiBjcmVhdGVkIGJ5IE1hcmlqbiBIYXZlcmJla2UgYW5kIHJlbGVhc2VkIHVuZGVyIGFuIE1JVCBsaWNlbnNlLlxuICpcbiAqL1xuXG52YXIgcGFwZXIgPSBuZXcgZnVuY3Rpb24odW5kZWZpbmVkKSB7XG5cbnZhciBCYXNlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgaGlkZGVuID0gL14oc3RhdGljc3xlbnVtZXJhYmxlfGJlYW5zfHByZXNlcnZlKSQvLFxuXG5cdFx0Zm9yRWFjaCA9IFtdLmZvckVhY2ggfHwgZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRmb3JJbiA9IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gdGhpcylcblx0XHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoaSkpXG5cdFx0XHRcdFx0aXRlci5jYWxsKGJpbmQsIHRoaXNbaV0sIGksIHRoaXMpO1xuXHRcdH0sXG5cblx0XHRjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uKHByb3RvKSB7XG5cdFx0XHRyZXR1cm4geyBfX3Byb3RvX186IHByb3RvIH07XG5cdFx0fSxcblxuXHRcdGRlc2NyaWJlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciB8fCBmdW5jdGlvbihvYmosIG5hbWUpIHtcblx0XHRcdHZhciBnZXQgPSBvYmouX19sb29rdXBHZXR0ZXJfXyAmJiBvYmouX19sb29rdXBHZXR0ZXJfXyhuYW1lKTtcblx0XHRcdHJldHVybiBnZXRcblx0XHRcdFx0XHQ/IHsgZ2V0OiBnZXQsIHNldDogb2JqLl9fbG9va3VwU2V0dGVyX18obmFtZSksXG5cdFx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUgfVxuXHRcdFx0XHRcdDogb2JqLmhhc093blByb3BlcnR5KG5hbWUpXG5cdFx0XHRcdFx0XHQ/IHsgdmFsdWU6IG9ialtuYW1lXSwgZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdF9kZWZpbmUgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgfHwgZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRpZiAoKGRlc2MuZ2V0IHx8IGRlc2Muc2V0KSAmJiBvYmouX19kZWZpbmVHZXR0ZXJfXykge1xuXHRcdFx0XHRpZiAoZGVzYy5nZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lR2V0dGVyX18obmFtZSwgZGVzYy5nZXQpO1xuXHRcdFx0XHRpZiAoZGVzYy5zZXQpXG5cdFx0XHRcdFx0b2JqLl9fZGVmaW5lU2V0dGVyX18obmFtZSwgZGVzYy5zZXQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2JqW25hbWVdID0gZGVzYy52YWx1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdGRlZmluZSA9IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0ZGVsZXRlIG9ialtuYW1lXTtcblx0XHRcdHJldHVybiBfZGVmaW5lKG9iaiwgbmFtZSwgZGVzYyk7XG5cdFx0fTtcblxuXHRmdW5jdGlvbiBpbmplY3QoZGVzdCwgc3JjLCBlbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpIHtcblx0XHR2YXIgYmVhbnNOYW1lcyA9IHt9O1xuXG5cdFx0ZnVuY3Rpb24gZmllbGQobmFtZSwgdmFsKSB7XG5cdFx0XHR2YWwgPSB2YWwgfHwgKHZhbCA9IGRlc2NyaWJlKHNyYywgbmFtZSkpXG5cdFx0XHRcdFx0JiYgKHZhbC5nZXQgPyB2YWwgOiB2YWwudmFsdWUpO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbFswXSA9PT0gJyMnKVxuXHRcdFx0XHR2YWwgPSBkZXN0W3ZhbC5zdWJzdHJpbmcoMSldIHx8IHZhbDtcblx0XHRcdHZhciBpc0Z1bmMgPSB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nLFxuXHRcdFx0XHRyZXMgPSB2YWwsXG5cdFx0XHRcdHByZXYgPSBwcmVzZXJ2ZSB8fCBpc0Z1bmNcblx0XHRcdFx0XHRcdD8gKHZhbCAmJiB2YWwuZ2V0ID8gbmFtZSBpbiBkZXN0IDogZGVzdFtuYW1lXSlcblx0XHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdFx0YmVhbjtcblx0XHRcdGlmICghcHJlc2VydmUgfHwgIXByZXYpIHtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBwcmV2KVxuXHRcdFx0XHRcdHZhbC5iYXNlID0gcHJldjtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBiZWFucyAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIChiZWFuID0gbmFtZS5tYXRjaCgvXihbZ3NdZXR8aXMpKChbQS1aXSkoLiopKSQvKSkpXG5cdFx0XHRcdFx0YmVhbnNOYW1lc1tiZWFuWzNdLnRvTG93ZXJDYXNlKCkgKyBiZWFuWzRdXSA9IGJlYW5bMl07XG5cdFx0XHRcdGlmICghcmVzIHx8IGlzRnVuYyB8fCAhcmVzLmdldCB8fCB0eXBlb2YgcmVzLmdldCAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0fHwgIUJhc2UuaXNQbGFpbk9iamVjdChyZXMpKVxuXHRcdFx0XHRcdHJlcyA9IHsgdmFsdWU6IHJlcywgd3JpdGFibGU6IHRydWUgfTtcblx0XHRcdFx0aWYgKChkZXNjcmliZShkZXN0LCBuYW1lKVxuXHRcdFx0XHRcdFx0fHwgeyBjb25maWd1cmFibGU6IHRydWUgfSkuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0cmVzLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0cmVzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmluZShkZXN0LCBuYW1lLCByZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3JjKSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIHNyYykge1xuXHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KG5hbWUpICYmICFoaWRkZW4udGVzdChuYW1lKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIG5hbWUgaW4gYmVhbnNOYW1lcykge1xuXHRcdFx0XHR2YXIgcGFydCA9IGJlYW5zTmFtZXNbbmFtZV0sXG5cdFx0XHRcdFx0c2V0ID0gZGVzdFsnc2V0JyArIHBhcnRdLFxuXHRcdFx0XHRcdGdldCA9IGRlc3RbJ2dldCcgKyBwYXJ0XSB8fCBzZXQgJiYgZGVzdFsnaXMnICsgcGFydF07XG5cdFx0XHRcdGlmIChnZXQgJiYgKGJlYW5zID09PSB0cnVlIHx8IGdldC5sZW5ndGggPT09IDApKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUsIHsgZ2V0OiBnZXQsIHNldDogc2V0IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBiaW5kKSB7XG5cdFx0aWYgKG9iailcblx0XHRcdCgnbGVuZ3RoJyBpbiBvYmogJiYgIW9iai5nZXRMZW5ndGhcblx0XHRcdFx0XHQmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PT0gJ251bWJlcidcblx0XHRcdFx0PyBmb3JFYWNoXG5cdFx0XHRcdDogZm9ySW4pLmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuXHRcdHJldHVybiBiaW5kO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0KG9iaiwgcHJvcHMpIHtcblx0XHRmb3IgKHZhciBpIGluIHByb3BzKVxuXHRcdFx0aWYgKHByb3BzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRvYmpbaV0gPSBwcm9wc1tpXTtcblx0XHRyZXR1cm4gb2JqO1xuXHR9XG5cblx0cmV0dXJuIGluamVjdChmdW5jdGlvbiBCYXNlKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHNldCh0aGlzLCBhcmd1bWVudHNbaV0pO1xuXHR9LCB7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbihzcmMpIHtcblx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0dmFyIHN0YXRpY3MgPSBzcmMuc3RhdGljcyA9PT0gdHJ1ZSA/IHNyYyA6IHNyYy5zdGF0aWNzLFxuXHRcdFx0XHRcdGJlYW5zID0gc3JjLmJlYW5zLFxuXHRcdFx0XHRcdHByZXNlcnZlID0gc3JjLnByZXNlcnZlO1xuXHRcdFx0XHRpZiAoc3RhdGljcyAhPT0gc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLnByb3RvdHlwZSwgc3JjLCBzcmMuZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdFx0aW5qZWN0KHRoaXMsIHN0YXRpY3MsIHRydWUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuaW5qZWN0KGFyZ3VtZW50c1tpXSk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBiYXNlID0gdGhpcyxcblx0XHRcdFx0Y3Rvcjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKGN0b3IgPSBhcmd1bWVudHNbaV0uaW5pdGlhbGl6ZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0Y3Rvci5wcm90b3R5cGUgPSBjcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0Y3Rvci5iYXNlID0gYmFzZTtcblx0XHRcdGRlZmluZShjdG9yLnByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPyB0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpIDogY3Rvcjtcblx0XHR9XG5cdH0sIHRydWUpLmluamVjdCh7XG5cdFx0aW5qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldO1xuXHRcdFx0XHRpZiAoc3JjKVxuXHRcdFx0XHRcdGluamVjdCh0aGlzLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBzcmMuYmVhbnMsIHNyYy5wcmVzZXJ2ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZXMgPSBjcmVhdGUodGhpcyk7XG5cdFx0XHRyZXR1cm4gcmVzLmluamVjdC5hcHBseShyZXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdGVhY2g6IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdHJldHVybiBlYWNoKHRoaXMsIGl0ZXIsIGJpbmQpO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGVhY2g6IGVhY2gsXG5cdFx0XHRjcmVhdGU6IGNyZWF0ZSxcblx0XHRcdGRlZmluZTogZGVmaW5lLFxuXHRcdFx0ZGVzY3JpYmU6IGRlc2NyaWJlLFxuXHRcdFx0c2V0OiBzZXQsXG5cblx0XHRcdGNsb25lOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0cmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG5cdFx0XHRcdHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZVxuXHRcdFx0XHRcdFx0fHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGlmIChhcmd1bWVudHNbaV0gIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHJldHVybiBhcmd1bWVudHNbaV07XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn07XG5cbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJylcblx0bW9kdWxlLmV4cG9ydHMgPSBCYXNlO1xuXG5pZiAoIUFycmF5LmlzQXJyYXkpIHtcblx0QXJyYXkuaXNBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcblx0fTtcbn1cblxuaWYgKCFkb2N1bWVudC5oZWFkKSB7XG5cdGRvY3VtZW50LmhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xufVxuXG5CYXNlLmluamVjdCh7XG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQgIT0gbnVsbFxuXHRcdFx0PyAgKHRoaXMuX2NsYXNzIHx8ICdPYmplY3QnKSArICh0aGlzLl9uYW1lXG5cdFx0XHRcdD8gXCIgJ1wiICsgdGhpcy5fbmFtZSArIFwiJ1wiXG5cdFx0XHRcdDogJyBAJyArIHRoaXMuX2lkKVxuXHRcdFx0OiAneyAnICsgQmFzZS5lYWNoKHRoaXMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0aWYgKCEvXl8vLnRlc3Qoa2V5KSkge1xuXHRcdFx0XHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuXHRcdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsgKHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHRcdD8gRm9ybWF0dGVyLmluc3RhbmNlLm51bWJlcih2YWx1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnc3RyaW5nJyA/IFwiJ1wiICsgdmFsdWUgKyBcIidcIiA6IHZhbHVlKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0sIFtdKS5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRleHBvcnRKU09OOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXhwb3J0SlNPTih0aGlzLCBvcHRpb25zKTtcblx0fSxcblxuXHR0b0pTT046IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzKTtcblx0fSxcblxuXHRfc2V0OiBmdW5jdGlvbihwcm9wcywgZXhjbHVkZSkge1xuXHRcdGlmIChwcm9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3QocHJvcHMpKSB7XG5cdFx0XHR2YXIgb3JpZyA9IHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHM7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gb3JpZykge1xuXHRcdFx0XHRpZiAoa2V5IGluIHRoaXMgJiYgb3JpZy5oYXNPd25Qcm9wZXJ0eShrZXkpXG5cdFx0XHRcdFx0XHQmJiAoIWV4Y2x1ZGUgfHwgIWV4Y2x1ZGVba2V5XSkpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwcm9wc1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cblx0XHRleHBvcnRzOiB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlIFxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRcdGZ1bmN0aW9uIGNoZWNrS2V5cyhvMSwgbzIpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvMSlcblx0XHRcdFx0XHRpZiAobzEuaGFzT3duUHJvcGVydHkoaSkgJiYgIW8yLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHRpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoxLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtpXSwgb2JqMltpXSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqMSAmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCdcblx0XHRcdFx0XHQmJiBvYmoyICYmIHR5cGVvZiBvYmoyID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRpZiAoIWNoZWNrS2V5cyhvYmoxLCBvYmoyKSB8fCAhY2hlY2tLZXlzKG9iajIsIG9iajEpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdFx0aWYgKG9iajEuaGFzT3duUHJvcGVydHkoaSlcblx0XHRcdFx0XHRcdFx0JiYgIUJhc2UuZXF1YWxzKG9iajFbaV0sIG9iajJbaV0pKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0sXG5cblx0XHRyZWFkOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG5cdFx0XHRpZiAodGhpcyA9PT0gQmFzZSkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLnBlZWsobGlzdCwgc3RhcnQpO1xuXHRcdFx0XHRsaXN0Ll9faW5kZXgrKztcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHByb3RvID0gdGhpcy5wcm90b3R5cGUsXG5cdFx0XHRcdHJlYWRJbmRleCA9IHByb3RvLl9yZWFkSW5kZXgsXG5cdFx0XHRcdGluZGV4ID0gc3RhcnQgfHwgcmVhZEluZGV4ICYmIGxpc3QuX19pbmRleCB8fCAwO1xuXHRcdFx0aWYgKCFsZW5ndGgpXG5cdFx0XHRcdGxlbmd0aCA9IGxpc3QubGVuZ3RoIC0gaW5kZXg7XG5cdFx0XHR2YXIgb2JqID0gbGlzdFtpbmRleF07XG5cdFx0XHRpZiAob2JqIGluc3RhbmNlb2YgdGhpc1xuXHRcdFx0XHR8fCBvcHRpb25zICYmIG9wdGlvbnMucmVhZE51bGwgJiYgb2JqID09IG51bGwgJiYgbGVuZ3RoIDw9IDEpIHtcblx0XHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0XHRsaXN0Ll9faW5kZXggPSBpbmRleCArIDE7XG5cdFx0XHRcdHJldHVybiBvYmogJiYgb3B0aW9ucyAmJiBvcHRpb25zLmNsb25lID8gb2JqLmNsb25lKCkgOiBvYmo7XG5cdFx0XHR9XG5cdFx0XHRvYmogPSBCYXNlLmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRvYmouX19yZWFkID0gdHJ1ZTtcblx0XHRcdG9iaiA9IG9iai5pbml0aWFsaXplLmFwcGx5KG9iaiwgaW5kZXggPiAwIHx8IGxlbmd0aCA8IGxpc3QubGVuZ3RoXG5cdFx0XHRcdD8gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobGlzdCwgaW5kZXgsIGluZGV4ICsgbGVuZ3RoKVxuXHRcdFx0XHQ6IGxpc3QpIHx8IG9iajtcblx0XHRcdGlmIChyZWFkSW5kZXgpIHtcblx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyBvYmouX19yZWFkO1xuXHRcdFx0XHRvYmouX19yZWFkID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0cGVlazogZnVuY3Rpb24obGlzdCwgc3RhcnQpIHtcblx0XHRcdHJldHVybiBsaXN0W2xpc3QuX19pbmRleCA9IHN0YXJ0IHx8IGxpc3QuX19pbmRleCB8fCAwXTtcblx0XHR9LFxuXG5cdFx0cmVtYWluOiBmdW5jdGlvbihsaXN0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdC5sZW5ndGggLSAobGlzdC5fX2luZGV4IHx8IDApO1xuXHRcdH0sXG5cblx0XHRyZWFkQWxsOiBmdW5jdGlvbihsaXN0LCBzdGFydCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIHJlcyA9IFtdLFxuXHRcdFx0XHRlbnRyeTtcblx0XHRcdGZvciAodmFyIGkgPSBzdGFydCB8fCAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0cmVzLnB1c2goQXJyYXkuaXNBcnJheShlbnRyeSA9IGxpc3RbaV0pXG5cdFx0XHRcdFx0XHQ/IHRoaXMucmVhZChlbnRyeSwgMCwgb3B0aW9ucylcblx0XHRcdFx0XHRcdDogdGhpcy5yZWFkKGxpc3QsIGksIG9wdGlvbnMsIDEpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXM7XG5cdFx0fSxcblxuXHRcdHJlYWROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0dmFyIHZhbHVlID0gdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKSxcblx0XHRcdFx0aGFzT2JqZWN0ID0gdmFsdWUgIT09IHVuZGVmaW5lZDtcblx0XHRcdGlmIChoYXNPYmplY3QpIHtcblx0XHRcdFx0dmFyIGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQ7XG5cdFx0XHRcdGlmICghZmlsdGVyZWQpIHtcblx0XHRcdFx0XHRmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkID0gQmFzZS5jcmVhdGUobGlzdFswXSk7XG5cdFx0XHRcdFx0ZmlsdGVyZWQuX2ZpbHRlcmluZyA9IGxpc3RbMF07XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmlsdGVyZWRbbmFtZV0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5yZWFkKGhhc09iamVjdCA/IFt2YWx1ZV0gOiBsaXN0LCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKTtcblx0XHR9LFxuXG5cdFx0Z2V0TmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHZhciBhcmcgPSBsaXN0WzBdO1xuXHRcdFx0aWYgKGxpc3QuX2hhc09iamVjdCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRsaXN0Ll9oYXNPYmplY3QgPSBsaXN0Lmxlbmd0aCA9PT0gMSAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QpXG5cdFx0XHRcdHJldHVybiBuYW1lID8gYXJnW25hbWVdIDogbGlzdC5fZmlsdGVyZWQgfHwgYXJnO1xuXHRcdH0sXG5cblx0XHRoYXNOYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuICEhdGhpcy5nZXROYW1lZChsaXN0LCBuYW1lKTtcblx0XHR9LFxuXG5cdFx0aXNQbGFpblZhbHVlOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdHJldHVybiB0aGlzLmlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iaik7XG5cdFx0fSxcblxuXHRcdHNlcmlhbGl6ZTogZnVuY3Rpb24ob2JqLCBvcHRpb25zLCBjb21wYWN0LCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdFx0dmFyIHJvb3QgPSAhZGljdGlvbmFyeSxcblx0XHRcdFx0cmVzO1xuXHRcdFx0aWYgKHJvb3QpIHtcblx0XHRcdFx0b3B0aW9ucy5mb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdFx0ZGljdGlvbmFyeSA9IHtcblx0XHRcdFx0XHRsZW5ndGg6IDAsXG5cdFx0XHRcdFx0ZGVmaW5pdGlvbnM6IHt9LFxuXHRcdFx0XHRcdHJlZmVyZW5jZXM6IHt9LFxuXHRcdFx0XHRcdGFkZDogZnVuY3Rpb24oaXRlbSwgY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHR2YXIgaWQgPSAnIycgKyBpdGVtLl9pZCxcblx0XHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXTtcblx0XHRcdFx0XHRcdGlmICghcmVmKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoKys7XG5cdFx0XHRcdFx0XHRcdHZhciByZXMgPSBjcmVhdGUuY2FsbChpdGVtKSxcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gaXRlbS5fY2xhc3M7XG5cdFx0XHRcdFx0XHRcdGlmIChuYW1lICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdFx0XHRcdFx0dGhpcy5kZWZpbml0aW9uc1tpZF0gPSByZXM7XG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF0gPSBbaWRdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHJlZjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRpZiAob2JqICYmIG9iai5fc2VyaWFsaXplKSB7XG5cdFx0XHRcdHJlcyA9IG9iai5fc2VyaWFsaXplKG9wdGlvbnMsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR2YXIgbmFtZSA9IG9iai5fY2xhc3M7XG5cdFx0XHRcdGlmIChuYW1lICYmICFjb21wYWN0ICYmICFyZXMuX2NvbXBhY3QgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdHJlcy51bnNoaWZ0KG5hbWUpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXNbaV0gPSBCYXNlLnNlcmlhbGl6ZShvYmpbaV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHRpZiAoY29tcGFjdClcblx0XHRcdFx0XHRyZXMuX2NvbXBhY3QgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3Qob2JqKSkge1xuXHRcdFx0XHRyZXMgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIgaSBpbiBvYmopXG5cdFx0XHRcdFx0aWYgKG9iai5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ251bWJlcicpIHtcblx0XHRcdFx0cmVzID0gb3B0aW9ucy5mb3JtYXR0ZXIubnVtYmVyKG9iaiwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVzID0gb2JqO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJvb3QgJiYgZGljdGlvbmFyeS5sZW5ndGggPiAwXG5cdFx0XHRcdFx0PyBbWydkaWN0aW9uYXJ5JywgZGljdGlvbmFyeS5kZWZpbml0aW9uc10sIHJlc11cblx0XHRcdFx0XHQ6IHJlcztcblx0XHR9LFxuXG5cdFx0ZGVzZXJpYWxpemU6IGZ1bmN0aW9uKGpzb24sIGNyZWF0ZSwgX2RhdGEpIHtcblx0XHRcdHZhciByZXMgPSBqc29uLFxuXHRcdFx0XHRpc1Jvb3QgPSAhX2RhdGE7XG5cdFx0XHRfZGF0YSA9IF9kYXRhIHx8IHt9O1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoanNvbikpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSBqc29uWzBdLFxuXHRcdFx0XHRcdGlzRGljdGlvbmFyeSA9IHR5cGUgPT09ICdkaWN0aW9uYXJ5Jztcblx0XHRcdFx0aWYgKCFpc0RpY3Rpb25hcnkpIHtcblx0XHRcdFx0XHRpZiAoX2RhdGEuZGljdGlvbmFyeSAmJiBqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSlcblx0XHRcdFx0XHRcdHJldHVybiBfZGF0YS5kaWN0aW9uYXJ5W3R5cGVdO1xuXHRcdFx0XHRcdHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEpKTtcblx0XHRcdFx0aWYgKGlzRGljdGlvbmFyeSkge1xuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXNbMF07XG5cdFx0XHRcdH0gZWxzZSBpZiAodHlwZSkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHJlcyA9IGNyZWF0ZSh0eXBlLCBhcmdzLCBpc1Jvb3QpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBCYXNlLmNyZWF0ZSh0eXBlLnByb3RvdHlwZSk7XG5cdFx0XHRcdFx0XHR0eXBlLmFwcGx5KHJlcywgYXJncyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChqc29uKSkge1xuXHRcdFx0XHRyZXMgPSB7fTtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIGpzb24pXG5cdFx0XHRcdFx0cmVzW2tleV0gPSBCYXNlLmRlc2VyaWFsaXplKGpzb25ba2V5XSwgY3JlYXRlLCBfZGF0YSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRleHBvcnRKU09OOiBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcblx0XHRcdHZhciBqc29uID0gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zKTtcblx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPT09IGZhbHNlXG5cdFx0XHRcdFx0PyBqc29uXG5cdFx0XHRcdFx0OiBKU09OLnN0cmluZ2lmeShqc29uKTtcblx0XHR9LFxuXG5cdFx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbiwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5kZXNlcmlhbGl6ZShcblx0XHRcdFx0XHR0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbixcblx0XHRcdFx0XHRmdW5jdGlvbih0eXBlLCBhcmdzLCBpc1Jvb3QpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG5cdFx0XHRcdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKSxcblx0XHRcdFx0XHRcdFx0aXNUYXJnZXQgPSBvYmogPT09IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmICghaXNSb290ICYmIGFyZ3MubGVuZ3RoID09PSAxICYmIG9iaiBpbnN0YW5jZW9mIEl0ZW1cblx0XHRcdFx0XHRcdFx0XHQmJiAoIShvYmogaW5zdGFuY2VvZiBMYXllcikgfHwgaXNUYXJnZXQpKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBhcmcgPSBhcmdzWzBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGFyZykpXG5cdFx0XHRcdFx0XHRcdFx0YXJnLmluc2VydCA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShvYmosIGFyZ3MpO1xuXHRcdFx0XHRcdFx0aWYgKGlzVGFyZ2V0KVxuXHRcdFx0XHRcdFx0XHR0YXJnZXQgPSBudWxsO1xuXHRcdFx0XHRcdFx0cmV0dXJuIG9iajtcblx0XHRcdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0c3BsaWNlOiBmdW5jdGlvbihsaXN0LCBpdGVtcywgaW5kZXgsIHJlbW92ZSkge1xuXHRcdFx0dmFyIGFtb3VudCA9IGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCxcblx0XHRcdFx0YXBwZW5kID0gaW5kZXggPT09IHVuZGVmaW5lZDtcblx0XHRcdGluZGV4ID0gYXBwZW5kID8gbGlzdC5sZW5ndGggOiBpbmRleDtcblx0XHRcdGlmIChpbmRleCA+IGxpc3QubGVuZ3RoKVxuXHRcdFx0XHRpbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKylcblx0XHRcdFx0aXRlbXNbaV0uX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKGFwcGVuZCkge1xuXHRcdFx0XHRsaXN0LnB1c2guYXBwbHkobGlzdCwgaXRlbXMpO1xuXHRcdFx0XHRyZXR1cm4gW107XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYXJncyA9IFtpbmRleCwgcmVtb3ZlXTtcblx0XHRcdFx0aWYgKGl0ZW1zKVxuXHRcdFx0XHRcdGFyZ3MucHVzaC5hcHBseShhcmdzLCBpdGVtcyk7XG5cdFx0XHRcdHZhciByZW1vdmVkID0gbGlzdC5zcGxpY2UuYXBwbHkobGlzdCwgYXJncyk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcmVtb3ZlZC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVtb3ZlZFtpXS5faW5kZXggPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGxpc3RbaV0uX2luZGV4ID0gaTtcblx0XHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNhcGl0YWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC9cXGJbYS16XS9nLCBmdW5jdGlvbihtYXRjaCkge1xuXHRcdFx0XHRyZXR1cm4gbWF0Y2gudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRjYW1lbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLy0oLikvZywgZnVuY3Rpb24oYWxsLCBjaHIpIHtcblx0XHRcdFx0cmV0dXJuIGNoci50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGh5cGhlbmF0ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoLyhbYS16XSkoW0EtWl0pL2csICckMS0kMicpLnRvTG93ZXJDYXNlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIENhbGxiYWNrID0ge1xuXHRhdHRhY2g6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLmF0dGFjaChrZXksIHZhbHVlKTtcblx0XHRcdH0sIHRoaXMpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdO1xuXHRcdGlmIChlbnRyeSkge1xuXHRcdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVycyB8fCB7fTtcblx0XHRcdGhhbmRsZXJzID0gaGFuZGxlcnNbdHlwZV0gPSBoYW5kbGVyc1t0eXBlXSB8fCBbXTtcblx0XHRcdGlmIChoYW5kbGVycy5pbmRleE9mKGZ1bmMpID09IC0xKSB7IFxuXHRcdFx0XHRoYW5kbGVycy5wdXNoKGZ1bmMpO1xuXHRcdFx0XHRpZiAoZW50cnkuaW5zdGFsbCAmJiBoYW5kbGVycy5sZW5ndGggPT0gMSlcblx0XHRcdFx0XHRlbnRyeS5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGRldGFjaDogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMuZGV0YWNoKGtleSwgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBlbnRyeSA9IHRoaXMuX2V2ZW50VHlwZXNbdHlwZV0sXG5cdFx0XHRoYW5kbGVycyA9IHRoaXMuX2hhbmRsZXJzICYmIHRoaXMuX2hhbmRsZXJzW3R5cGVdLFxuXHRcdFx0aW5kZXg7XG5cdFx0aWYgKGVudHJ5ICYmIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoIWZ1bmMgfHwgKGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihmdW5jKSkgIT0gLTFcblx0XHRcdFx0XHQmJiBoYW5kbGVycy5sZW5ndGggPT0gMSkge1xuXHRcdFx0XHRpZiAoZW50cnkudW5pbnN0YWxsKVxuXHRcdFx0XHRcdGVudHJ5LnVuaW5zdGFsbC5jYWxsKHRoaXMsIHR5cGUpO1xuXHRcdFx0XHRkZWxldGUgdGhpcy5faGFuZGxlcnNbdHlwZV07XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHR0aGlzLmF0dGFjaCh0eXBlLCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMuZGV0YWNoKHR5cGUsIGZ1bmMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGZpcmU6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5faGFuZGxlcnMgJiYgdGhpcy5faGFuZGxlcnNbdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVycylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbaV0uYXBwbHkodGhhdCwgYXJncykgPT09IGZhbHNlXG5cdFx0XHRcdFx0JiYgZXZlbnQgJiYgZXZlbnQuc3RvcCkge1xuXHRcdFx0XHRldmVudC5zdG9wKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRyZXNwb25kczogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiAhISh0aGlzLl9oYW5kbGVycyAmJiB0aGlzLl9oYW5kbGVyc1t0eXBlXSk7XG5cdH0sXG5cblx0b246ICcjYXR0YWNoJyxcblx0b2ZmOiAnI2RldGFjaCcsXG5cdHRyaWdnZXI6ICcjZmlyZScsXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uKGluc3RhbGwpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9oYW5kbGVycyxcblx0XHRcdGtleSA9IGluc3RhbGwgPyAnaW5zdGFsbCcgOiAndW5pbnN0YWxsJztcblx0XHRmb3IgKHZhciB0eXBlIGluIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9ldmVudFR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdGZ1bmMgPSBlbnRyeVtrZXldO1xuXHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRmdW5jLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uIGluamVjdCgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3JjID0gYXJndW1lbnRzW2ldLFxuXHRcdFx0XHRcdGV2ZW50cyA9IHNyYy5fZXZlbnRzO1xuXHRcdFx0XHRpZiAoZXZlbnRzKSB7XG5cdFx0XHRcdFx0dmFyIHR5cGVzID0ge307XG5cdFx0XHRcdFx0QmFzZS5lYWNoKGV2ZW50cywgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHRcdFx0XHRcdFx0dmFyIGlzU3RyaW5nID0gdHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJyxcblx0XHRcdFx0XHRcdFx0bmFtZSA9IGlzU3RyaW5nID8gZW50cnkgOiBrZXksXG5cdFx0XHRcdFx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdFx0XHRcdHR5cGUgPSBuYW1lLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0dHlwZXNbdHlwZV0gPSBpc1N0cmluZyA/IHt9IDogZW50cnk7XG5cdFx0XHRcdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHRcdFx0XHRcdHNyY1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdHNyY1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24oZnVuYykge1xuXHRcdFx0XHRcdFx0XHR2YXIgcHJldiA9IHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0XHRcdGlmIChwcmV2KVxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuZGV0YWNoKHR5cGUsIHByZXYpO1xuXHRcdFx0XHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dGFjaCh0eXBlLCBmdW5jKTtcblx0XHRcdFx0XHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmM7XG5cdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdHNyYy5fZXZlbnRUeXBlcyA9IHR5cGVzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluamVjdC5iYXNlLmNhbGwodGhpcywgc3JjKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhcGVyU2NvcGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhcGVyU2NvcGUoc2NyaXB0KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSB7XG5cdFx0XHRhcHBseU1hdHJpeDogdHJ1ZSxcblx0XHRcdGhhbmRsZVNpemU6IDQsXG5cdFx0XHRoaXRUb2xlcmFuY2U6IDBcblx0XHR9O1xuXHRcdHRoaXMucHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5wcm9qZWN0cyA9IFtdO1xuXHRcdHRoaXMudG9vbHMgPSBbXTtcblx0XHR0aGlzLnBhbGV0dGVzID0gW107XG5cdFx0dGhpcy5faWQgPSBzY3JpcHQgJiYgKHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ2lkJykgfHwgc2NyaXB0LnNyYylcblx0XHRcdFx0fHwgKCdwYXBlcnNjb3BlLScgKyAoUGFwZXJTY29wZS5faWQrKykpO1xuXHRcdGlmIChzY3JpcHQpXG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkKTtcblx0XHRQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcblx0XHRpZiAoIXRoaXMuc3VwcG9ydCkge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdFx0XHRQYXBlclNjb3BlLnByb3RvdHlwZS5zdXBwb3J0ID0ge1xuXHRcdFx0XHRuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuXHRcdFx0XHRuYXRpdmVCbGVuZE1vZGVzOiBCbGVuZE1vZGUubmF0aXZlTW9kZXNcblx0XHRcdH07XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0fVxuXHR9LFxuXG5cdHZlcnNpb246ICcwLjkuMTgnLFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByb2plY3QgJiYgdGhpcy5wcm9qZWN0LmdldFZpZXcoKTtcblx0fSxcblxuXHRnZXRQYXBlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXhlY3V0ZTogZnVuY3Rpb24oY29kZSkge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcyk7XG5cdFx0Vmlldy51cGRhdGVGb2N1cygpO1xuXHR9LFxuXG5cdGluc3RhbGw6IGZ1bmN0aW9uKHNjb3BlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0QmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXRba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMpXG5cdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSlcblx0XHRcdFx0c2NvcGVba2V5XSA9IHRoaXNba2V5XTtcblx0fSxcblxuXHRzZXR1cDogZnVuY3Rpb24oY2FudmFzKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGNhbnZhcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YWN0aXZhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucHJvamVjdHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnByb2plY3RzW2ldLnJlbW92ZSgpO1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnRvb2xzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy50b29sc1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5wYWxldHRlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMucGFsZXR0ZXNbaV0ucmVtb3ZlKCk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmNsZWFyKCk7XG5cdFx0ZGVsZXRlIFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF07XG5cdH0sXG5cblx0c3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRcdGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZShuYW1lKSB7XG5cdFx0XHRuYW1lICs9ICdBdHRyaWJ1dGUnO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKGVsLCBhdHRyKSB7XG5cdFx0XHRcdHJldHVybiBlbFtuYW1lXShhdHRyKSB8fCBlbFtuYW1lXSgnZGF0YS1wYXBlci0nICsgYXR0cik7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRfc2NvcGVzOiB7fSxcblx0XHRcdF9pZDogMCxcblxuXHRcdFx0Z2V0OiBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRpZiAoaWQgJiYgaWQuZ2V0QXR0cmlidXRlKVxuXHRcdFx0XHRcdGlkID0gaWQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fc2NvcGVzW2lkXSB8fCBudWxsO1xuXHRcdFx0fSxcblxuXHRcdFx0Z2V0QXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2dldCcpLFxuXHRcdFx0aGFzQXR0cmlidXRlOiBoYW5kbGVBdHRyaWJ1dGUoJ2hhcycpXG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBQYXBlclNjb3BlSXRlbSA9IEJhc2UuZXh0ZW5kKENhbGxiYWNrLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcblx0XHR0aGlzLl9zY29wZSA9IHBhcGVyO1xuXHRcdHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG5cdFx0aWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKVxuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Njb3BlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcblx0XHRpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuXHRcdFx0cHJldi5maXJlKCdkZWFjdGl2YXRlJyk7XG5cdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG5cdFx0dGhpcy5maXJlKCdhY3RpdmF0ZScsIHByZXYpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9pbmRleCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0aWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcblx0XHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuXHRcdHRoaXMuX3Njb3BlID0gbnVsbDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDU7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXI7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdGNvcyA9IE1hdGguY29zLFxuXHRcdFBJID0gTWF0aC5QSSxcblx0XHRUT0xFUkFOQ0UgPSAxMGUtNixcblx0XHRFUFNJTE9OID0gMTBlLTEyO1xuXG5cdGZ1bmN0aW9uIHNldHVwUm9vdHMocm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHVuYm91bmQgPSBtaW4gPT09IHVuZGVmaW5lZCxcblx0XHRcdG1pbkUgPSBtaW4gLSBFUFNJTE9OLFxuXHRcdFx0bWF4RSA9IG1heCArIEVQU0lMT04sXG5cdFx0XHRjb3VudCA9IDA7XG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHJvb3QpIHtcblx0XHRcdGlmICh1bmJvdW5kIHx8IHJvb3QgPiBtaW5FICYmIHJvb3QgPCBtYXhFKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IHJvb3QgPCBtaW4gPyBtaW4gOiByb290ID4gbWF4ID8gbWF4IDogcm9vdDtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRUT0xFUkFOQ0U6IFRPTEVSQU5DRSxcblx0XHRFUFNJTE9OOiBFUFNJTE9OLFxuXHRcdEtBUFBBOiA0ICogKHNxcnQoMikgLSAxKSAvIDMsXG5cblx0XHRpc1plcm86IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0cmV0dXJuIGFicyh2YWwpIDw9IEVQU0lMT047XG5cdFx0fSxcblxuXHRcdGludGVncmF0ZTogZnVuY3Rpb24oZiwgYSwgYiwgbikge1xuXHRcdFx0dmFyIHggPSBhYnNjaXNzYXNbbiAtIDJdLFxuXHRcdFx0XHR3ID0gd2VpZ2h0c1tuIC0gMl0sXG5cdFx0XHRcdEEgPSAwLjUgKiAoYiAtIGEpLFxuXHRcdFx0XHRCID0gQSArIGEsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRtID0gKG4gKyAxKSA+PiAxLFxuXHRcdFx0XHRzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwOyBcblx0XHRcdHdoaWxlIChpIDwgbSkge1xuXHRcdFx0XHR2YXIgQXggPSBBICogeFtpXTtcblx0XHRcdFx0c3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEEgKiBzdW07XG5cdFx0fSxcblxuXHRcdGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZnggPSBmKHgpLFxuXHRcdFx0XHRcdGR4ID0gZnggLyBkZih4KSxcblx0XHRcdFx0XHRueCA9IHggLSBkeDtcblx0XHRcdFx0aWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0cmV0dXJuIG54O1xuXHRcdFx0XHRpZiAoZnggPiAwKSB7XG5cdFx0XHRcdFx0YiA9IHg7XG5cdFx0XHRcdFx0eCA9IG54IDw9IGEgPyAwLjUgKiAoYSArIGIpIDogbng7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHg7XG5cdFx0XHRcdFx0eCA9IG54ID49IGIgPyAwLjUgKiAoYSArIGIpIDogbng7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB4O1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgYWRkID0gc2V0dXBSb290cyhyb290cywgbWluLCBtYXgpO1xuXG5cdFx0XHRpZiAoYWJzKGEpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKGIpID49IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFkZCgtYyAvIGIpO1xuXHRcdFx0XHRyZXR1cm4gYWJzKGMpIDwgRVBTSUxPTiA/IC0xIDogMDsgXG5cdFx0XHR9XG5cdFx0XHR2YXIgcCA9IGIgLyAoMiAqIGEpO1xuXHRcdFx0dmFyIHEgPSBjIC8gYTtcblx0XHRcdHZhciBwMiA9IHAgKiBwO1xuXHRcdFx0aWYgKHAyIDwgcSAtIEVQU0lMT04pXG5cdFx0XHRcdHJldHVybiAwO1xuXHRcdFx0dmFyIHMgPSBwMiA+IHEgPyBzcXJ0KHAyIC0gcSkgOiAwLFxuXHRcdFx0XHRjb3VudCA9IGFkZChzIC0gcCk7XG5cdFx0XHRpZiAocyA+IDApXG5cdFx0XHRcdGNvdW50ID0gYWRkKC1zIC0gcCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pXG5cdFx0XHRcdHJldHVybiBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYiwgYywgZCwgcm9vdHMsIG1pbiwgbWF4KTtcblxuXHRcdFx0YiAvPSBhO1xuXHRcdFx0YyAvPSBhO1xuXHRcdFx0ZCAvPSBhO1xuXHRcdFx0dmFyIGFkZCA9IHNldHVwUm9vdHMocm9vdHMsIG1pbiwgbWF4KSxcblx0XHRcdFx0YmIgPSBiICogYixcblx0XHRcdFx0cCA9IChiYiAtIDMgKiBjKSAvIDksXG5cdFx0XHRcdHEgPSAoMiAqIGJiICogYiAtIDkgKiBiICogYyArIDI3ICogZCkgLyA1NCxcblx0XHRcdFx0cHBwID0gcCAqIHAgKiBwLFxuXHRcdFx0XHREID0gcSAqIHEgLSBwcHA7XG5cdFx0XHRiIC89IDM7XG5cdFx0XHRpZiAoYWJzKEQpIDwgRVBTSUxPTikge1xuXHRcdFx0XHRpZiAoYWJzKHEpIDwgRVBTSUxPTikgXG5cdFx0XHRcdFx0cmV0dXJuIGFkZCgtYik7XG5cdFx0XHRcdHZhciBzcXAgPSBzcXJ0KHApLFxuXHRcdFx0XHRcdHNucSA9IHEgPiAwID8gMSA6IC0xO1xuXHRcdFx0XHRhZGQoLXNucSAqIDIgKiBzcXAgLSBiKTtcblx0XHRcdFx0cmV0dXJuIGFkZChzbnEgKiBzcXAgLSBiKTtcblx0XHRcdH1cblx0XHRcdGlmIChEIDwgMCkgeyBcblx0XHRcdFx0dmFyIHNxcCA9IHNxcnQocCksXG5cdFx0XHRcdFx0cGhpID0gTWF0aC5hY29zKHEgLyAoc3FwICogc3FwICogc3FwKSkgLyAzLFxuXHRcdFx0XHRcdHQgPSAtMiAqIHNxcCxcblx0XHRcdFx0XHRvID0gMiAqIFBJIC8gMztcblx0XHRcdFx0YWRkKHQgKiBjb3MocGhpKSAtIGIpO1xuXHRcdFx0XHRhZGQodCAqIGNvcyhwaGkgKyBvKSAtIGIpO1xuXHRcdFx0XHRyZXR1cm4gYWRkKHQgKiBjb3MocGhpIC0gbykgLSBiKTtcblx0XHRcdH1cblx0XHRcdHZhciBBID0gKHEgPiAwID8gLTEgOiAxKSAqIHBvdyhhYnMocSkgKyBzcXJ0KEQpLCAxIC8gMyk7XG5cdFx0XHRyZXR1cm4gYWRkKEEgKyBwIC8gQSAtIGIpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBQb2ludCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnQnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc1kgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gaGFzWSA/IGFyZzEgOiBhcmcwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGhhc1kgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueSA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5hbmdsZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0XHR0aGlzLnNldEFuZ2xlKGFyZzAuYW5nbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdHRoaXMuX19yZWFkID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSAxO1xuXHRcdH1cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludFxuXHRcdFx0XHQmJiAodGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueVxuXHRcdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkocG9pbnQpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KV07XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAodGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGFuZ2xlID0gdGhpcy5fYW5nbGUgfHwgMDtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlID0gbGVuZ3RoIC8gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNjYWxlKSlcblx0XHRcdFx0dGhpcy5nZXRBbmdsZSgpO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdHRoaXMueCAqIHNjYWxlLFxuXHRcdFx0XHR0aGlzLnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblx0fSxcblxuXHRnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG5cdHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuXHRnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5fYW5nbGUgfHwgMFxuXHRcdFx0XHRcdDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5hY29zKHRoaXMuZG90KHBvaW50KSAvIGRpdik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cdFx0aWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UXVhZHJhbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCAtIHRoaXMueCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy55LFxuXHRcdFx0ZCA9IHggKiB4ICsgeSAqIHksXG5cdFx0XHRzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG5cdFx0XHRzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcblx0XHRcdHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG5cdFx0aWYgKHNjYWxlID49IDApXG5cdFx0XHRwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSwgY2VudGVyKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwKVxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0XHRhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuXHRcdFx0cyA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGMgPSBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cG9pbnQgPSBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogYyAtIHBvaW50LnkgKiBzLFxuXHRcdFx0cG9pbnQueCAqIHMgKyBwb2ludC55ICogY1xuXHRcdCk7XG5cdFx0cmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHRyZXR1cm4gcmVjdC5jb250YWlucyh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb3NlOiBmdW5jdGlvbihwb2ludCwgdG9sZXJhbmNlKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0RGlzdGFuY2UocG9pbnQpIDwgdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKHRoaXMuY3Jvc3MocG9pbnQpKSA8IDAuMDAwMDE7XG5cdH0sXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyh0aGlzLmRvdChwb2ludCkpIDwgMC4wMDAwMTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLnkpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy54KSB8fCBpc05hTih0aGlzLnkpO1xuXHR9LFxuXG5cdGRvdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC54ICsgdGhpcy55ICogcG9pbnQueTtcblx0fSxcblxuXHRjcm9zczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLnggKiBwb2ludC55IC0gdGhpcy55ICogcG9pbnQueDtcblx0fSxcblxuXHRwcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHBvaW50LmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KDAsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSB0aGlzLmRvdChwb2ludCkgLyBwb2ludC5kb3QocG9pbnQpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0cG9pbnQueCAqIHNjYWxlLFxuXHRcdFx0XHRwb2ludC55ICogc2NhbGVcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5taW4ocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5taW4ocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgb3AgPSBNYXRoW25hbWVdO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KHgsIHksIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgU2l6ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2l6ZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZShhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNIZWlnaHQgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLndpZHRoID0gYXJnMDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGFzSGVpZ2h0ID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzSGVpZ2h0ID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5sZW5ndGggPiAxID8gYXJnMFsxXSA6IGFyZzBbMF07XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAueDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRyZXR1cm4gc2l6ZSA9PT0gdGhpcyB8fCBzaXplICYmICh0aGlzLndpZHRoID09PSBzaXplLndpZHRoXG5cdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodFxuXHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHNpemUpICYmIHRoaXMud2lkdGggPT09IHNpemVbMF1cblx0XHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZVsxXSkgfHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCArIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICsgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKiBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAqIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggJSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAlIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSgtdGhpcy53aWR0aCwgLXRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMud2lkdGgpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy53aWR0aCkgfHwgaXNOYU4odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgb3AgPSBNYXRoW25hbWVdO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKG9wKHRoaXMud2lkdGgpLCBvcCh0aGlzLmhlaWdodCkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFNpemUgPSBTaXplLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH0sXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBSZWN0YW5nbGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1JlY3RhbmdsZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcblx0XHRcdHJlYWQgPSAwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy54ID0gYXJnMDtcblx0XHRcdHRoaXMueSA9IGFyZzE7XG5cdFx0XHR0aGlzLndpZHRoID0gYXJnMjtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMztcblx0XHRcdHJlYWQgPSA0O1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwWzFdO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFsyXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwWzNdO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9PSB1bmRlZmluZWQgfHwgYXJnMC53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAueCB8fCAwO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnkgfHwgMDtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAud2lkdGggfHwgMDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodCB8fCAwO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5mcm9tID09PSB1bmRlZmluZWQgJiYgYXJnMC50byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMueCA9IHRoaXMueSA9IHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdHRoaXMuX3NldChhcmcwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghcmVhZCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0bmV4dCA9IEJhc2UucGVlayhhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdFx0XHRpZiAobmV4dCAmJiBuZXh0LnggIT09IHVuZGVmaW5lZCB8fCBCYXNlLmhhc05hbWVkKGFyZ3VtZW50cywgJ3RvJykpIHtcblx0XHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyk7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0by54IC0gcG9pbnQueDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0by55IC0gcG9pbnQueTtcblx0XHRcdFx0aWYgKHRoaXMud2lkdGggPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy54ID0gdG8ueDtcblx0XHRcdFx0XHR0aGlzLndpZHRoID0gLXRoaXMud2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuaGVpZ2h0IDwgMCkge1xuXHRcdFx0XHRcdHRoaXMueSA9IHRvLnk7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSAtdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0cmVhZCA9IGFyZ3VtZW50cy5fX2luZGV4O1xuXHRcdH1cblx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KVxuXHRcdFx0XHQ/IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0OiByZWN0O1xuXHRcdHJldHVybiBydCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBydCAmJiB0aGlzLnggPT09IHJ0LnggJiYgdGhpcy55ID09PSBydC55XG5cdFx0XHRcdFx0JiYgdGhpcy53aWR0aCA9PT0gcnQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHJ0LmhlaWdodFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpXG5cdFx0XHRcdCsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSlcblx0XHRcdFx0KyAnLCB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpXG5cdFx0XHRcdCsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMueSksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9maXhYKVxuXHRcdFx0dGhpcy54ICs9ICh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCkgKiB0aGlzLl9maXhYO1xuXHRcdGlmICh0aGlzLl9maXhZKVxuXHRcdFx0dGhpcy55ICs9ICh0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KSAqIHRoaXMuX2ZpeFk7XG5cdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHR0aGlzLl9maXhXID0gMTtcblx0XHR0aGlzLl9maXhIID0gMTtcblx0fSxcblxuXHRnZXRMZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54O1xuXHR9LFxuXG5cdHNldExlZnQ6IGZ1bmN0aW9uKGxlZnQpIHtcblx0XHRpZiAoIXRoaXMuX2ZpeFcpXG5cdFx0XHR0aGlzLndpZHRoIC09IGxlZnQgLSB0aGlzLng7XG5cdFx0dGhpcy54ID0gbGVmdDtcblx0XHR0aGlzLl9maXhYID0gMDtcblx0fSxcblxuXHRnZXRUb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnk7XG5cdH0sXG5cblx0c2V0VG9wOiBmdW5jdGlvbih0b3ApIHtcblx0XHRpZiAoIXRoaXMuX2ZpeEgpXG5cdFx0XHR0aGlzLmhlaWdodCAtPSB0b3AgLSB0aGlzLnk7XG5cdFx0dGhpcy55ID0gdG9wO1xuXHRcdHRoaXMuX2ZpeFkgPSAwO1xuXHR9LFxuXG5cdGdldFJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcblx0fSxcblxuXHRzZXRSaWdodDogZnVuY3Rpb24ocmlnaHQpIHtcblx0XHRpZiAodGhpcy5fZml4WCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpeFggIT09IDEpXG5cdFx0XHR0aGlzLl9maXhXID0gMDtcblx0XHRpZiAodGhpcy5fZml4Vylcblx0XHRcdHRoaXMueCA9IHJpZ2h0IC0gdGhpcy53aWR0aDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLndpZHRoID0gcmlnaHQgLSB0aGlzLng7XG5cdFx0dGhpcy5fZml4WCA9IDE7XG5cdH0sXG5cblx0Z2V0Qm90dG9tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0c2V0Qm90dG9tOiBmdW5jdGlvbihib3R0b20pIHtcblx0XHRpZiAodGhpcy5fZml4WSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpeFkgIT09IDEpXG5cdFx0XHR0aGlzLl9maXhIID0gMDtcblx0XHRpZiAodGhpcy5fZml4SClcblx0XHRcdHRoaXMueSA9IGJvdHRvbSAtIHRoaXMuaGVpZ2h0O1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuaGVpZ2h0ID0gYm90dG9tIC0gdGhpcy55O1xuXHRcdHRoaXMuX2ZpeFkgPSAxO1xuXHR9LFxuXG5cdGdldENlbnRlclg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcblx0XHR0aGlzLl9maXhYID0gMC41O1xuXHR9LFxuXG5cdGdldENlbnRlclk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAqIDAuNTtcblx0fSxcblxuXHRzZXRDZW50ZXJZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy55ID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXHRcdHRoaXMuX2ZpeFkgPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0Q2VudGVyWCgpLCB0aGlzLmdldENlbnRlclkoKSwgdGhpcywgJ3NldENlbnRlcicpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWChwb2ludC54KTtcblx0XHR0aGlzLnNldENlbnRlclkocG9pbnQueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGFyZyAmJiBhcmcud2lkdGggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHR8fCAoQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKS5sZW5ndGggPT0gNFxuXHRcdFx0XHQ/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHRcdDogdGhpcy5fY29udGFpbnNQb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRfY29udGFpbnNSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeCA9IHJlY3QueCxcblx0XHRcdHkgPSByZWN0Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggKyByZWN0LndpZHRoIDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSArIHJlY3QuaGVpZ2h0IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueVxuXHRcdFx0XHQmJiByZWN0LnggPCB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHJlY3QueSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdHRvdWNoZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+PSB0aGlzLnhcblx0XHRcdFx0JiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHJlY3QueSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0dW5pdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0aW5jbHVkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciB4MSA9IE1hdGgubWluKHRoaXMueCwgcG9pbnQueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcG9pbnQueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHBvaW50LngpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcG9pbnQueSk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbW91bnQgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGhvciA9IGFtb3VudC53aWR0aCxcblx0XHRcdHZlciA9IGFtb3VudC5oZWlnaHQ7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gaG9yIC8gMiwgdGhpcy55IC0gdmVyIC8gMixcblx0XHRcdFx0dGhpcy53aWR0aCArIGhvciwgdGhpcy5oZWlnaHQgKyB2ZXIpO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbihob3IsIHZlcikge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZCh0aGlzLndpZHRoICogaG9yIC0gdGhpcy53aWR0aCxcblx0XHRcdFx0dGhpcy5oZWlnaHQgKiAodmVyID09PSB1bmRlZmluZWQgPyBob3IgOiB2ZXIpIC0gdGhpcy5oZWlnaHQpO1xuXHR9XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdHJldHVybiBCYXNlLmVhY2goW1xuXHRcdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFx0WydCb3R0b20nLCAnTGVmdCddLCBbJ0JvdHRvbScsICdSaWdodCddLFxuXHRcdFx0WydMZWZ0JywgJ0NlbnRlciddLCBbJ1RvcCcsICdDZW50ZXInXSxcblx0XHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdFx0XSxcblx0XHRmdW5jdGlvbihwYXJ0cywgaW5kZXgpIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyk7XG5cdFx0XHR2YXIgeEZpcnN0ID0gL15bUkxdLy50ZXN0KHBhcnQpO1xuXHRcdFx0aWYgKGluZGV4ID49IDQpXG5cdFx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHRcdHZhciB4ID0gcGFydHNbeEZpcnN0ID8gMCA6IDFdLFxuXHRcdFx0XHR5ID0gcGFydHNbeEZpcnN0ID8gMSA6IDBdLFxuXHRcdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0XHRnZXRZID0gJ2dldCcgKyB5LFxuXHRcdFx0XHRzZXRYID0gJ3NldCcgKyB4LFxuXHRcdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQsXG5cdFx0XHRcdHNldCA9ICdzZXQnICsgcGFydDtcblx0XHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0XHRcdHJldHVybiBuZXcgY3Rvcih0aGlzW2dldFhdKCksIHRoaXNbZ2V0WV0oKSwgdGhpcywgc2V0KTtcblx0XHRcdH07XG5cdFx0XHR0aGlzW3NldF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0XHR0aGlzW3NldFldKHBvaW50LnkpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRiZWFuczogdHJ1ZVxuXHRcdH0pO1xufSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sIG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHByb3RvID0gUmVjdGFuZ2xlLnByb3RvdHlwZTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKFsneCcsICd5JywgJ3dpZHRoJywgJ2hlaWdodCddLCBmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpO1xuXHRcdHZhciBpbnRlcm5hbCA9ICdfJyArIGtleTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW2ludGVybmFsXTtcblx0XHR9O1xuXG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXNbaW50ZXJuYWxdID0gdmFsdWU7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnROb3RpZnkpXG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0fTtcblx0fSwgQmFzZS5lYWNoKFsnUG9pbnQnLCAnU2l6ZScsICdDZW50ZXInLFxuXHRcdFx0J0xlZnQnLCAnVG9wJywgJ1JpZ2h0JywgJ0JvdHRvbScsICdDZW50ZXJYJywgJ0NlbnRlclknLFxuXHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ10sXG5cdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgbmFtZSA9ICdzZXQnICsga2V5O1xuXHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gdHJ1ZTtcblx0XHRcdFx0cHJvdG9bbmFtZV0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IGZhbHNlO1xuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX293bmVyLl9ib3VuZHNTZWxlY3RlZDtcblx0XHRcdH0sXG5cblx0XHRcdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRcdFx0aWYgKG93bmVyLnNldFNlbGVjdGVkKSB7XG5cdFx0XHRcdFx0b3duZXIuX2JvdW5kc1NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHRcdFx0b3duZXIuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQgfHwgb3duZXIuX3NlbGVjdGVkU2VnbWVudFN0YXRlID4gMCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHQpO1xufSk7XG5cbnZhciBNYXRyaXggPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ01hdHJpeCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTWF0cml4KGFyZykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRvayA9IHRydWU7XG5cdFx0aWYgKGNvdW50ID09PSA2KSB7XG5cdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmIChhcmcgaW5zdGFuY2VvZiBNYXRyaXgpIHtcblx0XHRcdFx0dGhpcy5zZXQoYXJnLl9hLCBhcmcuX2MsIGFyZy5fYiwgYXJnLl9kLCBhcmcuX3R4LCBhcmcuX3R5KTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvayA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDApIHtcblx0XHRcdHRoaXMucmVzZXQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHR9XG5cdFx0aWYgKCFvaylcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgbWF0cml4IHBhcmFtZXRlcnMnKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKGEsIGMsIGIsIGQsIHR4LCB0eSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gYTtcblx0XHR0aGlzLl9jID0gYztcblx0XHR0aGlzLl9iID0gYjtcblx0XHR0aGlzLl9kID0gZDtcblx0XHR0aGlzLl90eCA9IHR4O1xuXHRcdHRoaXMuX3R5ID0gdHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuZ2V0VmFsdWVzKCksIG9wdGlvbnMpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcjtcblx0XHRpZiAob3duZXIpIHtcblx0XHRcdGlmIChvd25lci5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3duZXIuX2NoYW5nZWQoOSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLFxuXHRcdFx0XHR0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24obXgpIHtcblx0XHRyZXR1cm4gbXggPT09IHRoaXMgfHwgbXggJiYgdGhpcy5fYSA9PT0gbXguX2EgJiYgdGhpcy5fYiA9PT0gbXguX2Jcblx0XHRcdFx0JiYgdGhpcy5fYyA9PT0gbXguX2MgJiYgdGhpcy5fZCA9PT0gbXguX2Rcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IG14Ll90eCAmJiB0aGlzLl90eSA9PT0gbXguX3R5XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ1tbJyArIFtmLm51bWJlcih0aGlzLl9hKSwgZi5udW1iZXIodGhpcy5fYiksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHgpXS5qb2luKCcsICcpICsgJ10sIFsnXG5cdFx0XHRcdCsgW2YubnVtYmVyKHRoaXMuX2MpLCBmLm51bWJlcih0aGlzLl9kKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eSldLmpvaW4oJywgJykgKyAnXV0nO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbihfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSB0aGlzLl9kID0gMTtcblx0XHR0aGlzLl9jID0gdGhpcy5fYiA9IHRoaXMuX3R4ID0gdGhpcy5fdHkgPSAwO1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0YXBwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHRoaXMuX3R4ICs9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2I7XG5cdFx0dGhpcy5fdHkgKz0geCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY2FsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdHRoaXMuX2EgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9jICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYiAqPSBzY2FsZS55O1xuXHRcdHRoaXMuX2QgKj0gc2NhbGUueTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuXHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSksXG5cdFx0XHR4ID0gY2VudGVyLngsXG5cdFx0XHR5ID0gY2VudGVyLnksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR0eCA9IHggLSB4ICogY29zICsgeSAqIHNpbixcblx0XHRcdHR5ID0geSAtIHggKiBzaW4gLSB5ICogY29zLFxuXHRcdFx0YSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2Q7XG5cdFx0dGhpcy5fYSA9IGNvcyAqIGEgKyBzaW4gKiBiO1xuXHRcdHRoaXMuX2IgPSAtc2luICogYSArIGNvcyAqIGI7XG5cdFx0dGhpcy5fYyA9IGNvcyAqIGMgKyBzaW4gKiBkO1xuXHRcdHRoaXMuX2QgPSAtc2luICogYyArIGNvcyAqIGQ7XG5cdFx0dGhpcy5fdHggKz0gdHggKiBhICsgdHkgKiBiO1xuXHRcdHRoaXMuX3R5ICs9IHR4ICogYyArIHR5ICogZDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2hlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaGVhciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGMgPSB0aGlzLl9jO1xuXHRcdHRoaXMuX2EgKz0gc2hlYXIueSAqIHRoaXMuX2I7XG5cdFx0dGhpcy5fYyArPSBzaGVhci55ICogdGhpcy5fZDtcblx0XHR0aGlzLl9iICs9IHNoZWFyLnggKiBhO1xuXHRcdHRoaXMuX2QgKz0gc2hlYXIueCAqIGM7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNrZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBza2V3ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSksXG5cdFx0XHR0b1JhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0c2hlYXIgPSBuZXcgUG9pbnQoTWF0aC50YW4oc2tldy54ICogdG9SYWRpYW5zKSxcblx0XHRcdFx0TWF0aC50YW4oc2tldy55ICogdG9SYWRpYW5zKSk7XG5cdFx0cmV0dXJuIHRoaXMuc2hlYXIoc2hlYXIsIGNlbnRlcik7XG5cdH0sXG5cblx0Y29uY2F0ZW5hdGU6IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBteC5fYSAqIGEgKyBteC5fYyAqIGI7XG5cdFx0dGhpcy5fYiA9IG14Ll9iICogYSArIG14Ll9kICogYjtcblx0XHR0aGlzLl9jID0gbXguX2EgKiBjICsgbXguX2MgKiBkO1xuXHRcdHRoaXMuX2QgPSBteC5fYiAqIGMgKyBteC5fZCAqIGQ7XG5cdFx0dGhpcy5fdHggKz0gbXguX3R4ICogYSArIG14Ll90eSAqIGI7XG5cdFx0dGhpcy5fdHkgKz0gbXguX3R4ICogYyArIG14Ll90eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHByZUNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGIgPSB0aGlzLl9iLFxuXHRcdFx0YyA9IHRoaXMuX2MsXG5cdFx0XHRkID0gdGhpcy5fZCxcblx0XHRcdHR4ID0gdGhpcy5fdHgsXG5cdFx0XHR0eSA9IHRoaXMuX3R5O1xuXHRcdHRoaXMuX2EgPSBteC5fYSAqIGEgKyBteC5fYiAqIGM7XG5cdFx0dGhpcy5fYiA9IG14Ll9hICogYiArIG14Ll9iICogZDtcblx0XHR0aGlzLl9jID0gbXguX2MgKiBhICsgbXguX2QgKiBjO1xuXHRcdHRoaXMuX2QgPSBteC5fYyAqIGIgKyBteC5fZCAqIGQ7XG5cdFx0dGhpcy5fdHggPSBteC5fYSAqIHR4ICsgbXguX2IgKiB0eSArIG14Ll90eDtcblx0XHR0aGlzLl90eSA9IG14Ll9jICogdHggKyBteC5fZCAqIHR5ICsgbXguX3R5O1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRpc0lkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYSA9PT0gMSAmJiB0aGlzLl9jID09PSAwICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fZCA9PT0gMVxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gMCAmJiB0aGlzLl90eSA9PT0gMDtcblx0fSxcblxuXHRvck51bGxJZklkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCkgPyBudWxsIDogdGhpcztcblx0fSxcblxuXHRpc0ludmVydGlibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0aXNTaW5ndWxhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24oIHNyYywgc3JjT2Zmc2V0LCBkc3QsIGRzdE9mZnNldCwgY291bnQpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDVcblx0XHRcdD8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIHNyY09mZnNldCwgZHN0LCBkc3RPZmZzZXQsIGNvdW50KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHR4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHgsXG5cdFx0XHR4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHksXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihzcmMsIHNyY09mZnNldCwgZHN0LCBkc3RPZmZzZXQsIGNvdW50KSB7XG5cdFx0dmFyIGkgPSBzcmNPZmZzZXQsXG5cdFx0XHRqID0gZHN0T2Zmc2V0LFxuXHRcdFx0bWF4ID0gaSArIDIgKiBjb3VudDtcblx0XHR3aGlsZSAoaSA8IG1heCkge1xuXHRcdFx0dmFyIHggPSBzcmNbaSsrXSxcblx0XHRcdFx0eSA9IHNyY1tpKytdO1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iICsgdGhpcy5fdHg7XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eTtcblx0XHR9XG5cdFx0cmV0dXJuIGRzdDtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29ybmVyczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4MSA9IHJlY3QueCxcblx0XHRcdHkxID0gcmVjdC55LFxuXHRcdFx0eDIgPSB4MSArIHJlY3Qud2lkdGgsXG5cdFx0XHR5MiA9IHkxICsgcmVjdC5oZWlnaHQsXG5cdFx0XHRjb29yZHMgPSBbIHgxLCB5MSwgeDIsIHkxLCB4MiwgeTIsIHgxLCB5MiBdO1xuXHRcdHJldHVybiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIDAsIGNvb3JkcywgMCwgNCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUJvdW5kczogZnVuY3Rpb24oYm91bmRzLCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLl90cmFuc2Zvcm1Db3JuZXJzKGJvdW5kcyksXG5cdFx0XHRtaW4gPSBjb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBjb29yZHMuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMjsgaSA8IDg7IGkrKykge1xuXHRcdFx0dmFyIHZhbCA9IGNvb3Jkc1tpXSxcblx0XHRcdFx0aiA9IGkgJiAxO1xuXHRcdFx0aWYgKHZhbCA8IG1pbltqXSlcblx0XHRcdFx0bWluW2pdID0gdmFsO1xuXHRcdFx0ZWxzZSBpZiAodmFsID4gbWF4W2pdKVxuXHRcdFx0XHRtYXhbal0gPSB2YWw7XG5cdFx0fVxuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSxcblx0XHRcdFx0X2RvbnROb3RpZnkpO1xuXHR9LFxuXG5cdGludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2dldERldGVybWluYW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fYSAqIHRoaXMuX2QgLSB0aGlzLl9iICogdGhpcy5fYztcblx0XHRyZXR1cm4gaXNGaW5pdGUoZGV0KSAmJiAhTnVtZXJpY2FsLmlzWmVybyhkZXQpXG5cdFx0XHRcdCYmIGlzRmluaXRlKHRoaXMuX3R4KSAmJiBpc0Zpbml0ZSh0aGlzLl90eSlcblx0XHRcdFx0PyBkZXQgOiBudWxsO1xuXHR9LFxuXG5cdF9pbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRpZiAoIWRldClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciB4ID0gcG9pbnQueCAtIHRoaXMuX3R4LFxuXHRcdFx0eSA9IHBvaW50LnkgLSB0aGlzLl90eTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0KHggKiB0aGlzLl9kIC0geSAqIHRoaXMuX2IpIC8gZGV0LFxuXHRcdFx0KHkgKiB0aGlzLl9hIC0geCAqIHRoaXMuX2MpIC8gZGV0LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdGRlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGEgPSB0aGlzLl9hLCBiID0gdGhpcy5fYiwgYyA9IHRoaXMuX2MsIGQgPSB0aGlzLl9kO1xuXHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGEgKiBkIC0gYiAqIGMpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgc2NhbGVYID0gTWF0aC5zcXJ0KGEgKiBhICsgYiAqIGIpO1xuXHRcdGEgLz0gc2NhbGVYO1xuXHRcdGIgLz0gc2NhbGVYO1xuXG5cdFx0dmFyIHNoZWFyID0gYSAqIGMgKyBiICogZDtcblx0XHRjIC09IGEgKiBzaGVhcjtcblx0XHRkIC09IGIgKiBzaGVhcjtcblxuXHRcdHZhciBzY2FsZVkgPSBNYXRoLnNxcnQoYyAqIGMgKyBkICogZCk7XG5cdFx0YyAvPSBzY2FsZVk7XG5cdFx0ZCAvPSBzY2FsZVk7XG5cdFx0c2hlYXIgLz0gc2NhbGVZO1xuXG5cdFx0aWYgKGEgKiBkIDwgYiAqIGMpIHtcblx0XHRcdGEgPSAtYTtcblx0XHRcdGIgPSAtYjtcblx0XHRcdHNoZWFyID0gLXNoZWFyO1xuXHRcdFx0c2NhbGVYID0gLXNjYWxlWDtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0c2NhbGluZzogbmV3IFBvaW50KHNjYWxlWCwgc2NhbGVZKSxcblx0XHRcdHJvdGF0aW9uOiAtTWF0aC5hdGFuMihiLCBhKSAqIDE4MCAvIE1hdGguUEksXG5cdFx0XHRzaGVhcmluZzogc2hlYXJcblx0XHR9O1xuXHR9LFxuXG5cdGdldFZhbHVlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFsgdGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5IF07XG5cdH0sXG5cblx0Z2V0VHJhbnNsYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnNjYWxpbmc7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkucm90YXRpb247XG5cdH0sXG5cblx0aW52ZXJ0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdHJldHVybiBkZXQgJiYgbmV3IE1hdHJpeChcblx0XHRcdFx0dGhpcy5fZCAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2MgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9iIC8gZGV0LFxuXHRcdFx0XHR0aGlzLl9hIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYiAqIHRoaXMuX3R5IC0gdGhpcy5fZCAqIHRoaXMuX3R4KSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2MgKiB0aGlzLl90eCAtIHRoaXMuX2EgKiB0aGlzLl90eSkgLyBkZXQpO1xuXHR9LFxuXG5cdHNoaWZ0bGVzczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgMCwgMCk7XG5cdH0sXG5cblx0YXBwbHlUb0NvbnRleHQ6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGN0eC50cmFuc2Zvcm0odGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCwgdGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fVxufSwgQmFzZS5lYWNoKFsnYScsICdjJywgJ2InLCAnZCcsICd0eCcsICd0eSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdHByb3AgPSAnXycgKyBuYW1lO1xuXHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpc1twcm9wXTtcblx0fTtcblx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHR0aGlzW3Byb3BdID0gdmFsdWU7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xpbmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIExpbmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCkge1xuXHRcdHZhciBhc1ZlY3RvciA9IGZhbHNlO1xuXHRcdGlmIChhcmd1bWVudHMubGVuZ3RoID49IDQpIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMjtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMztcblx0XHRcdGFzVmVjdG9yID0gYXJnNDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwLng7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzAueTtcblx0XHRcdHRoaXMuX3Z4ID0gYXJnMS54O1xuXHRcdFx0dGhpcy5fdnkgPSBhcmcxLnk7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzI7XG5cdFx0fVxuXHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdHRoaXMuX3Z4IC09IHRoaXMuX3B4O1xuXHRcdFx0dGhpcy5fdnkgLT0gdGhpcy5fcHk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3B4LCB0aGlzLl9weSk7XG5cdH0sXG5cblx0Z2V0VmVjdG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3Z4LCB0aGlzLl92eSk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRWZWN0b3IoKS5nZXRMZW5ndGgoKTtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKGxpbmUsIGlzSW5maW5pdGUpIHtcblx0XHRyZXR1cm4gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRsaW5lLl9weCwgbGluZS5fcHksIGxpbmUuX3Z4LCBsaW5lLl92eSxcblx0XHRcdFx0dHJ1ZSwgaXNJbmZpbml0ZSk7XG5cdH0sXG5cblx0Z2V0U2lkZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTGluZS5nZXRTaWRlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0RGlzdGFuY2U6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIE1hdGguYWJzKExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlKSk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGludGVyc2VjdDogZnVuY3Rpb24oYXB4LCBhcHksIGF2eCwgYXZ5LCBicHgsIGJweSwgYnZ4LCBidnksIGFzVmVjdG9yLFxuXHRcdFx0XHRpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdGF2eCAtPSBhcHg7XG5cdFx0XHRcdGF2eSAtPSBhcHk7XG5cdFx0XHRcdGJ2eCAtPSBicHg7XG5cdFx0XHRcdGJ2eSAtPSBicHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3Jvc3MgPSBidnkgKiBhdnggLSBidnggKiBhdnk7XG5cdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oY3Jvc3MpKSB7XG5cdFx0XHRcdHZhciBkeCA9IGFweCAtIGJweCxcblx0XHRcdFx0XHRkeSA9IGFweSAtIGJweSxcblx0XHRcdFx0XHR0YSA9IChidnggKiBkeSAtIGJ2eSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdHRiID0gKGF2eCAqIGR5IC0gYXZ5ICogZHgpIC8gY3Jvc3M7XG5cdFx0XHRcdGlmICgoaXNJbmZpbml0ZSB8fCAwIDw9IHRhICYmIHRhIDw9IDEpXG5cdFx0XHRcdFx0XHQmJiAoaXNJbmZpbml0ZSB8fCAwIDw9IHRiICYmIHRiIDw9IDEpKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdFx0YXB4ICsgdGEgKiBhdngsXG5cdFx0XHRcdFx0XHRcdFx0YXB5ICsgdGEgKiBhdnkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRnZXRTaWRlOiBmdW5jdGlvbihweCwgcHksIHZ4LCB2eSwgeCwgeSwgYXNWZWN0b3IpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0dnggLT0gcHg7XG5cdFx0XHRcdHZ5IC09IHB5O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHYyeCA9IHggLSBweCxcblx0XHRcdFx0djJ5ID0geSAtIHB5LFxuXHRcdFx0XHRjY3cgPSB2MnggKiB2eSAtIHYyeSAqIHZ4OyBcblx0XHRcdGlmIChjY3cgPT09IDApIHtcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnggKyB2MnkgKiB2eTsgXG5cdFx0XHRcdGlmIChjY3cgPiAwKSB7XG5cdFx0XHRcdFx0djJ4IC09IHZ4O1xuXHRcdFx0XHRcdHYyeSAtPSB2eTtcblx0XHRcdFx0XHRjY3cgPSB2MnggKiB2eCArIHYyeSAqIHZ5O1xuXHRcdFx0XHRcdGlmIChjY3cgPCAwKVxuXHRcdFx0XHRcdFx0Y2N3ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcblx0XHR9LFxuXG5cdFx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbSA9IHZ5IC8gdngsIFxuXHRcdFx0XHRiID0gcHkgLSBtICogcHg7IFxuXHRcdFx0cmV0dXJuICh5IC0gKG0gKiB4KSAtIGIpIC8gTWF0aC5zcXJ0KG0gKiBtICsgMSk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFByb2plY3QgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQcm9qZWN0Jyxcblx0X2xpc3Q6ICdwcm9qZWN0cycsXG5cdF9yZWZlcmVuY2U6ICdwcm9qZWN0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQcm9qZWN0KGVsZW1lbnQpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMsIHRydWUpO1xuXHRcdHRoaXMubGF5ZXJzID0gW107XG5cdFx0dGhpcy5zeW1ib2xzID0gW107XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlID0gbmV3IFN0eWxlKG51bGwsIG51bGwsIHRoaXMpO1xuXHRcdHRoaXMuYWN0aXZlTGF5ZXIgPSBuZXcgTGF5ZXIoKTtcblx0XHR0aGlzLl92aWV3ID0gVmlldy5jcmVhdGUodGhpcyxcblx0XHRcdFx0ZWxlbWVudCB8fCBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoMSwgMSkpO1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudCA9IDA7XG5cdFx0dGhpcy5fdXBkYXRlVmVyc2lvbiA9IDA7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmxheWVycywgb3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMubGF5ZXJzW2ldLnJlbW92ZSgpO1xuXHRcdHRoaXMuc3ltYm9scyA9IFtdO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxheWVycy5sZW5ndGggPD0gMVxuXHRcdFx0JiYgKCF0aGlzLmFjdGl2ZUxheWVyIHx8IHRoaXMuYWN0aXZlTGF5ZXIuaXNFbXB0eSgpKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRpZiAoIXJlbW92ZS5iYXNlLmNhbGwodGhpcykpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3ZpZXcpXG5cdFx0XHR0aGlzLl92aWV3LnJlbW92ZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9LFxuXG5cdGdldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRTdHlsZTtcblx0fSxcblxuXHRzZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlLmluaXRpYWxpemUoc3R5bGUpO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGNoaWxkKSB7XG5cdFx0aWYgKGNoaWxkIGluc3RhbmNlb2YgTGF5ZXIpIHtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMubGF5ZXJzLCBbY2hpbGRdKTtcblx0XHRcdGlmICghdGhpcy5hY3RpdmVMYXllcilcblx0XHRcdFx0dGhpcy5hY3RpdmVMYXllciA9IGNoaWxkO1xuXHRcdH0gZWxzZSBpZiAoY2hpbGQgaW5zdGFuY2VvZiBJdGVtKSB7XG5cdFx0XHQodGhpcy5hY3RpdmVMYXllclxuXHRcdFx0XHR8fCB0aGlzLmFkZENoaWxkKG5ldyBMYXllcihJdGVtLk5PX0lOU0VSVCkpKS5hZGRDaGlsZChjaGlsZCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNoaWxkID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGNoaWxkO1xuXHR9LFxuXG5cdGdldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX3NlbGVjdGVkSXRlbXMpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fc2VsZWN0ZWRJdGVtc1tpZF07XG5cdFx0XHRpZiAoaXRlbS5pc0luc2VydGVkKCkpXG5cdFx0XHRcdGl0ZW1zLnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRnZXRPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGUuc2V0dGluZ3M7XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBpZCA9IGl0ZW0uX2lkLFxuXHRcdFx0c2VsZWN0ZWRJdGVtcyA9IHRoaXMuX3NlbGVjdGVkSXRlbXM7XG5cdFx0aWYgKGl0ZW0uX3NlbGVjdGVkKSB7XG5cdFx0XHRpZiAoc2VsZWN0ZWRJdGVtc1tpZF0gIT09IGl0ZW0pIHtcblx0XHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQrKztcblx0XHRcdFx0c2VsZWN0ZWRJdGVtc1tpZF0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc2VsZWN0ZWRJdGVtc1tpZF0gPT09IGl0ZW0pIHtcblx0XHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50LS07XG5cdFx0XHRkZWxldGUgc2VsZWN0ZWRJdGVtc1tpZF07XG5cdFx0fVxuXHR9LFxuXG5cdHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGxheWVyc1tpXS5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGRlc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuX3NlbGVjdGVkSXRlbXM7XG5cdFx0Zm9yICh2YXIgaSBpbiBzZWxlY3RlZEl0ZW1zKVxuXHRcdFx0c2VsZWN0ZWRJdGVtc1tpXS5zZXRGdWxseVNlbGVjdGVkKGZhbHNlKTtcblx0fSxcblxuXHRoaXRUZXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRvcHRpb25zID0gSGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpO1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIHJlcyA9IHRoaXMubGF5ZXJzW2ldLmhpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdFx0aWYgKHJlcykgcmV0dXJuIHJlcztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoLCBmYWxzZSk7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLmFjdGl2ZUxheWVyO1xuXHRcdHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgbGF5ZXIgJiYgbGF5ZXIuaXNFbXB0eSgpICYmIGxheWVyKTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgcGl4ZWxSYXRpbykge1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24rKztcblx0XHRjdHguc2F2ZSgpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBwYXJhbSA9IG5ldyBCYXNlKHtcblx0XHRcdG9mZnNldDogbmV3IFBvaW50KDAsIDApLFxuXHRcdFx0cGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcblx0XHRcdHRyYWNrVHJhbnNmb3JtczogdHJ1ZSxcblx0XHRcdHRyYW5zZm9ybXM6IFttYXRyaXhdXG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLmxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLmxheWVyc1tpXS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRpZiAodGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQgPiAwKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnN0cm9rZVdpZHRoID0gMTtcblx0XHRcdGZvciAodmFyIGlkIGluIHRoaXMuX3NlbGVjdGVkSXRlbXMpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9zZWxlY3RlZEl0ZW1zW2lkXSxcblx0XHRcdFx0XHRnbG9iYWxNYXRyaXggPSBpdGVtLl9nbG9iYWxNYXRyaXgsXG5cdFx0XHRcdFx0c2l6ZSA9IHRoaXMuX3Njb3BlLnNldHRpbmdzLmhhbmRsZVNpemUsXG5cdFx0XHRcdFx0aGFsZiA9IHNpemUgLyAyO1xuXHRcdFx0XHRpZiAoaXRlbS5fdXBkYXRlVmVyc2lvbiA9PT0gdGhpcy5fdXBkYXRlVmVyc2lvblxuXHRcdFx0XHRcdFx0JiYgKGl0ZW0uX2RyYXdTZWxlY3RlZCB8fCBpdGVtLl9ib3VuZHNTZWxlY3RlZClcblx0XHRcdFx0XHRcdCYmIGdsb2JhbE1hdHJpeCkge1xuXHRcdFx0XHRcdHZhciBjb2xvciA9IGl0ZW0uZ2V0U2VsZWN0ZWRDb2xvcigpXG5cdFx0XHRcdFx0XHRcdHx8IGl0ZW0uZ2V0TGF5ZXIoKS5nZXRTZWxlY3RlZENvbG9yKCk7XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cdFx0XHRcdFx0XHRcdD8gY29sb3IudG9DYW52YXNTdHlsZShjdHgpIDogJyMwMDlkZWMnO1xuXHRcdFx0XHRcdGlmIChpdGVtLl9kcmF3U2VsZWN0ZWQpXG5cdFx0XHRcdFx0XHRpdGVtLl9kcmF3U2VsZWN0ZWQoY3R4LCBnbG9iYWxNYXRyaXgpO1xuXHRcdFx0XHRcdGlmIChpdGVtLl9ib3VuZHNTZWxlY3RlZCkge1xuXHRcdFx0XHRcdFx0dmFyIGNvb3JkcyA9IGdsb2JhbE1hdHJpeC5fdHJhbnNmb3JtQ29ybmVycyhcblx0XHRcdFx0XHRcdFx0XHRpdGVtLmdldEludGVybmFsQm91bmRzKCkpO1xuXHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0XHRcdGN0eFtpID09PSAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10oXG5cdFx0XHRcdFx0XHRcdFx0XHRjb29yZHNbaV0sIGNvb3Jkc1srK2ldKTtcblx0XHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuXHRcdFx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29vcmRzW2ldIC0gaGFsZiwgY29vcmRzWysraV0gLSBoYWxmLFxuXHRcdFx0XHRcdFx0XHRcdFx0c2l6ZSwgc2l6ZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTeW1ib2wgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sKGl0ZW0sIGRvbnRDZW50ZXIpIHtcblx0XHR0aGlzLl9pZCA9IFN5bWJvbC5faWQgPSAoU3ltYm9sLl9pZCB8fCAwKSArIDE7XG5cdFx0dGhpcy5wcm9qZWN0ID0gcGFwZXIucHJvamVjdDtcblx0XHR0aGlzLnByb2plY3Quc3ltYm9scy5wdXNoKHRoaXMpO1xuXHRcdGlmIChpdGVtKVxuXHRcdFx0dGhpcy5zZXREZWZpbml0aW9uKGl0ZW0sIGRvbnRDZW50ZXIpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NsYXNzLCB0aGlzLl9kZWZpbml0aW9uXSxcblx0XHRcdFx0XHRvcHRpb25zLCBmYWxzZSwgZGljdGlvbmFyeSk7XG5cdFx0fSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0dGhpcy5wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdGdldERlZmluaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9kZWZpbml0aW9uO1xuXHR9LFxuXG5cdHNldERlZmluaXRpb246IGZ1bmN0aW9uKGl0ZW0sIF9kb250Q2VudGVyKSB7XG5cdFx0aWYgKGl0ZW0uX3BhcmVudFN5bWJvbClcblx0XHRcdGl0ZW0gPSBpdGVtLmNsb25lKCk7XG5cdFx0aWYgKHRoaXMuX2RlZmluaXRpb24pXG5cdFx0XHR0aGlzLl9kZWZpbml0aW9uLl9wYXJlbnRTeW1ib2wgPSBudWxsO1xuXHRcdHRoaXMuX2RlZmluaXRpb24gPSBpdGVtO1xuXHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0aXRlbS5zZXRTZWxlY3RlZChmYWxzZSk7XG5cdFx0aWYgKCFfZG9udENlbnRlcilcblx0XHRcdGl0ZW0uc2V0UG9zaXRpb24obmV3IFBvaW50KCkpO1xuXHRcdGl0ZW0uX3BhcmVudFN5bWJvbCA9IHRoaXM7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRwbGFjZTogZnVuY3Rpb24ocG9zaXRpb24pIHtcblx0XHRyZXR1cm4gbmV3IFBsYWNlZFN5bWJvbCh0aGlzLCBwb3NpdGlvbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU3ltYm9sKHRoaXMuX2RlZmluaXRpb24uY2xvbmUoZmFsc2UpKTtcblx0fVxufSk7XG5cbnZhciBJdGVtID0gQmFzZS5leHRlbmQoQ2FsbGJhY2ssIHtcblx0c3RhdGljczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuXHRcdFx0aWYgKHNyYy5fc2VyaWFsaXplRmllbGRzKVxuXHRcdFx0XHRzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IG5ldyBCYXNlKFxuXHRcdFx0XHRcdFx0dGhpcy5wcm90b3R5cGUuX3NlcmlhbGl6ZUZpZWxkcywgc3JjLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdFx0cmV0dXJuIGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdE5PX0lOU0VSVDogeyBpbnNlcnQ6IGZhbHNlIH1cblx0fSxcblxuXHRfY2xhc3M6ICdJdGVtJyxcblx0X2FwcGx5TWF0cml4OiB0cnVlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IHRydWUsXG5cdF9ib3VuZHNTZWxlY3RlZDogZmFsc2UsXG5cdF9zZWxlY3RDaGlsZHJlbjogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRuYW1lOiBudWxsLFxuXHRcdG1hdHJpeDogbmV3IE1hdHJpeCgpLFxuXHRcdHBpdm90OiBudWxsLFxuXHRcdGxvY2tlZDogZmFsc2UsXG5cdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRibGVuZE1vZGU6ICdub3JtYWwnLFxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0Z3VpZGU6IGZhbHNlLFxuXHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRjbGlwTWFzazogZmFsc2UsXG5cdFx0YXBwbHlNYXRyaXg6IG51bGwsXG5cdFx0ZGF0YToge31cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBJdGVtKCkge1xuXHR9LFxuXG5cdF9pbml0aWFsaXplOiBmdW5jdGlvbihwcm9wcywgcG9pbnQpIHtcblx0XHR2YXIgaW50ZXJuYWwgPSBwcm9wcyAmJiBwcm9wcy5pbnRlcm5hbCA9PT0gdHJ1ZSxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdHByb2plY3QgPSBwYXBlci5wcm9qZWN0O1xuXHRcdGlmICghaW50ZXJuYWwpXG5cdFx0XHR0aGlzLl9pZCA9IEl0ZW0uX2lkID0gKEl0ZW0uX2lkIHx8IDApICsgMTtcblx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRoaXMuX2NhbkFwcGx5TWF0cml4ICYmIHBhcGVyLnNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdGlmIChwb2ludClcblx0XHRcdG1hdHJpeC50cmFuc2xhdGUocG9pbnQpO1xuXHRcdG1hdHJpeC5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3N0eWxlID0gbmV3IFN0eWxlKHByb2plY3QuX2N1cnJlbnRTdHlsZSwgdGhpcywgcHJvamVjdCk7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KSB7XG5cdFx0XHRpZiAoaW50ZXJuYWwgfHwgcHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSkge1xuXHRcdFx0XHR0aGlzLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KHByb2plY3QuYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKCkpLmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcHJvcHMgJiYgcHJvcHMgIT09IEl0ZW0uTk9fSU5TRVJUXG5cdFx0XHRcdD8gdGhpcy5fc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSB9KSBcblx0XHRcdFx0OiB0cnVlO1xuXHR9LFxuXG5cdF9ldmVudHM6IG5ldyBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBtb3VzZUZsYWdzID0ge1xuXHRcdFx0bW91c2Vkb3duOiB7XG5cdFx0XHRcdG1vdXNlZG93bjogMSxcblx0XHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0XHRjbGljazogMSxcblx0XHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHRcdH0sXG5cdFx0XHRtb3VzZXVwOiB7XG5cdFx0XHRcdG1vdXNldXA6IDEsXG5cdFx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0XHR9LFxuXHRcdFx0bW91c2Vtb3ZlOiB7XG5cdFx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdFx0bW91c2Vtb3ZlOiAxLFxuXHRcdFx0XHRtb3VzZWVudGVyOiAxLFxuXHRcdFx0XHRtb3VzZWxlYXZlOiAxXG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBtb3VzZUV2ZW50ID0ge1xuXHRcdFx0aW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHR2YXIgY291bnRlcnMgPSB0aGlzLmdldFZpZXcoKS5fZXZlbnRDb3VudGVycztcblx0XHRcdFx0aWYgKGNvdW50ZXJzKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpIHtcblx0XHRcdFx0XHRcdGNvdW50ZXJzW2tleV0gPSAoY291bnRlcnNba2V5XSB8fCAwKVxuXHRcdFx0XHRcdFx0XHRcdCsgKG1vdXNlRmxhZ3Nba2V5XVt0eXBlXSB8fCAwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIGNvdW50ZXJzID0gdGhpcy5nZXRWaWV3KCkuX2V2ZW50Q291bnRlcnM7XG5cdFx0XHRcdGlmIChjb3VudGVycykge1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKVxuXHRcdFx0XHRcdFx0Y291bnRlcnNba2V5XSAtPSBtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gQmFzZS5lYWNoKFsnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uQ2xpY2snLFxuXHRcdFx0J29uRG91YmxlQ2xpY2snLCAnb25Nb3VzZU1vdmUnLCAnb25Nb3VzZUVudGVyJywgJ29uTW91c2VMZWF2ZSddLFxuXHRcdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0XHR0aGlzW25hbWVdID0gbW91c2VFdmVudDtcblx0XHRcdH0sIHtcblx0XHRcdFx0b25GcmFtZToge1xuXHRcdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fYW5pbWF0ZUl0ZW0odHJ1ZSk7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0dGhpcy5fYW5pbWF0ZUl0ZW0oZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0XHRvbkxvYWQ6IHt9XG5cdFx0XHR9XG5cdFx0KTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGFuaW1hdGUpIHtcblx0XHR0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgYW5pbWF0ZSk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHZhciBwcm9wcyA9IHt9LFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cblx0XHRmdW5jdGlvbiBzZXJpYWxpemUoZmllbGRzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gZmllbGRzKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoYXRba2V5XTtcblx0XHRcdFx0aWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwga2V5ID09PSAnbGVhZGluZydcblx0XHRcdFx0XHRcdD8gZmllbGRzLmZvbnRTaXplICogMS4yIDogZmllbGRzW2tleV0pKSB7XG5cdFx0XHRcdFx0cHJvcHNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKHZhbHVlLCBvcHRpb25zLFxuXHRcdFx0XHRcdFx0XHRrZXkgIT09ICdkYXRhJywgZGljdGlvbmFyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRzZXJpYWxpemUodGhpcy5fc2VyaWFsaXplRmllbGRzKTtcblx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgR3JvdXApKVxuXHRcdFx0c2VyaWFsaXplKHRoaXMuX3N0eWxlLl9kZWZhdWx0cyk7XG5cdFx0cmV0dXJuIFsgdGhpcy5fY2xhc3MsIHByb3BzIF07XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0dmFyIHN5bWJvbCA9IHRoaXMuX3BhcmVudFN5bWJvbCxcblx0XHRcdGNhY2hlUGFyZW50ID0gdGhpcy5fcGFyZW50IHx8IHN5bWJvbCxcblx0XHRcdHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX3Bvc2l0aW9uID0gdGhpcy5fZGVjb21wb3NlZCA9XG5cdFx0XHRcdFx0dGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fY3VycmVudFBhdGggPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChjYWNoZVBhcmVudCAmJiAoZmxhZ3Ncblx0XHRcdFx0JiAoOCB8IDMyKSkpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUoY2FjaGVQYXJlbnQpO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAyKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdH1cblx0XHRpZiAocHJvamVjdCkge1xuXHRcdFx0aWYgKGZsYWdzICYgMSkge1xuXHRcdFx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAocHJvamVjdC5fY2hhbmdlcykge1xuXHRcdFx0XHR2YXIgZW50cnkgPSBwcm9qZWN0Ll9jaGFuZ2VzQnlJZFt0aGlzLl9pZF07XG5cdFx0XHRcdGlmIChlbnRyeSkge1xuXHRcdFx0XHRcdGVudHJ5LmZsYWdzIHw9IGZsYWdzO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVudHJ5ID0geyBpdGVtOiB0aGlzLCBmbGFnczogZmxhZ3MgfTtcblx0XHRcdFx0XHRwcm9qZWN0Ll9jaGFuZ2VzQnlJZFt0aGlzLl9pZF0gPSBlbnRyeTtcblx0XHRcdFx0XHRwcm9qZWN0Ll9jaGFuZ2VzLnB1c2goZW50cnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzeW1ib2wpXG5cdFx0XHRzeW1ib2wuX2NoYW5nZWQoZmxhZ3MpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRpZiAocHJvcHMpXG5cdFx0XHR0aGlzLl9zZXQocHJvcHMsIHsgaW5zZXJ0OiB0cnVlIH0pO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldElkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faWQ7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3M7XG5cdH0sXG5cblx0Z2V0TmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX25hbWU7XG5cdH0sXG5cblx0c2V0TmFtZTogZnVuY3Rpb24obmFtZSwgdW5pcXVlKSB7XG5cblx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0aWYgKG5hbWUgPT09ICgrbmFtZSkgKyAnJylcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnTmFtZXMgY29uc2lzdGluZyBvbmx5IG9mIG51bWJlcnMgYXJlIG5vdCBzdXBwb3J0ZWQuJyk7XG5cdFx0aWYgKG5hbWUgJiYgdGhpcy5fcGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gdGhpcy5fcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRvcmlnID0gbmFtZSxcblx0XHRcdFx0aSA9IDE7XG5cdFx0XHR3aGlsZSAodW5pcXVlICYmIGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLl9uYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgxMjgpO1xuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3R5bGU7XG5cdH0sXG5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1N0cm9rZSgpO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTaGFkb3coKTtcblx0fVxufSwgQmFzZS5lYWNoKFsnbG9ja2VkJywgJ3Zpc2libGUnLCAnYmxlbmRNb2RlJywgJ29wYWNpdHknLCAnZ3VpZGUnXSxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tuYW1lXTtcblx0XHR9O1xuXHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAodmFsdWUgIT0gdGhpc1tuYW1lXSkge1xuXHRcdFx0XHR0aGlzW25hbWVdID0gdmFsdWU7XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQobmFtZSA9PT0gJ19sb2NrZWQnXG5cdFx0XHRcdFx0XHQ/IDEyOCA6IDEyOSk7XG5cdFx0XHR9XG5cdFx0fTtcbn0sIHt9KSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfbG9ja2VkOiBmYWxzZSxcblxuXHRfdmlzaWJsZTogdHJ1ZSxcblxuXHRfYmxlbmRNb2RlOiAnbm9ybWFsJyxcblxuXHRfb3BhY2l0eTogMSxcblxuXHRfZ3VpZGU6IGZhbHNlLFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9zZWxlY3RDaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmICh0aGlzLl9jaGlsZHJlbltpXS5pc1NlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG5vQ2hpbGRyZW4pIHtcblx0XHRpZiAoIW5vQ2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdGlmICgoc2VsZWN0ZWQgPSAhIXNlbGVjdGVkKSBeIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0dGhpcy5fcHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRfc2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCF0aGlzLl9jaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRydWUpO1xuXHR9LFxuXG5cdGlzQ2xpcE1hc2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGlwTWFzaztcblx0fSxcblxuXHRzZXRDbGlwTWFzazogZnVuY3Rpb24oY2xpcE1hc2spIHtcblx0XHRpZiAodGhpcy5fY2xpcE1hc2sgIT0gKGNsaXBNYXNrID0gISFjbGlwTWFzaykpIHtcblx0XHRcdHRoaXMuX2NsaXBNYXNrID0gY2xpcE1hc2s7XG5cdFx0XHRpZiAoY2xpcE1hc2spIHtcblx0XHRcdFx0dGhpcy5zZXRGaWxsQ29sb3IobnVsbCk7XG5cdFx0XHRcdHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0XHR0aGlzLl9wYXJlbnQuX2NoYW5nZWQoMTAyNCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbGlwTWFzazogZmFsc2UsXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRpZiAoIXBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gPSBwaXZvdFxuXHRcdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdGlmIChwaXZvdCkge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cGl2b3QgPSBuZXcgY3RvcihwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0QW5jaG9yJyk7XG5cdFx0fVxuXHRcdHJldHVybiBwaXZvdDtcblx0fSxcblxuXHRzZXRQaXZvdDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcGl2b3QgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0X3Bpdm90OiBudWxsLFxuXG5cdGdldFJlZ2lzdHJhdGlvbjogJyNnZXRQaXZvdCcsXG5cdHNldFJlZ2lzdHJhdGlvbjogJyNzZXRQaXZvdCdcbn0sIEJhc2UuZWFjaChbJ2JvdW5kcycsICdzdHJva2VCb3VuZHMnLCAnaGFuZGxlQm91bmRzJywgJ3JvdWdoQm91bmRzJyxcblx0XHQnaW50ZXJuYWxCb3VuZHMnLCAnaW50ZXJuYWxSb3VnaEJvdW5kcyddLFxuXHRmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgZ2V0dGVyID0gJ2dldCcgKyBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eaW50ZXJuYWwoLiopJC8pLFxuXHRcdFx0aW50ZXJuYWxHZXR0ZXIgPSBtYXRjaCA/ICdnZXQnICsgbWF0Y2hbMV0gOiBudWxsO1xuXHRcdHRoaXNbZ2V0dGVyXSA9IGZ1bmN0aW9uKF9tYXRyaXgpIHtcblx0XHRcdHZhciBib3VuZHNHZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdG5hbWUgPSAhaW50ZXJuYWxHZXR0ZXIgJiYgKHR5cGVvZiBib3VuZHNHZXR0ZXIgPT09ICdzdHJpbmcnXG5cdFx0XHRcdFx0XHQ/IGJvdW5kc0dldHRlciA6IGJvdW5kc0dldHRlciAmJiBib3VuZHNHZXR0ZXJbZ2V0dGVyXSlcblx0XHRcdFx0XHRcdHx8IGdldHRlcixcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkQm91bmRzKG5hbWUsIF9tYXRyaXgsIG51bGwsXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEdldHRlcik7XG5cdFx0XHRyZXR1cm4ga2V5ID09PSAnYm91bmRzJ1xuXHRcdFx0XHRcdD8gbmV3IExpbmtlZFJlY3RhbmdsZShib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCxcblx0XHRcdFx0XHRcdFx0Ym91bmRzLmhlaWdodCwgdGhpcywgJ3NldEJvdW5kcycpXG5cdFx0XHRcdFx0OiBib3VuZHM7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IHRydWUsXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoID09IDApXG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHZhciB4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQuX3Zpc2libGUgJiYgIWNoaWxkLmlzRW1wdHkoKSkge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGNoaWxkLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSk7XG5cdFx0XHRcdHgxID0gTWF0aC5taW4ocmVjdC54LCB4MSk7XG5cdFx0XHRcdHkxID0gTWF0aC5taW4ocmVjdC55LCB5MSk7XG5cdFx0XHRcdHgyID0gTWF0aC5tYXgocmVjdC54ICsgcmVjdC53aWR0aCwgeDIpO1xuXHRcdFx0XHR5MiA9IE1hdGgubWF4KHJlY3QueSArIHJlY3QuaGVpZ2h0LCB5Mik7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBpc0Zpbml0ZSh4MSlcblx0XHRcdFx0PyBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSlcblx0XHRcdFx0OiBuZXcgUmVjdGFuZ2xlKCk7XG5cdH0sXG5cblx0c2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0Y2VudGVyID0gcmVjdC5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0aWYgKHJlY3Qud2lkdGggIT0gYm91bmRzLndpZHRoIHx8IHJlY3QuaGVpZ2h0ICE9IGJvdW5kcy5oZWlnaHQpIHtcblx0XHRcdG1hdHJpeC5zY2FsZShcblx0XHRcdFx0XHRib3VuZHMud2lkdGggIT0gMCA/IHJlY3Qud2lkdGggLyBib3VuZHMud2lkdGggOiAxLFxuXHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQgIT0gMCA/IHJlY3QuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCA6IDEpO1xuXHRcdH1cblx0XHRjZW50ZXIgPSBib3VuZHMuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZSgtY2VudGVyLngsIC1jZW50ZXIueSk7XG5cdFx0dGhpcy50cmFuc2Zvcm0obWF0cml4KTtcblx0fSxcblxuXHRfZ2V0Q2FjaGVkQm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtLCBpbnRlcm5hbEdldHRlcikge1xuXHRcdG1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdHZhciBfbWF0cml4ID0gaW50ZXJuYWxHZXR0ZXIgPyBudWxsIDogdGhpcy5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdGNhY2hlID0gKCFtYXRyaXggfHwgbWF0cml4LmVxdWFscyhfbWF0cml4KSkgJiYgZ2V0dGVyO1xuXHRcdHZhciBjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCB0aGlzLl9wYXJlbnRTeW1ib2w7XG5cdFx0aWYgKGNhY2hlSXRlbSAmJiBjYWNoZVBhcmVudCkge1xuXHRcdFx0dmFyIGlkID0gY2FjaGVJdGVtLl9pZCxcblx0XHRcdFx0cmVmID0gY2FjaGVQYXJlbnQuX2JvdW5kc0NhY2hlID0gY2FjaGVQYXJlbnQuX2JvdW5kc0NhY2hlIHx8IHtcblx0XHRcdFx0XHRpZHM6IHt9LFxuXHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAoIXJlZi5pZHNbaWRdKSB7XG5cdFx0XHRcdHJlZi5saXN0LnB1c2goY2FjaGVJdGVtKTtcblx0XHRcdFx0cmVmLmlkc1tpZF0gPSBjYWNoZUl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjYWNoZSAmJiB0aGlzLl9ib3VuZHMgJiYgdGhpcy5fYm91bmRzW2NhY2hlXSlcblx0XHRcdHJldHVybiB0aGlzLl9ib3VuZHNbY2FjaGVdLmNsb25lKCk7XG5cdFx0bWF0cml4ID0gIW1hdHJpeFxuXHRcdFx0XHQ/IF9tYXRyaXhcblx0XHRcdFx0OiBfbWF0cml4XG5cdFx0XHRcdFx0PyBtYXRyaXguY2xvbmUoKS5jb25jYXRlbmF0ZShfbWF0cml4KVxuXHRcdFx0XHRcdDogbWF0cml4O1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHMoaW50ZXJuYWxHZXR0ZXIgfHwgZ2V0dGVyLCBtYXRyaXgsXG5cdFx0XHRcdGNhY2hlID8gdGhpcyA6IGNhY2hlSXRlbSk7XG5cdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgY2FjaGVkID0gdGhpcy5fYm91bmRzW2NhY2hlXSA9IGJvdW5kcy5jbG9uZSgpO1xuXHRcdFx0Y2FjaGVkLl9pbnRlcm5hbCA9ICEhaW50ZXJuYWxHZXR0ZXI7XG5cdFx0fVxuXHRcdHJldHVybiBib3VuZHM7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHRpZiAoaXRlbS5fYm91bmRzQ2FjaGUpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGxpc3QgPSBpdGVtLl9ib3VuZHNDYWNoZS5saXN0LCBsID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGNoaWxkID0gbGlzdFtpXTtcblx0XHRcdFx0XHRjaGlsZC5fYm91bmRzID0gY2hpbGQuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdGlmIChjaGlsZCAhPT0gaXRlbSAmJiBjaGlsZC5fYm91bmRzQ2FjaGUpXG5cdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNoaWxkKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpdGVtLl9ib3VuZHNDYWNoZSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2RlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCk7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnJvdGF0aW9uO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCk7XG5cdFx0cmV0dXJuIGRlY29tcG9zZWQgJiYgZGVjb21wb3NlZC5zY2FsaW5nO1xuXHR9LFxuXG5cdHNldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRTY2FsaW5nKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCkge1xuXHRcdFx0dmFyIHNjYWxpbmcgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyBjbG9uZTogdHJ1ZSB9KSxcblx0XHRcdFx0ZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnNjYWxlKHNjYWxpbmcueCAvIGN1cnJlbnQueCwgc2NhbGluZy55IC8gY3VycmVudC55KTtcblx0XHRcdGRlY29tcG9zZWQuc2NhbGluZyA9IHNjYWxpbmc7XG5cdFx0XHR0aGlzLl9kZWNvbXBvc2VkID0gZGVjb21wb3NlZDtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4O1xuXHR9LFxuXG5cdHNldE1hdHJpeDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmluaXRpYWxpemUobWF0cml4KTtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9pbnRlcm5hbCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXgsXG5cdFx0XHR1cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbixcblx0XHRcdHZpZXdNYXRyaXggPSB0aGlzLmdldFZpZXcoKS5fbWF0cml4O1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4Ll91cGRhdGVWZXJzaW9uICE9PSB1cGRhdGVWZXJzaW9uKVxuXHRcdFx0bWF0cml4ID0gbnVsbDtcblx0XHRpZiAoIW1hdHJpeCkge1xuXHRcdFx0bWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4ID0gdGhpcy5fbWF0cml4LmNsb25lKCk7XG5cdFx0XHRtYXRyaXgucHJlQ29uY2F0ZW5hdGUodGhpcy5fcGFyZW50XG5cdFx0XHRcdFx0PyB0aGlzLl9wYXJlbnQuZ2V0R2xvYmFsTWF0cml4KHRydWUpXG5cdFx0XHRcdFx0OiB2aWV3TWF0cml4KTtcblx0XHRcdG1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0fVxuXHRcdHJldHVybiBfaW50ZXJuYWwgPyBtYXRyaXggOiB2aWV3TWF0cml4LmludmVydGVkKCkuY29uY2F0ZW5hdGUobWF0cml4KTtcblx0fSxcblxuXHRnZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FwcGx5TWF0cml4O1xuXHR9LFxuXG5cdHNldEFwcGx5TWF0cml4OiBmdW5jdGlvbih0cmFuc2Zvcm0pIHtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIXRyYW5zZm9ybSlcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHR9LFxuXG5cdGdldFRyYW5zZm9ybUNvbnRlbnQ6ICcjZ2V0QXBwbHlNYXRyaXgnLFxuXHRzZXRUcmFuc2Zvcm1Db250ZW50OiAnI3NldEFwcGx5TWF0cml4Jyxcbn0sIHtcblx0Z2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Q7XG5cdH0sXG5cblx0X3NldFByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3QsIGluc3RhbGxFdmVudHMpIHtcblx0XHRpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdGluc3RhbGxFdmVudHMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFsbEV2ZW50cylcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG5cdFx0X2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG5cdH0sXG5cblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH0sXG5cblx0c2V0UGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRzZXRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID09PSB0aGlzIHx8IGl0ZW0gJiYgdGhpcy5fY2xhc3MgPT09IGl0ZW0uX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3N0eWxlLmVxdWFscyhpdGVtLl9zdHlsZSlcblx0XHRcdFx0JiYgdGhpcy5fbWF0cml4LmVxdWFscyhpdGVtLl9tYXRyaXgpXG5cdFx0XHRcdCYmIHRoaXMuX2xvY2tlZCA9PT0gaXRlbS5fbG9ja2VkXG5cdFx0XHRcdCYmIHRoaXMuX3Zpc2libGUgPT09IGl0ZW0uX3Zpc2libGVcblx0XHRcdFx0JiYgdGhpcy5fYmxlbmRNb2RlID09PSBpdGVtLl9ibGVuZE1vZGVcblx0XHRcdFx0JiYgdGhpcy5fb3BhY2l0eSA9PT0gaXRlbS5fb3BhY2l0eVxuXHRcdFx0XHQmJiB0aGlzLl9jbGlwTWFzayA9PT0gaXRlbS5fY2xpcE1hc2tcblx0XHRcdFx0JiYgdGhpcy5fZ3VpZGUgPT09IGl0ZW0uX2d1aWRlXG5cdFx0XHRcdCYmIHRoaXMuX2VxdWFscyhpdGVtKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX2NoaWxkcmVuLCBpdGVtLl9jaGlsZHJlbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgdGhpcy5jb25zdHJ1Y3RvcihJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbihjb3B5LCBpbnNlcnQpIHtcblx0XHRjb3B5LnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb3B5LmFkZENoaWxkKHRoaXMuX2NoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Lmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHZhciBrZXlzID0gWydfbG9ja2VkJywgJ192aXNpYmxlJywgJ19ibGVuZE1vZGUnLCAnX29wYWNpdHknLFxuXHRcdFx0XHQnX2NsaXBNYXNrJywgJ19ndWlkZScsICdfYXBwbHlNYXRyaXgnXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGtleSkpXG5cdFx0XHRcdGNvcHlba2V5XSA9IHRoaXNba2V5XTtcblx0XHR9XG5cdFx0Y29weS5fbWF0cml4LmluaXRpYWxpemUodGhpcy5fbWF0cml4KTtcblx0XHRjb3B5Ll9kYXRhID0gdGhpcy5fZGF0YSA/IEJhc2UuY2xvbmUodGhpcy5fZGF0YSkgOiBudWxsO1xuXHRcdGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0Y29weS5zZXROYW1lKHRoaXMuX25hbWUsIHRydWUpO1xuXHRcdHJldHVybiBjb3B5O1xuXHR9LFxuXG5cdGNvcHlUbzogZnVuY3Rpb24oaXRlbU9yUHJvamVjdCkge1xuXHRcdHJldHVybiBpdGVtT3JQcm9qZWN0LmFkZENoaWxkKHRoaXMuY2xvbmUoZmFsc2UpKTtcblx0fSxcblxuXHRyYXN0ZXJpemU6IGZ1bmN0aW9uKHJlc29sdXRpb24pIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoKSxcblx0XHRcdHNjYWxlID0gKHJlc29sdXRpb24gfHwgdGhpcy5nZXRWaWV3KCkuZ2V0UmVzb2x1dGlvbigpKSAvIDcyLFxuXHRcdFx0dG9wTGVmdCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKSxcblx0XHRcdGJvdHRvbVJpZ2h0ID0gYm91bmRzLmdldEJvdHRvbVJpZ2h0KCkuY2VpbCgpLFxuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGJvdHRvbVJpZ2h0LnN1YnRyYWN0KHRvcExlZnQpKSxcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplLm11bHRpcGx5KHNjYWxlKSksXG5cdFx0XHRjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS5zY2FsZShzY2FsZSkudHJhbnNsYXRlKHRvcExlZnQubmVnYXRlKCkpO1xuXHRcdGN0eC5zYXZlKCk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dGhpcy5kcmF3KGN0eCwgbmV3IEJhc2UoeyB0cmFuc2Zvcm1zOiBbbWF0cml4XSB9KSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuXHRcdHJhc3Rlci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZSh0b3BMZWZ0LmFkZChzaXplLmRpdmlkZSgyKSkpXG5cdFx0XHRcdC5zY2FsZSgxIC8gc2NhbGUpKTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fY29udGFpbnMoXG5cdFx0XHRcdHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NoaWxkcmVuW2ldLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRvcHRpb25zID0gSGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpO1xuXHRcdGlmICh0aGlzLl9sb2NrZWQgfHwgIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fZ3VpZGUgJiYgIW9wdGlvbnMuZ3VpZGVzXG5cdFx0XHRcdHx8IHRoaXMuaXNFbXB0eSgpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0cGFyZW50VG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCxcblx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdHRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeFxuXHRcdFx0XHRcdD8gcGFyZW50VG90YWxNYXRyaXguY2xvbmUoKS5jb25jYXRlbmF0ZShtYXRyaXgpXG5cdFx0XHRcdFx0OiB0aGlzLmdldEdsb2JhbE1hdHJpeCgpLmNsb25lKCkucHJlQ29uY2F0ZW5hdGUoXG5cdFx0XHRcdFx0XHRcdHZpZXcuX21hdHJpeCksXG5cdFx0XHR0b2xlcmFuY2VQYWRkaW5nID0gb3B0aW9ucy5fdG9sZXJhbmNlUGFkZGluZyA9IG5ldyBTaXplKFxuXHRcdFx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZygxLCB0b3RhbE1hdHJpeC5pbnZlcnRlZCgpKVxuXHRcdFx0XHRcdCkubXVsdGlwbHkoXG5cdFx0XHRcdFx0XHRNYXRoLm1heChvcHRpb25zLnRvbGVyYW5jZSwgMC4wMDAwMSlcblx0XHRcdFx0XHQpO1xuXHRcdHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHBvaW50KTtcblxuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4gJiYgIXRoaXMuZ2V0SW50ZXJuYWxSb3VnaEJvdW5kcygpXG5cdFx0XHRcdC5leHBhbmQodG9sZXJhbmNlUGFkZGluZy5tdWx0aXBseSgyKSkuX2NvbnRhaW5zUG9pbnQocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHR5cGUsXG5cdFx0XHRjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZVxuXHRcdFx0XHR8fCBvcHRpb25zLnNlbGVjdGVkICYmICF0aGlzLl9zZWxlY3RlZFxuXHRcdFx0XHR8fCAodHlwZSA9IG9wdGlvbnMudHlwZSkgJiYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyB0eXBlICE9PSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0XHRcdDogISh0aGlzIGluc3RhbmNlb2YgdHlwZSkpKSxcblx0XHRcdHRoYXQgPSB0aGlzLFxuXHRcdFx0cmVzO1xuXG5cdFx0ZnVuY3Rpb24gY2hlY2tCb3VuZHModHlwZSwgcGFydCkge1xuXHRcdFx0dmFyIHB0ID0gYm91bmRzWydnZXQnICsgcGFydF0oKTtcblx0XHRcdGlmIChwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHRvbGVyYW5jZVBhZGRpbmcpLmxlbmd0aCA8PSAxKVxuXHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCh0eXBlLCB0aGF0LFxuXHRcdFx0XHRcdFx0eyBuYW1lOiBCYXNlLmh5cGhlbmF0ZShwYXJ0KSwgcG9pbnQ6IHB0IH0pO1xuXHRcdH1cblxuXHRcdGlmIChjaGVja1NlbGYgJiYgKG9wdGlvbnMuY2VudGVyIHx8IG9wdGlvbnMuYm91bmRzKSAmJiB0aGlzLl9wYXJlbnQpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEludGVybmFsQm91bmRzKCk7XG5cdFx0XHRpZiAob3B0aW9ucy5jZW50ZXIpXG5cdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdjZW50ZXInLCAnQ2VudGVyJyk7XG5cdFx0XHRpZiAoIXJlcyAmJiBvcHRpb25zLmJvdW5kcykge1xuXHRcdFx0XHR2YXIgcG9pbnRzID0gW1xuXHRcdFx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXG5cdFx0XHRcdF07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgOCAmJiAhcmVzOyBpKyspXG5cdFx0XHRcdFx0cmVzID0gY2hlY2tCb3VuZHMoJ2JvdW5kcycsIHBvaW50c1tpXSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoaWxkcmVuID0gIXJlcyAmJiB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdHZhciBvcHRzID0gdGhpcy5fZ2V0Q2hpbGRIaXRUZXN0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdGZvciAodmFyIGkgPSBjaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDAgJiYgIXJlczsgaS0tKVxuXHRcdFx0XHRyZXMgPSBjaGlsZHJlbltpXS5oaXRUZXN0KHBvaW50LCBvcHRzKTtcblx0XHR9XG5cdFx0aWYgKCFyZXMgJiYgY2hlY2tTZWxmKVxuXHRcdFx0cmVzID0gdGhpcy5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcyAmJiByZXMucG9pbnQpXG5cdFx0XHRyZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG5cdFx0b3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeDtcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2hpdFRlc3Q6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0aWYgKG9wdGlvbnMuZmlsbCAmJiB0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLl9jb250YWlucyhwb2ludCkpXG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpO1xuXHR9XG59LCB7IFxuXHRtYXRjaGVzOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdGZ1bmN0aW9uIG1hdGNoT2JqZWN0KG9iajEsIG9iajIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gb2JqMSkge1xuXHRcdFx0XHRpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHZhciB2YWwxID0gb2JqMVtpXSxcblx0XHRcdFx0XHRcdHZhbDIgPSBvYmoyW2ldO1xuXHRcdFx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QodmFsMSkgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoT2JqZWN0KHZhbDEsIHZhbDIpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsMSwgdmFsMikpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRmb3IgKHZhciBrZXkgaW4gbWF0Y2gpIHtcblx0XHRcdGlmIChtYXRjaC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXNba2V5XSxcblx0XHRcdFx0XHRjb21wYXJlID0gbWF0Y2hba2V5XTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYga2V5ID09PSAndHlwZScpXG5cdFx0XHRcdFx0dmFsdWUgPSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcyk7XG5cdFx0XHRcdGlmICgvXihjb25zdHJ1Y3RvcnxjbGFzcykkLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgY29tcGFyZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY29tcGFyZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuXHRcdFx0XHRcdGlmICghY29tcGFyZS50ZXN0KHZhbHVlKSlcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgY29tcGFyZSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGlmICghY29tcGFyZSh2YWx1ZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGNvbXBhcmUpKSB7XG5cdFx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdChjb21wYXJlLCB2YWx1ZSkpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjb21wYXJlKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0cnVlKTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIGZhbHNlKTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X2dldEl0ZW1zOiBmdW5jdGlvbiBfZ2V0SXRlbXMoY2hpbGRyZW4sIG1hdGNoLCBsaXN0KSB7XG5cdFx0XHR2YXIgaXRlbXMgPSBsaXN0ICYmIFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC5tYXRjaGVzKG1hdGNoKSkge1xuXHRcdFx0XHRcdGlmIChsaXN0KSB7XG5cdFx0XHRcdFx0XHRpdGVtcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgcmVzID0gX2dldEl0ZW1zKGNoaWxkLl9jaGlsZHJlbiwgbWF0Y2gsIGxpc3QpO1xuXHRcdFx0XHRpZiAobGlzdCkge1xuXHRcdFx0XHRcdGl0ZW1zLnB1c2guYXBwbHkoaXRlbXMsIHJlcyk7XG5cdFx0XHRcdH0gZWxzZSBpZiAocmVzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGxpc3QgPyBpdGVtcyA6IG51bGw7XG5cdFx0fVxuXHR9XG59LCB7XG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdFx0cmV0dXJuIHJlcyAhPT0gdGhpc1xuXHRcdFx0XHQ/IHRoaXMuYWRkQ2hpbGQocmVzKVxuXHRcdFx0XHQ6IHJlcztcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIFtpdGVtXSwgX3ByZXNlcnZlKTtcblx0XHRyZXR1cm4gcmVzICYmIHJlc1swXTtcblx0fSxcblxuXHRhZGRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMsIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkcmVuKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCwgaXRlbXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBfcHJvdG8pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0aXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoaXRlbXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGlmIChfcHJvdG8gJiYgIShpdGVtIGluc3RhbmNlb2YgX3Byb3RvKSkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRCYXNlLnNwbGljZShjaGlsZHJlbiwgaXRlbXMsIGluZGV4LCAwKTtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0bm90aWZ5U2VsZiA9IHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGl0ZW0uX3BhcmVudCA9IHRoaXM7XG5cdFx0XHRcdGl0ZW0uX3NldFByb2plY3QodGhpcy5fcHJvamVjdCwgdHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtLl9uYW1lKVxuXHRcdFx0XHRcdGl0ZW0uc2V0TmFtZShpdGVtLl9uYW1lKTtcblx0XHRcdFx0aWYgKG5vdGlmeVNlbGYpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpdGVtcyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRfaW5zZXJ0OiBmdW5jdGlvbihhYm92ZSwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0aWYgKCFpdGVtLl9wYXJlbnQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgaW5kZXggPSBpdGVtLl9pbmRleCArIChhYm92ZSA/IDEgOiAwKTtcblx0XHRpZiAoaXRlbS5fcGFyZW50ID09PSB0aGlzLl9wYXJlbnQgJiYgaW5kZXggPiB0aGlzLl9pbmRleClcblx0XHRcdCBpbmRleC0tO1xuXHRcdHJldHVybiBpdGVtLl9wYXJlbnQuaW5zZXJ0Q2hpbGQoaW5kZXgsIHRoaXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0QWJvdmU6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLl9pbnNlcnQodHJ1ZSwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRCZWxvdzogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdCBcdHJldHVybiB0aGlzLl9pbnNlcnQoZmFsc2UsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdCB9LFxuXG5cdHNlbmRUb0JhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQuaW5zZXJ0Q2hpbGQoMCwgdGhpcyk7XG5cdH0sXG5cblx0YnJpbmdUb0Zyb250OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50LmFkZENoaWxkKHRoaXMpO1xuXHR9LFxuXG5cdGFwcGVuZFRvcDogJyNhZGRDaGlsZCcsXG5cblx0YXBwZW5kQm90dG9tOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQoMCwgaXRlbSk7XG5cdH0sXG5cblx0bW92ZUFib3ZlOiAnI2luc2VydEFib3ZlJyxcblxuXHRtb3ZlQmVsb3c6ICcjaW5zZXJ0QmVsb3cnLFxuXG5cdHJlZHVjZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5bMF0ucmVkdWNlKCk7XG5cdFx0XHRjaGlsZC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdGNoaWxkLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0XHRyZXR1cm4gY2hpbGQ7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9yZW1vdmVOYW1lZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdG5hbWVkQ2hpbGRyZW4gPSB0aGlzLl9wYXJlbnQuX25hbWVkQ2hpbGRyZW4sXG5cdFx0XHRuYW1lID0gdGhpcy5fbmFtZSxcblx0XHRcdG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuXHRcdFx0aW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG5cdFx0aWYgKGluZGV4ID09IC0xKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmIChjaGlsZHJlbltuYW1lXSA9PSB0aGlzKVxuXHRcdFx0ZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuXHRcdG5hbWVkQXJyYXkuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRpZiAobmFtZWRBcnJheS5sZW5ndGgpIHtcblx0XHRcdGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVtuYW1lZEFycmF5Lmxlbmd0aCAtIDFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgbmFtZWRDaGlsZHJlbltuYW1lXTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24obm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRpZiAocGFyZW50KSB7XG5cdFx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKVxuXHRcdFx0XHRCYXNlLnNwbGljZShwYXJlbnQuX2NoaWxkcmVuLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmKSB7XG5cdFx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRcdFx0aWYgKHByb2plY3QgJiYgcHJvamVjdC5fY2hhbmdlcylcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG5vdGlmeVBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jaGFuZ2VkKDExKTtcblx0XHRcdHRoaXMuX3BhcmVudCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JlbW92ZSh0cnVlLCB0cnVlKTtcblx0fSxcblxuXHRyZW1vdmVDaGlsZHJlbjogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0ZnJvbSA9IGZyb20gfHwgMDtcblx0XHR0byA9IEJhc2UucGljayh0bywgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoKTtcblx0XHR2YXIgcmVtb3ZlZCA9IEJhc2Uuc3BsaWNlKHRoaXMuX2NoaWxkcmVuLCBudWxsLCBmcm9tLCB0byAtIGZyb20pO1xuXHRcdGZvciAodmFyIGkgPSByZW1vdmVkLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRyZW1vdmVkW2ldLl9yZW1vdmUodHJ1ZSwgZmFsc2UpO1xuXHRcdH1cblx0XHRpZiAocmVtb3ZlZC5sZW5ndGggPiAwKVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xlYXI6ICcjcmVtb3ZlQ2hpbGRyZW4nLFxuXG5cdHJldmVyc2VDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHR0aGlzLl9jaGlsZHJlbi5yZXZlcnNlKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uX2luZGV4ID0gaTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdH1cblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NoaWxkcmVuIHx8IHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA9PSAwO1xuXHR9LFxuXG5cdGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtID0gdGhpcztcblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2dldE9yZGVyOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0ZnVuY3Rpb24gZ2V0TGlzdChpdGVtKSB7XG5cdFx0XHR2YXIgbGlzdCA9IFtdO1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRsaXN0LnVuc2hpZnQoaXRlbSk7XG5cdFx0XHR9IHdoaWxlIChpdGVtID0gaXRlbS5fcGFyZW50KTtcblx0XHRcdHJldHVybiBsaXN0O1xuXHRcdH1cblx0XHR2YXIgbGlzdDEgPSBnZXRMaXN0KHRoaXMpLFxuXHRcdFx0bGlzdDIgPSBnZXRMaXN0KGl0ZW0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gTWF0aC5taW4obGlzdDEubGVuZ3RoLCBsaXN0Mi5sZW5ndGgpOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAobGlzdDFbaV0gIT0gbGlzdDJbaV0pIHtcblx0XHRcdFx0cmV0dXJuIGxpc3QxW2ldLl9pbmRleCA8IGxpc3QyW2ldLl9pbmRleCA/IDEgOiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0aGFzQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPiAwO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09IGl0ZW0pXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNBbmNlc3RvcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID8gaXRlbS5pc0Rlc2NlbmRhbnQodGhpcykgOiBmYWxzZTtcblx0fSxcblxuXHRpc0dyb3VwZWRXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHR3aGlsZSAocGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50Ll9wYXJlbnRcblx0XHRcdFx0JiYgL14oR3JvdXB8TGF5ZXJ8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcylcblx0XHRcdFx0JiYgaXRlbS5pc0Rlc2NlbmRhbnQocGFyZW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbXggPSBuZXcgTWF0cml4KCk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG14LnRyYW5zbGF0ZS5hcHBseShteCwgYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnJvdGF0ZShhbmdsZSxcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMsIDEsIHsgcmVhZE51bGw6IHRydWUgfSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ3NjYWxlJywgJ3NoZWFyJywgJ3NrZXcnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSk7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKVtuYW1lXShwb2ludCxcblx0XHRcdFx0Y2VudGVyIHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fTtcbn0sIHtcblxufSksIHtcblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgsIF9hcHBseU1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0dmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRhcHBseU1hdHJpeCA9IChfYXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXgpXG5cdFx0XHRcdCYmICghX21hdHJpeC5pc0lkZW50aXR5KCkgfHwgbWF0cml4KTtcblx0XHRpZiAoIW1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0X21hdHJpeC5wcmVDb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdGlmIChhcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4ICYmIHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoX21hdHJpeCkpIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90LFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IodHJ1ZSksXG5cdFx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IodHJ1ZSk7XG5cdFx0XHRpZiAocGl2b3QpXG5cdFx0XHRcdHBpdm90LnRyYW5zZm9ybShfbWF0cml4KTtcblx0XHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRcdGZpbGxDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRpZiAoc3Ryb2tlQ29sb3IpXG5cdFx0XHRcdHN0cm9rZUNvbG9yLnRyYW5zZm9ybShfbWF0cml4KTtcblx0XHRcdF9tYXRyaXgucmVzZXQodHJ1ZSk7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHMsXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0dmFyIGRlY29tcCA9IGJvdW5kcyAmJiBtYXRyaXggJiYgbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdGlmIChkZWNvbXAgJiYgIWRlY29tcC5zaGVhcmluZyAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGJvdW5kc1trZXldO1xuXHRcdFx0XHRpZiAoYXBwbHlNYXRyaXggfHwgIXJlY3QuX2ludGVybmFsKVxuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGdldHRlciA9IHRoaXMuX2JvdW5kc0dldHRlcixcblx0XHRcdFx0cmVjdCA9IGJvdW5kc1tnZXR0ZXIgJiYgZ2V0dGVyLmdldEJvdW5kcyB8fCBnZXR0ZXIgfHwgJ2dldEJvdW5kcyddO1xuXHRcdFx0aWYgKHJlY3QpXG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXggJiYgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0udHJhbnNmb3JtKG1hdHJpeCwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCk7XG5cdFx0cmV0dXJuIG1hdHJpeCAmJiBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRsb2NhbFRvR2xvYmFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5nZXRHbG9iYWxNYXRyaXgoKTtcblx0XHRyZXR1cm4gbWF0cml4ICYmIG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgZmlsbCkge1xuXHRcdHJlY3RhbmdsZSA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRpdGVtUmF0aW8gPSBib3VuZHMuaGVpZ2h0IC8gYm91bmRzLndpZHRoLFxuXHRcdFx0cmVjdFJhdGlvID0gcmVjdGFuZ2xlLmhlaWdodCAvIHJlY3RhbmdsZS53aWR0aCxcblx0XHRcdHNjYWxlID0gKGZpbGwgPyBpdGVtUmF0aW8gPiByZWN0UmF0aW8gOiBpdGVtUmF0aW8gPCByZWN0UmF0aW8pXG5cdFx0XHRcdFx0PyByZWN0YW5nbGUud2lkdGggLyBib3VuZHMud2lkdGhcblx0XHRcdFx0XHQ6IHJlY3RhbmdsZS5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0LFxuXHRcdFx0bmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSxcblx0XHRcdFx0XHRuZXcgU2l6ZShib3VuZHMud2lkdGggKiBzY2FsZSwgYm91bmRzLmhlaWdodCAqIHNjYWxlKSk7XG5cdFx0bmV3Qm91bmRzLnNldENlbnRlcihyZWN0YW5nbGUuZ2V0Q2VudGVyKCkpO1xuXHRcdHRoaXMuc2V0Qm91bmRzKG5ld0JvdW5kcyk7XG5cdH0sXG5cblx0X3NldFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IoKSxcblx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IoKSxcblx0XHRcdHNoYWRvd0NvbG9yID0gc3R5bGUuZ2V0U2hhZG93Q29sb3IoKTtcblx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0aWYgKHN0cm9rZUNvbG9yKSB7XG5cdFx0XHR2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdFx0aWYgKHN0cm9rZVdpZHRoID4gMCkge1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblx0XHRcdFx0dmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRcdFx0c3Ryb2tlQ2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0aWYgKHN0cm9rZUpvaW4pXG5cdFx0XHRcdFx0Y3R4LmxpbmVKb2luID0gc3Ryb2tlSm9pbjtcblx0XHRcdFx0aWYgKHN0cm9rZUNhcClcblx0XHRcdFx0XHRjdHgubGluZUNhcCA9IHN0cm9rZUNhcDtcblx0XHRcdFx0aWYgKG1pdGVyTGltaXQpXG5cdFx0XHRcdFx0Y3R4Lm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdFx0XHRpZiAocGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoKSB7XG5cdFx0XHRcdFx0dmFyIGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRcdFx0ZGFzaE9mZnNldCA9IHN0eWxlLmdldERhc2hPZmZzZXQoKTtcblx0XHRcdFx0XHRpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICgnc2V0TGluZURhc2gnIGluIGN0eCkge1xuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoID0gZGFzaEFycmF5O1xuXHRcdFx0XHRcdFx0XHRjdHgubW96RGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzaGFkb3dDb2xvcikge1xuXHRcdFx0dmFyIHNoYWRvd0JsdXIgPSBzdHlsZS5nZXRTaGFkb3dCbHVyKCk7XG5cdFx0XHRpZiAoc2hhZG93Qmx1ciA+IDApIHtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0XHRjdHguc2hhZG93Qmx1ciA9IHNoYWRvd0JsdXI7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmdldFNoYWRvd09mZnNldCgpO1xuXHRcdFx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuXHRcdFx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IG9mZnNldC55O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0aWYgKCF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX29wYWNpdHkgPT09IDApXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcblx0XHR2YXIgdHJhY2tUcmFuc2Zvcm1zID0gcGFyYW0udHJhY2tUcmFuc2Zvcm1zLFxuXHRcdFx0dHJhbnNmb3JtcyA9IHBhcmFtLnRyYW5zZm9ybXMsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRwYXJlbnRNYXRyaXggPSB0cmFuc2Zvcm1zW3RyYW5zZm9ybXMubGVuZ3RoIC0gMV0sXG5cdFx0XHRnbG9iYWxNYXRyaXggPSBwYXJlbnRNYXRyaXguY2xvbmUoKS5jb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdGlmICghZ2xvYmFsTWF0cml4LmlzSW52ZXJ0aWJsZSgpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdGlmICh0cmFja1RyYW5zZm9ybXMpIHtcblx0XHRcdHRyYW5zZm9ybXMucHVzaCh0aGlzLl9nbG9iYWxNYXRyaXggPSBnbG9iYWxNYXRyaXgpO1xuXHRcdFx0Z2xvYmFsTWF0cml4Ll91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHR9XG5cblx0XHR2YXIgYmxlbmRNb2RlID0gdGhpcy5fYmxlbmRNb2RlLFxuXHRcdFx0b3BhY2l0eSA9IHRoaXMuX29wYWNpdHksXG5cdFx0XHRub3JtYWxCbGVuZCA9IGJsZW5kTW9kZSA9PT0gJ25vcm1hbCcsXG5cdFx0XHRuYXRpdmVCbGVuZCA9IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1tibGVuZE1vZGVdLFxuXHRcdFx0ZGlyZWN0ID0gbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA9PT0gMVxuXHRcdFx0XHRcdHx8IHBhcmFtLmNsaXBcblx0XHRcdFx0XHR8fCAobmF0aXZlQmxlbmQgfHwgbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA8IDEpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLl9jYW5Db21wb3NpdGUoKSxcblx0XHRcdG1haW5DdHgsIGl0ZW1PZmZzZXQsIHByZXZPZmZzZXQ7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcyhwYXJlbnRNYXRyaXgpO1xuXHRcdFx0aWYgKCFib3VuZHMud2lkdGggfHwgIWJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXZPZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpdGVtT2Zmc2V0ID0gcGFyYW0ub2Zmc2V0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpO1xuXHRcdFx0bWFpbkN0eCA9IGN0eDtcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoXG5cdFx0XHRcdFx0Ym91bmRzLmdldFNpemUoKS5jZWlsKCkuYWRkKG5ldyBTaXplKDEsIDEpKSxcblx0XHRcdFx0XHRwYXJhbS5waXhlbFJhdGlvKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRpZiAoZGlyZWN0KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXHRcdFx0aWYgKG5hdGl2ZUJsZW5kKVxuXHRcdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdHgudHJhbnNsYXRlKC1pdGVtT2Zmc2V0LngsIC1pdGVtT2Zmc2V0LnkpO1xuXHRcdH1cblx0XHQoZGlyZWN0ID8gbWF0cml4IDogZ2xvYmFsTWF0cml4KS5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdGlmICghZGlyZWN0ICYmIHBhcmFtLmNsaXBJdGVtKVxuXHRcdFx0cGFyYW0uY2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdHRoaXMuX2RyYXcoY3R4LCBwYXJhbSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRpZiAodHJhY2tUcmFuc2Zvcm1zKVxuXHRcdFx0dHJhbnNmb3Jtcy5wb3AoKTtcblx0XHRpZiAocGFyYW0uY2xpcCAmJiAhcGFyYW0uZG9udEZpbmlzaClcblx0XHRcdGN0eC5jbGlwKCk7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdEJsZW5kTW9kZS5wcm9jZXNzKGJsZW5kTW9kZSwgY3R4LCBtYWluQ3R4LCBvcGFjaXR5LFxuXHRcdFx0XHRcdGl0ZW1PZmZzZXQuc3VidHJhY3QocHJldk9mZnNldCkubXVsdGlwbHkocGFyYW0ucGl4ZWxSYXRpbykpO1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0cGFyYW0ub2Zmc2V0ID0gcHJldk9mZnNldDtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59LCBCYXNlLmVhY2goWydkb3duJywgJ2RyYWcnLCAndXAnLCAnbW92ZSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHRoaXNbJ3JlbW92ZU9uJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzaCA9IHt9O1xuXHRcdGhhc2hbbmFtZV0gPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZU9uKGhhc2gpO1xuXHR9O1xufSwge1xuXG5cdHJlbW92ZU9uOiBmdW5jdGlvbihvYmopIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0aWYgKG9ialtuYW1lXSkge1xuXHRcdFx0XHR2YXIga2V5ID0gJ21vdXNlJyArIG5hbWUsXG5cdFx0XHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdFx0c2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV0gPSBzZXRzW2tleV0gfHwge307XG5cdFx0XHRcdHNldHNba2V5XVt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSkpO1xuXG52YXIgR3JvdXAgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyb3VwJyxcblx0X3NlbGVjdENoaWxkcmVuOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpXG5cdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiAoMiB8IDEwMjQpKSB7XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0X2dldENsaXBJdGVtOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcblx0XHRpZiAoY2xpcEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2xpcEl0ZW0gPSBudWxsO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC5fY2xpcE1hc2spIHtcblx0XHRcdFx0XHRjbGlwSXRlbSA9IGNoaWxkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IGNsaXBJdGVtO1xuXHRcdH1cblx0XHRyZXR1cm4gY2xpcEl0ZW07XG5cdH0sXG5cblx0aXNDbGlwcGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHR9LFxuXG5cdHNldENsaXBwZWQ6IGZ1bmN0aW9uKGNsaXBwZWQpIHtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRpZiAoY2hpbGQpXG5cdFx0XHRjaGlsZC5zZXRDbGlwTWFzayhjbGlwcGVkKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHZhciBjbGlwID0gcGFyYW0uY2xpcCxcblx0XHRcdGNsaXBJdGVtID0gIWNsaXAgJiYgdGhpcy5fZ2V0Q2xpcEl0ZW0oKSxcblx0XHRcdGRyYXcgPSB0cnVlO1xuXHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgY2xpcEl0ZW06IGNsaXBJdGVtLCBjbGlwOiBmYWxzZSB9KTtcblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdFx0XHRkcmF3ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdHBhcmFtLmRvbnRTdGFydCA9IHBhcmFtLmRvbnRGaW5pc2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY2xpcEl0ZW0pIHtcblx0XHRcdGNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHR9XG5cdFx0aWYgKGRyYXcpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChpdGVtICE9PSBjbGlwSXRlbSlcblx0XHRcdFx0XHRpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgTGF5ZXIgPSBHcm91cC5leHRlbmQoe1xuXHRfY2xhc3M6ICdMYXllcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTGF5ZXIoYXJnKSB7XG5cdFx0dmFyIHByb3BzID0gQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0PyBuZXcgQmFzZShhcmcpIFxuXHRcdFx0XHQ6IHsgY2hpbGRyZW46IEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyB9LFxuXHRcdFx0aW5zZXJ0ID0gcHJvcHMuaW5zZXJ0O1xuXHRcdHByb3BzLmluc2VydCA9IGZhbHNlO1xuXHRcdEdyb3VwLmNhbGwodGhpcywgcHJvcHMpO1xuXHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuX3Byb2plY3QuYWRkQ2hpbGQodGhpcyk7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uIF9yZW1vdmUobm90aWZ5KSB7XG5cdFx0aWYgKHRoaXMuX3BhcmVudClcblx0XHRcdHJldHVybiBfcmVtb3ZlLmJhc2UuY2FsbCh0aGlzLCBub3RpZnkpO1xuXHRcdGlmICh0aGlzLl9pbmRleCAhPSBudWxsKSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdC5hY3RpdmVMYXllciA9PT0gdGhpcylcblx0XHRcdFx0dGhpcy5fcHJvamVjdC5hY3RpdmVMYXllciA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKVxuXHRcdFx0XHRcdFx0fHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Byb2plY3QubGF5ZXJzLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBnZXROZXh0U2libGluZy5iYXNlLmNhbGwodGhpcylcblx0XHRcdFx0OiB0aGlzLl9wcm9qZWN0LmxheWVyc1t0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiBnZXRQcmV2aW91c1NpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldFByZXZpb3VzU2libGluZy5iYXNlLmNhbGwodGhpcylcblx0XHRcdFx0OiB0aGlzLl9wcm9qZWN0LmxheWVyc1t0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24gaXNJbnNlcnRlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gaXNJbnNlcnRlZC5iYXNlLmNhbGwodGhpcykgOiB0aGlzLl9pbmRleCAhPSBudWxsO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0LmFjdGl2ZUxheWVyID0gdGhpcztcblx0fSxcblxuXHRfaW5zZXJ0OiBmdW5jdGlvbiBfaW5zZXJ0KGFib3ZlLCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIExheWVyICYmICFpdGVtLl9wYXJlbnQpIHtcblx0XHRcdHRoaXMuX3JlbW92ZSh0cnVlLCB0cnVlKTtcblx0XHRcdEJhc2Uuc3BsaWNlKGl0ZW0uX3Byb2plY3QubGF5ZXJzLCBbdGhpc10sXG5cdFx0XHRcdFx0aXRlbS5faW5kZXggKyAoYWJvdmUgPyAxIDogMCksIDApO1xuXHRcdFx0dGhpcy5fc2V0UHJvamVjdChpdGVtLl9wcm9qZWN0LCB0cnVlKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRyZXR1cm4gX2luc2VydC5iYXNlLmNhbGwodGhpcywgYWJvdmUsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH1cbn0pO1xuXG52YXIgU2hhcGUgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NoYXBlJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0dHlwZTogbnVsbCxcblx0XHRzaXplOiBudWxsLFxuXHRcdHJhZGl1czogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNoYXBlKHByb3BzKSB7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShwcm9wcyk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSBpdGVtLl90eXBlXG5cdFx0XHQmJiB0aGlzLl9zaXplLmVxdWFscyhpdGVtLl9zaXplKVxuXHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fcmFkaXVzLCBpdGVtLl9yYWRpdXMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBTaGFwZShJdGVtLk5PX0lOU0VSVCk7XG5cdFx0Y29weS5zZXRUeXBlKHRoaXMuX3R5cGUpO1xuXHRcdGNvcHkuc2V0U2l6ZSh0aGlzLl9zaXplKTtcblx0XHRjb3B5LnNldFJhZGl1cyh0aGlzLl9yYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9LFxuXG5cdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0fSxcblxuXHRnZXRTaGFwZTogJyNnZXRUeXBlJyxcblx0c2V0U2hhcGU6ICcjc2V0VHlwZScsXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghdGhpcy5fc2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcblx0XHR9IGVsc2UgaWYgKCF0aGlzLl9zaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBTaXplLm1pbih0aGlzLl9yYWRpdXMsIHNpemUuZGl2aWRlKDIpKTtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChyYWRpdXMud2lkdGgsIHJhZGl1cy5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHR3aWR0aCA9IGhlaWdodCA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSB3aWR0aCAvIDI7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zaXplLnNldCh3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJhZCA9IHRoaXMuX3JhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gJ2NpcmNsZSdcblx0XHRcdFx0PyByYWRcblx0XHRcdFx0OiBuZXcgTGlua2VkU2l6ZShyYWQud2lkdGgsIHJhZC5oZWlnaHQsIHRoaXMsICdzZXRSYWRpdXMnKTtcblx0fSxcblxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uKHJhZGl1cykge1xuXHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZTtcblx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdGlmIChyYWRpdXMgPT09IHRoaXMuX3JhZGl1cylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHNpemUgPSByYWRpdXMgKiAyO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdFx0dGhpcy5fc2l6ZS5zZXQoc2l6ZSwgc2l6ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0aWYgKCF0aGlzLl9yYWRpdXMpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gcmFkaXVzLmNsb25lKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fcmFkaXVzLmVxdWFscyhyYWRpdXMpKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChyYWRpdXMud2lkdGgsIHJhZGl1cy5oZWlnaHQpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUubWF4KHRoaXMuX3NpemUsIHJhZGl1cy5tdWx0aXBseSgyKSk7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuc2V0KHJhZGl1cy53aWR0aCAqIDIsIHJhZGl1cy5oZWlnaHQgKiAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0b1BhdGg6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBwYXRoID0gbmV3IFBhdGhbQmFzZS5jYXBpdGFsaXplKHRoaXMuX3R5cGUpXSh7XG5cdFx0XHRjZW50ZXI6IG5ldyBQb2ludCgpLFxuXHRcdFx0c2l6ZTogdGhpcy5fc2l6ZSxcblx0XHRcdHJhZGl1czogdGhpcy5fcmFkaXVzLFxuXHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdH0pO1xuXHRcdHBhdGguc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdHBhdGgudHJhbnNmb3JtKHRoaXMuX21hdHJpeCk7XG5cdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcDtcblx0XHRpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgfHwgZG9udFBhaW50KSB7XG5cdFx0XHR2YXIgcmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHR0eXBlID0gdGhpcy5fdHlwZTtcblx0XHRcdGlmICghcGFyYW0uZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0Y3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0XHR2YXJcdGN4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRcdGN5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0XHRjdHgubW92ZVRvKC1yeCwgMCk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oLXJ4LCAtY3ksIC1jeCwgLXJ5LCAwLCAtcnkpO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGN4LCAtcnksIHJ4LCAtY3ksIHJ4LCAwKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhyeCwgY3ksIGN4LCByeSwgMCwgcnkpO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKC1jeCwgcnksIC1yeCwgY3ksIC1yeCwgMCk7XG5cdFx0XHRcdH0gZWxzZSB7IFxuXHRcdFx0XHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZSxcblx0XHRcdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0XHRcdGlmIChyeCA9PT0gMCAmJiByeSA9PT0gMCkge1xuXHRcdFx0XHRcdFx0Y3R4LnJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRrYXBwYSA9IDEgLSBrYXBwYTtcblx0XHRcdFx0XHRcdHZhciB4ID0gd2lkdGggLyAyLFxuXHRcdFx0XHRcdFx0XHR5ID0gaGVpZ2h0IC8gMixcblx0XHRcdFx0XHRcdFx0Y3ggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdFx0XHRjeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdFx0XHRjdHgubW92ZVRvKC14LCAteSArIHJ5KTtcblx0XHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKC14LCAteSArIGN5LCAteCArIGN4LCAteSwgLXggKyByeCwgLXkpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh4IC0gcngsIC15KTtcblx0XHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKHggLSBjeCwgLXksIHgsIC15ICsgY3ksIHgsIC15ICsgcnkpO1xuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyh4LCB5IC0gcnkpO1xuXHRcdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oeCwgeSAtIGN5LCB4IC0gY3gsIHksIHggLSByeCwgeSk7XG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKC14ICsgcngsIHkpO1xuXHRcdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oLXggKyBjeCwgeSwgLXgsIHkgLSBjeSwgLXgsIHkgLSByeSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdGlmIChnZXR0ZXIgIT09ICdnZXRCb3VuZHMnICYmIHRoaXMuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZWN0ID0gcmVjdC5leHBhbmQodGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkgeyBcblxuXHRmdW5jdGlvbiBnZXRDb3JuZXJDZW50ZXIodGhhdCwgcG9pbnQsIGV4cGFuZCkge1xuXHRcdHZhciByYWRpdXMgPSB0aGF0Ll9yYWRpdXM7XG5cdFx0aWYgKCFyYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBoYWxmU2l6ZSA9IHRoYXQuX3NpemUuZGl2aWRlKDIpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0dmFyIGRpciA9IG5ldyBQb2ludChpICYgMSA/IDEgOiAtMSwgaSA+IDEgPyAxIDogLTEpLFxuXHRcdFx0XHRcdGNvcm5lciA9IGRpci5tdWx0aXBseShoYWxmU2l6ZSksXG5cdFx0XHRcdFx0Y2VudGVyID0gY29ybmVyLnN1YnRyYWN0KGRpci5tdWx0aXBseShyYWRpdXMpKSxcblx0XHRcdFx0XHRyZWN0ID0gbmV3IFJlY3RhbmdsZShjb3JuZXIsIGNlbnRlcik7XG5cdFx0XHRcdGlmICgoZXhwYW5kID8gcmVjdC5leHBhbmQoZXhwYW5kKSA6IHJlY3QpLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gY2VudGVyO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEVsbGlwc2VSYWRpdXMocG9pbnQsIHJhZGl1cykge1xuXHRcdHZhciBhbmdsZSA9IHBvaW50LmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHR3aWR0aCA9IHJhZGl1cy53aWR0aCAqIDIsXG5cdFx0XHRoZWlnaHQgPSByYWRpdXMuaGVpZ2h0ICogMixcblx0XHRcdHggPSB3aWR0aCAqIE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHkgPSBoZWlnaHQgKiBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cmV0dXJuIHdpZHRoICogaGVpZ2h0IC8gKDIgKiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfY29udGFpbnM6IGZ1bmN0aW9uIF9jb250YWlucyhwb2ludCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY2VudGVyXG5cdFx0XHRcdFx0XHQ/IHBvaW50LnN1YnRyYWN0KGNlbnRlcikuZGl2aWRlKHRoaXMuX3JhZGl1cylcblx0XHRcdFx0XHRcdFx0LmdldExlbmd0aCgpIDw9IDFcblx0XHRcdFx0XHRcdDogX2NvbnRhaW5zLmJhc2UuY2FsbCh0aGlzLCBwb2ludCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcG9pbnQuZGl2aWRlKHRoaXMuc2l6ZSkuZ2V0TGVuZ3RoKCkgPD0gMC41O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGl0VGVzdDogZnVuY3Rpb24gX2hpdFRlc3QocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBoaXQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKCkgKyAyICogb3B0aW9ucy50b2xlcmFuY2U7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHQgPSBwb2ludC5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRcdFx0aGl0ID0gMiAqIE1hdGguYWJzKHB0LmdldExlbmd0aCgpXG5cdFx0XHRcdFx0XHRcdFx0LSBnZXRFbGxpcHNlUmFkaXVzKHB0LCByYWRpdXMpKSA8PSBzdHJva2VXaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChzdHJva2VXaWR0aCksXG5cdFx0XHRcdFx0XHRcdGlubmVyID0gcmVjdC5leHBhbmQoLXN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAnZWxsaXBzZScpXG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpO1xuXHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwb2ludC5nZXRMZW5ndGgoKSAtIHJhZGl1cylcblx0XHRcdFx0XHRcdFx0PD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoaXRcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ3N0cm9rZScsIHRoaXMpXG5cdFx0XHRcdFx0OiBfaGl0VGVzdC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5zdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGNyZWF0ZVNoYXBlKHR5cGUsIHBvaW50LCBzaXplLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgaXRlbSA9IG5ldyBTaGFwZShCYXNlLmdldE5hbWVkKGFyZ3MpKTtcblx0XHRpdGVtLl90eXBlID0gdHlwZTtcblx0XHRpdGVtLl9zaXplID0gc2l6ZTtcblx0XHRpdGVtLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIGl0ZW0udHJhbnNsYXRlKHBvaW50KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdjaXJjbGUnLCBjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyAqIDIpLCByYWRpdXMsXG5cdFx0XHRcdFx0YXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0UmVjdGFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmd1bWVudHMsICdyZWN0YW5nbGUnKSxcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5taW4oU2l6ZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgncmVjdGFuZ2xlJywgcmVjdC5nZXRDZW50ZXIodHJ1ZSksXG5cdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLCByYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKSxcblx0XHRcdFx0cmFkaXVzID0gZWxsaXBzZS5yYWRpdXM7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2VsbGlwc2UnLCBlbGxpcHNlLmNlbnRlciwgcmFkaXVzLm11bHRpcGx5KDIpLFxuXHRcdFx0XHRcdHJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0X3JlYWRFbGxpcHNlOiBmdW5jdGlvbihhcmdzKSB7XG5cdFx0XHR2YXIgY2VudGVyLFxuXHRcdFx0XHRyYWRpdXM7XG5cdFx0XHRpZiAoQmFzZS5oYXNOYW1lZChhcmdzLCAncmFkaXVzJykpIHtcblx0XHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKTtcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKTtcblx0XHRcdFx0Y2VudGVyID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHRcdHJhZGl1cyA9IHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geyBjZW50ZXI6IGNlbnRlciwgcmFkaXVzOiByYWRpdXMgfTtcblx0XHR9XG5cdH07XG59fSk7XG5cbnZhciBSYXN0ZXIgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Jhc3RlcicsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzb3VyY2U6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSYXN0ZXIob2JqZWN0LCBwb3NpdGlvbikge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShvYmplY3QsXG5cdFx0XHRcdHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0U291cmNlKG9iamVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKG9iamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghdGhpcy5fc2l6ZSlcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZSgpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKSxcblx0XHRcdGltYWdlID0gdGhpcy5faW1hZ2UsXG5cdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHRjb3B5LnNldEltYWdlKGltYWdlKTtcblx0XHR9IGVsc2UgaWYgKGNhbnZhcykge1xuXHRcdFx0dmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXModGhpcy5fc2l6ZSk7XG5cdFx0XHRjb3B5Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cdFx0XHRjb3B5LnNldENhbnZhcyhjb3B5Q2FudmFzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0XHR0aGlzLnNldENhbnZhcyhDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSkpO1xuXHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplLndpZHRoO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NpemUuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplLndpZHRoID09IDAgJiYgdGhpcy5fc2l6ZS5oZWlnaHQgPT0gMDtcblx0fSxcblxuXHRnZXRQcGk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0dSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcblx0XHRcdHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0NzIgLyB1LmdldExlbmd0aCgpLFxuXHRcdFx0NzIgLyB2LmdldExlbmd0aCgpXG5cdFx0KTtcblx0fSxcblxuXHRnZXRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xuXHR9LFxuXG5cdHNldEltYWdlOiBmdW5jdGlvbihpbWFnZSkge1xuXHRcdGlmICh0aGlzLl9jYW52YXMpXG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0aWYgKGltYWdlLmdldENvbnRleHQpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IGltYWdlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IGltYWdlO1xuXHRcdFx0dGhpcy5fY2FudmFzID0gbnVsbDtcblx0XHR9XG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKFxuXHRcdFx0XHRpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGgsXG5cdFx0XHRcdGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0KTtcblx0XHR0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDkgfCA1MTMpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihtb2RpZnkpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRleHQpXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChtb2RpZnkpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5nZWQoNTEzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0aW1hZ2U7XG5cblx0XHRmdW5jdGlvbiBsb2FkZWQoKSB7XG5cdFx0XHR2YXIgdmlldyA9IHRoYXQuZ2V0VmlldygpO1xuXHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0cGFwZXIgPSB2aWV3Ll9zY29wZTtcblx0XHRcdFx0dGhhdC5zZXRJbWFnZShpbWFnZSk7XG5cdFx0XHRcdHRoYXQuZmlyZSgnbG9hZCcpO1xuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdFx0aW1hZ2UgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzcmMpIHx8IG5ldyBJbWFnZSgpO1xuXG5cdFx0aWYgKGltYWdlLm5hdHVyYWxXaWR0aCAmJiBpbWFnZS5uYXR1cmFsSGVpZ2h0KSB7XG5cdFx0XHRzZXRUaW1lb3V0KGxvYWRlZCwgMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdERvbUV2ZW50LmFkZChpbWFnZSwge1xuXHRcdFx0XHRsb2FkOiBsb2FkZWRcblx0XHRcdH0pO1xuXHRcdFx0aWYgKCFpbWFnZS5zcmMpXG5cdFx0XHRcdGltYWdlLnNyYyA9IHNyYztcblx0XHR9XG5cdFx0dGhpcy5zZXRJbWFnZShpbWFnZSk7XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcyB8fCB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKHJlY3QpIHsgXG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChyZWN0LmdldFNpemUoKSk7XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmdldENhbnZhcygpLCByZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gY3R4LmNhbnZhcztcblx0fSxcblxuXHRnZXRTdWJSYXN0ZXI6IGZ1bmN0aW9uKHJlY3QpIHsgXG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0cmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldENhbnZhcyh0aGlzLmdldFN1YkNhbnZhcyhyZWN0KSk7XG5cdFx0cmFzdGVyLnRyYW5zbGF0ZShyZWN0LmdldENlbnRlcigpLnN1YnRyYWN0KHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZSgyKSkpO1xuXHRcdHJhc3Rlci5fbWF0cml4LnByZUNvbmNhdGVuYXRlKHRoaXMuX21hdHJpeCk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0dG9EYXRhVVJMOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3JjID0gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2Uuc3JjO1xuXHRcdGlmICgvXmRhdGE6Ly50ZXN0KHNyYykpXG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuXHRcdHJldHVybiBjYW52YXMgPyBjYW52YXMudG9EYXRhVVJMKCkgOiBudWxsO1xuXHR9LFxuXG5cdGRyYXdJbWFnZTogZnVuY3Rpb24oaW1hZ2UgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoaW1hZ2UsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEF2ZXJhZ2VDb2xvcjogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0dmFyIGJvdW5kcywgcGF0aDtcblx0XHRpZiAoIW9iamVjdCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFBhdGhJdGVtKSB7XG5cdFx0XHRwYXRoID0gb2JqZWN0O1xuXHRcdFx0Ym91bmRzID0gb2JqZWN0LmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0LndpZHRoKSB7XG5cdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QueCkge1xuXHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QueCAtIDAuNSwgb2JqZWN0LnkgLSAwLjUsIDEsIDEpO1xuXHRcdH1cblx0XHR2YXIgc2FtcGxlU2l6ZSA9IDMyLFxuXHRcdFx0d2lkdGggPSBNYXRoLm1pbihib3VuZHMud2lkdGgsIHNhbXBsZVNpemUpLFxuXHRcdFx0aGVpZ2h0ID0gTWF0aC5taW4oYm91bmRzLmhlaWdodCwgc2FtcGxlU2l6ZSk7XG5cdFx0dmFyIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dDtcblx0XHRpZiAoIWN0eCkge1xuXHRcdFx0Y3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChcblx0XHRcdFx0XHRuZXcgU2l6ZShzYW1wbGVTaXplKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2FtcGxlU2l6ZSArIDEsIHNhbXBsZVNpemUgKyAxKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpXG5cdFx0XHRcdC5zY2FsZSh3aWR0aCAvIGJvdW5kcy53aWR0aCwgaGVpZ2h0IC8gYm91bmRzLmhlaWdodClcblx0XHRcdFx0LnRyYW5zbGF0ZSgtYm91bmRzLngsIC1ib3VuZHMueSk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0aWYgKHBhdGgpXG5cdFx0XHRwYXRoLmRyYXcoY3R4LCBuZXcgQmFzZSh7IGNsaXA6IHRydWUsIHRyYW5zZm9ybXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRjdHguZHJhd0ltYWdlKHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksXG5cdFx0XHRcdE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuXHRcdFx0Y2hhbm5lbHMgPSBbMCwgMCwgMF0sXG5cdFx0XHR0b3RhbCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXHRcdFx0dG90YWwgKz0gYWxwaGE7XG5cdFx0XHRhbHBoYSAvPSAyNTU7XG5cdFx0XHRjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG5cdFx0XHRjaGFubmVsc1tpXSAvPSB0b3RhbDtcblx0XHRyZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGl4ZWw6IGZ1bmN0aW9uKHBvaW50KSB7IFxuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSxcblx0XHRcdFx0ZGF0YVszXSAvIDI1NSk7XG5cdH0sXG5cblx0c2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdGFscGhhID0gY29sb3IuX2FscGhhLFxuXHRcdFx0Y3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0aW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcblx0XHRcdGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcblx0XHRkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcblx0XHRkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcblx0XHRkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbihyZWN0KSB7IFxuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocmVjdC5pc0VtcHR5KCkpXG5cdFx0XHRyZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHJlY3QueCwgcmVjdC55LFxuXHRcdFx0XHRyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdH0sXG5cblx0c2V0SW1hZ2VEYXRhOiBmdW5jdGlvbihkYXRhICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkucHV0SW1hZ2VEYXRhKGRhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuXHR9LFxuXG5cdF9oaXRUZXN0OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdGlmICh0aGlzLl9jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdwaXhlbCcsIHRoYXQsIHtcblx0XHRcdFx0b2Zmc2V0OiBwb2ludC5hZGQodGhhdC5fc2l6ZS5kaXZpZGUoMikpLnJvdW5kKCksXG5cdFx0XHRcdGNvbG9yOiB7XG5cdFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGF0LmdldFBpeGVsKHRoaXMub2Zmc2V0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKTtcblx0XHRpZiAoZWxlbWVudCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gdGhpcy5fb3BhY2l0eTtcblx0XHRcdGN0eC5kcmF3SW1hZ2UoZWxlbWVudCxcblx0XHRcdFx0XHQtdGhpcy5fc2l6ZS53aWR0aCAvIDIsIC10aGlzLl9zaXplLmhlaWdodCAvIDIpO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBQbGFjZWRTeW1ib2wgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BsYWNlZFN5bWJvbCcsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNHZXR0ZXI6IHsgZ2V0Qm91bmRzOiAnZ2V0U3Ryb2tlQm91bmRzJyB9LFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzeW1ib2w6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQbGFjZWRTeW1ib2woYXJnMCwgYXJnMSkge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcwLFxuXHRcdFx0XHRhcmcxICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSlcblx0XHRcdHRoaXMuc2V0U3ltYm9sKGFyZzAgaW5zdGFuY2VvZiBTeW1ib2wgPyBhcmcwIDogbmV3IFN5bWJvbChhcmcwKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wgPT09IGl0ZW0uX3N5bWJvbDtcblx0fSxcblxuXHRnZXRTeW1ib2w6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2w7XG5cdH0sXG5cblx0c2V0U3ltYm9sOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHR0aGlzLl9zeW1ib2wgPSBzeW1ib2w7XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUGxhY2VkU3ltYm9sKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRjb3B5LnNldFN5bWJvbCh0aGlzLl9zeW1ib2wpO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zeW1ib2wuX2RlZmluaXRpb24uaXNFbXB0eSgpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5zeW1ib2wuX2RlZmluaXRpb24uX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsIG1hdHJpeCxcblx0XHRcdFx0Y2FjaGVJdGVtKTtcblx0fSxcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVzID0gdGhpcy5fc3ltYm9sLl9kZWZpbml0aW9uLmhpdFRlc3QocG9pbnQsIG9wdGlvbnMpO1xuXHRcdGlmIChyZXMpXG5cdFx0XHRyZXMuaXRlbSA9IHRoaXM7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHRoaXMuc3ltYm9sLl9kZWZpbml0aW9uLmRyYXcoY3R4LCBwYXJhbSk7XG5cdH1cblxufSk7XG5cbnZhciBIaXRSZXN1bHQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0hpdFJlc3VsdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gSGl0UmVzdWx0KHR5cGUsIGl0ZW0sIHZhbHVlcykge1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5pdGVtID0gaXRlbTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHR2YWx1ZXMuZW51bWVyYWJsZSA9IHRydWU7XG5cdFx0XHR0aGlzLmluamVjdCh2YWx1ZXMpO1xuXHRcdH1cblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0Z2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5fbWVyZ2VkID8gb3B0aW9ucyA6IG5ldyBCYXNlKHtcblx0XHRcdFx0dHlwZTogbnVsbCxcblx0XHRcdFx0dG9sZXJhbmNlOiBwYXBlci5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdGZpbGw6ICFvcHRpb25zLFxuXHRcdFx0XHRzdHJva2U6ICFvcHRpb25zLFxuXHRcdFx0XHRzZWdtZW50czogIW9wdGlvbnMsXG5cdFx0XHRcdGhhbmRsZXM6IGZhbHNlLFxuXHRcdFx0XHRlbmRzOiBmYWxzZSxcblx0XHRcdFx0Y2VudGVyOiBmYWxzZSxcblx0XHRcdFx0Ym91bmRzOiBmYWxzZSxcblx0XHRcdFx0Z3VpZGVzOiBmYWxzZSxcblx0XHRcdFx0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdFx0XHRfbWVyZ2VkOiB0cnVlXG5cdFx0XHR9LCBvcHRpb25zKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2VnbWVudCcsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNlZ21lbnQoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSkge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRwb2ludCwgaGFuZGxlSW4sIGhhbmRsZU91dDtcblx0XHRpZiAoY291bnQgPT09IDApIHtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoYXJnMC5wb2ludCkge1xuXHRcdFx0XHRwb2ludCA9IGFyZzAucG9pbnQ7XG5cdFx0XHRcdGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcblx0XHRcdFx0aGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMiAmJiB0eXBlb2YgYXJnMCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHBvaW50ID0gYXJndW1lbnRzO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPD0gMykge1xuXHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0aGFuZGxlSW4gPSBhcmcxO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnMjtcblx0XHR9IGVsc2UgeyBcblx0XHRcdHBvaW50ID0gYXJnMCAhPT0gdW5kZWZpbmVkID8gWyBhcmcwLCBhcmcxIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlSW4gPSBhcmcyICE9PSB1bmRlZmluZWQgPyBbIGFyZzIsIGFyZzMgXSA6IG51bGw7XG5cdFx0XHRoYW5kbGVPdXQgPSBhcmc0ICE9PSB1bmRlZmluZWQgPyBbIGFyZzQsIGFyZzUgXSA6IG51bGw7XG5cdFx0fVxuXHRcdG5ldyBTZWdtZW50UG9pbnQocG9pbnQsIHRoaXMsICdfcG9pbnQnKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZUluLCB0aGlzLCAnX2hhbmRsZUluJyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVPdXQsIHRoaXMsICdfaGFuZGxlT3V0Jyk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmlzTGluZWFyKCkgPyB0aGlzLl9wb2ludFxuXHRcdFx0XHQ6IFt0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dF0sXG5cdFx0XHRcdG9wdGlvbnMsIHRydWUpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRpZiAoIXBhdGgpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIGN1cnZlcyA9IHBhdGguX2N1cnZlcyxcblx0XHRcdGluZGV4ID0gdGhpcy5faW5kZXgsXG5cdFx0XHRjdXJ2ZUluLCBjdXJ2ZU91dDtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluKVxuXHRcdFx0XHRcdCYmIChjdXJ2ZUluID0gY3VydmVzW2luZGV4IC0gMV1cblx0XHRcdFx0XHRcdHx8IHBhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSlcblx0XHRcdFx0Y3VydmVJbi5fY2hhbmdlZCgpO1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQpXG5cdFx0XHRcdFx0JiYgKGN1cnZlT3V0ID0gY3VydmVzW2luZGV4XSkpXG5cdFx0XHRcdGN1cnZlT3V0Ll9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdHBhdGguX2NoYW5nZWQoMjUpO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlT3V0LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluLmlzWmVybygpICYmIHRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcblx0fSxcblxuXHRzZXRMaW5lYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2hhbmRsZUluLnNldCgwLCAwKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KDAsIDApO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHR2YXIgbmV4dDEgPSB0aGlzLmdldE5leHQoKSxcblx0XHRcdG5leHQyID0gc2VnbWVudC5nZXROZXh0KCk7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBuZXh0MS5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0JiYgc2VnbWVudC5faGFuZGxlT3V0LmlzWmVybygpICYmIG5leHQyLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHQmJiBuZXh0MS5fcG9pbnQuc3VidHJhY3QodGhpcy5fcG9pbnQpLmlzQ29saW5lYXIoXG5cdFx0XHRcdFx0bmV4dDIuX3BvaW50LnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdH0sXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJldiA9IHRoaXMuZ2V0UHJldmlvdXMoKSxcblx0XHRcdG5leHQgPSB0aGlzLmdldE5leHQoKTtcblx0XHRyZXR1cm4gcHJldi5faGFuZGxlT3V0LmlzWmVybygpICYmIHRoaXMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgbmV4dC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdCYmIHRoaXMuX3BvaW50LnN1YnRyYWN0KHByZXYuX3BvaW50KS5pc09ydGhvZ29uYWwoXG5cdFx0XHRcdFx0bmV4dC5fcG9pbnQuc3VidHJhY3QodGhpcy5fcG9pbnQpKTtcblx0fSxcblxuXHRpc0FyYzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG5leHQgPSB0aGlzLmdldE5leHQoKSxcblx0XHRcdGhhbmRsZTEgPSB0aGlzLl9oYW5kbGVPdXQsXG5cdFx0XHRoYW5kbGUyID0gbmV4dC5faGFuZGxlSW4sXG5cdFx0XHRrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcblx0XHRpZiAoaGFuZGxlMS5pc09ydGhvZ29uYWwoaGFuZGxlMikpIHtcblx0XHRcdHZhciBmcm9tID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRcdHRvID0gbmV4dC5fcG9pbnQsXG5cdFx0XHRcdGNvcm5lciA9IG5ldyBMaW5lKGZyb20sIGhhbmRsZTEsIHRydWUpLmludGVyc2VjdChcblx0XHRcdFx0XHRcdG5ldyBMaW5lKHRvLCBoYW5kbGUyLCB0cnVlKSwgdHJ1ZSk7XG5cdFx0XHRyZXR1cm4gY29ybmVyICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMS5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KGZyb20pLmdldExlbmd0aCgpIC0ga2FwcGEpXG5cdFx0XHRcdCYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMi5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHRvKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdF9zZWxlY3Rpb25TdGF0ZTogMCxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbihfcG9pbnQpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLl9zZWxlY3Rpb25TdGF0ZTtcblx0XHRyZXR1cm4gIV9wb2ludCA/ICEhKHN0YXRlICYgNylcblx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9wb2ludCA/ICEhKHN0YXRlICYgNClcblx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/ICEhKHN0YXRlICYgMSlcblx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQgPyAhIShzdGF0ZSAmIDIpXG5cdFx0XHQ6IGZhbHNlO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCwgX3BvaW50KSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0c2VsZWN0ZWQgPSAhIXNlbGVjdGVkLCBcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlT3V0LCB0aGlzLl9oYW5kbGVJbik7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCA/ICEhdGhpcy5fcGF0aC5yZW1vdmVTZWdtZW50KHRoaXMuX2luZGV4KSA6IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZUluLCB0aGlzLl9oYW5kbGVPdXQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHJldHVybiBzZWdtZW50ID09PSB0aGlzIHx8IHNlZ21lbnQgJiYgdGhpcy5fY2xhc3MgPT09IHNlZ21lbnQuX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3BvaW50LmVxdWFscyhzZWdtZW50Ll9wb2ludClcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlSW4uZXF1YWxzKHNlZ21lbnQuX2hhbmRsZUluKVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVPdXQuZXF1YWxzKHNlZ21lbnQuX2hhbmRsZU91dClcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50OiAnICsgdGhpcy5fcG9pbnQgXTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlSW46ICcgKyB0aGlzLl9oYW5kbGVJbik7XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVPdXQ6ICcgKyB0aGlzLl9oYW5kbGVPdXQpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgdHJ1ZSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24obWF0cml4LCBjb29yZHMsIGNoYW5nZSkge1xuXHRcdHZhciBwb2ludCA9IHRoaXMuX3BvaW50LFxuXHRcdFx0aGFuZGxlSW4gPSAgIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZUluIDogbnVsbCxcblx0XHRcdGhhbmRsZU91dCA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlT3V0IDogbnVsbCxcblx0XHRcdHggPSBwb2ludC5feCxcblx0XHRcdHkgPSBwb2ludC5feSxcblx0XHRcdGkgPSAyO1xuXHRcdGNvb3Jkc1swXSA9IHg7XG5cdFx0Y29vcmRzWzFdID0geTtcblx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll95ICsgeTtcblx0XHR9XG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIDAsIGNvb3JkcywgMCwgaSAvIDIpO1xuXHRcdFx0eCA9IGNvb3Jkc1swXTtcblx0XHRcdHkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoY2hhbmdlKSB7XG5cdFx0XHRcdHBvaW50Ll94ID0geDtcblx0XHRcdFx0cG9pbnQuX3kgPSB5O1xuXHRcdFx0XHRpICA9IDI7XG5cdFx0XHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0XHRcdGhhbmRsZUluLl94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZUluLl95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWhhbmRsZUluKSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fVxufSk7XG5cbnZhciBTZWdtZW50UG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50UG9pbnQocG9pbnQsIG93bmVyLCBrZXkpIHtcblx0XHR2YXIgeCwgeSwgc2VsZWN0ZWQ7XG5cdFx0aWYgKCFwb2ludCkge1xuXHRcdFx0eCA9IHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoKHggPSBwb2ludFswXSkgIT09IHVuZGVmaW5lZCkgeyBcblx0XHRcdHkgPSBwb2ludFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQ7XG5cdFx0XHRpZiAoKHggPSBwdC54KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHB0ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR4ID0gcHQueDtcblx0XHRcdH1cblx0XHRcdHkgPSBwdC55O1xuXHRcdFx0c2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcblx0XHR9XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHRvd25lcltrZXldID0gdGhpcztcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyLFxuXHRcdFx0eCA9IGYubnVtYmVyKHRoaXMuX3gpLFxuXHRcdFx0eSA9IGYubnVtYmVyKHRoaXMuX3kpO1xuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQ/IHsgeDogeCwgeTogeSwgc2VsZWN0ZWQ6IHRydWUgfVxuXHRcdFx0XHQ6IFt4LCB5XTtcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy5feCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLl95KTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9vd25lci5zZXRTZWxlY3RlZChzZWxlY3RlZCwgdGhpcyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX293bmVyLmlzU2VsZWN0ZWQodGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgQ3VydmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlJyxcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ3VydmUoYXJnMCwgYXJnMSwgYXJnMiwgYXJnMywgYXJnNCwgYXJnNSwgYXJnNiwgYXJnNykge1xuXHRcdHZhciBjb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gYXJnMTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLl9zZWdtZW50MSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHR0aGlzLl9zZWdtZW50MiA9IG5ldyBTZWdtZW50KCk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50Mik7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0dGhpcy5fc2VnbWVudDEgPSBuZXcgU2VnbWVudChhcmcwKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQoYXJnMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwb2ludDEsIGhhbmRsZTEsIGhhbmRsZTIsIHBvaW50Mjtcblx0XHRcdGlmIChjb3VudCA9PT0gNCkge1xuXHRcdFx0XHRwb2ludDEgPSBhcmcwO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdFx0aGFuZGxlMiA9IGFyZzI7XG5cdFx0XHRcdHBvaW50MiA9IGFyZzM7XG5cdFx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRcdHBvaW50MSA9IFthcmcwLCBhcmcxXTtcblx0XHRcdFx0cG9pbnQyID0gW2FyZzYsIGFyZzddO1xuXHRcdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRcdGhhbmRsZTIgPSBbYXJnNCAtIGFyZzYsIGFyZzUgLSBhcmc3XTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3NlZ21lbnQxID0gbmV3IFNlZ21lbnQocG9pbnQxLCBudWxsLCBoYW5kbGUxKTtcblx0XHRcdHRoaXMuX3NlZ21lbnQyID0gbmV3IFNlZ21lbnQocG9pbnQyLCBoYW5kbGUyLCBudWxsKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2JvdW5kcyA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRnZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGUxOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRTZWdtZW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDI7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faW5kZXg7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggKyAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCAtIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50MSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UG9pbnQyKCkuaXNTZWxlY3RlZCgpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuZ2V0UG9pbnQxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRQb2ludDIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcblx0fSxcblxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5pc0xpbmVhcigpXG5cdFx0XHRcdD8gdGhpcy5fc2VnbWVudDIuX3BvaW50LmdldERpc3RhbmNlKHRoaXMuX3NlZ21lbnQxLl9wb2ludClcblx0XHRcdFx0OiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgMCwgMSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKEN1cnZlLmdldFBhcnQodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pKTtcblx0fSxcblxuXHRnZXRQYXJ0TGVuZ3RoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHQmJiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCk7XG5cdH0sXG5cblx0aXNIb3Jpem9udGFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0xpbmVhcigpICYmIE51bWVyaWNhbC5pc1plcm8oXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5feSAtIHRoaXMuX3NlZ21lbnQyLl9wb2ludC5feSk7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0SW50ZXJzZWN0aW9ucyh0aGlzLmdldFZhbHVlcygpLCBjdXJ2ZS5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0dGhpcywgY3VydmUsIFtdKTtcblx0fSxcblxuXHRfZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0cmV0dXJuIGlzUGFyYW1ldGVyXG5cdFx0XHRcdD8gb2Zmc2V0XG5cdFx0XHRcdDogb2Zmc2V0ICYmIG9mZnNldC5jdXJ2ZSA9PT0gdGhpc1xuXHRcdFx0XHRcdD8gb2Zmc2V0LnBhcmFtZXRlclxuXHRcdFx0XHRcdDogb2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgaXNQYXJhbWV0ZXIgPT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0PyAwLjUgXG5cdFx0XHRcdFx0XHQ6IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0LCAwKTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIsIGlnbm9yZUxpbmVhcikge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlciksXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAxLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAocGFyYW1ldGVyID4gdG9sZXJhbmNlICYmIHBhcmFtZXRlciA8IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh0aGlzLmdldFZhbHVlcygpLCBwYXJhbWV0ZXIpLFxuXHRcdFx0XHRpc0xpbmVhciA9IGlnbm9yZUxpbmVhciA/IGZhbHNlIDogdGhpcy5pc0xpbmVhcigpLFxuXHRcdFx0XHRsZWZ0ID0gcGFydHNbMF0sXG5cdFx0XHRcdHJpZ2h0ID0gcGFydHNbMV07XG5cblx0XHRcdGlmICghaXNMaW5lYXIpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQobGVmdFsyXSAtIGxlZnRbMF0sXG5cdFx0XHRcdFx0XHRsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocmlnaHRbNF0gLSByaWdodFs2XSxcblx0XHRcdFx0XHRcdHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgeCA9IGxlZnRbNl0sIHkgPSBsZWZ0WzddLFxuXHRcdFx0XHRzZWdtZW50ID0gbmV3IFNlZ21lbnQobmV3IFBvaW50KHgsIHkpLFxuXHRcdFx0XHRcdFx0IWlzTGluZWFyICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLFxuXHRcdFx0XHRcdFx0IWlzTGluZWFyICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXG5cdFx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0XHRpZiAodGhpcy5fc2VnbWVudDEuX2luZGV4ID4gMCAmJiB0aGlzLl9zZWdtZW50Mi5faW5kZXggPT09IDApIHtcblx0XHRcdFx0XHR0aGlzLl9wYXRoLmFkZChzZWdtZW50KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9wYXRoLmluc2VydCh0aGlzLl9zZWdtZW50Mi5faW5kZXgsIHNlZ21lbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJlcyA9IHRoaXM7IFxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGVuZCA9IHRoaXMuX3NlZ21lbnQyO1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50MiA9IHNlZ21lbnQ7XG5cdFx0XHRcdHJlcyA9IG5ldyBDdXJ2ZShzZWdtZW50LCBlbmQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGhcblx0XHRcdD8gdGhpcy5fcGF0aC5zcGxpdCh0aGlzLl9zZWdtZW50MS5faW5kZXgsXG5cdFx0XHRcdFx0dGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpKVxuXHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDIucmV2ZXJzZSgpLCB0aGlzLl9zZWdtZW50MS5yZXZlcnNlKCkpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlbW92ZWQgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnQyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQyLl9oYW5kbGVPdXQ7XG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudDIucmVtb3ZlKCk7XG5cdFx0XHRpZiAocmVtb3ZlZClcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoaGFuZGxlT3V0LngsIGhhbmRsZU91dC55KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyKTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gWyAncG9pbnQxOiAnICsgdGhpcy5fc2VnbWVudDEuX3BvaW50IF07XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlMTogJyArIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQpO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlMjogJyArIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbik7XG5cdFx0cGFydHMucHVzaCgncG9pbnQyOiAnICsgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGdldFZhbHVlczogZnVuY3Rpb24oc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgpIHtcblx0XHR2YXIgcDEgPSBzZWdtZW50MS5fcG9pbnQsXG5cdFx0XHRoMSA9IHNlZ21lbnQxLl9oYW5kbGVPdXQsXG5cdFx0XHRoMiA9IHNlZ21lbnQyLl9oYW5kbGVJbixcblx0XHRcdHAyID0gc2VnbWVudDIuX3BvaW50LFxuXHRcdFx0dmFsdWVzID0gW1xuXHRcdFx0XHRwMS5feCwgcDEuX3ksXG5cdFx0XHRcdHAxLl94ICsgaDEuX3gsIHAxLl95ICsgaDEuX3ksXG5cdFx0XHRcdHAyLl94ICsgaDIuX3gsIHAyLl95ICsgaDIuX3ksXG5cdFx0XHRcdHAyLl94LCBwMi5feVxuXHRcdFx0XTtcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyh2YWx1ZXMsIDAsIHZhbHVlcywgMCwgNik7XG5cdFx0cmV0dXJuIHZhbHVlcztcblx0fSxcblxuXHRldmFsdWF0ZTogZnVuY3Rpb24odiwgdCwgdHlwZSkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0dG9sZXJhbmNlID0gMC4wMDAwMSxcblx0XHRcdHgsIHk7XG5cblx0XHRpZiAodHlwZSA9PT0gMCAmJiAodCA8IHRvbGVyYW5jZSB8fCB0ID4gMSAtIHRvbGVyYW5jZSkpIHtcblx0XHRcdHZhciBpc1plcm8gPSB0IDwgdG9sZXJhbmNlO1xuXHRcdFx0eCA9IGlzWmVybyA/IHAxeCA6IHAyeDtcblx0XHRcdHkgPSBpc1plcm8gPyBwMXkgOiBwMnk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblx0XHRcdFx0YnggPSAzICogKGMyeCAtIGMxeCkgLSBjeCxcblx0XHRcdFx0YXggPSBwMnggLSBwMXggLSBjeCAtIGJ4LFxuXG5cdFx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpLFxuXHRcdFx0XHRieSA9IDMgKiAoYzJ5IC0gYzF5KSAtIGN5LFxuXHRcdFx0XHRheSA9IHAyeSAtIHAxeSAtIGN5IC0gYnk7XG5cdFx0XHRpZiAodHlwZSA9PT0gMCkge1xuXHRcdFx0XHR4ID0gKChheCAqIHQgKyBieCkgKiB0ICsgY3gpICogdCArIHAxeDtcblx0XHRcdFx0eSA9ICgoYXkgKiB0ICsgYnkpICogdCArIGN5KSAqIHQgKyBwMXk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodCA8IHRvbGVyYW5jZSAmJiBjMXggPT09IHAxeCAmJiBjMXkgPT09IHAxeVxuXHRcdFx0XHRcdFx0fHwgdCA+IDEgLSB0b2xlcmFuY2UgJiYgYzJ4ID09PSBwMnggJiYgYzJ5ID09PSBwMnkpIHtcblx0XHRcdFx0XHR4ID0gcDJ4IC0gcDF4O1xuXHRcdFx0XHRcdHkgPSBwMnkgLSBwMXk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA8IHRvbGVyYW5jZSkge1xuXHRcdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0XHR5ID0gY3k7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA+IDEgLSB0b2xlcmFuY2UpIHtcblx0XHRcdFx0XHR4ID0gMyAqIChwMnggLSBjMngpO1xuXHRcdFx0XHRcdHkgPSAzICogKHAyeSAtIGMyeSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcblx0XHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0dmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcblx0XHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieTtcblx0XHRcdFx0XHRyZXR1cm4gKHggKiB5MiAtIHkgKiB4MikgLyBNYXRoLnBvdyh4ICogeCArIHkgKiB5LCAzIC8gMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHR5cGUgPT09IDIgPyBuZXcgUG9pbnQoeSwgLXgpIDogbmV3IFBvaW50KHgsIHkpO1xuXHR9LFxuXG5cdHN1YmRpdmlkZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdGlmICh0ID09PSB1bmRlZmluZWQpXG5cdFx0XHR0ID0gMC41O1xuXHRcdHZhciB1ID0gMSAtIHQsXG5cdFx0XHRwM3ggPSB1ICogcDF4ICsgdCAqIGMxeCwgcDN5ID0gdSAqIHAxeSArIHQgKiBjMXksXG5cdFx0XHRwNHggPSB1ICogYzF4ICsgdCAqIGMyeCwgcDR5ID0gdSAqIGMxeSArIHQgKiBjMnksXG5cdFx0XHRwNXggPSB1ICogYzJ4ICsgdCAqIHAyeCwgcDV5ID0gdSAqIGMyeSArIHQgKiBwMnksXG5cdFx0XHRwNnggPSB1ICogcDN4ICsgdCAqIHA0eCwgcDZ5ID0gdSAqIHAzeSArIHQgKiBwNHksXG5cdFx0XHRwN3ggPSB1ICogcDR4ICsgdCAqIHA1eCwgcDd5ID0gdSAqIHA0eSArIHQgKiBwNXksXG5cdFx0XHRwOHggPSB1ICogcDZ4ICsgdCAqIHA3eCwgcDh5ID0gdSAqIHA2eSArIHQgKiBwN3k7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtwMXgsIHAxeSwgcDN4LCBwM3ksIHA2eCwgcDZ5LCBwOHgsIHA4eV0sIFxuXHRcdFx0W3A4eCwgcDh5LCBwN3gsIHA3eSwgcDV4LCBwNXksIHAyeCwgcDJ5XSBcblx0XHRdO1xuXHR9LFxuXG5cdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcblx0XHR2YXIgcDEgPSB2W2Nvb3JkXSxcblx0XHRcdGMxID0gdltjb29yZCArIDJdLFxuXHRcdFx0YzIgPSB2W2Nvb3JkICsgNF0sXG5cdFx0XHRwMiA9IHZbY29vcmQgKyA2XSxcblx0XHRcdGMgPSAzICogKGMxIC0gcDEpLFxuXHRcdFx0YiA9IDMgKiAoYzIgLSBjMSkgLSBjLFxuXHRcdFx0YSA9IHAyIC0gcDEgLSBjIC0gYjtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoYSwgYiwgYywgcDEgLSB2YWwsIHJvb3RzLCBtaW4sIG1heCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHYsIHgsIHkpIHtcblx0XHR2YXIgdG9sZXJhbmNlID0gMC4wMDAwMTtcblx0XHRpZiAoTWF0aC5hYnModlswXSAtIHgpIDwgdG9sZXJhbmNlICYmIE1hdGguYWJzKHZbMV0gLSB5KSA8IHRvbGVyYW5jZSlcblx0XHRcdHJldHVybiAwO1xuXHRcdGlmIChNYXRoLmFicyh2WzZdIC0geCkgPCB0b2xlcmFuY2UgJiYgTWF0aC5hYnModls3XSAtIHkpIDwgdG9sZXJhbmNlKVxuXHRcdFx0cmV0dXJuIDE7XG5cdFx0dmFyIHR4cyA9IFtdLFxuXHRcdFx0dHlzID0gW10sXG5cdFx0XHRzeCA9IEN1cnZlLnNvbHZlQ3ViaWModiwgMCwgeCwgdHhzKSxcblx0XHRcdHN5ID0gQ3VydmUuc29sdmVDdWJpYyh2LCAxLCB5LCB0eXMpLFxuXHRcdFx0dHgsIHR5O1xuXHRcdGZvciAodmFyIGN4ID0gMDsgIHN4ID09IC0xIHx8IGN4IDwgc3g7KSB7XG5cdFx0XHRpZiAoc3ggPT0gLTEgfHwgKHR4ID0gdHhzW2N4KytdKSA+PSAwICYmIHR4IDw9IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgY3kgPSAwOyBzeSA9PSAtMSB8fCBjeSA8IHN5Oykge1xuXHRcdFx0XHRcdGlmIChzeSA9PSAtMSB8fCAodHkgPSB0eXNbY3krK10pID49IDAgJiYgdHkgPD0gMSkge1xuXHRcdFx0XHRcdFx0aWYgKHN4ID09IC0xKSB0eCA9IHR5O1xuXHRcdFx0XHRcdFx0ZWxzZSBpZiAoc3kgPT0gLTEpIHR5ID0gdHg7XG5cdFx0XHRcdFx0XHRpZiAoTWF0aC5hYnModHggLSB0eSkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0XHRcdHJldHVybiAodHggKyB0eSkgKiAwLjU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChzeCA9PSAtMSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24odiwgZnJvbSwgdG8pIHtcblx0XHRpZiAoZnJvbSA+IDApXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsIGZyb20pWzFdOyBcblx0XHRpZiAodG8gPCAxKVxuXHRcdFx0diA9IEN1cnZlLnN1YmRpdmlkZSh2LCAodG8gLSBmcm9tKSAvICgxIC0gZnJvbSkpWzBdOyBcblx0XHRyZXR1cm4gdjtcblx0fSxcblxuXHRpc0xpbmVhcjogZnVuY3Rpb24odikge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdHJldHVybiBpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0JiYgaXNaZXJvKHZbNF0gLSB2WzZdKSAmJiBpc1plcm8odls1XSAtIHZbN10pO1xuXHR9LFxuXG5cdGlzRmxhdEVub3VnaDogZnVuY3Rpb24odiwgdG9sZXJhbmNlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR1eCA9IDMgKiBjMXggLSAyICogcDF4IC0gcDJ4LFxuXHRcdFx0dXkgPSAzICogYzF5IC0gMiAqIHAxeSAtIHAyeSxcblx0XHRcdHZ4ID0gMyAqIGMyeCAtIDIgKiBwMnggLSBwMXgsXG5cdFx0XHR2eSA9IDMgKiBjMnkgLSAyICogcDJ5IC0gcDF5O1xuXHRcdHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpXG5cdFx0XHRcdDwgMTAgKiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdHJldHVybiAoICAzLjAgKiBjMXkgKiBwMXggLSAxLjUgKiBjMXkgKiBjMnhcblx0XHRcdFx0LSAxLjUgKiBjMXkgKiBwMnggLSAzLjAgKiBwMXkgKiBjMXhcblx0XHRcdFx0LSAxLjUgKiBwMXkgKiBjMnggLSAwLjUgKiBwMXkgKiBwMnhcblx0XHRcdFx0KyAxLjUgKiBjMnkgKiBwMXggKyAxLjUgKiBjMnkgKiBjMXhcblx0XHRcdFx0LSAzLjAgKiBjMnkgKiBwMnggKyAwLjUgKiBwMnkgKiBwMXhcblx0XHRcdFx0KyAxLjUgKiBwMnkgKiBjMXggKyAzLjAgKiBwMnkgKiBjMngpIC8gMTA7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIG1pbiA9IHYuc2xpY2UoMCwgMiksIFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksIFxuXHRcdFx0cm9vdHMgPSBbMCwgMF07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspXG5cdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKHZbaV0sIHZbaSArIDJdLCB2W2kgKyA0XSwgdltpICsgNl0sXG5cdFx0XHRcdFx0aSwgMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdF9hZGRCb3VuZHM6IGZ1bmN0aW9uKHYwLCB2MSwgdjIsIHYzLCBjb29yZCwgcGFkZGluZywgbWluLCBtYXgsIHJvb3RzKSB7XG5cdFx0ZnVuY3Rpb24gYWRkKHZhbHVlLCBwYWRkaW5nKSB7XG5cdFx0XHR2YXIgbGVmdCA9IHZhbHVlIC0gcGFkZGluZyxcblx0XHRcdFx0cmlnaHQgPSB2YWx1ZSArIHBhZGRpbmc7XG5cdFx0XHRpZiAobGVmdCA8IG1pbltjb29yZF0pXG5cdFx0XHRcdG1pbltjb29yZF0gPSBsZWZ0O1xuXHRcdFx0aWYgKHJpZ2h0ID4gbWF4W2Nvb3JkXSlcblx0XHRcdFx0bWF4W2Nvb3JkXSA9IHJpZ2h0O1xuXHRcdH1cblx0XHR2YXIgYSA9IDMgKiAodjEgLSB2MikgLSB2MCArIHYzLFxuXHRcdFx0YiA9IDIgKiAodjAgKyB2MikgLSA0ICogdjEsXG5cdFx0XHRjID0gdjEgLSB2MCxcblx0XHRcdGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzKSxcblx0XHRcdHRNaW4gPSAwLjAwMDAxLFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGFkZCh2MywgMCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdCA9IHJvb3RzW2ldLFxuXHRcdFx0XHR1ID0gMSAtIHQ7XG5cdFx0XHRpZiAodE1pbiA8IHQgJiYgdCA8IHRNYXgpXG5cdFx0XHRcdGFkZCh1ICogdSAqIHUgKiB2MFxuXHRcdFx0XHRcdCsgMyAqIHUgKiB1ICogdCAqIHYxXG5cdFx0XHRcdFx0KyAzICogdSAqIHQgKiB0ICogdjJcblx0XHRcdFx0XHQrIHQgKiB0ICogdCAqIHYzLFxuXHRcdFx0XHRcdHBhZGRpbmcpO1xuXHRcdH1cblx0fVxufX0sIEJhc2UuZWFjaChbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJywgJ2dldFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShbdGhpcy5fc2VnbWVudDEsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLCB0aGlzLl9wYXRoLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcy5jbG9uZSgpO1xuXHRcdH07XG5cdH0sXG57XG5cbn0pLCBCYXNlLmVhY2goWydnZXRQb2ludCcsICdnZXRUYW5nZW50JywgJ2dldE5vcm1hbCcsICdnZXRDdXJ2YXR1cmUnXSxcblx0ZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXHRcdFx0cmV0dXJuIEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgaXNQYXJhbWV0ZXJcblx0XHRcdFx0XHQ/IG9mZnNldCA6IEN1cnZlLmdldFBhcmFtZXRlckF0KHZhbHVlcywgb2Zmc2V0LCAwKSwgaW5kZXgpO1xuXHRcdH07XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKHBhcmFtZXRlcikge1xuXHRcdFx0cmV0dXJuIEN1cnZlLmV2YWx1YXRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciwgaW5kZXgpO1xuXHRcdH07XG5cdH0sXG57XG5cdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbihvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFBhcmFtZXRlckF0KHRoaXMuZ2V0VmFsdWVzKCksIG9mZnNldCxcblx0XHRcdFx0c3RhcnQgIT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogb2Zmc2V0IDwgMCA/IDEgOiAwKTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24ocG9pbnQpIHsgXG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLmdldFZhbHVlcygpLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0aWYgKCFpc1BhcmFtZXRlcilcblx0XHRcdG9mZnNldCA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgb2Zmc2V0KTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbihwb2ludCkgeyBcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR0ID0gdGhpcy5nZXRQYXJhbWV0ZXJPZihwb2ludCk7XG5cdFx0cmV0dXJuIHQgIT0gbnVsbCA/IG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQpIDogbnVsbDtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKHBvaW50KSB7IFxuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRjb3VudCA9IDEwMCxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pblQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVmaW5lKHQpIHtcblx0XHRcdGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG5cdFx0XHRcdHZhciBkaXN0ID0gcG9pbnQuZ2V0RGlzdGFuY2UoXG5cdFx0XHRcdFx0XHRDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIHQsIDApLCB0cnVlKTtcblx0XHRcdFx0aWYgKGRpc3QgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdFx0bWluRGlzdCA9IGRpc3Q7XG5cdFx0XHRcdFx0bWluVCA9IHQ7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKVxuXHRcdFx0cmVmaW5lKGkgLyBjb3VudCk7XG5cblx0XHR2YXIgc3RlcCA9IDEgLyAoY291bnQgKiAyKTtcblx0XHR3aGlsZSAoc3RlcCA+IDAuMDAwMDEpIHtcblx0XHRcdGlmICghcmVmaW5lKG1pblQgLSBzdGVwKSAmJiAhcmVmaW5lKG1pblQgKyBzdGVwKSlcblx0XHRcdFx0c3RlcCAvPSAyO1xuXHRcdH1cblx0XHR2YXIgcHQgPSBDdXJ2ZS5ldmFsdWF0ZSh2YWx1ZXMsIG1pblQsIDApO1xuXHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCBtaW5ULCBwdCwgbnVsbCwgbnVsbCwgbnVsbCxcblx0XHRcdFx0cG9pbnQuZ2V0RGlzdGFuY2UocHQpKTtcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkuZ2V0UG9pbnQoKTtcblx0fVxuXG59KSxcbm5ldyBmdW5jdGlvbigpIHsgXG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblxuXHRcdFx0YXggPSA5ICogKGMxeCAtIGMyeCkgKyAzICogKHAyeCAtIHAxeCksXG5cdFx0XHRieCA9IDYgKiAocDF4ICsgYzJ4KSAtIDEyICogYzF4LFxuXHRcdFx0Y3ggPSAzICogKGMxeCAtIHAxeCksXG5cblx0XHRcdGF5ID0gOSAqIChjMXkgLSBjMnkpICsgMyAqIChwMnkgLSBwMXkpLFxuXHRcdFx0YnkgPSA2ICogKHAxeSArIGMyeSkgLSAxMiAqIGMxeSxcblx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBkeCA9IChheCAqIHQgKyBieCkgKiB0ICsgY3gsXG5cdFx0XHRcdGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJdGVyYXRpb25zKGEsIGIpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMiwgTWF0aC5taW4oMTYsIE1hdGguY2VpbChNYXRoLmFicyhiIC0gYSkgKiAzMikpKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c3RhdGljczogdHJ1ZSxcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24odiwgYSwgYikge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdFx0aWYgKGEgPT09IDAgJiYgYiA9PT0gMVxuXHRcdFx0XHRcdCYmIGlzWmVybyh2WzBdIC0gdlsyXSkgJiYgaXNaZXJvKHZbMV0gLSB2WzNdKVxuXHRcdFx0XHRcdCYmIGlzWmVybyh2WzZdIC0gdls0XSkgJiYgaXNaZXJvKHZbN10gLSB2WzVdKSkge1xuXHRcdFx0XHR2YXIgZHggPSB2WzZdIC0gdlswXSwgXG5cdFx0XHRcdFx0ZHkgPSB2WzddIC0gdlsxXTsgXG5cdFx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpO1xuXHRcdFx0cmV0dXJuIE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIGEsIGIsIGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdH0sXG5cblx0XHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24odiwgb2Zmc2V0LCBzdGFydCkge1xuXHRcdFx0aWYgKG9mZnNldCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xuXHRcdFx0dmFyIGZvcndhcmQgPSBvZmZzZXQgPiAwLFxuXHRcdFx0XHRhID0gZm9yd2FyZCA/IHN0YXJ0IDogMCxcblx0XHRcdFx0YiA9IGZvcndhcmQgPyAxIDogc3RhcnQsXG5cdFx0XHRcdG9mZnNldCA9IE1hdGguYWJzKG9mZnNldCksXG5cdFx0XHRcdGRzID0gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpLFxuXHRcdFx0XHRyYW5nZUxlbmd0aCA9IE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIGEsIGIsXG5cdFx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHRcdGlmIChvZmZzZXQgPj0gcmFuZ2VMZW5ndGgpXG5cdFx0XHRcdHJldHVybiBmb3J3YXJkID8gYiA6IGE7XG5cdFx0XHR2YXIgZ3Vlc3MgPSBvZmZzZXQgLyByYW5nZUxlbmd0aCxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZ1bmN0aW9uIGYodCkge1xuXHRcdFx0XHR2YXIgY291bnQgPSBnZXRJdGVyYXRpb25zKHN0YXJ0LCB0KTtcblx0XHRcdFx0bGVuZ3RoICs9IHN0YXJ0IDwgdFxuXHRcdFx0XHRcdFx0PyBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBzdGFydCwgdCwgY291bnQpXG5cdFx0XHRcdFx0XHQ6IC1OdW1lcmljYWwuaW50ZWdyYXRlKGRzLCB0LCBzdGFydCwgY291bnQpO1xuXHRcdFx0XHRzdGFydCA9IHQ7XG5cdFx0XHRcdHJldHVybiBsZW5ndGggLSBvZmZzZXQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmZpbmRSb290KGYsIGRzLFxuXHRcdFx0XHRcdGZvcndhcmQgPyBhICsgZ3Vlc3MgOiBiIC0gZ3Vlc3MsIFxuXHRcdFx0XHRcdGEsIGIsIDE2LCAwLjAwMDAxKTtcblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7IFxuXHRmdW5jdGlvbiBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIGluY2x1ZGUsIGN1cnZlMSwgdDEsIHBvaW50MSwgY3VydmUyLCB0Mixcblx0XHRcdHBvaW50Mikge1xuXHRcdHZhciBsb2MgPSBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZTEsIHQxLCBwb2ludDEsIGN1cnZlMiwgdDIsIHBvaW50Mik7XG5cdFx0aWYgKCFpbmNsdWRlIHx8IGluY2x1ZGUobG9jKSlcblx0XHRcdGxvY2F0aW9ucy5wdXNoKGxvYyk7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0dE1pbiwgdE1heCwgdU1pbiwgdU1heCwgb2xkVERpZmYsIHJldmVyc2UsIHJlY3Vyc2lvbikge1xuXHRcdGlmIChyZWN1cnNpb24gPiAyMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcTB4ID0gdjJbMF0sIHEweSA9IHYyWzFdLCBxM3ggPSB2Mls2XSwgcTN5ID0gdjJbN10sXG5cdFx0XHR0b2xlcmFuY2UgPSAwLjAwMDAxLFxuXHRcdFx0aHVsbEVwc2lsb24gPSAxZS05LFxuXHRcdFx0Z2V0U2lnbmVkRGlzdGFuY2UgPSBMaW5lLmdldFNpZ25lZERpc3RhbmNlLFxuXHRcdFx0ZDEgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzJdLCB2MlszXSkgfHwgMCxcblx0XHRcdGQyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2Mls0XSwgdjJbNV0pIHx8IDAsXG5cdFx0XHRmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG5cdFx0XHRkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcblx0XHRcdGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuXHRcdFx0ZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuXHRcdFx0ZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuXHRcdFx0ZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuXHRcdFx0ZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuXHRcdFx0dE1pbk5ldywgdE1heE5ldywgdERpZmY7XG5cdFx0aWYgKHEweCA9PT0gcTN4ICYmIHVNYXggLSB1TWluIDw9IGh1bGxFcHNpbG9uICYmIHJlY3Vyc2lvbiA+IDMpIHtcblx0XHRcdHRNaW5OZXcgPSAodE1heCArIHRNaW4pIC8gMjtcblx0XHRcdHRNYXhOZXcgPSB0TWluTmV3O1xuXHRcdFx0dERpZmYgPSAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgaHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcblx0XHRcdFx0dG9wID0gaHVsbFswXSxcblx0XHRcdFx0Ym90dG9tID0gaHVsbFsxXSxcblx0XHRcdFx0dE1pbkNsaXAsIHRNYXhDbGlwO1xuXHRcdFx0dE1pbkNsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AsIGJvdHRvbSwgZE1pbiwgZE1heCk7XG5cdFx0XHR0b3AucmV2ZXJzZSgpO1xuXHRcdFx0Ym90dG9tLnJldmVyc2UoKTtcblx0XHRcdHRNYXhDbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpO1xuXHRcdFx0aWYgKHRNaW5DbGlwID09IG51bGwgfHwgdE1heENsaXAgPT0gbnVsbClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0djEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCB0TWluQ2xpcCwgdE1heENsaXApO1xuXHRcdFx0dERpZmYgPSB0TWF4Q2xpcCAtIHRNaW5DbGlwO1xuXHRcdFx0dE1pbk5ldyA9IHRNYXggKiB0TWluQ2xpcCArIHRNaW4gKiAoMSAtIHRNaW5DbGlwKTtcblx0XHRcdHRNYXhOZXcgPSB0TWF4ICogdE1heENsaXAgKyB0TWluICogKDEgLSB0TWF4Q2xpcCk7XG5cdFx0fVxuXHRcdGlmIChvbGRURGlmZiA+IDAuOCAmJiB0RGlmZiA+IDAuOCkge1xuXHRcdFx0aWYgKHRNYXhOZXcgLSB0TWluTmV3ID4gdU1heCAtIHVNaW4pIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYxLCAwLjUpLFxuXHRcdFx0XHRcdHQgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDI7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2MiwgcGFydHNbMF0sIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdCwgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2MiwgcGFydHNbMV0sIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdCwgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYyLCAwLjUpLFxuXHRcdFx0XHRcdHQgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRwYXJ0c1swXSwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHRwYXJ0c1sxXSwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dCwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoTWF0aC5tYXgodU1heCAtIHVNaW4sIHRNYXhOZXcgLSB0TWluTmV3KSA8IHRvbGVyYW5jZSkge1xuXHRcdFx0dmFyIHQxID0gdE1pbk5ldyArICh0TWF4TmV3IC0gdE1pbk5ldykgLyAyLFxuXHRcdFx0XHR0MiA9IHVNaW4gKyAodU1heCAtIHVNaW4pIC8gMjtcblx0XHRcdGlmIChyZXZlcnNlKSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTEsIHQxLCBDdXJ2ZS5ldmFsdWF0ZSh2MSwgdDEsIDApKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgaW5jbHVkZSxcblx0XHRcdFx0XHRcdGN1cnZlMSwgdDEsIEN1cnZlLmV2YWx1YXRlKHYxLCB0MSwgMCksXG5cdFx0XHRcdFx0XHRjdXJ2ZTIsIHQyLCBDdXJ2ZS5ldmFsdWF0ZSh2MiwgdDIsIDApKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgeyBcblx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGN1cnZlMiwgY3VydmUxLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0dU1pbiwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCArK3JlY3Vyc2lvbik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkaXN0MSA9IGdldFNpZ25lZERpc3RhbmNlKDAsIGRxMCwgMSwgZHEzLCAxIC8gMywgZHExKSxcblx0XHRcdGRpc3QyID0gZ2V0U2lnbmVkRGlzdGFuY2UoMCwgZHEwLCAxLCBkcTMsIDIgLyAzLCBkcTIpLFxuXHRcdFx0ZmxpcCA9IGZhbHNlLFxuXHRcdFx0aHVsbDtcblx0XHRpZiAoZGlzdDEgKiBkaXN0MiA8IDApIHtcblx0XHRcdGh1bGwgPSBbW3AwLCBwMSwgcDNdLCBbcDAsIHAyLCBwM11dO1xuXHRcdFx0ZmxpcCA9IGRpc3QxIDwgMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBtYXgsIGNyb3NzID0gMCxcblx0XHRcdFx0ZGlzdFplcm8gPSBkaXN0MSA9PT0gMCB8fCBkaXN0MiA9PT0gMDtcblx0XHRcdGlmIChNYXRoLmFicyhkaXN0MSkgPiBNYXRoLmFicyhkaXN0MikpIHtcblx0XHRcdFx0cG1heCA9IHAxO1xuXHRcdFx0XHRjcm9zcyA9IChkcTMgLSBkcTIgLSAoZHEzIC0gZHEwKSAvIDMpXG5cdFx0XHRcdFx0XHQqICgyICogKGRxMyAtIGRxMikgLSBkcTMgKyBkcTEpIC8gMztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBtYXggPSBwMjtcblx0XHRcdFx0Y3Jvc3MgPSAoZHExIC0gZHEwICsgKGRxMCAtIGRxMykgLyAzKVxuXHRcdFx0XHRcdFx0KiAoLTIgKiAoZHEwIC0gZHExKSArIGRxMCAtIGRxMikgLyAzO1xuXHRcdFx0fVxuXHRcdFx0aHVsbCA9IGNyb3NzIDwgMCB8fCBkaXN0WmVyb1xuXHRcdFx0XHRcdD8gW1twMCwgcG1heCwgcDNdLCBbcDAsIHAzXV1cblx0XHRcdFx0XHQ6IFtbcDAsIHAxLCBwMiwgcDNdLCBbcDAsIHAzXV07XG5cdFx0XHRmbGlwID0gZGlzdDEgPyBkaXN0MSA8IDAgOiBkaXN0MiA8IDA7XG5cdFx0fVxuXHRcdHJldHVybiBmbGlwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuXHRcdHZhciB0UHJveHksXG5cdFx0XHR0VmFsID0gbnVsbCxcblx0XHRcdHB4LCBweSxcblx0XHRcdHF4LCBxeTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGh1bGxCb3R0b20ubGVuZ3RoIC0gMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0cHkgPSBodWxsQm90dG9tW2ldWzFdO1xuXHRcdFx0cXkgPSBodWxsQm90dG9tW2kgKyAxXVsxXTtcblx0XHRcdGlmIChweSA8IHF5KSB7XG5cdFx0XHRcdHRQcm94eSA9IG51bGw7XG5cdFx0XHR9IGVsc2UgaWYgKHF5IDw9IGRNYXgpIHtcblx0XHRcdFx0cHggPSBodWxsQm90dG9tW2ldWzBdO1xuXHRcdFx0XHRxeCA9IGh1bGxCb3R0b21baSArIDFdWzBdO1xuXHRcdFx0XHR0UHJveHkgPSBweCArIChkTWF4ICAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChodWxsVG9wWzBdWzFdIDw9IGRNYXgpXG5cdFx0XHR0UHJveHkgPSBodWxsVG9wWzBdWzBdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaHVsbFRvcC5sZW5ndGggLSAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRweSA9IGh1bGxUb3BbaV1bMV07XG5cdFx0XHRxeSA9IGh1bGxUb3BbaSArIDFdWzFdO1xuXHRcdFx0aWYgKHB5ID49IGRNaW4pIHtcblx0XHRcdFx0dFZhbCA9IHRQcm94eTtcblx0XHRcdH0gZWxzZSBpZiAocHkgPiBxeSkge1xuXHRcdFx0XHR0VmFsID0gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAocXkgPj0gZE1pbikge1xuXHRcdFx0XHRweCA9IGh1bGxUb3BbaV1bMF07XG5cdFx0XHRcdHF4ID0gaHVsbFRvcFtpICsgMV1bMF07XG5cdFx0XHRcdHRWYWwgPSBweCArIChkTWluICAtIHB5KSAqIChxeCAtIHB4KSAvIChxeSAtIHB5KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHJldHVybiB0VmFsO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsXG5cdFx0XHRpbmNsdWRlKSB7XG5cdFx0dmFyIGZsaXAgPSBDdXJ2ZS5pc0xpbmVhcih2MSksXG5cdFx0XHR2YyA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0dmwgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdGx4MSA9IHZsWzBdLCBseTEgPSB2bFsxXSxcblx0XHRcdGx4MiA9IHZsWzZdLCBseTIgPSB2bFs3XSxcblx0XHRcdGxkeCA9IGx4MiAtIGx4MSxcblx0XHRcdGxkeSA9IGx5MiAtIGx5MSxcblx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtbGR5LCBsZHgpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cmx4MiA9IGxkeCAqIGNvcyAtIGxkeSAqIHNpbixcblx0XHRcdHJ2bCA9IFswLCAwLCAwLCAwLCBybHgyLCAwLCBybHgyLCAwXSxcblx0XHRcdHJ2YyA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpIHtcblx0XHRcdHZhciB4ID0gdmNbaV0gLSBseDEsXG5cdFx0XHRcdHkgPSB2Y1tpICsgMV0gLSBseTE7XG5cdFx0XHRydmMucHVzaChcblx0XHRcdFx0eCAqIGNvcyAtIHkgKiBzaW4sXG5cdFx0XHRcdHkgKiBjb3MgKyB4ICogc2luKTtcblx0XHR9XG5cdFx0dmFyIHJvb3RzID0gW10sXG5cdFx0XHRjb3VudCA9IEN1cnZlLnNvbHZlQ3ViaWMocnZjLCAxLCAwLCByb290cywgMCwgMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdGMgPSByb290c1tpXSxcblx0XHRcdFx0eCA9IEN1cnZlLmV2YWx1YXRlKHJ2YywgdGMsIDApLng7XG5cdFx0XHRpZiAoeCA+PSAwICYmIHggPD0gcmx4Mikge1xuXHRcdFx0XHR2YXIgdGwgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZihydmwsIHgsIDApLFxuXHRcdFx0XHRcdHQxID0gZmxpcCA/IHRsIDogdGMsXG5cdFx0XHRcdFx0dDIgPSBmbGlwID8gdGMgOiB0bDtcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdFx0Y3VydmUxLCB0MSwgQ3VydmUuZXZhbHVhdGUodjEsIHQxLCAwKSxcblx0XHRcdFx0XHRcdGN1cnZlMiwgdDIsIEN1cnZlLmV2YWx1YXRlKHYyLCB0MiwgMCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGFkZExpbmVJbnRlcnNlY3Rpb24odjEsIHYyLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLCBpbmNsdWRlKSB7XG5cdFx0dmFyIHBvaW50ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHBvaW50KSB7XG5cdFx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHRcdHkgPSBwb2ludC55O1xuXHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBpbmNsdWRlLFxuXHRcdFx0XHRcdGN1cnZlMSwgQ3VydmUuZ2V0UGFyYW1ldGVyT2YodjEsIHgsIHkpLCBwb2ludCxcblx0XHRcdFx0XHRjdXJ2ZTIsIEN1cnZlLmdldFBhcmFtZXRlck9mKHYyLCB4LCB5KSwgcG9pbnQpO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblx0XHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbih2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUpIHtcblx0XHRcdHZhciBsaW5lYXIxID0gQ3VydmUuaXNMaW5lYXIodjEpLFxuXHRcdFx0XHRsaW5lYXIyID0gQ3VydmUuaXNMaW5lYXIodjIpO1xuXHRcdFx0KGxpbmVhcjEgJiYgbGluZWFyMlxuXHRcdFx0XHQ/IGFkZExpbmVJbnRlcnNlY3Rpb25cblx0XHRcdFx0OiBsaW5lYXIxIHx8IGxpbmVhcjJcblx0XHRcdFx0XHQ/IGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnNcblx0XHRcdFx0XHQ6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoXG5cdFx0XHRcdFx0XHR2MSwgdjIsIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsIGluY2x1ZGUsXG5cdFx0XHRcdFx0XHQwLCAxLCAwLCAxLCAwLCBmYWxzZSwgMCk7XG5cdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdH1cblx0fX07XG59KTtcblxudmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCBwYXJhbWV0ZXIsIHBvaW50LCBfY3VydmUyLFxuXHRcdFx0X3BhcmFtZXRlcjIsIF9wb2ludDIsIF9kaXN0YW5jZSkge1xuXHRcdHRoaXMuX2lkID0gQ3VydmVMb2NhdGlvbi5faWQgPSAoQ3VydmVMb2NhdGlvbi5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMuX2N1cnZlID0gY3VydmU7XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0dGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdFx0dGhpcy5fY3VydmUyID0gX2N1cnZlMjtcblx0XHR0aGlzLl9wYXJhbWV0ZXIyID0gX3BhcmFtZXRlcjI7XG5cdFx0dGhpcy5fcG9pbnQyID0gX3BvaW50Mjtcblx0XHR0aGlzLl9kaXN0YW5jZSA9IF9kaXN0YW5jZTtcblx0fSxcblxuXHRnZXRTZWdtZW50OiBmdW5jdGlvbihfcHJlZmVyRmlyc3QpIHtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0cGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPT09IDEpIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyID09PSAwIHx8IF9wcmVmZXJGaXJzdCkge1xuXHRcdFx0XHR0aGlzLl9zZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgPT0gbnVsbCkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcilcblx0XHRcdFx0XHQ8IGN1cnZlLmdldFBhcnRMZW5ndGgocGFyYW1ldGVyLCAxKVxuXHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHRcdDogY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDtcblx0fSxcblxuXHRnZXRDdXJ2ZTogZnVuY3Rpb24oX3VuY2FjaGVkKSB7XG5cdFx0aWYgKCF0aGlzLl9jdXJ2ZSB8fCBfdW5jYWNoZWQpIHtcblx0XHRcdHRoaXMuX2N1cnZlID0gdGhpcy5fc2VnbWVudDEuZ2V0Q3VydmUoKTtcblx0XHRcdGlmICh0aGlzLl9jdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLl9wb2ludCkgPT0gbnVsbClcblx0XHRcdFx0dGhpcy5fY3VydmUgPSB0aGlzLl9zZWdtZW50Mi5nZXRQcmV2aW91cygpLmdldEN1cnZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jdXJ2ZTtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlcnNlY3Rpb24gPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcnNlY3Rpb24gJiYgdGhpcy5fY3VydmUyKSB7XG5cdFx0XHR2YXIgcGFyYW0gPSB0aGlzLl9wYXJhbWV0ZXIyO1xuXHRcdFx0dGhpcy5faW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uID0gbmV3IEN1cnZlTG9jYXRpb24oXG5cdFx0XHRcdFx0dGhpcy5fY3VydmUyLCBwYXJhbSwgdGhpcy5fcG9pbnQyIHx8IHRoaXMuX3BvaW50LCB0aGlzKTtcblx0XHRcdGludGVyc2VjdGlvbi5faW50ZXJzZWN0aW9uID0gdGhpcztcblx0XHR9XG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlICYmIGN1cnZlLmdldEluZGV4KCk7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpO1xuXHRcdHJldHVybiBwYXRoICYmIHBhdGguX2dldE9mZnNldCh0aGlzKTtcblx0fSxcblxuXHRnZXRDdXJ2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24oX3VuY2FjaGVkKSB7XG5cdFx0aWYgKCh0aGlzLl9wYXJhbWV0ZXIgPT0gbnVsbCB8fCBfdW5jYWNoZWQpICYmIHRoaXMuX3BvaW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKF91bmNhY2hlZCAmJiB0aGlzLl9wb2ludCk7XG5cdFx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLl9wb2ludCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9wYXJhbWV0ZXI7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF91bmNhY2hlZCkge1xuXHRcdGlmICgoIXRoaXMuX3BvaW50IHx8IF91bmNhY2hlZCkgJiYgdGhpcy5fcGFyYW1ldGVyICE9IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRcdHRoaXMuX3BvaW50ID0gY3VydmUgJiYgY3VydmUuZ2V0UG9pbnRBdCh0aGlzLl9wYXJhbWV0ZXIsIHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0Z2V0VGFuZ2VudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCksXG5cdFx0XHRjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmUuZ2V0VGFuZ2VudEF0KHBhcmFtZXRlciwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Tm9ybWFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKSxcblx0XHRcdGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBwYXJhbWV0ZXIgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZS5nZXROb3JtYWxBdChwYXJhbWV0ZXIsIHRydWUpO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlzdGFuY2U7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKHRydWUpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5kaXZpZGUodGhpcy5nZXRQYXJhbWV0ZXIodHJ1ZSksIHRydWUpO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKHRydWUpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5zcGxpdCh0aGlzLmdldFBhcmFtZXRlcih0cnVlKSwgdHJ1ZSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gdGhpcyA9PT0gbG9jXG5cdFx0XHRcdHx8IGxvY1xuXHRcdFx0XHRcdCYmIHRoaXMuX2N1cnZlID09PSBsb2MuX2N1cnZlXG5cdFx0XHRcdFx0JiYgdGhpcy5fY3VydmUyID09PSBsb2MuX2N1cnZlMlxuXHRcdFx0XHRcdCYmIGlzWmVybyh0aGlzLl9wYXJhbWV0ZXIgLSBsb2MuX3BhcmFtZXRlcilcblx0XHRcdFx0XHQmJiBpc1plcm8odGhpcy5fcGFyYW1ldGVyMiAtIGxvYy5fcGFyYW1ldGVyMilcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0cG9pbnQgPSB0aGlzLmdldFBvaW50KCksXG5cdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdGlmIChwb2ludClcblx0XHRcdHBhcnRzLnB1c2goJ3BvaW50OiAnICsgcG9pbnQpO1xuXHRcdHZhciBpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2luZGV4OiAnICsgaW5kZXgpO1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdGlmIChwYXJhbWV0ZXIgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ3BhcmFtZXRlcjogJyArIGYubnVtYmVyKHBhcmFtZXRlcikpO1xuXHRcdGlmICh0aGlzLl9kaXN0YW5jZSAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnZGlzdGFuY2U6ICcgKyBmLm51bWJlcih0aGlzLl9kaXN0YW5jZSkpO1xuXHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgUGF0aEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVtJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoSXRlbSgpIHtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwYXRoLCBfZXhwYW5kKSB7XG5cdFx0aWYgKHRoaXMgPT09IHBhdGgpXG5cdFx0XHRwYXRoID0gbnVsbDtcblx0XHRpZiAocGF0aCAmJiAhdGhpcy5nZXRCb3VuZHMoKS50b3VjaGVzKHBhdGguZ2V0Qm91bmRzKCkpKVxuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdHZhciBsb2NhdGlvbnMgPSBbXSxcblx0XHRcdGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHBhdGggPyBwYXRoLmdldEN1cnZlcygpIDogY3VydmVzMSxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHBhdGggPyBwYXRoLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpIDogbWF0cml4MSxcblx0XHRcdGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcblx0XHRcdGxlbmd0aDIgPSBwYXRoID8gY3VydmVzMi5sZW5ndGggOiBsZW5ndGgxLFxuXHRcdFx0dmFsdWVzMiA9IFtdLFxuXHRcdFx0TUlOID0gMWUtMTEsXG5cdFx0XHRNQVggPSAxIC0gMWUtMTE7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspXG5cdFx0XHR2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2ldLFxuXHRcdFx0XHR2YWx1ZXMxID0gcGF0aCA/IGN1cnZlMS5nZXRWYWx1ZXMobWF0cml4MSkgOiB2YWx1ZXMyW2ldO1xuXHRcdFx0aWYgKCFwYXRoKSB7XG5cdFx0XHRcdHZhciBzZWcxID0gY3VydmUxLmdldFNlZ21lbnQxKCksXG5cdFx0XHRcdFx0c2VnMiA9IGN1cnZlMS5nZXRTZWdtZW50MigpLFxuXHRcdFx0XHRcdGgxID0gc2VnMS5faGFuZGxlT3V0LFxuXHRcdFx0XHRcdGgyID0gc2VnMi5faGFuZGxlSW47XG5cdFx0XHRcdGlmIChuZXcgTGluZShzZWcxLl9wb2ludC5zdWJ0cmFjdChoMSksIGgxLm11bHRpcGx5KDIpLCB0cnVlKVxuXHRcdFx0XHRcdFx0LmludGVyc2VjdChuZXcgTGluZShzZWcyLl9wb2ludC5zdWJ0cmFjdChoMiksXG5cdFx0XHRcdFx0XHRoMi5tdWx0aXBseSgyKSwgdHJ1ZSksIGZhbHNlKSkge1xuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2YWx1ZXMxKTtcblx0XHRcdFx0XHRDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdFx0cGFydHNbMF0sIHBhcnRzWzFdLCBjdXJ2ZTEsIGN1cnZlMSwgbG9jYXRpb25zLFxuXHRcdFx0XHRcdFx0ZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChsb2MuX3BhcmFtZXRlciA8PSBNQVgpIHtcblx0XHRcdFx0XHRcdFx0XHRsb2MuX3BhcmFtZXRlciAvPSAyO1xuXHRcdFx0XHRcdFx0XHRcdGxvYy5fcGFyYW1ldGVyMiA9IDAuNSArIGxvYy5fcGFyYW1ldGVyMiAvIDI7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBqID0gcGF0aCA/IDAgOiBpICsgMTsgaiA8IGxlbmd0aDI7IGorKykge1xuXHRcdFx0XHRDdXJ2ZS5nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHZhbHVlczEsIHZhbHVlczJbal0sIGN1cnZlMSwgY3VydmVzMltqXSwgbG9jYXRpb25zLFxuXHRcdFx0XHRcdCFwYXRoICYmIChqID09PSBpICsgMSB8fCBqID09PSBsZW5ndGgyIC0gMSAmJiBpID09PSAwKVxuXHRcdFx0XHRcdFx0JiYgZnVuY3Rpb24obG9jKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0ID0gbG9jLl9wYXJhbWV0ZXI7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0ID49IE1JTiAmJiB0IDw9IE1BWDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGxhc3QgPSBsb2NhdGlvbnMubGVuZ3RoIC0gMTtcblx0XHRmb3IgKHZhciBpID0gbGFzdDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBsb2MgPSBsb2NhdGlvbnNbaV0sXG5cdFx0XHRcdG5leHQgPSBsb2MuX2N1cnZlLmdldE5leHQoKSxcblx0XHRcdFx0bmV4dDIgPSBsb2MuX2N1cnZlMi5nZXROZXh0KCk7XG5cdFx0XHRpZiAobmV4dCAmJiBsb2MuX3BhcmFtZXRlciA+PSBNQVgpIHtcblx0XHRcdFx0bG9jLl9wYXJhbWV0ZXIgPSAwO1xuXHRcdFx0XHRsb2MuX2N1cnZlID0gbmV4dDtcblx0XHRcdH1cblx0XHRcdGlmIChuZXh0MiAmJiBsb2MuX3BhcmFtZXRlcjIgPj0gTUFYKSB7XG5cdFx0XHRcdGxvYy5fcGFyYW1ldGVyMiA9IDA7XG5cdFx0XHRcdGxvYy5fY3VydmUyID0gbmV4dDI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY29tcGFyZShsb2MxLCBsb2MyKSB7XG5cdFx0XHR2YXIgcGF0aDEgPSBsb2MxLmdldFBhdGgoKSxcblx0XHRcdFx0cGF0aDIgPSBsb2MyLmdldFBhdGgoKTtcblx0XHRcdHJldHVybiBwYXRoMSA9PT0gcGF0aDJcblx0XHRcdFx0XHQ/IChsb2MxLmdldEluZGV4KCkgKyBsb2MxLmdldFBhcmFtZXRlcigpKVxuXHRcdFx0XHRcdFx0XHQtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFBhcmFtZXRlcigpKVxuXHRcdFx0XHRcdDogcGF0aDEuX2lkIC0gcGF0aDIuX2lkO1xuXHRcdH1cblxuXHRcdGlmIChsYXN0ID4gMCkge1xuXHRcdFx0bG9jYXRpb25zLnNvcnQoY29tcGFyZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gbGFzdDsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKGxvY2F0aW9uc1tpXS5lcXVhbHMobG9jYXRpb25zW2kgPT09IDAgPyBsYXN0IDogaSAtIDFdKSkge1xuXHRcdFx0XHRcdGxvY2F0aW9ucy5zcGxpY2UoaSwgMSk7XG5cdFx0XHRcdFx0bGFzdC0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChfZXhwYW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gbGFzdDsgaSA+PSAwOyBpLS0pXG5cdFx0XHRcdGxvY2F0aW9ucy5wdXNoKGxvY2F0aW9uc1tpXS5nZXRJbnRlcnNlY3Rpb24oKSk7XG5cdFx0XHRsb2NhdGlvbnMuc29ydChjb21wYXJlKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0fSxcblxuXHRzZXRQYXRoRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXG5cdFx0dmFyIHBhcnRzID0gZGF0YS5tYXRjaCgvW21saHZjc3F0YXpdW15tbGh2Y3NxdGF6XSovaWcpLFxuXHRcdFx0Y29vcmRzLFxuXHRcdFx0cmVsYXRpdmUgPSBmYWxzZSxcblx0XHRcdHByZXZpb3VzLFxuXHRcdFx0Y29udHJvbCxcblx0XHRcdGN1cnJlbnQgPSBuZXcgUG9pbnQoKSxcblx0XHRcdHN0YXJ0ID0gbmV3IFBvaW50KCk7XG5cblx0XHRmdW5jdGlvbiBnZXRDb29yZChpbmRleCwgY29vcmQpIHtcblx0XHRcdHZhciB2YWwgPSArY29vcmRzW2luZGV4XTtcblx0XHRcdGlmIChyZWxhdGl2ZSlcblx0XHRcdFx0dmFsICs9IGN1cnJlbnRbY29vcmRdO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQb2ludChpbmRleCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXgsICd4JyksXG5cdFx0XHRcdGdldENvb3JkKGluZGV4ICsgMSwgJ3knKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLmNsZWFyKCk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRbMF0sXG5cdFx0XHRcdGxvd2VyID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29vcmRzID0gcGFydC5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29vcmRzICYmIGNvb3Jkcy5sZW5ndGg7XG5cdFx0XHRyZWxhdGl2ZSA9IGNvbW1hbmQgPT09IGxvd2VyO1xuXHRcdFx0aWYgKHByZXZpb3VzID09PSAneicgJiYgIS9bbXpdLy50ZXN0KGxvd2VyKSlcblx0XHRcdFx0dGhpcy5tb3ZlVG8oY3VycmVudCA9IHN0YXJ0KTtcblx0XHRcdHN3aXRjaCAobG93ZXIpIHtcblx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHZhciBtb3ZlID0gbG93ZXIgPT09ICdtJztcblx0XHRcdFx0aWYgKG1vdmUgJiYgcHJldmlvdXMgJiYgcHJldmlvdXMgIT09ICd6Jylcblx0XHRcdFx0XHR0aGlzLmNsb3NlUGF0aCh0cnVlKTtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMilcblx0XHRcdFx0XHR0aGlzW2ogPT09IDAgJiYgbW92ZSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0aWYgKG1vdmUpXG5cdFx0XHRcdFx0c3RhcnQgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdHZhciBjb29yZCA9IGxvd2VyID09PSAnaCcgPyAneCcgOiAneSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRjdXJyZW50W2Nvb3JkXSA9IGdldENvb3JkKGosIGNvb3JkKTtcblx0XHRcdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNikge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGogKyAyKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyA0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHQvW2NzXS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gKC9bcXRdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNykge1xuXHRcdFx0XHRcdHRoaXMuYXJjVG8oY3VycmVudCA9IGdldFBvaW50KGogKyA1KSxcblx0XHRcdFx0XHRcdFx0bmV3IFNpemUoK2Nvb3Jkc1swXSwgK2Nvb3Jkc1sxXSksXG5cdFx0XHRcdFx0XHRcdCtjb29yZHNbMl0sICtjb29yZHNbNF0sICtjb29yZHNbM10pO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAneic6XG5cdFx0XHRcdHRoaXMuY2xvc2VQYXRoKHRydWUpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgd2luZGluZyA9IHRoaXMuX2dldFdpbmRpbmcocG9pbnQsIGZhbHNlLCB0cnVlKTtcblx0XHRyZXR1cm4gISEodGhpcy5nZXRXaW5kaW5nUnVsZSgpID09PSAnZXZlbm9kZCcgPyB3aW5kaW5nICYgMSA6IHdpbmRpbmcpO1xuXHR9XG5cbn0pO1xuXG52YXIgUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c2VnbWVudHM6IFtdLFxuXHRcdGNsb3NlZDogZmFsc2Vcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoKGFyZykge1xuXHRcdHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuXHRcdHRoaXMuX3NlZ21lbnRzID0gW107XG5cdFx0dmFyIHNlZ21lbnRzID0gQXJyYXkuaXNBcnJheShhcmcpXG5cdFx0XHQ/IHR5cGVvZiBhcmdbMF0gPT09ICdvYmplY3QnXG5cdFx0XHRcdD8gYXJnXG5cdFx0XHRcdDogYXJndW1lbnRzXG5cdFx0XHQ6IGFyZyAmJiAoYXJnLnNpemUgPT09IHVuZGVmaW5lZCAmJiAoYXJnLnggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdHx8IGFyZy5wb2ludCAhPT0gdW5kZWZpbmVkKSlcblx0XHRcdFx0PyBhcmd1bWVudHNcblx0XHRcdFx0OiBudWxsO1xuXHRcdGlmIChzZWdtZW50cyAmJiBzZWdtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLnNldFNlZ21lbnRzKHNlZ21lbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5fY3VydmVzID0gdW5kZWZpbmVkOyBcblx0XHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHRcdGlmICghc2VnbWVudHMgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuXHRcdFx0XHRhcmcgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9pbml0aWFsaXplKCFzZWdtZW50cyAmJiBhcmcpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gQmFzZS5lcXVhbHModGhpcy5fc2VnbWVudHMsIGl0ZW0uX3NlZ21lbnRzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0Y29weS5zZXRTZWdtZW50cyh0aGlzLl9zZWdtZW50cyk7XG5cdFx0Y29weS5fY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdGNvcHkuX2Nsb2Nrd2lzZSA9IHRoaXMuX2Nsb2Nrd2lzZTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcblx0XHRfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRwYXJlbnQuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5fY2xvY2t3aXNlID0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcyAmJiAhKGZsYWdzICYgMTYpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbaV0uX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX21vbm9DdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIGlmIChmbGFncyAmIDMyKSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdHJldHVybiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogdGhpcykuX3N0eWxlO1xuXHR9LFxuXG5cdGdldFNlZ21lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHM7XG5cdH0sXG5cblx0c2V0U2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0dmFyIGZ1bGx5U2VsZWN0ZWQgPSB0aGlzLmlzRnVsbHlTZWxlY3RlZCgpO1xuXHRcdHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSAwO1xuXHRcdHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpKTtcblx0XHRpZiAoZnVsbHlTZWxlY3RlZClcblx0XHRcdHRoaXMuc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1swXTtcblx0fSxcblxuXHRnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzW3RoaXMuX3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0aWYgKCFjdXJ2ZXMpIHtcblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0XHRjdXJ2ZXNbaV0gPSBuZXcgQ3VydmUodGhpcywgc2VnbWVudHNbaV0sXG5cdFx0XHRcdFx0c2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDdXJ2ZXMoKVswXTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdHJldHVybiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdO1xuXHR9LFxuXG5cdGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHR9LFxuXG5cdHNldENsb3NlZDogZnVuY3Rpb24oY2xvc2VkKSB7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCAhPSAoY2xvc2VkID0gISFjbG9zZWQpKSB7XG5cdFx0XHR0aGlzLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0XHRpZiAodGhpcy5fY3VydmVzKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdFx0aWYgKGNsb3NlZClcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbbGVuZ3RoIC0gMV0gPSBuZXcgQ3VydmUodGhpcyxcblx0XHRcdFx0XHRcdHRoaXMuX3NlZ21lbnRzW2xlbmd0aCAtIDFdLCB0aGlzLl9zZWdtZW50c1swXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHR9XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9wcmVjaXNpb24pIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2UsXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkQ3VydmUoc2VnMSwgc2VnMiwgc2tpcExpbmUpIHtcblx0XHRcdHZhciBwb2ludDEgPSBzZWcxLl9wb2ludCxcblx0XHRcdFx0cG9pbnQyID0gc2VnMi5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZTEgPSBzZWcxLl9oYW5kbGVPdXQsXG5cdFx0XHRcdGhhbmRsZTIgPSBzZWcyLl9oYW5kbGVJbjtcblx0XHRcdGlmIChoYW5kbGUxLmlzWmVybygpICYmIGhhbmRsZTIuaXNaZXJvKCkpIHtcblx0XHRcdFx0aWYgKCFza2lwTGluZSkge1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ0wnICsgZi5wb2ludChwb2ludDIsIF9wcmVjaXNpb24pKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGVuZCA9IHBvaW50Mi5zdWJ0cmFjdChwb2ludDEpO1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdjJyArIGYucG9pbnQoaGFuZGxlMSwgX3ByZWNpc2lvbilcblx0XHRcdFx0XHRcdCsgJyAnICsgZi5wb2ludChlbmQuYWRkKGhhbmRsZTIpLCBfcHJlY2lzaW9uKVxuXHRcdFx0XHRcdFx0KyAnICcgKyBmLnBvaW50KGVuZCwgX3ByZWNpc2lvbikpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0cGFydHMucHVzaCgnTScgKyBmLnBvaW50KHNlZ21lbnRzWzBdLl9wb2ludCkpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoICAtIDE7IGkgPCBsOyBpKyspXG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50c1tpXSwgc2VnbWVudHNbaSArIDFdLCBmYWxzZSk7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0YWRkQ3VydmUoc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0sIHNlZ21lbnRzWzBdLCB0cnVlKTtcblx0XHRcdHBhcnRzLnB1c2goJ3onKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhcnRzLmpvaW4oJycpO1xuXHR9XG59LCB7XG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRpc1BvbHlnb246IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoIXRoaXMuX3NlZ21lbnRzW2ldLmlzTGluZWFyKCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9zZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hZGQ6IGZ1bmN0aW9uKHNlZ3MsIGluZGV4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRhbW91bnQgPSBzZWdzLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9wYXRoKVxuXHRcdFx0XHRzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcblx0XHRcdHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCAwLCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSk7XG5cdFx0fVxuXHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHNlZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWdtZW50cy5zcGxpY2UuYXBwbHkoc2VnbWVudHMsIFtpbmRleCwgMF0uY29uY2F0KHNlZ3MpKTtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlcyB8fCBzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdGlmICghY3VydmVzKVxuXHRcdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMgPSBbXTtcblx0XHRcdHZhciBmcm9tID0gaW5kZXggPiAwID8gaW5kZXggLSAxIDogaW5kZXgsXG5cdFx0XHRcdHN0YXJ0ID0gZnJvbSxcblx0XHRcdFx0dG8gPSBNYXRoLm1pbihmcm9tICsgYW1vdW50LCB0aGlzLl9jb3VudEN1cnZlcygpKTtcblx0XHRcdGlmIChzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0Y3VydmVzLnNwbGljZS5hcHBseShjdXJ2ZXMsIFtmcm9tLCAwXS5jb25jYXQoc2Vncy5fY3VydmVzKSk7XG5cdFx0XHRcdHN0YXJ0ICs9IHNlZ3MuX2N1cnZlcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCB0bzsgaSsrKVxuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlKGksIDAsIG5ldyBDdXJ2ZSh0aGlzLCBudWxsLCBudWxsKSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoZnJvbSwgdG8pO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHRfYWRqdXN0Q3VydmVzOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y3VydmU7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG5cdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGN1cnZlLl9wYXRoID0gdGhpcztcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdGhpcy5fY2xvc2VkICYmIGZyb20gPT09IDAgPyBzZWdtZW50cy5sZW5ndGggLSAxXG5cdFx0XHRcdDogZnJvbSAtIDFdKVxuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbZnJvbV0gfHwgc2VnbWVudHNbMF07XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RvXSlcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW3RvXTtcblx0fSxcblxuXHRfY291bnRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuICF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbihzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cykpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydDogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoYXJndW1lbnRzLCAxKSwgaW5kZXgpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cykpO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnRzOiBmdW5jdGlvbihpbmRleCwgc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cyksIGluZGV4KTtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCBpbmRleCArIDEpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudHM6IGZ1bmN0aW9uKGZyb20sIHRvLCBfaW5jbHVkZUN1cnZlcykge1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCk7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjb3VudCA9IHNlZ21lbnRzLmxlbmd0aCwgXG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudHMuc3BsaWNlKGZyb20sIHRvIC0gZnJvbSksXG5cdFx0XHRhbW91bnQgPSByZW1vdmVkLmxlbmd0aDtcblx0XHRpZiAoIWFtb3VudClcblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLCAwKTtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBmcm9tLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBmcm9tID4gMCAmJiB0byA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApXG5cdFx0XHRcdFx0PyBmcm9tIC0gMVxuXHRcdFx0XHRcdDogZnJvbSxcblx0XHRcdFx0Y3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblx0XHRcdGlmIChfaW5jbHVkZUN1cnZlcylcblx0XHRcdFx0cmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuXHRpc0Z1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkICYmIGxlbmd0aCA+IDAgJiYgdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGVcblx0XHRcdFx0PT09IGxlbmd0aCAqIDc7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyh0cnVlKTtcblx0XHR0aGlzLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24gc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpIHtcblx0XHRpZiAoIXNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHMoZmFsc2UpO1xuXHRcdHNldFNlbGVjdGVkLmJhc2UuY2FsbCh0aGlzLCBzZWxlY3RlZCk7XG5cdH0sXG5cblx0X3NlbGVjdFNlZ21lbnRzOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSBzZWxlY3RlZFxuXHRcdFx0XHQ/IGxlbmd0aCAqIDcgOiAwO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHR0aGlzLl9zZWdtZW50c1tpXS5fc2VsZWN0aW9uU3RhdGUgPSBzZWxlY3RlZFxuXHRcdFx0XHRcdD8gNyA6IDA7XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oc2VnbWVudCwgb2xkU3RhdGUsIG5ld1N0YXRlKSB7XG5cdFx0c2VnbWVudC5fc2VsZWN0aW9uU3RhdGUgPSBuZXdTdGF0ZTtcblx0XHR2YXIgdG90YWwgPSB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSArPSBuZXdTdGF0ZSAtIG9sZFN0YXRlO1xuXHRcdGlmICh0b3RhbCA+IDApXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGZsYXR0ZW46IGZ1bmN0aW9uKG1heERpc3RhbmNlKSB7XG5cdFx0dmFyIGZsYXR0ZW5lciA9IG5ldyBQYXRoRmxhdHRlbmVyKHRoaXMpLFxuXHRcdFx0cG9zID0gMCxcblx0XHRcdHN0ZXAgPSBmbGF0dGVuZXIubGVuZ3RoIC8gTWF0aC5jZWlsKGZsYXR0ZW5lci5sZW5ndGggLyBtYXhEaXN0YW5jZSksXG5cdFx0XHRlbmQgPSBmbGF0dGVuZXIubGVuZ3RoICsgKHRoaXMuX2Nsb3NlZCA/IC1zdGVwIDogc3RlcCkgLyAyO1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdHdoaWxlIChwb3MgPD0gZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KGZsYXR0ZW5lci5ldmFsdWF0ZShwb3MsIDApKSk7XG5cdFx0XHRwb3MgKz0gc3RlcDtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRpZiAoY3VydmUuaXNMaW5lYXIoKSAmJiBjdXJ2ZS5nZXRMZW5ndGgoKSA9PT0gMClcblx0XHRcdFx0Y3VydmUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRpZiAodGhpcy5fc2VnbWVudHMubGVuZ3RoID4gMikge1xuXHRcdFx0dmFyIGZpdHRlciA9IG5ldyBQYXRoRml0dGVyKHRoaXMsIHRvbGVyYW5jZSB8fCAyLjUpO1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhmaXR0ZXIuZml0KCkpO1xuXHRcdH1cblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHBhcmFtZXRlcikge1xuXHRcdGlmIChwYXJhbWV0ZXIgPT09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBhcmcgPSBpbmRleDtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJylcblx0XHRcdFx0YXJnID0gdGhpcy5nZXRMb2NhdGlvbkF0KGFyZyk7XG5cdFx0XHRpbmRleCA9IGFyZy5pbmRleDtcblx0XHRcdHBhcmFtZXRlciA9IGFyZy5wYXJhbWV0ZXI7XG5cdFx0fVxuXHRcdHZhciB0b2xlcmFuY2UgPSAwLjAwMDAxO1xuXHRcdGlmIChwYXJhbWV0ZXIgPj0gMSAtIHRvbGVyYW5jZSkge1xuXHRcdFx0aW5kZXgrKztcblx0XHRcdHBhcmFtZXRlci0tO1xuXHRcdH1cblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGN1cnZlcy5sZW5ndGgpIHtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPiB0b2xlcmFuY2UpIHtcblx0XHRcdFx0Y3VydmVzW2luZGV4KytdLmRpdmlkZShwYXJhbWV0ZXIsIHRydWUpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNlZ3MgPSB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCB0aGlzLl9zZWdtZW50cy5sZW5ndGgsIHRydWUpLFxuXHRcdFx0XHRwYXRoO1xuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZCkge1xuXHRcdFx0XHR0aGlzLnNldENsb3NlZChmYWxzZSk7XG5cdFx0XHRcdHBhdGggPSB0aGlzO1xuXHRcdFx0fSBlbHNlIGlmIChpbmRleCA+IDApIHtcblx0XHRcdFx0cGF0aCA9IHRoaXMuX2Nsb25lKG5ldyBQYXRoKCkuaW5zZXJ0QWJvdmUodGhpcywgdHJ1ZSkpO1xuXHRcdFx0fVxuXHRcdFx0cGF0aC5fYWRkKHNlZ3MsIDApO1xuXHRcdFx0dGhpcy5hZGRTZWdtZW50KHNlZ3NbMF0pO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHJldHVybiBQYXRoLmlzQ2xvY2t3aXNlKHRoaXMuX3NlZ21lbnRzKTtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT0gKGNsb2Nrd2lzZSA9ICEhY2xvY2t3aXNlKSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHRcdHRoaXMuX2Nsb2Nrd2lzZSA9IGNsb2Nrd2lzZTtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50cy5yZXZlcnNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZUluID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0c2VnbWVudC5faGFuZGxlT3V0ID0gaGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnZlcyA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhpcy5fY2xvY2t3aXNlID0gIXRoaXMuX2Nsb2Nrd2lzZTtcblx0fSxcblxuXHRqb2luOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0XHRsYXN0MSA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAobGFzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdHZhciBmaXJzdDEsXG5cdFx0XHRcdGZpcnN0MiA9IHBhdGguZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdFx0XHRpZiAobGFzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSkge1xuXHRcdFx0XHRsYXN0MS5zZXRIYW5kbGVPdXQoZmlyc3QyLl9oYW5kbGVPdXQpO1xuXHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMSkpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Zmlyc3QxID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MS5fcG9pbnQuZXF1YWxzKGZpcnN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MS5fcG9pbnQuZXF1YWxzKGxhc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0XHRmaXJzdDEuc2V0SGFuZGxlSW4obGFzdDIuX2hhbmRsZUluKTtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoMCwgc2VnbWVudHMubGVuZ3RoIC0gMSksIDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGguY2xvc2VkKVxuXHRcdFx0XHR0aGlzLl9hZGQoW3NlZ21lbnRzWzBdXSk7XG5cdFx0XHRwYXRoLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpLFxuXHRcdFx0bGFzdCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRpZiAoZmlyc3QgIT09IGxhc3QgJiYgZmlyc3QuX3BvaW50LmVxdWFscyhsYXN0Ll9wb2ludCkpIHtcblx0XHRcdGZpcnN0LnNldEhhbmRsZUluKGxhc3QuX2hhbmRsZUluKTtcblx0XHRcdGxhc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fbGVuZ3RoICs9IGN1cnZlc1tpXS5nZXRMZW5ndGgoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2xlbmd0aDtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHR2YXIgYXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjdXJ2ZXNbaV0uZ2V0QXJlYSgpO1xuXHRcdHJldHVybiBhcmVhO1xuXHR9LFxuXG5cdF9nZXRPZmZzZXQ6IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG5cdFx0dmFyIGluZGV4ID0gbG9jYXRpb24gJiYgbG9jYXRpb24uZ2V0SW5kZXgoKTtcblx0XHRpZiAoaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4OyBpKyspXG5cdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaW5kZXhdLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBsb2NhdGlvbi5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPiAwKVxuXHRcdFx0XHRvZmZzZXQgKz0gY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24ocG9pbnQpIHsgXG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TG9jYXRpb25PZihwb2ludCk7XG5cdFx0XHRpZiAobG9jKVxuXHRcdFx0XHRyZXR1cm4gbG9jO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRsZW5ndGggPSAwO1xuXHRcdGlmIChpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIGluZGV4ID0gfn5vZmZzZXQ7IFxuXHRcdFx0cmV0dXJuIGN1cnZlc1tpbmRleF0uZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBpbmRleCwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0YXJ0ID0gbGVuZ3RoLFxuXHRcdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChsZW5ndGggPiBvZmZzZXQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gc3RhcnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAob2Zmc2V0IDw9IHRoaXMuZ2V0TGVuZ3RoKCkpXG5cdFx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnRBdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQob2Zmc2V0LCBpc1BhcmFtZXRlcik7XG5cdFx0cmV0dXJuIGxvYyAmJiBsb2MuZ2V0UG9pbnQoKTtcblx0fSxcblxuXHRnZXRUYW5nZW50QXQ6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbkF0KG9mZnNldCwgaXNQYXJhbWV0ZXIpO1xuXHRcdHJldHVybiBsb2MgJiYgbG9jLmdldFRhbmdlbnQoKTtcblx0fSxcblxuXHRnZXROb3JtYWxBdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQob2Zmc2V0LCBpc1BhcmFtZXRlcik7XG5cdFx0cmV0dXJuIGxvYyAmJiBsb2MuZ2V0Tm9ybWFsKCk7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbihwb2ludCkgeyBcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluTG9jID0gbnVsbDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MuX2Rpc3RhbmNlIDwgbWluRGlzdCkge1xuXHRcdFx0XHRtaW5EaXN0ID0gbG9jLl9kaXN0YW5jZTtcblx0XHRcdFx0bWluTG9jID0gbG9jO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWluTG9jO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24ocG9pbnQpIHsgXG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkuZ2V0UG9pbnQoKTtcblx0fSxcblxuXHR0b1NoYXBlOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRpZiAoIXRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0c2l6ZSxcblx0XHRcdHJhZGl1cyxcblx0XHRcdHRvcENlbnRlcjtcblxuXHRcdGZ1bmN0aW9uIGlzQ29saW5lYXIoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzQ29saW5lYXIoc2VnbWVudHNbal0pO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzT3J0aG9nb25hbChpKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uaXNPcnRob2dvbmFsKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNBcmMoaSkge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLmlzQXJjKCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGlzdGFuY2UoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLl9wb2ludC5nZXREaXN0YW5jZShzZWdtZW50c1tqXS5fcG9pbnQpO1xuXHRcdH1cblxuXHRcdGlmICh0aGlzLmlzUG9seWdvbigpICYmIHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0NvbGluZWFyKDAsIDIpICYmIGlzQ29saW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG5cdFx0XHRcdCYmIGlzQXJjKDYpICYmIGlzQ29saW5lYXIoMSwgNSkgJiYgaXNDb2xpbmVhcigzLCA3KSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgxLCA2KSwgZ2V0RGlzdGFuY2UoMCwgMykpO1xuXHRcdFx0cmFkaXVzID0gc2l6ZS5zdWJ0cmFjdChuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCA3KSxcblx0XHRcdFx0XHRnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5DaXJjbGU7XG5cdFx0XHRcdHJhZGl1cyA9IGdldERpc3RhbmNlKDAsIDIpIC8gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuXHRcdFx0XHRyYWRpdXMgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgyLCAwKSAvIDIsIGdldERpc3RhbmNlKDMsIDEpIC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUpIHtcblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRzaGFwZSA9IG5ldyB0eXBlKHtcblx0XHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0fSk7XG5cdFx0XHRzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcblx0XHRcdHNoYXBlLnNldFN0eWxlKHRoaXMuX3N0eWxlKTtcblx0XHRcdGlmIChpbnNlcnQgfHwgaW5zZXJ0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdHNoYXBlLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHNoYXBlO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRqb2luLCBjYXAsIG1pdGVyTGltaXQsXG5cdFx0XHRhcmVhLCBsb2MsIHJlcyxcblx0XHRcdGhhc1N0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0aGFzRmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRyYWRpdXMgPSBoYXNTdHJva2UgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMlxuXHRcdFx0XHRcdDogaGFzRmlsbCA/IDAgOiBudWxsO1xuXHRcdGlmIChyYWRpdXMgIT0gbnVsbCkge1xuXHRcdFx0aWYgKHJhZGl1cyA+IDApIHtcblx0XHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKTtcblx0XHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCk7XG5cdFx0XHRcdG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdHN0cm9rZVBhZGRpbmcgPSB0b2xlcmFuY2VQYWRkaW5nLmFkZChuZXcgUG9pbnQocmFkaXVzLCByYWRpdXMpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpvaW4gPSBjYXAgPSAncm91bmQnO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQ2xvc2VFbm91Z2gocHQsIHBhZGRpbmcpIHtcblx0XHRcdHJldHVybiBwb2ludC5zdWJ0cmFjdChwdCkuZGl2aWRlKHBhZGRpbmcpLmxlbmd0aCA8PSAxO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50KHNlZywgcHQsIG5hbWUpIHtcblx0XHRcdGlmICghb3B0aW9ucy5zZWxlY3RlZCB8fCBwdC5pc1NlbGVjdGVkKCkpIHtcblx0XHRcdFx0dmFyIGFuY2hvciA9IHNlZy5fcG9pbnQ7XG5cdFx0XHRcdGlmIChwdCAhPT0gYW5jaG9yKVxuXHRcdFx0XHRcdHB0ID0gcHQuYWRkKGFuY2hvcik7XG5cdFx0XHRcdGlmIChpc0Nsb3NlRW5vdWdoKHB0LCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KG5hbWUsIHRoYXQsIHtcblx0XHRcdFx0XHRcdHNlZ21lbnQ6IHNlZyxcblx0XHRcdFx0XHRcdHBvaW50OiBwdFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnRzKHNlZywgZW5kcykge1xuXHRcdFx0cmV0dXJuIChlbmRzIHx8IG9wdGlvbnMuc2VnbWVudHMpXG5cdFx0XHRcdCYmIGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9wb2ludCwgJ3NlZ21lbnQnKVxuXHRcdFx0XHR8fCAoIWVuZHMgJiYgb3B0aW9ucy5oYW5kbGVzKSAmJiAoXG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZUluLCAnaGFuZGxlLWluJykgfHxcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlT3V0LCAnaGFuZGxlLW91dCcpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRUb0FyZWEocG9pbnQpIHtcblx0XHRcdGFyZWEuYWRkKHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkge1xuXHRcdFx0aWYgKGpvaW4gIT09ICdyb3VuZCcgfHwgY2FwICE9PSAncm91bmQnKSB7XG5cdFx0XHRcdGFyZWEgPSBuZXcgUGF0aCh7IGludGVybmFsOiB0cnVlLCBjbG9zZWQ6IHRydWUgfSk7XG5cdFx0XHRcdGlmIChjbG9zZWQgfHwgc2VnbWVudC5faW5kZXggPiAwXG5cdFx0XHRcdFx0XHQmJiBzZWdtZW50Ll9pbmRleCA8IG51bVNlZ21lbnRzIC0gMSkge1xuXHRcdFx0XHRcdGlmIChqb2luICE9PSAncm91bmQnICYmIChzZWdtZW50Ll9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdFx0XHR8fCBzZWdtZW50Ll9oYW5kbGVPdXQuaXNaZXJvKCkpKVxuXHRcdFx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCxcblx0XHRcdFx0XHRcdFx0XHRhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRcdFBhdGguX2FkZFNxdWFyZUNhcChzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWFyZWEuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdFx0dmFyIGxvYztcblx0XHRcdFx0XHRyZXR1cm4gYXJlYS5jb250YWlucyhwb2ludClcblx0XHRcdFx0XHRcdHx8IChsb2MgPSBhcmVhLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCkpXG5cdFx0XHRcdFx0XHRcdCYmIGlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHRvbGVyYW5jZVBhZGRpbmcpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXNDbG9zZUVub3VnaChzZWdtZW50Ll9wb2ludCwgc3Ryb2tlUGFkZGluZyk7XG5cdFx0fVxuXG5cdFx0aWYgKG9wdGlvbnMuZW5kcyAmJiAhb3B0aW9ucy5zZWdtZW50cyAmJiAhY2xvc2VkKSB7XG5cdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzWzBdLCB0cnVlKVxuXHRcdFx0XHRcdHx8IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tudW1TZWdtZW50cyAtIDFdLCB0cnVlKSlcblx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9IGVsc2UgaWYgKG9wdGlvbnMuc2VnbWVudHMgfHwgb3B0aW9ucy5oYW5kbGVzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspXG5cdFx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMgIT0gbnVsbCkge1xuXHRcdFx0bG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYykge1xuXHRcdFx0XHR2YXIgcGFyYW1ldGVyID0gbG9jLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0XHRpZiAocGFyYW1ldGVyID09PSAwIHx8IHBhcmFtZXRlciA9PT0gMSAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0XHRpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSlcblx0XHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSAgaWYgKCFpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCBzdHJva2VQYWRkaW5nKSkge1xuXHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghbG9jICYmIGpvaW4gPT09ICdtaXRlcicgJiYgbnVtU2VnbWVudHMgPiAxKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKykge1xuXHRcdFx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRcdFx0aWYgKHBvaW50LmdldERpc3RhbmNlKHNlZ21lbnQuX3BvaW50KSA8PSBtaXRlckxpbWl0XG5cdFx0XHRcdFx0XHRcdCYmIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSkge1xuXHRcdFx0XHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAhbG9jICYmIGhhc0ZpbGwgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpIHx8IGxvYyAmJiAhaGFzU3Ryb2tlXG5cdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpXG5cdFx0XHRcdDogbG9jXG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdzdHJva2UnLCB0aGlzLCB7XG5cdFx0XHRcdFx0XHRsb2NhdGlvbjogbG9jLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IGxvYy5nZXRQb2ludCgpXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0XHQ6IG51bGw7XG5cdH1cblxufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblxuXHRmdW5jdGlvbiBkcmF3SGFuZGxlcyhjdHgsIHNlZ21lbnRzLCBtYXRyaXgsIHNpemUpIHtcblx0XHR2YXIgaGFsZiA9IHNpemUgLyAyO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0hhbmRsZShpbmRleCkge1xuXHRcdFx0dmFyIGhYID0gY29vcmRzW2luZGV4XSxcblx0XHRcdFx0aFkgPSBjb29yZHNbaW5kZXggKyAxXTtcblx0XHRcdGlmIChwWCAhPSBoWCB8fCBwWSAhPSBoWSkge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8ocFgsIHBZKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhoWCwgaFkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyhoWCwgaFksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLFxuXHRcdFx0XHRwWCA9IGNvb3Jkc1swXSxcblx0XHRcdFx0cFkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoc3RhdGUgJiAxKVxuXHRcdFx0XHRkcmF3SGFuZGxlKDIpO1xuXHRcdFx0aWYgKHN0YXRlICYgMilcblx0XHRcdFx0ZHJhd0hhbmRsZSg0KTtcblx0XHRcdGN0eC5maWxsUmVjdChwWCAtIGhhbGYsIHBZIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG5cdFx0XHRpZiAoIShzdGF0ZSAmIDQpKSB7XG5cdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmICsgMSwgcFkgLSBoYWxmICsgMSwgc2l6ZSAtIDIsIHNpemUgLSAyKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFk7XG5cblx0XHRmdW5jdGlvbiBkcmF3U2VnbWVudChpKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG5cdFx0XHRcdGN1clggPSBwb2ludC5feDtcblx0XHRcdFx0Y3VyWSA9IHBvaW50Ll95O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRcdFx0aW5YID0gY3VyWCArIGhhbmRsZS5feDtcblx0XHRcdFx0XHRpblkgPSBjdXJZICsgaGFuZGxlLl95O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpblggPT0gY3VyWCAmJiBpblkgPT0gY3VyWSAmJiBvdXRYID09IHByZXZYICYmIG91dFkgPT0gcHJldlkpIHtcblx0XHRcdFx0XHRjdHgubGluZVRvKGN1clgsIGN1clkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKG91dFgsIG91dFksIGluWCwgaW5ZLCBjdXJYLCBjdXJZKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRvdXRYID0gY29vcmRzWzRdO1xuXHRcdFx0XHRvdXRZID0gY29vcmRzWzVdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGhhbmRsZSA9IHNlZ21lbnQuX2hhbmRsZU91dDtcblx0XHRcdFx0b3V0WCA9IHByZXZYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRvdXRZID0gcHJldlkgKyBoYW5kbGUuX3k7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGRyYXdTZWdtZW50KGkpO1xuXHRcdGlmIChwYXRoLl9jbG9zZWQgJiYgbGVuZ3RoID4gMClcblx0XHRcdGRyYXdTZWdtZW50KDApO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdFx0dmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcblx0XHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwO1xuXHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblxuXHRcdFx0dmFyIHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGZ1bmN0aW9uIGdldE9mZnNldChpKSB7XG5cdFx0XHRcdHJldHVybiBkYXNoQXJyYXlbKChpICUgZGFzaExlbmd0aCkgKyBkYXNoTGVuZ3RoKSAlIGRhc2hMZW5ndGhdO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWRvbnRTdGFydCAmJiB0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgJiYgIWRhc2hMZW5ndGggfHwgZG9udFBhaW50KSB7XG5cdFx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMpO1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYXNTdHJva2UpIHtcblx0XHRcdFx0XHRpZiAoZGFzaExlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdHZhciBmbGF0dGVuZXIgPSBuZXcgUGF0aEZsYXR0ZW5lcih0aGlzKSxcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gZmxhdHRlbmVyLmxlbmd0aCxcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IC1zdHlsZS5nZXREYXNoT2Zmc2V0KCksIHRvLFxuXHRcdFx0XHRcdFx0XHRpID0gMDtcblx0XHRcdFx0XHRcdGZyb20gPSBmcm9tICUgbGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPiAwKSB7XG5cdFx0XHRcdFx0XHRcdGZyb20gLT0gZ2V0T2Zmc2V0KGktLSkgKyBnZXRPZmZzZXQoaS0tKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRcdHRvID0gZnJvbSArIGdldE9mZnNldChpKyspO1xuXHRcdFx0XHRcdFx0XHRpZiAoZnJvbSA+IDAgfHwgdG8gPiAwKVxuXHRcdFx0XHRcdFx0XHRcdGZsYXR0ZW5lci5kcmF3UGFydChjdHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgubWF4KGZyb20sIDApLCBNYXRoLm1heCh0bywgMCkpO1xuXHRcdFx0XHRcdFx0XHRmcm9tID0gdG8gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBtYXRyaXgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0ZHJhd0hhbmRsZXMoY3R4LCB0aGlzLl9zZWdtZW50cywgbWF0cml4LCBwYXBlci5zZXR0aW5ncy5oYW5kbGVTaXplKTtcblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7IFxuXG5cdGZ1bmN0aW9uIGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpIHtcblx0XHR2YXIgbiA9IHJocy5sZW5ndGgsXG5cdFx0XHR4ID0gW10sIFxuXHRcdFx0dG1wID0gW10sIFxuXHRcdFx0YiA9IDI7XG5cdFx0eFswXSA9IHJoc1swXSAvIGI7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0XHRcdHRtcFtpXSA9IDEgLyBiO1xuXHRcdFx0YiA9IChpIDwgbiAtIDEgPyA0IDogMikgLSB0bXBbaV07XG5cdFx0XHR4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR4W24gLSBpIC0gMV0gLT0gdG1wW24gLSBpXSAqIHhbbiAtIGldO1xuXHRcdH1cblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0XHRzaXplID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHRcdG4gPSBzaXplLFxuXHRcdFx0XHRvdmVybGFwID0gMDtcblx0XHRcdGlmIChzaXplIDw9IDIpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0b3ZlcmxhcCA9IE1hdGgubWluKHNpemUsIDQpO1xuXHRcdFx0XHRuICs9IE1hdGgubWluKHNpemUsIG92ZXJsYXApICogMjtcblx0XHRcdH1cblx0XHRcdHZhciBrbm90cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXG5cdFx0XHRcdGtub3RzW2kgKyBvdmVybGFwXSA9IHNlZ21lbnRzW2ldLl9wb2ludDtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0XHRrbm90c1tpXSA9IHNlZ21lbnRzW2kgKyBzaXplIC0gb3ZlcmxhcF0uX3BvaW50O1xuXHRcdFx0XHRcdGtub3RzW2kgKyBzaXplICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciByaHMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuXHRcdFx0XHRyaHNbaV0gPSA0ICoga25vdHNbaV0uX3ggKyAyICoga25vdHNbaSArIDFdLl94O1xuXHRcdFx0cmhzWzBdID0ga25vdHNbMF0uX3ggKyAyICoga25vdHNbMV0uX3g7XG5cdFx0XHRyaHNbbiAtIDFdID0gMyAqIGtub3RzW24gLSAxXS5feDtcblx0XHRcdHZhciB4ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl95ICsgMiAqIGtub3RzW2kgKyAxXS5feTtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl95ICsgMiAqIGtub3RzWzFdLl95O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3k7XG5cdFx0XHR2YXIgeSA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBqID0gc2l6ZTsgaSA8IG92ZXJsYXA7IGkrKywgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGYxID0gaSAvIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRmMiA9IDEgLSBmMSxcblx0XHRcdFx0XHRcdGllID0gaSArIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRqZSA9IGogKyBvdmVybGFwO1xuXHRcdFx0XHRcdHhbal0gPSB4W2ldICogZjEgKyB4W2pdICogZjI7XG5cdFx0XHRcdFx0eVtqXSA9IHlbaV0gKiBmMSArIHlbal0gKiBmMjtcblx0XHRcdFx0XHR4W2plXSA9IHhbaWVdICogZjIgKyB4W2plXSAqIGYxO1xuXHRcdFx0XHRcdHlbamVdID0geVtpZV0gKiBmMiArIHlbamVdICogZjE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bi0tO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhbmRsZUluID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSBvdmVybGFwOyBpIDw9IG4gLSBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpIC0gb3ZlcmxhcF07XG5cdFx0XHRcdGlmIChoYW5kbGVJbilcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdGlmIChpIDwgbikge1xuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlT3V0KFxuXHRcdFx0XHRcdFx0XHRuZXcgUG9pbnQoeFtpXSwgeVtpXSkuc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdFx0XHRoYW5kbGVJbiA9IGkgPCBuIC0gMVxuXHRcdFx0XHRcdFx0XHQ/IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQyICoga25vdHNbaSArIDFdLl94IC0geFtpICsgMV0sXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feSAtIHlbaSArIDFdKVxuXHRcdFx0XHRcdFx0XHQ6IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3ggKyB4W24gLSAxXSkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdChrbm90c1tuXS5feSArIHlbbiAtIDFdKSAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkICYmIGhhbmRsZUluKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlSW4oaGFuZGxlSW4uc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59LCBuZXcgZnVuY3Rpb24oKSB7IFxuXHRmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuXHRcdFx0XHRmcm9tID0gY3VycmVudC5fcG9pbnQsXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0aHJvdWdoLFxuXHRcdFx0XHRwZWVrID0gQmFzZS5wZWVrKGFyZ3VtZW50cyksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcblx0XHRcdFx0Y2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0dGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3VtZW50cykgPD0gMikge1xuXHRcdFx0XHR0aHJvdWdoID0gdG87XG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bGFyZ2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0RVBTSUxPTiA9IDFlLTExLFxuXHRcdFx0XHRcdHJ4ID0gYWJzKHJhZGl1cy53aWR0aCksXG5cdFx0XHRcdFx0cnkgPSBhYnMocmFkaXVzLmhlaWdodCksXG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcngsXG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnksXG5cdFx0XHRcdFx0eFNxID0gIHggKiB4LFxuXHRcdFx0XHRcdHlTcSA9ICB5ICogeTtcblx0XHRcdFx0dmFyIGZhY3RvciA9IE1hdGguc3FydCh4U3EgLyByeFNxICsgeVNxIC8gcnlTcSk7XG5cdFx0XHRcdGlmIChmYWN0b3IgPiAxKSB7XG5cdFx0XHRcdFx0cnggKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ5ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeDtcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmYWN0b3IgPSAocnhTcSAqIHJ5U3EgLSByeFNxICogeVNxIC0gcnlTcSAqIHhTcSkgL1xuXHRcdFx0XHRcdFx0KHJ4U3EgKiB5U3EgKyByeVNxICogeFNxKTtcblx0XHRcdFx0aWYgKGFicyhmYWN0b3IpIDwgRVBTSUxPTilcblx0XHRcdFx0XHRmYWN0b3IgPSAwO1xuXHRcdFx0XHRpZiAoZmFjdG9yIDwgMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0Y2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpXG5cdFx0XHRcdFx0XHRcdCogTWF0aC5zcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBNYXRoLmFicyhleHRlbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXh0ID0gTWF0aC5hYnMoZXh0ZW50KSxcblx0XHRcdFx0Y291bnQgPSAgZXh0ID49IDM2MCA/IDQgOiBNYXRoLmNlaWwoZXh0IC8gOTApLFxuXHRcdFx0XHRpbmMgPSBleHRlbnQgLyBjb3VudCxcblx0XHRcdFx0aGFsZiA9IGluYyAqIE1hdGguUEkgLyAzNjAsXG5cdFx0XHRcdHogPSA0IC8gMyAqIE1hdGguc2luKGhhbGYpIC8gKDEgKyBNYXRoLmNvcyhoYWxmKSksXG5cdFx0XHRcdHNlZ21lbnRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwdCA9IHRvLFxuXHRcdFx0XHRcdG91dCA9IG51bGw7XG5cdFx0XHRcdGlmIChpIDwgY291bnQpIHtcblx0XHRcdFx0XHRvdXQgPSB2ZWN0b3Iucm90YXRlKDkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRwdCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yKTtcblx0XHRcdFx0XHRcdG91dCA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChvdXQpKVxuXHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHB0ID0gY2VudGVyLmFkZCh2ZWN0b3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KG91dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIF9pbiA9IHZlY3Rvci5yb3RhdGUoLTkwKS5tdWx0aXBseSh6KTtcblx0XHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0XHRfaW4gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQoX2luKSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KHB0LCBfaW4sIG91dCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IHZlY3Rvci5yb3RhdGUoaW5jKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2FkZChzZWdtZW50cyk7XG5cdFx0fSxcblxuXHRcdGxpbmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGFyYW1ldGVyID0gQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1cnZlVG8oY3VycmVudC5hZGQodGhyb3VnaCksIGN1cnJlbnQuYWRkKHRvKSwgcGFyYW1ldGVyKTtcblx0XHR9LFxuXG5cdFx0Y3ViaWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRoYW5kbGUyID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZTEpLCBjdXJyZW50LmFkZChoYW5kbGUyKSxcblx0XHRcdFx0XHRjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGN1cnJlbnQuYWRkKGhhbmRsZSksIGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGFyY0J5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50LFxuXHRcdFx0XHRwb2ludCA9IGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhCYXNlLnBlZWsoYXJndW1lbnRzKSwgdHJ1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGNsb2Nrd2lzZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihqb2luKSB7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdGlmIChqb2luKVxuXHRcdFx0XHR0aGlzLmpvaW4oKTtcblx0XHR9XG5cdH07XG59LCB7ICBcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHJldHVybiBQYXRoW2dldHRlcl0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRtYXRyaXgpO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBzdW0gPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdiA9IEN1cnZlLmdldFZhbHVlcyhcblx0XHRcdFx0XHRzZWdtZW50c1tpXSwgc2VnbWVudHNbaSArIDEgPCBsID8gaSArIDEgOiAwXSk7XG5cdFx0XHRmb3IgKHZhciBqID0gMjsgaiA8IDg7IGogKz0gMilcblx0XHRcdFx0c3VtICs9ICh2W2ogLSAyXSAtIHZbal0pICogKHZbaiArIDFdICsgdltqIC0gMV0pO1xuXHRcdH1cblx0XHRyZXR1cm4gc3VtID4gMDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHN0cm9rZVBhZGRpbmcpIHtcblx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXTtcblx0XHRpZiAoIWZpcnN0KVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0cHJldkNvb3JkcyA9IGZpcnN0Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIG5ldyBBcnJheSg2KSwgZmFsc2UpLFxuXHRcdFx0bWluID0gcHJldkNvb3Jkcy5zbGljZSgwLCAyKSwgXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSwgXG5cdFx0XHRyb290cyA9IG5ldyBBcnJheSgyKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuXHRcdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaV0sIFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaSArIDRdLCBcblx0XHRcdFx0XHRjb29yZHNbaSArIDJdLCBcblx0XHRcdFx0XHRjb29yZHNbaV0sIFxuXHRcdFx0XHRcdGksIHN0cm9rZVBhZGRpbmcgPyBzdHJva2VQYWRkaW5nW2ldIDogMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRcdH1cblx0XHRcdHZhciB0bXAgPSBwcmV2Q29vcmRzO1xuXHRcdFx0cHJldkNvb3JkcyA9IGNvb3Jkcztcblx0XHRcdGNvb3JkcyA9IHRtcDtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHByb2Nlc3NTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAoY2xvc2VkKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoZmlyc3QpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0Z2V0U3Ryb2tlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0aWYgKCFzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdHJldHVybiBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KTtcblx0XHR2YXIgbGVuZ3RoID0gc2VnbWVudHMubGVuZ3RoIC0gKGNsb3NlZCA/IDAgOiAxKSxcblx0XHRcdHJhZGl1cyA9IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyLFxuXHRcdFx0cGFkZGluZyA9IFBhdGguX2dldFBlblBhZGRpbmcocmFkaXVzLCBtYXRyaXgpLFxuXHRcdFx0Ym91bmRzID0gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgcGFkZGluZyksXG5cdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0Y2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdHZhciBqb2luQm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgU2l6ZShwYWRkaW5nKS5tdWx0aXBseSgyKSk7XG5cblx0XHRmdW5jdGlvbiBhZGQocG9pbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy5pbmNsdWRlKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50KSA6IHBvaW50KTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRSb3VuZChzZWdtZW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMudW5pdGUoam9pbkJvdW5kcy5zZXRDZW50ZXIobWF0cml4XG5cdFx0XHRcdD8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChzZWdtZW50Ll9wb2ludCkgOiBzZWdtZW50Ll9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZEpvaW4oc2VnbWVudCwgam9pbikge1xuXHRcdFx0dmFyIGhhbmRsZUluID0gc2VnbWVudC5faGFuZGxlSW4sXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQuX2hhbmRsZU91dFxuXHRcdFx0aWYgKGpvaW4gPT09ICdyb3VuZCcgfHwgIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQmJiBoYW5kbGVJbi5pc0NvbGluZWFyKGhhbmRsZU91dCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcblx0XHRcdGlmIChjYXAgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbaV0sIGpvaW4pO1xuXHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuXHRcdH0gZWxzZSBpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdF9nZXRQZW5QYWRkaW5nOiBmdW5jdGlvbihyYWRpdXMsIG1hdHJpeCkge1xuXHRcdGlmICghbWF0cml4KVxuXHRcdFx0cmV0dXJuIFtyYWRpdXMsIHJhZGl1c107XG5cdFx0dmFyIG14ID0gbWF0cml4LnNoaWZ0bGVzcygpLFxuXHRcdFx0aG9yID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChyYWRpdXMsIDApKSxcblx0XHRcdHZlciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoMCwgcmFkaXVzKSksXG5cdFx0XHRwaGkgPSBob3IuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEgPSBob3IuZ2V0TGVuZ3RoKCksXG5cdFx0XHRiID0gdmVyLmdldExlbmd0aCgpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MocGhpKSxcblx0XHRcdHRhbiA9IE1hdGgudGFuKHBoaSksXG5cdFx0XHR0eCA9IC1NYXRoLmF0YW4oYiAqIHRhbiAvIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4oYiAvICh0YW4gKiBhKSk7XG5cdFx0cmV0dXJuIFtNYXRoLmFicyhhICogTWF0aC5jb3ModHgpICogY29zIC0gYiAqIE1hdGguc2luKHR4KSAqIHNpbiksXG5cdFx0XHRcdE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG5cdH0sXG5cblx0X2FkZEJldmVsSm9pbjogZnVuY3Rpb24oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50QXQoMCwgdHJ1ZSksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0KDEsIHRydWUpLFxuXHRcdFx0bm9ybWFsMiA9IGN1cnZlMi5nZXROb3JtYWxBdCgwLCB0cnVlKSxcblx0XHRcdHN0ZXAgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMikgPCAwID8gLXJhZGl1cyA6IHJhZGl1cztcblx0XHRub3JtYWwxLnNldExlbmd0aChzdGVwKTtcblx0XHRub3JtYWwyLnNldExlbmd0aChzdGVwKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHR9XG5cdFx0aWYgKGpvaW4gPT09ICdtaXRlcicpIHtcblx0XHRcdHZhciBjb3JuZXIgPSBuZXcgTGluZShcblx0XHRcdFx0XHRwb2ludC5hZGQobm9ybWFsMSksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcblx0XHRcdFx0KS5pbnRlcnNlY3QobmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDIpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlXG5cdFx0XHRcdCksIHRydWUpO1xuXHRcdFx0aWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQpIHtcblx0XHRcdFx0YWRkUG9pbnQoY29ybmVyKTtcblx0XHRcdFx0aWYgKCFhcmVhKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFhcmVhKVxuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LFxuXHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuXHRcdFx0bm9ybWFsID0gbG9jLmdldE5vcm1hbCgpLm5vcm1hbGl6ZShyYWRpdXMpO1xuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHR9XG5cdFx0aWYgKGNhcCA9PT0gJ3NxdWFyZScpXG5cdFx0XHRwb2ludCA9IHBvaW50LmFkZChub3JtYWwucm90YXRlKGxvYy5nZXRQYXJhbWV0ZXIoKSA9PSAwID8gLTkwIDogOTApKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nLFxuXHRcdFx0am9pblBhZGRpbmcpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0eDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcblx0XHRcdFx0dmFyIHBhZGRpbmcgPSBqID09IDAgPyBqb2luUGFkZGluZyA6IHN0cm9rZVBhZGRpbmcsXG5cdFx0XHRcdFx0cGFkZGluZ1ggPSBwYWRkaW5nID8gcGFkZGluZ1swXSA6IDAsXG5cdFx0XHRcdFx0cGFkZGluZ1kgPSBwYWRkaW5nID8gcGFkZGluZ1sxXSA6IDAsXG5cdFx0XHRcdFx0eCA9IGNvb3Jkc1tqXSxcblx0XHRcdFx0XHR5ID0gY29vcmRzW2ogKyAxXSxcblx0XHRcdFx0XHR4biA9IHggLSBwYWRkaW5nWCxcblx0XHRcdFx0XHR4eCA9IHggKyBwYWRkaW5nWCxcblx0XHRcdFx0XHR5biA9IHkgLSBwYWRkaW5nWSxcblx0XHRcdFx0XHR5eCA9IHkgKyBwYWRkaW5nWTtcblx0XHRcdFx0aWYgKHhuIDwgeDEpIHgxID0geG47XG5cdFx0XHRcdGlmICh4eCA+IHgyKSB4MiA9IHh4O1xuXHRcdFx0XHRpZiAoeW4gPCB5MSkgeTEgPSB5bjtcblx0XHRcdFx0aWYgKHl4ID4geTIpIHkyID0geXg7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0Z2V0Um91Z2hCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpIHtcblx0XHR2YXIgc3Ryb2tlUmFkaXVzID0gc3R5bGUuaGFzU3Ryb2tlKCkgPyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMiA6IDAsXG5cdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzO1xuXHRcdGlmIChzdHJva2VSYWRpdXMgPiAwKSB7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlSm9pbigpID09PSAnbWl0ZXInKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gc3Ryb2tlUmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUNhcCgpID09PSAnc3F1YXJlJylcblx0XHRcdFx0am9pblJhZGl1cyA9IE1hdGgubWF4KGpvaW5SYWRpdXMsIHN0cm9rZVJhZGl1cyAqIE1hdGguc3FydCgyKSk7XG5cdFx0fVxuXHRcdHJldHVybiBQYXRoLmdldEhhbmRsZUJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LFxuXHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKHN0cm9rZVJhZGl1cywgbWF0cml4KSxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhqb2luUmFkaXVzLCBtYXRyaXgpKTtcblx0fVxufX0pO1xuXG5QYXRoLmluamVjdCh7IHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIga2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0ZWxsaXBzZVNlZ21lbnRzID0gW1xuXHRcdFx0bmV3IFNlZ21lbnQoWy0xLCAwXSwgWzAsIGthcHBhIF0sIFswLCAta2FwcGFdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAtMV0sIFsta2FwcGEsIDBdLCBba2FwcGEsIDAgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMSwgMF0sIFswLCAta2FwcGFdLCBbMCwga2FwcGEgXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgMV0sIFtrYXBwYSwgMCBdLCBbLWthcHBhLCAwXSlcblx0XHRdO1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZVBhdGgoc2VnbWVudHMsIGNsb3NlZCwgYXJncykge1xuXHRcdHZhciBwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJncyksXG5cdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZSAmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cGF0aC5fYWRkKHNlZ21lbnRzKTtcblx0XHRwYXRoLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBuZXcgQXJyYXkoNCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gZWxsaXBzZVNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChcblx0XHRcdFx0c2VnbWVudC5fcG9pbnQubXVsdGlwbHkocmFkaXVzKS5hZGQoY2VudGVyKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4ubXVsdGlwbHkocmFkaXVzKSxcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0Lm11bHRpcGx5KHJhZGl1cylcblx0XHRcdCk7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmdzKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChbXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJykpLFxuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSlcblx0XHRcdF0sIGZhbHNlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRDaXJjbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyksIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycsIDAsXG5cdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0XHRibCA9IHJlY3QuZ2V0Qm90dG9tTGVmdCh0cnVlKSxcblx0XHRcdFx0dGwgPSByZWN0LmdldFRvcExlZnQodHJ1ZSksXG5cdFx0XHRcdHRyID0gcmVjdC5nZXRUb3BSaWdodCh0cnVlKSxcblx0XHRcdFx0YnIgPSByZWN0LmdldEJvdHRvbVJpZ2h0KHRydWUpLFxuXHRcdFx0XHRzZWdtZW50cztcblx0XHRcdGlmICghcmFkaXVzIHx8IHJhZGl1cy5pc1plcm8oKSkge1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChicilcblx0XHRcdFx0XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKHJhZGl1cywgcmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHZhciByeCA9IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IHJhZGl1cy5oZWlnaHQsXG5cdFx0XHRcdFx0aHggPSByeCAqIGthcHBhLFxuXHRcdFx0XHRcdGh5ID0gcnkgKiBrYXBwYTtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuYWRkKHJ4LCAwKSwgbnVsbCwgWy1oeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLnN1YnRyYWN0KDAsIHJ5KSwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKDAsIHJ5KSwgbnVsbCwgWzAsIC1oeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZChyeCwgMCksIFstaHgsIDBdLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5zdWJ0cmFjdChyeCwgMCksIG51bGwsIFtoeCwgMF0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLmFkZCgwLCByeSksIFswLCAtaHldLCBudWxsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdCgwLCByeSksIG51bGwsIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KHJ4LCAwKSwgW2h4LCAwXSlcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSb3VuZFJlY3RhbmdsZTogJyNSZWN0YW5nbGUnLFxuXG5cdFx0RWxsaXBzZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZWxsaXBzZSA9IFNoYXBlLl9yZWFkRWxsaXBzZShhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoZWxsaXBzZS5jZW50ZXIsIGVsbGlwc2UucmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRPdmFsOiAnI0VsbGlwc2UnLFxuXG5cdFx0QXJjOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBmcm9tID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0dGhyb3VnaCA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0aHJvdWdoJyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyksXG5cdFx0XHRcdHByb3BzID0gQmFzZS5nZXROYW1lZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgocHJvcHMgJiYgcHJvcHMuaW5zZXJ0ID09PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5tb3ZlVG8oZnJvbSk7XG5cdFx0XHRwYXRoLmFyY1RvKHRocm91Z2gsIHRvKTtcblx0XHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdFx0fSxcblxuXHRcdFJlZ3VsYXJQb2x5Z29uOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHNpZGVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAnc2lkZXMnKSxcblx0XHRcdFx0cmFkaXVzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBzaWRlcyxcblx0XHRcdFx0dGhyZWUgPSAhKHNpZGVzICUgMyksXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCB0aHJlZSA/IC1yYWRpdXMgOiByYWRpdXMpLFxuXHRcdFx0XHRvZmZzZXQgPSB0aHJlZSA/IC0xIDogMC41LFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShzaWRlcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpZGVzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZChcblx0XHRcdFx0XHR2ZWN0b3Iucm90YXRlKChpICsgb2Zmc2V0KSAqIHN0ZXApKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0U3RhcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRwb2ludHMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdwb2ludHMnKSAqIDIsXG5cdFx0XHRcdHJhZGl1czEgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMxJyksXG5cdFx0XHRcdHJhZGl1czIgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMyJyksXG5cdFx0XHRcdHN0ZXAgPSAzNjAgLyBwb2ludHMsXG5cdFx0XHRcdHZlY3RvciA9IG5ldyBQb2ludCgwLCAtMSksXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHBvaW50cyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50czsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQodmVjdG9yLnJvdGF0ZShzdGVwICogaSlcblx0XHRcdFx0XHRcdC5tdWx0aXBseShpICUgMiA/IHJhZGl1czIgOiByYWRpdXMxKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgQ29tcG91bmRQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ29tcG91bmRQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNoaWxkcmVuOiBbXVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENvbXBvdW5kUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uIGluc2VydENoaWxkcmVuKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0aXRlbXMgPSBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIFBhdGgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gIV9wcmVzZXJ2ZSAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRpZiAoaXRlbS5fY2xvY2t3aXNlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0uc2V0Q2xvY2t3aXNlKGl0ZW0uX2luZGV4ID09PSAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0ucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5zbW9vdGgoKTtcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGNoaWxkICYmIGNoaWxkLmlzQ2xvY2t3aXNlKCk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9PSAhIWNsb2Nrd2lzZSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRjdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGN1cnZlcy5wdXNoLmFwcGx5KGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9wcmVjaXNpb24pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhdGhzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwYXRocy5wdXNoKGNoaWxkcmVuW2ldLmdldFBhdGhEYXRhKF9wcmVjaXNpb24pKTtcblx0XHRyZXR1cm4gcGF0aHMuam9pbignICcpO1xuXHR9XG59LCB7XG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnMudHlwZSA9PT0gJ3BhdGgnXG5cdFx0XHRcdD8gb3B0aW9uc1xuXHRcdFx0XHQ6IG5ldyBCYXNlKG9wdGlvbnMsIHsgZmlsbDogZmFsc2UgfSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblxuXHRcdGlmICghcGFyYW0uY2xpcCkge1xuXHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChzdHlsZS5oYXNTdHJva2UoKSlcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0bXggPSBjaGlsZC5fbWF0cml4O1xuXHRcdFx0Y2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeFxuXHRcdFx0XHRcdDogbWF0cml4LmNsb25lKCkuY29uY2F0ZW5hdGUoY2hpbGQuX21hdHJpeCkpO1xuXHRcdH1cblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcblx0XHRpZiAoY2hlY2sgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0dmFyIGZpZWxkcyA9IHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzKSxcblx0XHRcdFx0cGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50IDogbmV3IFBhdGgoKTtcblx0XHRcdGlmIChwYXRoICE9PSBjdXJyZW50KVxuXHRcdFx0XHR0aGlzLmFkZENoaWxkKHBhdGgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSksXG5cdFx0XHRcdGxhc3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihqb2luKSB7XG5cdFx0XHRnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKS5jbG9zZVBhdGgoam9pbik7XG5cdFx0fVxuXHR9O1xuXG5cdEJhc2UuZWFjaChbJ2xpbmVUbycsICdjdWJpY0N1cnZlVG8nLCAncXVhZHJhdGljQ3VydmVUbycsICdjdXJ2ZVRvJywgJ2FyY1RvJyxcblx0XHRcdCdsaW5lQnknLCAnY3ViaWNDdXJ2ZUJ5JywgJ3F1YWRyYXRpY0N1cnZlQnknLCAnY3VydmVCeScsICdhcmNCeSddLFxuXHRcdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGZpZWxkc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHRwYXRoW2tleV0uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0KTtcblxuXHRyZXR1cm4gZmllbGRzO1xufSk7XG5cblBhdGhJdGVtLmluamVjdChuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGNvbXB1dGVCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0b3IsIHN1YnRyYWN0KSB7XG5cdFx0ZnVuY3Rpb24gcHJlcGFyZVBhdGgocGF0aCkge1xuXHRcdFx0cmV0dXJuIHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSgpLnJlb3JpZW50KCkudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH1cblxuXHRcdHZhciBfcGF0aDEgPSBwcmVwYXJlUGF0aChwYXRoMSksXG5cdFx0XHRfcGF0aDIgPSBwYXRoMiAmJiBwYXRoMSAhPT0gcGF0aDIgJiYgcHJlcGFyZVBhdGgocGF0aDIpO1xuXHRcdGlmICghX3BhdGgxLmlzQ2xvY2t3aXNlKCkpXG5cdFx0XHRfcGF0aDEucmV2ZXJzZSgpO1xuXHRcdGlmIChfcGF0aDIgJiYgIShzdWJ0cmFjdCBeIF9wYXRoMi5pc0Nsb2Nrd2lzZSgpKSlcblx0XHRcdF9wYXRoMi5yZXZlcnNlKCk7XG5cdFx0c3BsaXRQYXRoKF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgdHJ1ZSkpO1xuXG5cdFx0dmFyIGNoYWluID0gW10sXG5cdFx0XHR3aW5kaW5ncyA9IFtdLFxuXHRcdFx0bGVuZ3RocyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBbXSxcblx0XHRcdG1vbm9DdXJ2ZXMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGNvbGxlY3QocGF0aHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gcGF0aHNbaV07XG5cdFx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHBhdGguX3NlZ21lbnRzKTtcblx0XHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIHBhdGguX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29sbGVjdChfcGF0aDEuX2NoaWxkcmVuIHx8IFtfcGF0aDFdKTtcblx0XHRpZiAoX3BhdGgyKVxuXHRcdFx0Y29sbGVjdChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKTtcblx0XHRzZWdtZW50cy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHZhciBfYSA9IGEuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0X2IgPSBiLl9pbnRlcnNlY3Rpb247XG5cdFx0XHRyZXR1cm4gIV9hICYmICFfYiB8fCBfYSAmJiBfYiA/IDAgOiBfYSA/IC0xIDogMTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll93aW5kaW5nICE9IG51bGwpXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0Y2hhaW4ubGVuZ3RoID0gd2luZGluZ3MubGVuZ3RoID0gbGVuZ3Rocy5sZW5ndGggPSAwO1xuXHRcdFx0dmFyIHRvdGFsTGVuZ3RoID0gMCxcblx0XHRcdFx0c3RhcnRTZWcgPSBzZWdtZW50O1xuXHRcdFx0ZG8ge1xuXHRcdFx0XHRjaGFpbi5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0XHRsZW5ndGhzLnB1c2godG90YWxMZW5ndGggKz0gc2VnbWVudC5nZXRDdXJ2ZSgpLmdldExlbmd0aCgpKTtcblx0XHRcdFx0c2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdFx0fSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0U2VnKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSB0b3RhbExlbmd0aCAqIE1hdGgucmFuZG9tKCksXG5cdFx0XHRcdFx0YW1vdW50ID0gbGVuZ3Rocy5sZW5ndGgsXG5cdFx0XHRcdFx0ayA9IDA7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAobGVuZ3Roc1trXSA+PSBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmIChrID4gMClcblx0XHRcdFx0XHRcdFx0bGVuZ3RoIC09IGxlbmd0aHNbayAtIDFdO1xuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IHdoaWxlICgrK2sgPCBhbW91bnQpO1xuXHRcdFx0XHR2YXIgY3VydmUgPSBjaGFpbltrXS5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRcdHBvaW50ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuXHRcdFx0XHRcdGhvciA9IGN1cnZlLmlzSG9yaXpvbnRhbCgpLFxuXHRcdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aDtcblx0XHRcdFx0aWYgKHBhdGguX3BhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdFx0XHRwYXRoID0gcGF0aC5fcGFyZW50O1xuXHRcdFx0XHR3aW5kaW5nc1tqXSA9IHN1YnRyYWN0ICYmIF9wYXRoMlxuXHRcdFx0XHRcdFx0JiYgKHBhdGggPT09IF9wYXRoMSAmJiBfcGF0aDIuX2dldFdpbmRpbmcocG9pbnQsIGhvcilcblx0XHRcdFx0XHRcdHx8IHBhdGggPT09IF9wYXRoMiAmJiAhX3BhdGgxLl9nZXRXaW5kaW5nKHBvaW50LCBob3IpKVxuXHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHQ6IGdldFdpbmRpbmcocG9pbnQsIG1vbm9DdXJ2ZXMsIGhvcik7XG5cdFx0XHR9XG5cdFx0XHR3aW5kaW5ncy5zb3J0KCk7XG5cdFx0XHR2YXIgd2luZGluZyA9IHdpbmRpbmdzWzFdO1xuXHRcdFx0Zm9yICh2YXIgaiA9IGNoYWluLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKVxuXHRcdFx0XHRjaGFpbltqXS5fd2luZGluZyA9IHdpbmRpbmc7XG5cdFx0fVxuXHRcdHZhciByZXN1bHQgPSBuZXcgQ29tcG91bmRQYXRoKCk7XG5cdFx0cmVzdWx0LmFkZENoaWxkcmVuKHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdG9yKSwgdHJ1ZSk7XG5cdFx0X3BhdGgxLnJlbW92ZSgpO1xuXHRcdGlmIChfcGF0aDIpXG5cdFx0XHRfcGF0aDIucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIHJlc3VsdC5yZWR1Y2UoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNwbGl0UGF0aChpbnRlcnNlY3Rpb25zKSB7XG5cdFx0dmFyIFRPTEVSQU5DRSA9IDAuMDAwMDEsXG5cdFx0XHRsaW5lYXJTZWdtZW50cztcblxuXHRcdGZ1bmN0aW9uIHJlc2V0TGluZWFyKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lYXJTZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBsaW5lYXJTZWdtZW50c1tpXTtcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0XHRcdFx0c2VnbWVudC5faGFuZGxlSW4uc2V0KDAsIDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aCAtIDEsIGN1cnZlLCBwcmV2TG9jOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGxvYyA9IGludGVyc2VjdGlvbnNbaV0sXG5cdFx0XHRcdHQgPSBsb2MuX3BhcmFtZXRlcjtcblx0XHRcdGlmIChwcmV2TG9jICYmIHByZXZMb2MuX2N1cnZlID09PSBsb2MuX2N1cnZlXG5cdFx0XHRcdFx0JiYgcHJldkxvYy5fcGFyYW1ldGVyID4gMCkge1xuXHRcdFx0XHR0IC89IHByZXZMb2MuX3BhcmFtZXRlcjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChsaW5lYXJTZWdtZW50cylcblx0XHRcdFx0XHRyZXNldExpbmVhcigpO1xuXHRcdFx0XHRjdXJ2ZSA9IGxvYy5fY3VydmU7XG5cdFx0XHRcdGxpbmVhclNlZ21lbnRzID0gY3VydmUuaXNMaW5lYXIoKSAmJiBbXTtcblx0XHRcdH1cblx0XHRcdHZhciBuZXdDdXJ2ZSxcblx0XHRcdFx0c2VnbWVudDtcblx0XHRcdGlmIChuZXdDdXJ2ZSA9IGN1cnZlLmRpdmlkZSh0LCB0cnVlLCB0cnVlKSkge1xuXHRcdFx0XHRzZWdtZW50ID0gbmV3Q3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0XHRjdXJ2ZSA9IG5ld0N1cnZlLmdldFByZXZpb3VzKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWdtZW50ID0gdCA8IFRPTEVSQU5DRVxuXHRcdFx0XHRcdD8gY3VydmUuX3NlZ21lbnQxXG5cdFx0XHRcdFx0OiB0ID4gMSAtIFRPTEVSQU5DRVxuXHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDJcblx0XHRcdFx0XHRcdDogY3VydmUuZ2V0UGFydExlbmd0aCgwLCB0KSA8IGN1cnZlLmdldFBhcnRMZW5ndGgodCwgMSlcblx0XHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0XHRzZWdtZW50Ll9pbnRlcnNlY3Rpb24gPSBsb2MuZ2V0SW50ZXJzZWN0aW9uKCk7XG5cdFx0XHRsb2MuX3NlZ21lbnQgPSBzZWdtZW50O1xuXHRcdFx0aWYgKGxpbmVhclNlZ21lbnRzKVxuXHRcdFx0XHRsaW5lYXJTZWdtZW50cy5wdXNoKHNlZ21lbnQpO1xuXHRcdFx0cHJldkxvYyA9IGxvYztcblx0XHR9XG5cdFx0aWYgKGxpbmVhclNlZ21lbnRzKVxuXHRcdFx0cmVzZXRMaW5lYXIoKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0dmFyIFRPTEVSQU5DRSA9IDAuMDAwMDEsXG5cdFx0XHR4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55LFxuXHRcdFx0d2luZExlZnQgPSAwLFxuXHRcdFx0d2luZFJpZ2h0ID0gMCxcblx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdE1BWCA9IDEgLSBUT0xFUkFOQ0U7XG5cdFx0aWYgKGhvcml6b250YWwpIHtcblx0XHRcdHZhciB5VG9wID0gLUluZmluaXR5LFxuXHRcdFx0XHR5Qm90dG9tID0gSW5maW5pdHksXG5cdFx0XHRcdHlCZWZvcmUgPSB5IC0gVE9MRVJBTkNFLFxuXHRcdFx0XHR5QWZ0ZXIgPSB5ICsgVE9MRVJBTkNFO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXNbaV0udmFsdWVzO1xuXHRcdFx0XHRpZiAoQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDAsIHgsIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRcdHZhciB5MCA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgcm9vdHNbal0sIDApLnk7XG5cdFx0XHRcdFx0XHRpZiAoeTAgPCB5QmVmb3JlICYmIHkwID4geVRvcCkge1xuXHRcdFx0XHRcdFx0XHR5VG9wID0geTA7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHkwID4geUFmdGVyICYmIHkwIDwgeUJvdHRvbSkge1xuXHRcdFx0XHRcdFx0XHR5Qm90dG9tID0geTA7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR5VG9wID0gKHlUb3AgKyB5KSAvIDI7XG5cdFx0XHR5Qm90dG9tID0gKHlCb3R0b20gKyB5KSAvIDI7XG5cdFx0XHRpZiAoeVRvcCA+IC1JbmZpbml0eSlcblx0XHRcdFx0d2luZExlZnQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludCh4LCB5VG9wKSwgY3VydmVzKTtcblx0XHRcdGlmICh5Qm90dG9tIDwgSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRSaWdodCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHgsIHlCb3R0b20pLCBjdXJ2ZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgeEJlZm9yZSA9IHggLSBUT0xFUkFOQ0UsXG5cdFx0XHRcdHhBZnRlciA9IHggKyBUT0xFUkFOQ0U7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGN1cnZlLnZhbHVlcyxcblx0XHRcdFx0XHR3aW5kaW5nID0gY3VydmUud2luZGluZyxcblx0XHRcdFx0XHRuZXh0ID0gY3VydmUubmV4dDtcblx0XHRcdFx0aWYgKHdpbmRpbmcgJiYgKHdpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHkgPj0gdmFsdWVzWzFdICYmIHkgPD0gdmFsdWVzWzddXG5cdFx0XHRcdFx0XHR8fCB5ID49IHZhbHVlc1s3XSAmJiB5IDw9IHZhbHVlc1sxXSlcblx0XHRcdFx0XHQmJiBDdXJ2ZS5zb2x2ZUN1YmljKHZhbHVlcywgMSwgeSwgcm9vdHMsIDAsXG5cdFx0XHRcdFx0XHQhbmV4dC53aW5kaW5nICYmIG5leHQudmFsdWVzWzFdID09PSB5ID8gMSA6IE1BWCkgPT09IDEpe1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0XHR4MCA9IEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgdCwgMCkueCxcblx0XHRcdFx0XHRcdHNsb3BlID0gQ3VydmUuZXZhbHVhdGUodmFsdWVzLCB0LCAxKS55O1xuXHRcdFx0XHRcdGlmIChhYnMoc2xvcGUpIDwgVE9MRVJBTkNFICYmICFDdXJ2ZS5pc0xpbmVhcih2YWx1ZXMpXG5cdFx0XHRcdFx0XHRcdHx8IHQgPCBUT0xFUkFOQ0UgJiYgc2xvcGUgKiBDdXJ2ZS5ldmFsdWF0ZShcblx0XHRcdFx0XHRcdFx0XHRjdXJ2ZS5wcmV2aW91cy52YWx1ZXMsIHQsIDEpLnkgPCAwKSB7XG5cdFx0XHRcdFx0XHRpZiAodGVzdENvbnRhaW5zICYmIHgwID49IHhCZWZvcmUgJiYgeDAgPD0geEFmdGVyKSB7XG5cdFx0XHRcdFx0XHRcdCsrd2luZExlZnQ7XG5cdFx0XHRcdFx0XHRcdCsrd2luZFJpZ2h0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoeDAgPD0geEJlZm9yZSkge1xuXHRcdFx0XHRcdFx0d2luZExlZnQgKz0gd2luZGluZztcblx0XHRcdFx0XHR9IGVsc2UgaWYgKHgwID49IHhBZnRlcikge1xuXHRcdFx0XHRcdFx0d2luZFJpZ2h0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBNYXRoLm1heChhYnMod2luZExlZnQpLCBhYnMod2luZFJpZ2h0KSk7XG5cdH1cblxuXHRmdW5jdGlvbiB0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRvciwgc2VsZk9wKSB7XG5cdFx0b3BlcmF0b3IgPSBvcGVyYXRvciB8fCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cdFx0dmFyIHBhdGhzID0gW10sXG5cdFx0XHRaRVJPID0gMWUtMyxcblx0XHRcdE9ORSA9IDEgLSAxZS0zO1xuXHRcdGZvciAodmFyIGkgPSAwLCBzZWcsIHN0YXJ0U2VnLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRzZWcgPSBzdGFydFNlZyA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0aWYgKHNlZy5fdmlzaXRlZCB8fCAhb3BlcmF0b3Ioc2VnLl93aW5kaW5nKSlcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKSxcblx0XHRcdFx0aW50ZXIgPSBzZWcuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0c3RhcnRJbnRlclNlZyA9IGludGVyICYmIGludGVyLl9zZWdtZW50LFxuXHRcdFx0XHRhZGRlZCA9IGZhbHNlLCBcblx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdGRvIHtcblx0XHRcdFx0dmFyIGhhbmRsZUluID0gZGlyID4gMCA/IHNlZy5faGFuZGxlSW4gOiBzZWcuX2hhbmRsZU91dCxcblx0XHRcdFx0XHRoYW5kbGVPdXQgPSBkaXIgPiAwID8gc2VnLl9oYW5kbGVPdXQgOiBzZWcuX2hhbmRsZUluLFxuXHRcdFx0XHRcdGludGVyU2VnO1xuXHRcdFx0XHRpZiAoYWRkZWQgJiYgKCFvcGVyYXRvcihzZWcuX3dpbmRpbmcpIHx8IHNlbGZPcClcblx0XHRcdFx0XHRcdCYmIChpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uKVxuXHRcdFx0XHRcdFx0JiYgKGludGVyU2VnID0gaW50ZXIuX3NlZ21lbnQpXG5cdFx0XHRcdFx0XHQmJiBpbnRlclNlZyAhPT0gc3RhcnRTZWcpIHtcblx0XHRcdFx0XHRpZiAoc2VsZk9wKSB7XG5cdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdHNlZyA9IGludGVyU2VnO1xuXHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIGMxID0gc2VnLmdldEN1cnZlKCk7XG5cdFx0XHRcdFx0XHRpZiAoZGlyID4gMClcblx0XHRcdFx0XHRcdFx0YzEgPSBjMS5nZXRQcmV2aW91cygpO1xuXHRcdFx0XHRcdFx0dmFyIHQxID0gYzEuZ2V0VGFuZ2VudEF0KGRpciA8IDEgPyBaRVJPIDogT05FLCB0cnVlKSxcblx0XHRcdFx0XHRcdFx0YzQgPSBpbnRlclNlZy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRcdFx0XHRjMyA9IGM0LmdldFByZXZpb3VzKCksXG5cdFx0XHRcdFx0XHRcdHQzID0gYzMuZ2V0VGFuZ2VudEF0KE9ORSwgdHJ1ZSksXG5cdFx0XHRcdFx0XHRcdHQ0ID0gYzQuZ2V0VGFuZ2VudEF0KFpFUk8sIHRydWUpLFxuXHRcdFx0XHRcdFx0XHR3MyA9IHQxLmNyb3NzKHQzKSxcblx0XHRcdFx0XHRcdFx0dzQgPSB0MS5jcm9zcyh0NCk7XG5cdFx0XHRcdFx0XHRpZiAodzMgKiB3NCAhPT0gMCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgY3VydmUgPSB3MyA8IHc0ID8gYzMgOiBjNCxcblx0XHRcdFx0XHRcdFx0XHRuZXh0Q3VydmUgPSBvcGVyYXRvcihjdXJ2ZS5fc2VnbWVudDEuX3dpbmRpbmcpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnZlXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHczIDwgdzQgPyBjNCA6IGMzLFxuXHRcdFx0XHRcdFx0XHRcdG5leHRTZWcgPSBuZXh0Q3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0XHRcdFx0XHRkaXIgPSBuZXh0Q3VydmUgPT09IGMzID8gLTEgOiAxO1xuXHRcdFx0XHRcdFx0XHRpZiAobmV4dFNlZy5fdmlzaXRlZCAmJiBzZWcuX3BhdGggIT09IG5leHRTZWcuX3BhdGhcblx0XHRcdFx0XHRcdFx0XHRcdFx0fHwgIW9wZXJhdG9yKG5leHRTZWcuX3dpbmRpbmcpKSB7XG5cdFx0XHRcdFx0XHRcdFx0ZGlyID0gMTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSBpbnRlclNlZy5fdmlzaXRlZDtcblx0XHRcdFx0XHRcdFx0XHRzZWcgPSBpbnRlclNlZztcblx0XHRcdFx0XHRcdFx0XHRpZiAobmV4dFNlZy5fdmlzaXRlZClcblx0XHRcdFx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGRpciA9IDE7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGhhbmRsZU91dCA9IGRpciA+IDAgPyBzZWcuX2hhbmRsZU91dCA6IHNlZy5faGFuZGxlSW47XG5cdFx0XHRcdH1cblx0XHRcdFx0cGF0aC5hZGQobmV3IFNlZ21lbnQoc2VnLl9wb2ludCwgYWRkZWQgJiYgaGFuZGxlSW4sIGhhbmRsZU91dCkpO1xuXHRcdFx0XHRhZGRlZCA9IHRydWU7XG5cdFx0XHRcdHNlZy5fdmlzaXRlZCA9IHRydWU7XG5cdFx0XHRcdHNlZyA9IGRpciA+IDAgPyBzZWcuZ2V0TmV4dCgpIDogc2VnLiBnZXRQcmV2aW91cygpO1xuXHRcdFx0fSB3aGlsZSAoc2VnICYmICFzZWcuX3Zpc2l0ZWRcblx0XHRcdFx0XHQmJiBzZWcgIT09IHN0YXJ0U2VnICYmIHNlZyAhPT0gc3RhcnRJbnRlclNlZ1xuXHRcdFx0XHRcdCYmIChzZWcuX2ludGVyc2VjdGlvbiB8fCBvcGVyYXRvcihzZWcuX3dpbmRpbmcpKSk7XG5cdFx0XHRpZiAoc2VnICYmIChzZWcgPT09IHN0YXJ0U2VnIHx8IHNlZyA9PT0gc3RhcnRJbnRlclNlZykpIHtcblx0XHRcdFx0cGF0aC5maXJzdFNlZ21lbnQuc2V0SGFuZGxlSW4oKHNlZyA9PT0gc3RhcnRJbnRlclNlZ1xuXHRcdFx0XHRcdFx0PyBzdGFydEludGVyU2VnIDogc2VnKS5faGFuZGxlSW4pO1xuXHRcdFx0XHRwYXRoLnNldENsb3NlZCh0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGgubGFzdFNlZ21lbnQuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF0aC5fc2VnbWVudHMubGVuZ3RoID5cblx0XHRcdFx0XHQocGF0aC5fY2xvc2VkID8gcGF0aC5pc1BvbHlnb24oKSA/IDIgOiAwIDogMSkpXG5cdFx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocztcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2dldFdpbmRpbmc6IGZ1bmN0aW9uKHBvaW50LCBob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpIHtcblx0XHRcdHJldHVybiBnZXRXaW5kaW5nKHBvaW50LCB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG5cdFx0XHRcdFx0aG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKTtcblx0XHR9LFxuXG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCBmdW5jdGlvbih3KSB7XG5cdFx0XHRcdHJldHVybiB3ID09PSAxIHx8IHcgPT09IDA7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsIGZ1bmN0aW9uKHcpIHtcblx0XHRcdFx0cmV0dXJuIHcgPT09IDI7XG5cdFx0XHR9LCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgZnVuY3Rpb24odykge1xuXHRcdFx0XHRyZXR1cm4gdyA9PT0gMTtcblx0XHRcdH0sIHRydWUpO1xuXHRcdH0sXG5cblx0XHRleGNsdWRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEdyb3VwKFt0aGlzLnN1YnRyYWN0KHBhdGgpLCBwYXRoLnN1YnRyYWN0KHRoaXMpXSk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIG5ldyBHcm91cChbdGhpcy5zdWJ0cmFjdChwYXRoKSwgdGhpcy5pbnRlcnNlY3QocGF0aCldKTtcblx0XHR9XG5cdH07XG59KTtcblxuUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzLFxuXHRcdFx0cHJldkN1cnZlO1xuXG5cdFx0ZnVuY3Rpb24gaW5zZXJ0Q3VydmUodikge1xuXHRcdFx0dmFyIHkwID0gdlsxXSxcblx0XHRcdFx0eTEgPSB2WzddLFxuXHRcdFx0XHRjdXJ2ZSA9IHtcblx0XHRcdFx0XHR2YWx1ZXM6IHYsXG5cdFx0XHRcdFx0d2luZGluZzogeTAgPT09IHkxXG5cdFx0XHRcdFx0XHQ/IDAgXG5cdFx0XHRcdFx0XHQ6IHkwID4geTFcblx0XHRcdFx0XHRcdFx0PyAtMSBcblx0XHRcdFx0XHRcdFx0OiAxLCBcblx0XHRcdFx0XHRwcmV2aW91czogcHJldkN1cnZlLFxuXHRcdFx0XHRcdG5leHQ6IG51bGwgXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocHJldkN1cnZlKVxuXHRcdFx0XHRwcmV2Q3VydmUubmV4dCA9IGN1cnZlO1xuXHRcdFx0bW9ub0N1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcblx0XHRcdGlmIChDdXJ2ZS5nZXRMZW5ndGgodikgPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdlszXSxcblx0XHRcdFx0eTIgPSB2WzVdLFxuXHRcdFx0XHR5MyA9IHZbN107XG5cdFx0XHRpZiAoQ3VydmUuaXNMaW5lYXIodikpIHtcblx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IDMgKiAoeTEgLSB5MikgLSB5MCArIHkzLFxuXHRcdFx0XHRcdGIgPSAyICogKHkwICsgeTIpIC0gNCAqIHkxLFxuXHRcdFx0XHRcdGMgPSB5MSAtIHkwLFxuXHRcdFx0XHRcdFRPTEVSQU5DRSA9IDAuMDAwMDEsXG5cdFx0XHRcdFx0cm9vdHMgPSBbXTtcblx0XHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzLCBUT0xFUkFOQ0UsXG5cdFx0XHRcdFx0XHQxIC0gVE9MRVJBTkNFKTtcblx0XHRcdFx0aWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2LCB0KTtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0aWYgKGNvdW50ID4gMSkge1xuXHRcdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcblx0XHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFtb25vQ3VydmVzKSB7XG5cdFx0XHRtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGhhbmRsZUN1cnZlKGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSk7XG5cdFx0XHRpZiAoIXRoaXMuX2Nsb3NlZCAmJiBzZWdtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhciBwMSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludCxcblx0XHRcdFx0XHRwMiA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRwMXggPSBwMS5feCwgcDF5ID0gcDEuX3ksXG5cdFx0XHRcdFx0cDJ4ID0gcDIuX3gsIHAyeSA9IHAyLl95O1xuXHRcdFx0XHRoYW5kbGVDdXJ2ZShbcDF4LCBwMXksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDJ4LCBwMnldKTtcblx0XHRcdH1cblx0XHRcdGlmIChtb25vQ3VydmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gbW9ub0N1cnZlc1swXSxcblx0XHRcdFx0XHRsYXN0ID0gbW9ub0N1cnZlc1ttb25vQ3VydmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRmaXJzdC5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0XHRcdGxhc3QubmV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdFx0eEludGVyY2VwdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKChjdXJ2ZXNbaV0ud2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG5cdFx0XHRcdFx0XHR4SW50ZXJjZXB0cy5wdXNoKEN1cnZlLmV2YWx1YXRlKHZhbHVlcywgcm9vdHNbal0sIDApLngpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4SW50ZXJjZXB0cy5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnQueCA9ICh4SW50ZXJjZXB0c1swXSArIHhJbnRlcmNlcHRzWzFdKSAvIDI7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRDbG9ja3dpc2UodHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5Db21wb3VuZFBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9ICB0aGlzLl9jaGlsZHJlbixcblx0XHRcdG1vbm9DdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdG1vbm9DdXJ2ZXMucHVzaC5hcHBseShtb25vQ3VydmVzLCBjaGlsZHJlbltpXS5fZ2V0TW9ub0N1cnZlcygpKTtcblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5yZW1vdmVDaGlsZHJlbigpLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGIuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpIC0gYS5nZXRCb3VuZHMoKS5nZXRBcmVhKCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0dmFyIGNsb2Nrd2lzZSA9IGNoaWxkcmVuWzBdLmlzQ2xvY2t3aXNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHsgXG5cdFx0XHR2YXIgcG9pbnQgPSBjaGlsZHJlbltpXS5nZXRJbnRlcmlvclBvaW50KCksXG5cdFx0XHRcdGNvdW50ZXJzID0gMDtcblx0XHRcdGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW2pdLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRjb3VudGVycysrO1xuXHRcdFx0fVxuXHRcdFx0Y2hpbGRyZW5baV0uc2V0Q2xvY2t3aXNlKGNvdW50ZXJzICUgMiA9PT0gMCAmJiBjbG9ja3dpc2UpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbnZhciBQYXRoRmxhdHRlbmVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0dGhpcy5jdXJ2ZXMgPSBbXTsgXG5cdFx0dGhpcy5wYXJ0cyA9IFtdOyBcblx0XHR0aGlzLmxlbmd0aCA9IDA7IFxuXHRcdHRoaXMuaW5kZXggPSAwO1xuXG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnRzWzBdLFxuXHRcdFx0c2VnbWVudDIsXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHR0aGF0LmN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHRoYXQuX2NvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnbWVudDIgPSBzZWdtZW50c1tpXTtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnQyO1xuXHRcdH1cblx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblx0fSxcblxuXHRfY29tcHV0ZVBhcnRzOiBmdW5jdGlvbihjdXJ2ZSwgaW5kZXgsIG1pblQsIG1heFQpIHtcblx0XHRpZiAoKG1heFQgLSBtaW5UKSA+IDEgLyAzMiAmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCAwLjI1KSkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IEN1cnZlLnN1YmRpdmlkZShjdXJ2ZSk7XG5cdFx0XHR2YXIgaGFsZlQgPSAobWluVCArIG1heFQpIC8gMjtcblx0XHRcdHRoaXMuX2NvbXB1dGVQYXJ0cyhjdXJ2ZXNbMF0sIGluZGV4LCBtaW5ULCBoYWxmVCk7XG5cdFx0XHR0aGlzLl9jb21wdXRlUGFydHMoY3VydmVzWzFdLCBpbmRleCwgaGFsZlQsIG1heFQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgeCA9IGN1cnZlWzZdIC0gY3VydmVbMF0sXG5cdFx0XHRcdHkgPSBjdXJ2ZVs3XSAtIGN1cnZlWzFdLFxuXHRcdFx0XHRkaXN0ID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0aWYgKGRpc3QgPiAwLjAwMDAxKSB7XG5cdFx0XHRcdHRoaXMubGVuZ3RoICs9IGRpc3Q7XG5cdFx0XHRcdHRoaXMucGFydHMucHVzaCh7XG5cdFx0XHRcdFx0b2Zmc2V0OiB0aGlzLmxlbmd0aCxcblx0XHRcdFx0XHR2YWx1ZTogbWF4VCxcblx0XHRcdFx0XHRpbmRleDogaW5kZXhcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbihvZmZzZXQpIHtcblx0XHR2YXIgaSwgaiA9IHRoaXMuaW5kZXg7XG5cdFx0Zm9yICg7Oykge1xuXHRcdFx0aSA9IGo7XG5cdFx0XHRpZiAoaiA9PSAwIHx8IHRoaXMucGFydHNbLS1qXS5vZmZzZXQgPCBvZmZzZXQpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRmb3IgKHZhciBsID0gdGhpcy5wYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1tpXTtcblx0XHRcdGlmIChwYXJ0Lm9mZnNldCA+PSBvZmZzZXQpIHtcblx0XHRcdFx0dGhpcy5pbmRleCA9IGk7XG5cdFx0XHRcdHZhciBwcmV2ID0gdGhpcy5wYXJ0c1tpIC0gMV07XG5cdFx0XHRcdHZhciBwcmV2VmFsID0gcHJldiAmJiBwcmV2LmluZGV4ID09IHBhcnQuaW5kZXggPyBwcmV2LnZhbHVlIDogMCxcblx0XHRcdFx0XHRwcmV2TGVuID0gcHJldiA/IHByZXYub2Zmc2V0IDogMDtcblx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHR2YWx1ZTogcHJldlZhbCArIChwYXJ0LnZhbHVlIC0gcHJldlZhbClcblx0XHRcdFx0XHRcdCogKG9mZnNldCAtIHByZXZMZW4pIC8gIChwYXJ0Lm9mZnNldCAtIHByZXZMZW4pLFxuXHRcdFx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogMSxcblx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0fTtcblx0fSxcblxuXHRldmFsdWF0ZTogZnVuY3Rpb24ob2Zmc2V0LCB0eXBlKSB7XG5cdFx0dmFyIHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdHJldHVybiBDdXJ2ZS5ldmFsdWF0ZSh0aGlzLmN1cnZlc1twYXJhbS5pbmRleF0sIHBhcmFtLnZhbHVlLCB0eXBlKTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdGZyb20gPSB0aGlzLmdldFBhcmFtZXRlckF0KGZyb20pO1xuXHRcdHRvID0gdGhpcy5nZXRQYXJhbWV0ZXJBdCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20uaW5kZXg7IGkgPD0gdG8uaW5kZXg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09IGZyb20uaW5kZXggPyBmcm9tLnZhbHVlIDogMCxcblx0XHRcdFx0XHRpID09IHRvLmluZGV4ID8gdG8udmFsdWUgOiAxKTtcblx0XHRcdGlmIChpID09IGZyb20uaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBlcnJvcikge1xuXHRcdHRoaXMucG9pbnRzID0gW107XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRwcmV2O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50c1tpXS5wb2ludC5jbG9uZSgpO1xuXHRcdFx0aWYgKCFwcmV2IHx8ICFwcmV2LmVxdWFscyhwb2ludCkpIHtcblx0XHRcdFx0dGhpcy5wb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdHByZXYgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aDtcblx0XHR0aGlzLnNlZ21lbnRzID0gbGVuZ3RoID4gMCA/IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXSA6IFtdO1xuXHRcdGlmIChsZW5ndGggPiAxKVxuXHRcdFx0dGhpcy5maXRDdWJpYygwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKS5ub3JtYWxpemUoKSxcblx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuXHRcdHJldHVybiB0aGlzLnNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heCh0aGlzLmVycm9yLCB0aGlzLmVycm9yICogdGhpcy5lcnJvciksXG5cdFx0XHRzcGxpdDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IHRoaXMuZXJyb3IpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcblx0XHRcdG1heEVycm9yID0gbWF4LmVycm9yO1xuXHRcdH1cblx0XHR2YXIgVjEgPSB0aGlzLnBvaW50c1tzcGxpdCAtIDFdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0XSksXG5cdFx0XHRWMiA9IHRoaXMucG9pbnRzW3NwbGl0XS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdCArIDFdKSxcblx0XHRcdHRhbkNlbnRlciA9IFYxLmFkZChWMikuZGl2aWRlKDIpLm5vcm1hbGl6ZSgpO1xuXHRcdHRoaXMuZml0Q3ViaWMoZmlyc3QsIHNwbGl0LCB0YW4xLCB0YW5DZW50ZXIpO1xuXHRcdHRoaXMuZml0Q3ViaWMoc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG5cdH0sXG5cblx0YWRkQ3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLnNlZ21lbnRzW3RoaXMuc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdFx0cHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcblx0XHR0aGlzLnNlZ21lbnRzLnB1c2goXG5cdFx0XHRcdG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcblx0fSxcblxuXHRnZW5lcmF0ZUJlemllcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtMTEsXG5cdFx0XHRwdDEgPSB0aGlzLnBvaW50c1tmaXJzdF0sXG5cdFx0XHRwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcblx0XHRcdEMgPSBbWzAsIDBdLCBbMCwgMF1dLFxuXHRcdFx0WCA9IFswLCAwXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHUgPSB1UHJpbWVbaV0sXG5cdFx0XHRcdHQgPSAxIC0gdSxcblx0XHRcdFx0YiA9IDMgKiB1ICogdCxcblx0XHRcdFx0YjAgPSB0ICogdCAqIHQsXG5cdFx0XHRcdGIxID0gYiAqIHQsXG5cdFx0XHRcdGIyID0gYiAqIHUsXG5cdFx0XHRcdGIzID0gdSAqIHUgKiB1LFxuXHRcdFx0XHRhMSA9IHRhbjEubm9ybWFsaXplKGIxKSxcblx0XHRcdFx0YTIgPSB0YW4yLm5vcm1hbGl6ZShiMiksXG5cdFx0XHRcdHRtcCA9IHRoaXMucG9pbnRzW2ZpcnN0ICsgaV1cblx0XHRcdFx0XHQuc3VidHJhY3QocHQxLm11bHRpcGx5KGIwICsgYjEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDIubXVsdGlwbHkoYjIgKyBiMykpO1xuXHRcdFx0Q1swXVswXSArPSBhMS5kb3QoYTEpO1xuXHRcdFx0Q1swXVsxXSArPSBhMS5kb3QoYTIpO1xuXHRcdFx0Q1sxXVswXSA9IENbMF1bMV07XG5cdFx0XHRDWzFdWzFdICs9IGEyLmRvdChhMik7XG5cdFx0XHRYWzBdICs9IGExLmRvdCh0bXApO1xuXHRcdFx0WFsxXSArPSBhMi5kb3QodG1wKTtcblx0XHR9XG5cblx0XHR2YXIgZGV0QzBDMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV0sXG5cdFx0XHRhbHBoYTEsIGFscGhhMjtcblx0XHRpZiAoTWF0aC5hYnMoZGV0QzBDMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHR2YXIgZGV0QzBYICA9IENbMF1bMF0gKiBYWzFdICAgIC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMSAgPSBYWzBdICAgICogQ1sxXVsxXSAtIFhbMV0gICAgKiBDWzBdWzFdO1xuXHRcdFx0YWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcblx0XHRcdGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuXHRcdFx0XHRjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuXHRcdFx0aWYgKE1hdGguYWJzKGMwKSA+IGVwc2lsb24pIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gWFswXSAvIGMwO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhjMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMV0gLyBjMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpO1xuXHRcdGVwc2lsb24gKj0gc2VnTGVuZ3RoO1xuXHRcdGlmIChhbHBoYTEgPCBlcHNpbG9uIHx8IGFscGhhMiA8IGVwc2lsb24pIHtcblx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoYWxwaGExKSksXG5cdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG5cdH0sXG5cblx0cmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuXHRcdH1cblx0fSxcblxuXHRmaW5kUm9vdDogZnVuY3Rpb24oY3VydmUsIHBvaW50LCB1KSB7XG5cdFx0dmFyIGN1cnZlMSA9IFtdLFxuXHRcdFx0Y3VydmUyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0XHRcdGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG5cdFx0XHRwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG5cdFx0XHRwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG5cdFx0XHRkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuXHRcdFx0ZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuXHRcdGlmIChNYXRoLmFicyhkZikgPCAwLjAwMDAxKVxuXHRcdFx0cmV0dXJuIHU7XG5cdFx0cmV0dXJuIHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKGRlZ3JlZSwgY3VydmUsIHQpIHtcblx0XHR2YXIgdG1wID0gY3VydmUuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG5cdFx0XHRcdHRtcFtqXSA9IHRtcFtqXS5tdWx0aXBseSgxIC0gdCkuYWRkKHRtcFtqICsgMV0ubXVsdGlwbHkodCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG1wWzBdO1xuXHR9LFxuXG5cdGNob3JkTGVuZ3RoUGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCkge1xuXHRcdHZhciB1ID0gWzBdO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB1W2kgLSBmaXJzdCAtIDFdXG5cdFx0XHRcdFx0KyB0aGlzLnBvaW50c1tpXS5nZXREaXN0YW5jZSh0aGlzLnBvaW50c1tpIC0gMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbSA9IGxhc3QgLSBmaXJzdDsgaSA8PSBtOyBpKyspIHtcblx0XHRcdHVbaV0gLz0gdVttXTtcblx0XHR9XG5cdFx0cmV0dXJuIHU7XG5cdH0sXG5cblx0ZmluZE1heEVycm9yOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgY3VydmUsIHUpIHtcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKChsYXN0IC0gZmlyc3QgKyAxKSAvIDIpLFxuXHRcdFx0bWF4RGlzdCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuXHRcdFx0dmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuXHRcdFx0dmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcblx0XHRcdHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55OyBcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRleHRJdGVtKGFyZykge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJztcblx0XHR0aGlzLl9saW5lcyA9IFtdO1xuXHRcdHZhciBoYXNQcm9wcyA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQmJiBhcmcueCA9PT0gdW5kZWZpbmVkICYmIGFyZy55ID09PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShoYXNQcm9wcyAmJiBhcmcsICFoYXNQcm9wcyAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudCA9PT0gaXRlbS5fY29udGVudDtcblx0fSxcblxuXHRfY2xvbmU6IGZ1bmN0aW9uIF9jbG9uZShjb3B5KSB7XG5cdFx0Y29weS5zZXRDb250ZW50KHRoaXMuX2NvbnRlbnQpO1xuXHRcdHJldHVybiBfY2xvbmUuYmFzZS5jYWxsKHRoaXMsIGNvcHkpO1xuXHR9LFxuXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJycgKyBjb250ZW50O1xuXHRcdHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuXHRcdHRoaXMuX2NoYW5nZWQoMjY1KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0Z2V0Q2hhcmFjdGVyU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG5cblx0Z2V0UGFyYWdyYXBoU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRQYXJhZ3JhcGhTdHlsZTogJyNzZXRTdHlsZSdcbn0pO1xuXG52YXIgUG9pbnRUZXh0ID0gVGV4dEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnRUZXh0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludFRleHQoKSB7XG5cdFx0VGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKG5ldyBQb2ludFRleHQoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFBvaW50KHBvaW50LngsIHBvaW50LnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy50cmFuc2xhdGUocG9pbnQuc3VidHJhY3QodGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcblx0XHRjdHguZm9udCA9IHN0eWxlLmdldEZvbnRTdHlsZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRcdGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcblx0XHRcdGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0d2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcblx0XHRcdHggPSAwO1xuXHRcdGlmIChqdXN0aWZpY2F0aW9uICE9PSAnbGVmdCcpXG5cdFx0XHR4IC09IHdpZHRoIC8gKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInID8gMjogMSk7XG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoeCxcblx0XHRcdFx0XHRudW1MaW5lcyA/IC0gMC43NSAqIGxlYWRpbmcgOiAwLFxuXHRcdFx0XHRcdHdpZHRoLCBudW1MaW5lcyAqIGxlYWRpbmcpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIGJvdW5kcykgOiBib3VuZHM7XG5cdH1cbn0pO1xuXG52YXIgQ29sb3IgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIHR5cGVzID0ge1xuXHRcdGdyYXk6IFsnZ3JheSddLFxuXHRcdHJnYjogWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddLFxuXHRcdGhzYjogWydodWUnLCAnc2F0dXJhdGlvbicsICdicmlnaHRuZXNzJ10sXG5cdFx0aHNsOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2xpZ2h0bmVzcyddLFxuXHRcdGdyYWRpZW50OiBbJ2dyYWRpZW50JywgJ29yaWdpbicsICdkZXN0aW5hdGlvbicsICdoaWdobGlnaHQnXVxuXHR9O1xuXG5cdHZhciBjb21wb25lbnRQYXJzZXJzID0ge30sXG5cdFx0Y29sb3JDYWNoZSA9IHt9LFxuXHRcdGNvbG9yQ3R4O1xuXG5cdGZ1bmN0aW9uIGZyb21DU1Moc3RyaW5nKSB7XG5cdFx0dmFyIG1hdGNoID0gc3RyaW5nLm1hdGNoKC9eIyhcXHd7MSwyfSkoXFx3ezEsMn0pKFxcd3sxLDJ9KSQvKSxcblx0XHRcdGNvbXBvbmVudHM7XG5cdFx0aWYgKG1hdGNoKSB7XG5cdFx0XHRjb21wb25lbnRzID0gWzAsIDAsIDBdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gbWF0Y2hbaSArIDFdO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gcGFyc2VJbnQodmFsdWUubGVuZ3RoID09IDFcblx0XHRcdFx0XHRcdD8gdmFsdWUgKyB2YWx1ZSA6IHZhbHVlLCAxNikgLyAyNTU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtYXRjaCA9IHN0cmluZy5tYXRjaCgvXnJnYmE/XFwoKC4qKVxcKSQvKSkge1xuXHRcdFx0Y29tcG9uZW50cyA9IG1hdGNoWzFdLnNwbGl0KCcsJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9ICtjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRjb21wb25lbnRzW2ldID0gaSA8IDMgPyB2YWx1ZSAvIDI1NSA6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddO1xuXHRcdFx0aWYgKCFjYWNoZWQpIHtcblx0XHRcdFx0aWYgKCFjb2xvckN0eCkge1xuXHRcdFx0XHRcdGNvbG9yQ3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdFx0XHRjb2xvckN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnY29weSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSBzdHJpbmc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHR2YXIgZGF0YSA9IGNvbG9yQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhO1xuXHRcdFx0XHRjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ10gPSBbXG5cdFx0XHRcdFx0ZGF0YVswXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzFdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMl0gLyAyNTVcblx0XHRcdFx0XTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBjYWNoZWQuc2xpY2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdH1cblxuXHR2YXIgaHNiSW5kaWNlcyA9IFtcblx0XHRbMCwgMywgMV0sIFxuXHRcdFsyLCAwLCAxXSwgXG5cdFx0WzEsIDAsIDNdLCBcblx0XHRbMSwgMiwgMF0sIFxuXHRcdFszLCAxLCAwXSwgXG5cdFx0WzAsIDEsIDJdICBcblx0XTtcblxuXHR2YXIgY29udmVydGVycyA9IHtcblx0XHQncmdiLWhzYic6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRoID0gZGVsdGEgPT09IDAgPyAwXG5cdFx0XHRcdFx0OiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MDsgXG5cdFx0XHRyZXR1cm4gW2gsIG1heCA9PT0gMCA/IDAgOiBkZWx0YSAvIG1heCwgbWF4XTtcblx0XHR9LFxuXG5cdFx0J2hzYi1yZ2InOiBmdW5jdGlvbihoLCBzLCBiKSB7XG5cdFx0XHRoID0gKCgoaCAvIDYwKSAlIDYpICsgNikgJSA2O1xuXHRcdFx0dmFyIGkgPSBNYXRoLmZsb29yKGgpLCBcblx0XHRcdFx0ZiA9IGggLSBpLFxuXHRcdFx0XHRpID0gaHNiSW5kaWNlc1tpXSxcblx0XHRcdFx0diA9IFtcblx0XHRcdFx0XHRiLFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMpLFx0XHRcdFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiBmKSxcdFx0XG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqICgxIC0gZikpXHRcblx0XHRcdFx0XTtcblx0XHRcdHJldHVybiBbdltpWzBdXSwgdltpWzFdXSwgdltpWzJdXV07XG5cdFx0fSxcblxuXHRcdCdyZ2ItaHNsJzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0dmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpLFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbihyLCBnLCBiKSxcblx0XHRcdFx0ZGVsdGEgPSBtYXggLSBtaW4sXG5cdFx0XHRcdGFjaHJvbWF0aWMgPSBkZWx0YSA9PT0gMCxcblx0XHRcdFx0aCA9IGFjaHJvbWF0aWMgPyAwXG5cdFx0XHRcdFx0OiAgICggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6ICAgICAgICAgICAgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MCwgXG5cdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDIsXG5cdFx0XHRcdHMgPSBhY2hyb21hdGljID8gMCA6IGwgPCAwLjVcblx0XHRcdFx0XHRcdD8gZGVsdGEgLyAobWF4ICsgbWluKVxuXHRcdFx0XHRcdFx0OiBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0XHRcdHJldHVybiBbaCwgcywgbF07XG5cdFx0fSxcblxuXHRcdCdoc2wtcmdiJzogZnVuY3Rpb24oaCwgcywgbCkge1xuXHRcdFx0aCA9ICgoKGggLyAzNjApICUgMSkgKyAxKSAlIDE7XG5cdFx0XHRpZiAocyA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtsLCBsLCBsXTtcblx0XHRcdHZhciB0M3MgPSBbIGggKyAxIC8gMywgaCwgaCAtIDEgLyAzIF0sXG5cdFx0XHRcdHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcblx0XHRcdFx0dDEgPSAyICogbCAtIHQyLFxuXHRcdFx0XHRjID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdDMgPSB0M3NbaV07XG5cdFx0XHRcdGlmICh0MyA8IDApIHQzICs9IDE7XG5cdFx0XHRcdGlmICh0MyA+IDEpIHQzIC09IDE7XG5cdFx0XHRcdGNbaV0gPSA2ICogdDMgPCAxXG5cdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqIDYgKiB0M1xuXHRcdFx0XHRcdDogMiAqIHQzIDwgMVxuXHRcdFx0XHRcdFx0PyB0MlxuXHRcdFx0XHRcdFx0OiAzICogdDMgPCAyXG5cdFx0XHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiAoKDIgLyAzKSAtIHQzKSAqIDZcblx0XHRcdFx0XHRcdFx0OiB0MTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYXknOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHRyZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1yZ2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gW2csIGcsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2wnOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JhZGllbnQtcmdiJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JhZGllbnQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG5cdFx0Y29tcG9uZW50UGFyc2Vyc1t0eXBlXSA9IFtdO1xuXHRcdEJhc2UuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdGhhc092ZXJsYXAgPSAvXihodWV8c2F0dXJhdGlvbikkLy50ZXN0KG5hbWUpLFxuXHRcdFx0XHRwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IG5hbWUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudCA9IHRoaXMuX2NvbXBvbmVudHNbMF07XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IEdyYWRpZW50LnJlYWQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdDogYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChjdXJyZW50KVxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQuX3JlbW92ZU93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUuX2FkZE93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdD8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE51bGw6IG5hbWUgPT09ICdoaWdobGlnaHQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvbmU6IHRydWVcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdHx8IGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2NvbnZlcnQodHlwZSlbaW5kZXhdO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09IHR5cGVcblx0XHRcdFx0XHRcdCYmICEoaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkpKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhbHVlID0gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sIHRoaXMpO1xuXHR9LCB7XG5cdFx0X2NsYXNzOiAnQ29sb3InLFxuXHRcdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb2xvcihhcmcpIHtcblx0XHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cmVhZCA9IDAsXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMsXG5cdFx0XHRcdGFscGhhLFxuXHRcdFx0XHR2YWx1ZXM7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMF07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmc7XG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgJiYgYXJnIGluIHR5cGVzKSB7XG5cdFx0XHRcdHR5cGUgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnO1xuXHRcdFx0XHRcdGFscGhhID0gYXJnc1syXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkID0gMTsgXG5cdFx0XHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoYXJncywgMSk7XG5cdFx0XHRcdFx0YXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBhcmdzXG5cdFx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRpZiAoIXR5cGUpXG5cdFx0XHRcdFx0XHR0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzXG5cdFx0XHRcdFx0XHRcdFx0PyAncmdiJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG5cdFx0XHRcdFx0YWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkICs9IHZhbHVlcyA9PT0gYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdD8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMClcblx0XHRcdFx0XHRcdFx0OiAxO1xuXHRcdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKVxuXHRcdFx0XHRcdFx0dmFsdWVzID0gc2xpY2UuY2FsbCh2YWx1ZXMsIDAsIGxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0eXBlID0gJ3JnYic7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGZyb21DU1MoYXJnKTtcblx0XHRcdFx0XHRpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdGFscGhhID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSBhcmcuX3R5cGU7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5fYWxwaGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBHcmFkaWVudCkge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdncmFkaWVudCc7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBhcmdzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2h1ZScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdD8gJ2xpZ2h0bmVzcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnaHNsJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2hzYidcblx0XHRcdFx0XHRcdFx0OiAnZ3JhZGllbnQnIGluIGFyZyB8fCAnc3RvcHMnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0fHwgJ3JhZGlhbCcgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICdncmF5J1xuXHRcdFx0XHRcdFx0XHRcdFx0OiAncmdiJztcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHRcdFx0XHRcdHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuXHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gYXJnW3Byb3BlcnRpZXNbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiBpID09PSAwICYmIHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHRcdCYmICdzdG9wcycgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdG9wczogYXJnLnN0b3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmFkaWFsOiBhcmcucmFkaWFsXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLmFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQgJiYgdHlwZSlcblx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8ICdyZ2InO1xuXHRcdFx0aWYgKHR5cGUgPT09ICdncmFkaWVudCcpXG5cdFx0XHRcdHRoaXMuX2lkID0gQ29sb3IuX2lkID0gKENvbG9yLl9pZCB8fCAwKSArIDE7XG5cdFx0XHRpZiAoIWNvbXBvbmVudHMpIHtcblx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0dmFyIHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3RoaXMuX3R5cGVdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnNlcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlcyAmJiB2YWx1ZXNbaV0pO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cztcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0aGlzLl90eXBlXTtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0XHR9LFxuXG5cdFx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLmdldENvbXBvbmVudHMoKTtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShcblx0XHRcdFx0XHQvXihncmF5fHJnYikkLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IGNvbXBvbmVudHNcblx0XHRcdFx0XHRcdDogW3RoaXMuX3R5cGVdLmNvbmNhdChjb21wb25lbnRzKSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9LFxuXG5cdFx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhpcy5fY2FudmFzU3R5bGUgPSBudWxsO1xuXHRcdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCg2NSk7XG5cdFx0fSxcblxuXHRcdF9jb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgY29udmVydGVyO1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKVxuXHRcdFx0XHRcdDogKGNvbnZlcnRlciA9IGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctJyArIHR5cGVdKVxuXHRcdFx0XHRcdFx0PyBjb252ZXJ0ZXIuYXBwbHkodGhpcywgdGhpcy5fY29tcG9uZW50cylcblx0XHRcdFx0XHRcdDogY29udmVydGVyc1sncmdiLScgKyB0eXBlXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLXJnYiddLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cykpO1xuXHRcdH0sXG5cblx0XHRjb252ZXJ0OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIHRoaXMuX2NvbnZlcnQodHlwZSksIHRoaXMuX2FscGhhKTtcblx0XHR9LFxuXG5cdFx0Z2V0VHlwZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0XHR9LFxuXG5cdFx0c2V0VHlwZTogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV07XG5cdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHR9LFxuXG5cdFx0Z2V0Q29tcG9uZW50czogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2godGhpcy5fYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGNvbXBvbmVudHM7XG5cdFx0fSxcblxuXHRcdGdldEFscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsID8gdGhpcy5fYWxwaGEgOiAxO1xuXHRcdH0sXG5cblx0XHRzZXRBbHBoYTogZnVuY3Rpb24oYWxwaGEpIHtcblx0XHRcdHRoaXMuX2FscGhhID0gYWxwaGEgPT0gbnVsbCA/IG51bGwgOiBNYXRoLm1pbihNYXRoLm1heChhbHBoYSwgMCksIDEpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdH0sXG5cblx0XHRoYXNBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbDtcblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0dmFyIGNvbCA9IEJhc2UuaXNQbGFpblZhbHVlKGNvbG9yKVxuXHRcdFx0XHRcdD8gQ29sb3IucmVhZChhcmd1bWVudHMpXG5cdFx0XHRcdFx0OiBjb2xvcjtcblx0XHRcdHJldHVybiBjb2wgPT09IHRoaXMgfHwgY29sICYmIHRoaXMuX2NsYXNzID09PSBjb2wuX2NsYXNzXG5cdFx0XHRcdFx0JiYgdGhpcy5fdHlwZSA9PT0gY29sLl90eXBlXG5cdFx0XHRcdFx0JiYgdGhpcy5fYWxwaGEgPT09IGNvbC5fYWxwaGFcblx0XHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl9jb21wb25lbnRzLCBjb2wuX2NvbXBvbmVudHMpXG5cdFx0XHRcdFx0fHwgZmFsc2U7XG5cdFx0fSxcblxuXHRcdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdGhpcy5fcHJvcGVydGllcyxcblx0XHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdFx0aXNHcmFkaWVudCA9IHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcsXG5cdFx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHByb3BlcnRpZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX2NvbXBvbmVudHNbaV07XG5cdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2gocHJvcGVydGllc1tpXSArICc6ICdcblx0XHRcdFx0XHRcdFx0KyAoaXNHcmFkaWVudCA/IHZhbHVlIDogZi5udW1iZXIodmFsdWUpKSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcblx0XHRcdFx0cGFydHMucHVzaCgnYWxwaGE6ICcgKyBmLm51bWJlcih0aGlzLl9hbHBoYSkpO1xuXHRcdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0XHR9LFxuXG5cdFx0dG9DU1M6IGZ1bmN0aW9uKGhleCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdFx0YWxwaGEgPSBoZXggfHwgdGhpcy5fYWxwaGEgPT0gbnVsbCA/IDEgOiB0aGlzLl9hbHBoYTtcblx0XHRcdGZ1bmN0aW9uIGNvbnZlcnQodmFsKSB7XG5cdFx0XHRcdHJldHVybiBNYXRoLnJvdW5kKCh2YWwgPCAwID8gMCA6IHZhbCA+IDEgPyAxIDogdmFsKSAqIDI1NSk7XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRzID0gW1xuXHRcdFx0XHRjb252ZXJ0KGNvbXBvbmVudHNbMF0pLFxuXHRcdFx0XHRjb252ZXJ0KGNvbXBvbmVudHNbMV0pLFxuXHRcdFx0XHRjb252ZXJ0KGNvbXBvbmVudHNbMl0pXG5cdFx0XHRdO1xuXHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0Y29tcG9uZW50cy5wdXNoKGFscGhhIDwgMCA/IDAgOiBhbHBoYSk7XG5cdFx0XHRyZXR1cm4gaGV4XG5cdFx0XHRcdFx0PyAnIycgKyAoKDEgPDwgMjQpICsgKGNvbXBvbmVudHNbMF0gPDwgMTYpXG5cdFx0XHRcdFx0XHQrIChjb21wb25lbnRzWzFdIDw8IDgpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHNbMl0pLnRvU3RyaW5nKDE2KS5zbGljZSgxKVxuXHRcdFx0XHRcdDogKGNvbXBvbmVudHMubGVuZ3RoID09IDQgPyAncmdiYSgnIDogJ3JnYignKVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzLmpvaW4oJywnKSArICcpJztcblx0XHR9LFxuXG5cdFx0dG9DYW52YXNTdHlsZTogZnVuY3Rpb24oY3R4KSB7XG5cdFx0XHRpZiAodGhpcy5fY2FudmFzU3R5bGUpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZTtcblx0XHRcdGlmICh0aGlzLl90eXBlICE9PSAnZ3JhZGllbnQnKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSB0aGlzLnRvQ1NTKCk7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGdyYWRpZW50ID0gY29tcG9uZW50c1swXSxcblx0XHRcdFx0c3RvcHMgPSBncmFkaWVudC5fc3RvcHMsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbXBvbmVudHNbMV0sXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29tcG9uZW50c1syXSxcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQ7XG5cdFx0XHRpZiAoZ3JhZGllbnQuX3JhZGlhbCkge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gZGVzdGluYXRpb24uZ2V0RGlzdGFuY2Uob3JpZ2luKSxcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBjb21wb25lbnRzWzNdO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0dmFyIHZlY3RvciA9IGhpZ2hsaWdodC5zdWJ0cmFjdChvcmlnaW4pO1xuXHRcdFx0XHRcdGlmICh2ZWN0b3IuZ2V0TGVuZ3RoKCkgPiByYWRpdXMpXG5cdFx0XHRcdFx0XHRoaWdobGlnaHQgPSBvcmlnaW4uYWRkKHZlY3Rvci5ub3JtYWxpemUocmFkaXVzIC0gMC4xKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIHN0YXJ0ID0gaGlnaGxpZ2h0IHx8IG9yaWdpbjtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQoc3RhcnQueCwgc3RhcnQueSxcblx0XHRcdFx0XHRcdDAsIG9yaWdpbi54LCBvcmlnaW4ueSwgcmFkaXVzKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KG9yaWdpbi54LCBvcmlnaW4ueSxcblx0XHRcdFx0XHRcdGRlc3RpbmF0aW9uLngsIGRlc3RpbmF0aW9uLnkpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXTtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQuYWRkQ29sb3JTdG9wKHN0b3AuX3JhbXBQb2ludCxcblx0XHRcdFx0XHRcdHN0b3AuX2NvbG9yLnRvQ2FudmFzU3R5bGUoKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGUgPSBjYW52YXNHcmFkaWVudDtcblx0XHR9LFxuXG5cdFx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cztcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBwb2ludCA9IGNvbXBvbmVudHNbaV07XG5cdFx0XHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0X3R5cGVzOiB0eXBlcyxcblxuXHRcdFx0cmFuZG9tOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXHRcdFx0XHRyZXR1cm4gbmV3IENvbG9yKHJhbmRvbSgpLCByYW5kb20oKSwgcmFuZG9tKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59LCBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBvcGVyYXRvcnMgPSB7XG5cdFx0YWRkOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSArIGI7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAqIGI7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLyBiO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKG9wZXJhdG9ycywgZnVuY3Rpb24ob3BlcmF0b3IsIG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzMSA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGNvbXBvbmVudHMyID0gY29sb3IuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMxLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y29tcG9uZW50czJbaV0gPSBvcGVyYXRvcihjb21wb25lbnRzMVtpXSwgY29tcG9uZW50czJbaV0pO1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCBjb21wb25lbnRzMixcblx0XHRcdFx0XHR0aGlzLl9hbHBoYSAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gb3BlcmF0b3IodGhpcy5fYWxwaGEsIGNvbG9yLmdldEFscGhhKCkpXG5cdFx0XHRcdFx0XHRcdDogbnVsbCk7XG5cdFx0fTtcblx0fSwge1xuXHR9KTtcbn0pO1xuXG5CYXNlLmVhY2goQ29sb3IuX3R5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG5cdHZhciBjdG9yID0gdGhpc1tCYXNlLmNhcGl0YWxpemUodHlwZSkgKyAnQ29sb3InXSA9IGZ1bmN0aW9uKGFyZykge1xuXHRcdFx0dmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnLFxuXHRcdFx0XHRjb21wb25lbnRzID0gYXJnVHlwZSA9PT0gJ29iamVjdCcgJiYgYXJnLmxlbmd0aCAhPSBudWxsXG5cdFx0XHRcdFx0PyBhcmdcblx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdzdHJpbmcnXG5cdFx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHRcdDogYXJndW1lbnRzO1xuXHRcdFx0cmV0dXJuIGNvbXBvbmVudHNcblx0XHRcdFx0XHQ/IG5ldyBDb2xvcih0eXBlLCBjb21wb25lbnRzKVxuXHRcdFx0XHRcdDogbmV3IENvbG9yKGFyZyk7XG5cdFx0fTtcblx0aWYgKHR5cGUubGVuZ3RoID09IDMpIHtcblx0XHR2YXIgYWNyb255bSA9IHR5cGUudG9VcHBlckNhc2UoKTtcblx0XHRDb2xvclthY3JvbnltXSA9IHRoaXNbYWNyb255bSArICdDb2xvciddID0gY3Rvcjtcblx0fVxufSwgQmFzZS5leHBvcnRzKTtcblxudmFyIEdyYWRpZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnQoc3RvcHMsIHJhZGlhbCkge1xuXHRcdHRoaXMuX2lkID0gR3JhZGllbnQuX2lkID0gKEdyYWRpZW50Ll9pZCB8fCAwKSArIDE7XG5cdFx0aWYgKHN0b3BzICYmIHRoaXMuX3NldChzdG9wcykpXG5cdFx0XHRzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG5cdFx0aWYgKCF0aGlzLl9zdG9wcylcblx0XHRcdHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcblx0XHRpZiAodGhpcy5fcmFkaWFsID09IG51bGwpXG5cdFx0XHR0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnXG5cdFx0XHRcdFx0fHwgcmFkaWFsIHx8IGZhbHNlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9zdG9wcywgdGhpcy5fcmFkaWFsXSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF9hZGRPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRpZiAoIXRoaXMuX293bmVycylcblx0XHRcdHRoaXMuX293bmVycyA9IFtdO1xuXHRcdHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcblx0fSxcblxuXHRfcmVtb3ZlT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fb3duZXJzID8gdGhpcy5fb3duZXJzLmluZGV4T2YoY29sb3IpIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGlmICh0aGlzLl9vd25lcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aGlzLl9vd25lcnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RvcHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50KHN0b3BzKTtcblx0fSxcblxuXHRnZXRTdG9wczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0b3BzO1xuXHR9LFxuXG5cdHNldFN0b3BzOiBmdW5jdGlvbihzdG9wcykge1xuXHRcdGlmICh0aGlzLnN0b3BzKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5fc3RvcHNbaV0uX293bmVyID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoc3RvcHMubGVuZ3RoIDwgMilcblx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnR3JhZGllbnQgc3RvcCBsaXN0IG5lZWRzIHRvIGNvbnRhaW4gYXQgbGVhc3QgdHdvIHN0b3BzLicpO1xuXHRcdHRoaXMuX3N0b3BzID0gR3JhZGllbnRTdG9wLnJlYWRBbGwoc3RvcHMsIDAsIHsgY2xvbmU6IHRydWUgfSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzdG9wID0gdGhpcy5fc3RvcHNbaV07XG5cdFx0XHRzdG9wLl9vd25lciA9IHRoaXM7XG5cdFx0XHRpZiAoc3RvcC5fZGVmYXVsdFJhbXApXG5cdFx0XHRcdHN0b3Auc2V0UmFtcFBvaW50KGkgLyAobCAtIDEpKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldFJhZGlhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhZGlhbDtcblx0fSxcblxuXHRzZXRSYWRpYWw6IGZ1bmN0aW9uKHJhZGlhbCkge1xuXHRcdHRoaXMuX3JhZGlhbCA9IHJhZGlhbDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihncmFkaWVudCkge1xuXHRcdGlmIChncmFkaWVudCA9PT0gdGhpcylcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdGlmIChncmFkaWVudCAmJiAgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdG9wcy5sZW5ndGggPT09IGdyYWRpZW50Ll9zdG9wcy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc3RvcHNbaV0uZXF1YWxzKGdyYWRpZW50Ll9zdG9wc1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBHcmFkaWVudFN0b3AgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50U3RvcCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoYXJnMCkge1xuXHRcdFx0dmFyIGNvbG9yLCByYW1wUG9pbnQ7XG5cdFx0XHRpZiAoYXJnMSA9PT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwWzBdO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcwWzFdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmNvbG9yKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMC5jb2xvcjtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMC5yYW1wUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2xvciA9IGFyZzA7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMuc2V0UmFtcFBvaW50KHJhbXBQb2ludCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9yYW1wUG9pbnQpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NvbG9yLCB0aGlzLl9yYW1wUG9pbnRdLCBvcHRpb25zLCB0cnVlLFxuXHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhbXBQb2ludDtcblx0fSxcblxuXHRzZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKHJhbXBQb2ludCkge1xuXHRcdHRoaXMuX2RlZmF1bHRSYW1wID0gcmFtcFBvaW50ID09IG51bGw7XG5cdFx0dGhpcy5fcmFtcFBvaW50ID0gcmFtcFBvaW50IHx8IDA7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3I7XG5cdH0sXG5cblx0c2V0Q29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dGhpcy5fY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2NvbG9yID09PSBjb2xvcilcblx0XHRcdHRoaXMuX2NvbG9yID0gY29sb3IuY2xvbmUoKTtcblx0XHR0aGlzLl9jb2xvci5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN0b3ApIHtcblx0XHRyZXR1cm4gc3RvcCA9PT0gdGhpcyB8fCBzdG9wICYmIHRoaXMuX2NsYXNzID09PSBzdG9wLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9jb2xvci5lcXVhbHMoc3RvcC5fY29sb3IpXG5cdFx0XHRcdCYmIHRoaXMuX3JhbXBQb2ludCA9PSBzdG9wLl9yYW1wUG9pbnRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgU3R5bGUgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHN0cm9rZVdpZHRoOiAxLFxuXHRcdHN0cm9rZUNhcDogJ2J1dHQnLFxuXHRcdHN0cm9rZUpvaW46ICdtaXRlcicsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHdpbmRpbmdSdWxlOiAnbm9uemVybycsXG5cdFx0c2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcblx0XHRzaGFkb3dCbHVyOiAwLFxuXHRcdHNoYWRvd09mZnNldDogbmV3IFBvaW50KCksXG5cdFx0c2VsZWN0ZWRDb2xvcjogdW5kZWZpbmVkLFxuXHRcdGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0XHRmb250V2VpZ2h0OiAnbm9ybWFsJyxcblx0XHRmb250U2l6ZTogMTIsXG5cdFx0Zm9udDogJ3NhbnMtc2VyaWYnLCBcblx0XHRsZWFkaW5nOiBudWxsLFxuXHRcdGp1c3RpZmljYXRpb246ICdsZWZ0J1xuXHR9O1xuXG5cdHZhciBmbGFncyA9IHtcblx0XHRzdHJva2VXaWR0aDogOTcsXG5cdFx0c3Ryb2tlQ2FwOiA5Nyxcblx0XHRzdHJva2VKb2luOiA5Nyxcblx0XHRtaXRlckxpbWl0OiA5Nyxcblx0XHRmb250RmFtaWx5OiA5LFxuXHRcdGZvbnRXZWlnaHQ6IDksXG5cdFx0Zm9udFNpemU6IDksXG5cdFx0Zm9udDogOSwgXG5cdFx0bGVhZGluZzogOSxcblx0XHRqdXN0aWZpY2F0aW9uOiA5XG5cdH07XG5cblx0dmFyIGl0ZW0gPSB7fSxcblx0XHRmaWVsZHMgPSB7XG5cdFx0XHRfZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRcdFx0X3RleHREZWZhdWx0czogbmV3IEJhc2UoZGVmYXVsdHMsIHtcblx0XHRcdFx0ZmlsbENvbG9yOiBuZXcgQ29sb3IoKSBcblx0XHRcdH0pLFxuXHRcdFx0YmVhbnM6IHRydWVcblx0XHR9O1xuXG5cdEJhc2UuZWFjaChkZWZhdWx0cywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdHZhciBpc0NvbG9yID0gL0NvbG9yJC8udGVzdChrZXkpLFxuXHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0ZmxhZyA9IGZsYWdzW2tleV0sXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQsXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cblx0XHRmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW47XG5cdFx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuXHRcdFx0XHRcdCYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLl9zdHlsZVtzZXRdKHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKG9sZCAhPSB2YWx1ZSkge1xuXHRcdFx0XHRcdGlmIChpc0NvbG9yKSB7XG5cdFx0XHRcdFx0XHRpZiAob2xkKVxuXHRcdFx0XHRcdFx0XHRvbGQuX293bmVyID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUuX293bmVyKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0dmFsdWUuX293bmVyID0gb3duZXI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWU7XG5cdFx0XHRcdFx0aWYgKG93bmVyKVxuXHRcdFx0XHRcdFx0b3duZXIuX2NoYW5nZWQoZmxhZyB8fCA2NSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0ZmllbGRzW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW4sXG5cdFx0XHRcdHZhbHVlO1xuXHRcdFx0aWYgKCFjaGlsZHJlbiB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgX2RvbnRNZXJnZVxuXHRcdFx0XHRcdHx8IG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuX3ZhbHVlc1trZXldO1xuXHRcdFx0XHRpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHZhbHVlID0gdGhpcy5fZGVmYXVsdHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY2xvbmUpXG5cdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChpc0NvbG9yICYmICEodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSkge1xuXHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBDb2xvci5yZWFkKFt2YWx1ZV0sIDAsXG5cdFx0XHRcdFx0XHRcdHsgcmVhZE51bGw6IHRydWUsIGNsb25lOiB0cnVlIH0pO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZFZhbHVlID0gY2hpbGRyZW5baV0uX3N0eWxlW2dldF0oKTtcblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHR2YWx1ZSA9IGNoaWxkVmFsdWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBjaGlsZFZhbHVlKSkge1xuXHRcdFx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9O1xuXG5cdFx0aXRlbVtnZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XSgpO1xuXHRcdH07XG5cblx0XHRpdGVtW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0fTtcblx0fSk7XG5cblx0SXRlbS5pbmplY3QoaXRlbSk7XG5cdHJldHVybiBmaWVsZHM7XG59LCB7XG5cdF9jbGFzczogJ1N0eWxlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTdHlsZShzdHlsZSwgX293bmVyLCBfcHJvamVjdCkge1xuXHRcdHRoaXMuX3ZhbHVlcyA9IHt9O1xuXHRcdHRoaXMuX293bmVyID0gX293bmVyO1xuXHRcdHRoaXMuX3Byb2plY3QgPSBfb3duZXIgJiYgX293bmVyLl9wcm9qZWN0IHx8IF9wcm9qZWN0IHx8IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKF9vd25lciBpbnN0YW5jZW9mIFRleHRJdGVtKVxuXHRcdFx0dGhpcy5fZGVmYXVsdHMgPSB0aGlzLl90ZXh0RGVmYXVsdHM7XG5cdFx0aWYgKHN0eWxlKVxuXHRcdFx0dGhpcy5zZXQoc3R5bGUpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR2YXIgaXNTdHlsZSA9IHN0eWxlIGluc3RhbmNlb2YgU3R5bGUsXG5cdFx0XHR2YWx1ZXMgPSBpc1N0eWxlID8gc3R5bGUuX3ZhbHVlcyA6IHN0eWxlO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuXHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlICYmIGlzU3R5bGUgJiYgdmFsdWUuY2xvbmVcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHJldHVybiBzdHlsZSA9PT0gdGhpcyB8fCBzdHlsZSAmJiB0aGlzLl9jbGFzcyA9PT0gc3R5bGUuX2NsYXNzXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3ZhbHVlcywgc3R5bGUuX3ZhbHVlcylcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRGaWxsQ29sb3IoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U3Ryb2tlQ29sb3IoKSAmJiB0aGlzLmdldFN0cm9rZVdpZHRoKCkgPiAwO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRTaGFkb3dDb2xvcigpICYmIHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMDtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpXG5cdFx0XHRcdCsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKVxuXHRcdFx0XHQrIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuXHR9LFxuXG5cdGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG5cdHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cblx0Z2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcblx0XHR2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0aWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSlcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcblx0XHRyZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuXHR9XG5cbn0pO1xuXG52YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbigpIHtcblxuXHR2YXIgc3BlY2lhbCA9IC9eKGNoZWNrZWR8dmFsdWV8c2VsZWN0ZWR8ZGlzYWJsZWQpJC9pLFxuXHRcdHRyYW5zbGF0ZWQgPSB7IHRleHQ6ICd0ZXh0Q29udGVudCcsIGh0bWw6ICdpbm5lckhUTUwnIH0sXG5cdFx0dW5pdGxlc3MgPSB7IGxpbmVIZWlnaHQ6IDEsIHpvb206IDEsIHpJbmRleDogMSwgb3BhY2l0eTogMSB9O1xuXG5cdGZ1bmN0aW9uIGNyZWF0ZShub2RlcywgcGFyZW50KSB7XG5cdFx0dmFyIHJlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAgMCwgbCA9IG5vZGVzICYmIG5vZGVzLmxlbmd0aDsgaSA8IGw7KSB7XG5cdFx0XHR2YXIgZWwgPSBub2Rlc1tpKytdO1xuXHRcdFx0aWYgKHR5cGVvZiBlbCA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0ZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KGVsKTtcblx0XHRcdH0gZWxzZSBpZiAoIWVsIHx8ICFlbC5ub2RlVHlwZSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3Qobm9kZXNbaV0pKVxuXHRcdFx0XHREb21FbGVtZW50LnNldChlbCwgbm9kZXNbaSsrXSk7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShub2Rlc1tpXSkpXG5cdFx0XHRcdGNyZWF0ZShub2Rlc1tpKytdLCBlbCk7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQoZWwpO1xuXHRcdFx0cmVzLnB1c2goZWwpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gWyd3ZWJraXQnLCAnbW96JywgJ01veicsICdtcycsICdvJywgJyddLFxuXHRcdFx0c3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcblx0XHRcdFx0a2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblx0XHRcdGlmIChrZXkgaW4gZWwpIHtcblx0XHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNyZWF0ZTogZnVuY3Rpb24obm9kZXMsIHBhcmVudCkge1xuXHRcdFx0dmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KG5vZGVzKSxcblx0XHRcdFx0cmVzID0gY3JlYXRlKGlzQXJyYXkgPyBub2RlcyA6IGFyZ3VtZW50cywgaXNBcnJheSA/IHBhcmVudCA6IG51bGwpO1xuXHRcdFx0cmV0dXJuIHJlcy5sZW5ndGggPT0gMSA/IHJlc1swXSA6IHJlcztcblx0XHR9LFxuXG5cdFx0ZmluZDogZnVuY3Rpb24oc2VsZWN0b3IsIHJvb3QpIHtcblx0XHRcdHJldHVybiAocm9vdCB8fCBkb2N1bWVudCkucXVlcnlTZWxlY3RvcihzZWxlY3Rvcik7XG5cdFx0fSxcblxuXHRcdGZpbmRBbGw6IGZ1bmN0aW9uKHNlbGVjdG9yLCByb290KSB7XG5cdFx0XHRyZXR1cm4gKHJvb3QgfHwgZG9jdW1lbnQpLnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuXHRcdH0sXG5cblx0XHRnZXQ6IGZ1bmN0aW9uKGVsLCBrZXkpIHtcblx0XHRcdHJldHVybiBlbFxuXHRcdFx0XHQ/IHNwZWNpYWwudGVzdChrZXkpXG5cdFx0XHRcdFx0PyBrZXkgPT09ICd2YWx1ZScgfHwgdHlwZW9mIGVsW2tleV0gIT09ICdzdHJpbmcnXG5cdFx0XHRcdFx0XHQ/IGVsW2tleV1cblx0XHRcdFx0XHRcdDogdHJ1ZVxuXHRcdFx0XHRcdDoga2V5IGluIHRyYW5zbGF0ZWRcblx0XHRcdFx0XHRcdD8gZWxbdHJhbnNsYXRlZFtrZXldXVxuXHRcdFx0XHRcdFx0OiBlbC5nZXRBdHRyaWJ1dGUoa2V5KVxuXHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oZWwsIGtleSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHRmb3IgKHZhciBuYW1lIGluIGtleSlcblx0XHRcdFx0XHRpZiAoa2V5Lmhhc093blByb3BlcnR5KG5hbWUpKVxuXHRcdFx0XHRcdFx0dGhpcy5zZXQoZWwsIG5hbWUsIGtleVtuYW1lXSk7XG5cdFx0XHR9IGVsc2UgaWYgKCFlbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHJldHVybiBlbDtcblx0XHRcdH0gZWxzZSBpZiAoc3BlY2lhbC50ZXN0KGtleSkpIHtcblx0XHRcdFx0ZWxba2V5XSA9IHZhbHVlO1xuXHRcdFx0fSBlbHNlIGlmIChrZXkgaW4gdHJhbnNsYXRlZCkge1xuXHRcdFx0XHRlbFt0cmFuc2xhdGVkW2tleV1dID0gdmFsdWU7XG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ3N0eWxlJykge1xuXHRcdFx0XHR0aGlzLnNldFN0eWxlKGVsLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKGtleSA9PT0gJ2V2ZW50cycpIHtcblx0XHRcdFx0RG9tRXZlbnQuYWRkKGVsLCB2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbC5zZXRBdHRyaWJ1dGUoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZWw7XG5cdFx0fSxcblxuXHRcdGdldFN0eWxlczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcblx0XHRcdFx0dmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0U3R5bGU6IGZ1bmN0aW9uKGVsLCBrZXkpIHtcblx0XHRcdHJldHVybiBlbCAmJiBlbC5zdHlsZVtrZXldIHx8IHRoaXMuZ2V0U3R5bGVzKGVsKVtrZXldIHx8IG51bGw7XG5cdFx0fSxcblxuXHRcdHNldFN0eWxlOiBmdW5jdGlvbihlbCwga2V5LCB2YWx1ZSkge1xuXHRcdFx0aWYgKHR5cGVvZiBrZXkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdGZvciAodmFyIG5hbWUgaW4ga2V5KVxuXHRcdFx0XHRcdGlmIChrZXkuaGFzT3duUHJvcGVydHkobmFtZSkpXG5cdFx0XHRcdFx0XHR0aGlzLnNldFN0eWxlKGVsLCBuYW1lLCBrZXlbbmFtZV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKC9eLT9bXFxkXFwuXSskLy50ZXN0KHZhbHVlKSAmJiAhKGtleSBpbiB1bml0bGVzcykpXG5cdFx0XHRcdFx0dmFsdWUgKz0gJ3B4Jztcblx0XHRcdFx0ZWwuc3R5bGVba2V5XSA9IHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGVsO1xuXHRcdH0sXG5cblx0XHRoYXNDbGFzczogZnVuY3Rpb24oZWwsIGNscykge1xuXHRcdFx0cmV0dXJuIG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBjbHMgKyAnXFxcXHMqJykudGVzdChlbC5jbGFzc05hbWUpO1xuXHRcdH0sXG5cblx0XHRhZGRDbGFzczogZnVuY3Rpb24oZWwsIGNscykge1xuXHRcdFx0ZWwuY2xhc3NOYW1lID0gKGVsLmNsYXNzTmFtZSArICcgJyArIGNscykudHJpbSgpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmVDbGFzczogZnVuY3Rpb24oZWwsIGNscykge1xuXHRcdFx0ZWwuY2xhc3NOYW1lID0gZWwuY2xhc3NOYW1lLnJlcGxhY2UoXG5cdFx0XHRcdG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBjbHMgKyAnXFxcXHMqJyksICcgJykudHJpbSgpO1xuXHRcdH0sXG5cblx0XHRyZW1vdmU6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRpZiAoZWwucGFyZW50Tm9kZSlcblx0XHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChlbCk7XG5cdFx0fSxcblxuXHRcdHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0d2hpbGUgKGVsLmZpcnN0Q2hpbGQpXG5cdFx0XHRcdGVsLnJlbW92ZUNoaWxkKGVsLmZpcnN0Q2hpbGQpO1xuXHRcdH0sXG5cblx0XHRnZXRCb3VuZHM6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdGJvZHkgPSBkb2MuYm9keSxcblx0XHRcdFx0aHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG5cdFx0XHRcdHJlY3Q7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRyZWN0ID0gZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdHJlY3QgPSB7IGxlZnQ6IDAsIHRvcDogMCwgd2lkdGg6IDAsIGhlaWdodDogMCB9O1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSByZWN0LmxlZnQgLSAoaHRtbC5jbGllbnRMZWZ0IHx8IGJvZHkuY2xpZW50TGVmdCB8fCAwKSxcblx0XHRcdFx0eSA9IHJlY3QudG9wIC0gKGh0bWwuY2xpZW50VG9wICB8fCBib2R5LmNsaWVudFRvcCAgfHwgMCk7XG5cdFx0XHRpZiAoIXZpZXdwb3J0KSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0XHR4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdFx0eSArPSB2aWV3LnBhZ2VZT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdH0sXG5cblx0XHRnZXRWaWV3cG9ydEJvdW5kczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHR2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsXG5cdFx0XHRcdHZpZXcuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLFxuXHRcdFx0XHR2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKGVsLCB2aWV3cG9ydCkuZ2V0UG9pbnQoKTtcblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldEJvdW5kcyhlbCwgdHJ1ZSkuZ2V0U2l6ZSgpO1xuXHRcdH0sXG5cblx0XHRpc0ludmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiB0aGlzLmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5WaWV3OiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuICF0aGlzLmlzSW52aXNpYmxlKGVsKSAmJiB0aGlzLmdldFZpZXdwb3J0Qm91bmRzKGVsKS5pbnRlcnNlY3RzKFxuXHRcdFx0XHRcdHRoaXMuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG5cdFx0fSxcblxuXHRcdGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpXG5cdFx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG52YXIgRG9tRXZlbnQgPSB7XG5cdGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuXHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcG9zID0gZXZlbnQudGFyZ2V0VG91Y2hlc1xuXHRcdFx0XHQ/IGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoXG5cdFx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzWzBdXG5cdFx0XHRcdFx0OiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuXHRcdFx0XHQ6IGV2ZW50O1xuXHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRwb3MucGFnZVggfHwgcG9zLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcblx0XHRcdHBvcy5wYWdlWSB8fCBwb3MuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3Bcblx0XHQpO1xuXHR9LFxuXG5cdGdldFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UmVsYXRlZFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihldmVudCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldFBvaW50KGV2ZW50KS5zdWJ0cmFjdChEb21FbGVtZW50LmdldE9mZnNldChcblx0XHRcdFx0dGFyZ2V0IHx8IERvbUV2ZW50LmdldFRhcmdldChldmVudCkpKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cbn07XG5cbkRvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG5hdGl2ZVJlcXVlc3QgPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHdpbmRvdywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxuXHRcdHJlcXVlc3RlZCA9IGZhbHNlLFxuXHRcdGNhbGxiYWNrcyA9IFtdLFxuXHRcdGZvY3VzZWQgPSB0cnVlLFxuXHRcdHRpbWVyO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb2N1c2VkID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9jdXNlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2tzKCkge1xuXHRcdGZvciAodmFyIGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBlbnRyeSA9IGNhbGxiYWNrc1tpXSxcblx0XHRcdFx0ZnVuYyA9IGVudHJ5WzBdLFxuXHRcdFx0XHRlbCA9IGVudHJ5WzFdO1xuXHRcdFx0aWYgKCFlbCB8fCAoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoZWwsICdrZWVwYWxpdmUnKSA9PSAndHJ1ZSdcblx0XHRcdFx0XHR8fCBmb2N1c2VkKSAmJiBEb21FbGVtZW50LmlzSW5WaWV3KGVsKSkge1xuXHRcdFx0XHRjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRmdW5jKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChuYXRpdmVSZXF1ZXN0KSB7XG5cdFx0XHRpZiAoY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcblx0XHRjYWxsYmFja3MucHVzaChbY2FsbGJhY2ssIGVsZW1lbnRdKTtcblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKCFyZXF1ZXN0ZWQpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0XHRyZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIXRpbWVyKSB7XG5cdFx0XHR0aW1lciA9IHNldEludGVydmFsKGhhbmRsZUNhbGxiYWNrcywgMTAwMCAvIDYwKTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgVmlldyA9IEJhc2UuZXh0ZW5kKENhbGxiYWNrLCB7XG5cdF9jbGFzczogJ1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0dmFyIHNpemU7XG5cdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0dGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKyspO1xuXHRcdERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHREb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdHVzZXJTZWxlY3Q6IG5vbmUsXG5cdFx0XHR0b3VjaEFjdGlvbjogbm9uZSxcblx0XHRcdHRvdWNoQ2FsbG91dDogbm9uZSxcblx0XHRcdGNvbnRlbnRab29taW5nOiBub25lLFxuXHRcdFx0dXNlckRyYWc6IG5vbmUsXG5cdFx0XHR0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG5cdFx0fSk7XG5cdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdyZXNpemUnKSkge1xuXHRcdFx0dmFyIG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQsIHRydWUpLFxuXHRcdFx0XHR0aGF0ID0gdGhpcztcblx0XHRcdHNpemUgPSBEb21FbGVtZW50LmdldFZpZXdwb3J0Qm91bmRzKGVsZW1lbnQpXG5cdFx0XHRcdFx0LmdldFNpemUoKS5zdWJ0cmFjdChvZmZzZXQpO1xuXHRcdFx0dGhpcy5fd2luZG93RXZlbnRzID0ge1xuXHRcdFx0XHRyZXNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICghRG9tRWxlbWVudC5pc0ludmlzaWJsZShlbGVtZW50KSlcblx0XHRcdFx0XHRcdG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQsIHRydWUpO1xuXHRcdFx0XHRcdHRoYXQuc2V0Vmlld1NpemUoRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbGVtZW50KVxuXHRcdFx0XHRcdFx0XHQuZ2V0U2l6ZSgpLnN1YnRyYWN0KG9mZnNldCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0RG9tRXZlbnQuYWRkKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdGlmIChzaXplLmlzTmFOKCkgfHwgc2l6ZS5pc1plcm8oKSkge1xuXHRcdFx0XHR2YXIgZ2V0U2l6ZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbWVudFtuYW1lXVxuXHRcdFx0XHRcdFx0XHR8fCBwYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZShuYW1lKSwgMTApO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRzaXplID0gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9zZXRWaWV3U2l6ZShzaXplKTtcblx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0YXRzJylcblx0XHRcdFx0JiYgdHlwZW9mIFN0YXRzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcblx0XHRcdHZhciBzdGF0cyA9IHRoaXMuX3N0YXRzLmRvbUVsZW1lbnQsXG5cdFx0XHRcdHN0eWxlID0gc3RhdHMuc3R5bGUsXG5cdFx0XHRcdG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQpO1xuXHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0c3R5bGUubGVmdCA9IG9mZnNldC54ICsgJ3B4Jztcblx0XHRcdHN0eWxlLnRvcCA9IG9mZnNldC55ICsgJ3B4Jztcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMpO1xuXHRcdH1cblx0XHRWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXHRcdFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblx0XHQodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3pvb20gPSAxO1xuXHRcdGlmICghVmlldy5fZm9jdXNlZClcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0aGlzO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1Db3VudCA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKFZpZXcuX2ZvY3VzZWQgPT09IHRoaXMpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gbnVsbDtcblx0XHRWaWV3Ll92aWV3cy5zcGxpY2UoVmlldy5fdmlld3MuaW5kZXhPZih0aGlzKSwgMSk7XG5cdFx0ZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QuX3ZpZXcgPT09IHRoaXMpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll92aWV3ID0gbnVsbDtcblx0XHREb21FdmVudC5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcblx0XHR0aGlzLl9lbGVtZW50ID0gdGhpcy5fcHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5kZXRhY2goJ2ZyYW1lJyk7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZXZlbnRzOiB7XG5cdFx0b25GcmFtZToge1xuXHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMucGxheSgpO1xuXHRcdFx0fSxcblxuXHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRvblJlc2l6ZToge31cblx0fSxcblxuXHRfYW5pbWF0ZTogZmFsc2UsXG5cdF90aW1lOiAwLFxuXHRfY291bnQ6IDAsXG5cblx0X3JlcXVlc3RGcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdERvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcblx0XHRcdHRoYXQuX3JlcXVlc3RlZCA9IGZhbHNlO1xuXHRcdFx0aWYgKCF0aGF0Ll9hbmltYXRlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0RnJhbWUoKTtcblx0XHRcdHRoYXQuX2hhbmRsZUZyYW1lKCk7XG5cdFx0fSwgdGhpcy5fZWxlbWVudCk7XG5cdFx0dGhpcy5fcmVxdWVzdGVkID0gdHJ1ZTtcblx0fSxcblxuXHRfaGFuZGxlRnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIG5vdyA9IERhdGUubm93KCkgLyAxMDAwLFxuXHRcdFx0ZGVsdGEgPSB0aGlzLl9iZWZvcmUgPyBub3cgLSB0aGlzLl9iZWZvcmUgOiAwO1xuXHRcdHRoaXMuX2JlZm9yZSA9IG5vdztcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gdHJ1ZTtcblx0XHR0aGlzLmZpcmUoJ2ZyYW1lJywgbmV3IEJhc2Uoe1xuXHRcdFx0ZGVsdGE6IGRlbHRhLFxuXHRcdFx0dGltZTogdGhpcy5fdGltZSArPSBkZWx0YSxcblx0XHRcdGNvdW50OiB0aGlzLl9jb3VudCsrXG5cdFx0fSkpO1xuXHRcdGlmICh0aGlzLl9zdGF0cylcblx0XHRcdHRoaXMuX3N0YXRzLnVwZGF0ZSgpO1xuXHRcdHRoaXMuX2hhbmRsaW5nRnJhbWUgPSBmYWxzZTtcblx0XHR0aGlzLnVwZGF0ZSgpO1xuXHR9LFxuXG5cdF9hbmltYXRlSXRlbTogZnVuY3Rpb24oaXRlbSwgYW5pbWF0ZSkge1xuXHRcdHZhciBpdGVtcyA9IHRoaXMuX2ZyYW1lSXRlbXM7XG5cdFx0aWYgKGFuaW1hdGUpIHtcblx0XHRcdGl0ZW1zW2l0ZW0uX2lkXSA9IHtcblx0XHRcdFx0aXRlbTogaXRlbSxcblx0XHRcdFx0dGltZTogMCxcblx0XHRcdFx0Y291bnQ6IDBcblx0XHRcdH07XG5cdFx0XHRpZiAoKyt0aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMSlcblx0XHRcdFx0dGhpcy5hdHRhY2goJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLmRldGFjaCgnZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5maXJlKCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5faGFuZGxpbmdGcmFtZSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5fYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlRnJhbWUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgMSlcblx0XHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguY29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHR9LFxuXG5cdGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG5cdH0sXG5cblx0Z2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcblx0fSxcblxuXHRzZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG5cdFx0aWYgKGRlbHRhLmlzWmVybygpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDsgXG5cdFx0dGhpcy5maXJlKCdyZXNpemUnLCB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0ZGVsdGE6IGRlbHRhXG5cdFx0fSk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3NldFZpZXdTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXHRcdGVsZW1lbnQud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGVsZW1lbnQuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMoXG5cdFx0XHRcdFx0bmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgdGhpcy5fdmlld1NpemUpKTtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldFNpemUoKTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oY2VudGVyKSB7XG5cdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2Nyb2xsQnkoY2VudGVyLnN1YnRyYWN0KHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0fSxcblxuXHRnZXRab29tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcblx0fSxcblxuXHRzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5fem9vbSxcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0XHR0aGlzLl96b29tID0gem9vbTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpKTtcblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gdHJ1ZTtcblx0XHRpZiAoIXRoaXMuX3JlcXVlc3RlZClcblx0XHRcdHRoaXMuX3JlcXVlc3RGcmFtZSgpO1xuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHZpZXdUb1Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fVxuXG59LCB7XG5cdHN0YXRpY3M6IHtcblx0XHRfdmlld3M6IFtdLFxuXHRcdF92aWV3c0J5SWQ6IHt9LFxuXHRcdF9pZDogMCxcblxuXHRcdGNyZWF0ZTogZnVuY3Rpb24ocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIG5ldyBDYW52YXNWaWV3KHByb2plY3QsIGVsZW1lbnQpO1xuXHRcdH1cblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdG9vbCxcblx0XHRwcmV2Rm9jdXMsXG5cdFx0dGVtcEZvY3VzLFxuXHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cblx0ZnVuY3Rpb24gZ2V0VmlldyhldmVudCkge1xuXHRcdHZhciB0YXJnZXQgPSBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpO1xuXHRcdHJldHVybiB0YXJnZXQuZ2V0QXR0cmlidXRlICYmIFZpZXcuX3ZpZXdzQnlJZFt0YXJnZXQuZ2V0QXR0cmlidXRlKCdpZCcpXTtcblx0fVxuXG5cdGZ1bmN0aW9uIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpIHtcblx0XHRyZXR1cm4gdmlldy52aWV3VG9Qcm9qZWN0KERvbUV2ZW50LmdldE9mZnNldChldmVudCwgdmlldy5fZWxlbWVudCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gdXBkYXRlRm9jdXMoKSB7XG5cdFx0aWYgKCFWaWV3Ll9mb2N1c2VkIHx8ICFWaWV3Ll9mb2N1c2VkLmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IFZpZXcuX3ZpZXdzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmlldyA9IFZpZXcuX3ZpZXdzW2ldO1xuXHRcdFx0XHRpZiAodmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpKSB7XG5cdFx0XHRcdFx0Vmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KSB7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0dmFyIHRvb2wgPSB2aWV3Ll9zY29wZS50b29sO1xuXHRcdGlmICh0b29sKSB7XG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudChkcmFnZ2luZyAmJiB0b29sLnJlc3BvbmRzKCdtb3VzZWRyYWcnKVxuXHRcdFx0XHRcdD8gJ21vdXNlZHJhZycgOiAnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdFx0dmlldy51cGRhdGUoKTtcblx0XHRyZXR1cm4gdG9vbDtcblx0fVxuXG5cdHZhciBuYXZpZ2F0b3IgPSB3aW5kb3cubmF2aWdhdG9yLFxuXHRcdG1vdXNlZG93biwgbW91c2Vtb3ZlLCBtb3VzZXVwO1xuXHRpZiAobmF2aWdhdG9yLnBvaW50ZXJFbmFibGVkIHx8IG5hdmlnYXRvci5tc1BvaW50ZXJFbmFibGVkKSB7XG5cdFx0bW91c2Vkb3duID0gJ3BvaW50ZXJkb3duIE1TUG9pbnRlckRvd24nO1xuXHRcdG1vdXNlbW92ZSA9ICdwb2ludGVybW92ZSBNU1BvaW50ZXJNb3ZlJztcblx0XHRtb3VzZXVwID0gJ3BvaW50ZXJ1cCBwb2ludGVyY2FuY2VsIE1TUG9pbnRlclVwIE1TUG9pbnRlckNhbmNlbCc7XG5cdH0gZWxzZSB7XG5cdFx0bW91c2Vkb3duID0gJ3RvdWNoc3RhcnQnO1xuXHRcdG1vdXNlbW92ZSA9ICd0b3VjaG1vdmUnO1xuXHRcdG1vdXNldXAgPSAndG91Y2hlbmQgdG91Y2hjYW5jZWwnO1xuXHRcdGlmICghKCdvbnRvdWNoc3RhcnQnIGluIHdpbmRvdyAmJiBuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFxuXHRcdFx0XHQvbW9iaWxlfHRhYmxldHxpcChhZHxob25lfG9kKXxhbmRyb2lkfHNpbGsvaSkpKSB7XG5cdFx0XHRtb3VzZWRvd24gKz0gJyBtb3VzZWRvd24nO1xuXHRcdFx0bW91c2Vtb3ZlICs9ICcgbW91c2Vtb3ZlJztcblx0XHRcdG1vdXNldXAgKz0gJyBtb3VzZXVwJztcblx0XHR9XG5cdH1cblxuXHR2YXIgdmlld0V2ZW50cyA9IHtcblx0XHQnc2VsZWN0c3RhcnQgZHJhZ3N0YXJ0JzogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkcmFnZ2luZylcblx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIGRvY0V2ZW50cyA9IHtcblx0XHRtb3VzZW91dDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdFx0dGFyZ2V0ID0gRG9tRXZlbnQuZ2V0UmVsYXRlZFRhcmdldChldmVudCk7XG5cdFx0XHRpZiAodmlldyAmJiAoIXRhcmdldCB8fCB0YXJnZXQubm9kZU5hbWUgPT09ICdIVE1MJykpXG5cdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdH0sXG5cblx0XHRzY3JvbGw6IHVwZGF0ZUZvY3VzXG5cdH07XG5cblx0dmlld0V2ZW50c1ttb3VzZWRvd25dID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBnZXRWaWV3KGV2ZW50KSxcblx0XHRcdHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSB0cnVlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdGlmICh0b29sID0gdmlldy5fc2NvcGUudG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZWRvd24nLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZpZXcudXBkYXRlKCk7XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNlbW92ZV0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIWRyYWdnaW5nKSB7XG5cdFx0XHR2YXIgdGFyZ2V0ID0gZ2V0VmlldyhldmVudCk7XG5cdFx0XHRpZiAodGFyZ2V0KSB7XG5cdFx0XHRcdGlmICh2aWV3ICE9PSB0YXJnZXQpXG5cdFx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG5cdFx0XHRcdHByZXZGb2N1cyA9IHZpZXc7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdGFyZ2V0O1xuXHRcdFx0fSBlbHNlIGlmICh0ZW1wRm9jdXMgJiYgdGVtcEZvY3VzID09PSB2aWV3KSB7XG5cdFx0XHRcdHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gcHJldkZvY3VzO1xuXHRcdFx0XHR1cGRhdGVGb2N1cygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAodmlldykge1xuXHRcdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0XHRpZiAoZHJhZ2dpbmcgfHwgdmlldy5nZXRCb3VuZHMoKS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdHRvb2wgPSBoYW5kbGVNb3VzZU1vdmUodmlldywgcG9pbnQsIGV2ZW50KTtcblx0XHR9XG5cdH07XG5cblx0ZG9jRXZlbnRzW21vdXNldXBdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCF2aWV3IHx8ICFkcmFnZ2luZylcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbClcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KCdtb3VzZXVwJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwgZG9jRXZlbnRzKTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0bG9hZDogdXBkYXRlRm9jdXNcblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRfdmlld0V2ZW50czogdmlld0V2ZW50cyxcblxuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdHVwZGF0ZUZvY3VzOiB1cGRhdGVGb2N1c1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgQ2FudmFzVmlldyA9IFZpZXcuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ2FudmFzVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ2FudmFzVmlldyhwcm9qZWN0LCBjYW52YXMpIHtcblx0XHRpZiAoIShjYW52YXMgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudCkpIHtcblx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRpZiAoc2l6ZS5pc1plcm8oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgQ2FudmFzVmlldyB3aXRoIHRoZSBwcm92aWRlZCBhcmd1bWVudDogJ1xuXHRcdFx0XHRcdFx0KyBjYW52YXMpO1xuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpO1xuXHRcdH1cblx0XHR0aGlzLl9jb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cdFx0dGhpcy5fZXZlbnRDb3VudGVycyA9IHt9O1xuXHRcdHRoaXMuX3BpeGVsUmF0aW8gPSAxO1xuXHRcdGlmIChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShjYW52YXMsICdoaWRwaScpICE9PSAnb2ZmJykge1xuXHRcdFx0dmFyIGRldmljZVJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdFx0YmFja2luZ1N0b3JlUmF0aW8gPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHRoaXMuX2NvbnRleHQsXG5cdFx0XHRcdFx0XHQnYmFja2luZ1N0b3JlUGl4ZWxSYXRpbycpIHx8IDE7XG5cdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gZGV2aWNlUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblx0XHR9XG5cdFx0Vmlldy5jYWxsKHRoaXMsIHByb2plY3QsIGNhbnZhcyk7XG5cdH0sXG5cblx0X3NldFZpZXdTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0LFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHRoaXMuX3BpeGVsUmF0aW8sXG5cdFx0XHRlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcblx0XHRcdHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRlbGVtZW50LndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuXHRcdGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0dGhpcy5fY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250O1xuXHRcdGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuXHRcdHNpemUgPSBwYXJzZUZsb2F0KGN0eC5mb250KTtcblx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdHJldHVybiBzaXplO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQsXG5cdFx0XHR3aWR0aCA9IDA7XG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKCFwcm9qZWN0IHx8ICFwcm9qZWN0Ll9uZWVkc1VwZGF0ZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuXHRcdHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG5cdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSwgbmV3IGZ1bmN0aW9uKCkgeyBcblxuXHR2YXIgZG93blBvaW50LFxuXHRcdGxhc3RQb2ludCxcblx0XHRvdmVyUG9pbnQsXG5cdFx0ZG93bkl0ZW0sXG5cdFx0bGFzdEl0ZW0sXG5cdFx0b3Zlckl0ZW0sXG5cdFx0ZHJhZ0l0ZW0sXG5cdFx0ZGJsQ2xpY2ssXG5cdFx0Y2xpY2tUaW1lO1xuXG5cdGZ1bmN0aW9uIGNhbGxFdmVudCh2aWV3LCB0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgbGFzdFBvaW50KSB7XG5cdFx0dmFyIGl0ZW0gPSB0YXJnZXQsXG5cdFx0XHRtb3VzZUV2ZW50O1xuXG5cdFx0ZnVuY3Rpb24gY2FsbChvYmopIHtcblx0XHRcdGlmIChvYmoucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdFx0aWYgKCFtb3VzZUV2ZW50KSB7XG5cdFx0XHRcdFx0bW91c2VFdmVudCA9IG5ldyBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LFxuXHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQgPyBwb2ludC5zdWJ0cmFjdChsYXN0UG9pbnQpIDogbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG9iai5maXJlKHR5cGUsIG1vdXNlRXZlbnQpICYmIG1vdXNlRXZlbnQuaXNTdG9wcGVkKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoY2FsbChpdGVtKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRpdGVtID0gaXRlbS5nZXRQYXJlbnQoKTtcblx0XHR9XG5cdFx0aWYgKGNhbGwodmlldykpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIGV2ZW50KSB7XG5cdFx0XHRpZiAoIXRoaXMuX2V2ZW50Q291bnRlcnNbdHlwZV0pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0aGl0ID0gcHJvamVjdC5oaXRUZXN0KHBvaW50LCB7XG5cdFx0XHRcdFx0dG9sZXJhbmNlOiB0aGlzLl9zY29wZS5zZXR0aW5ncy5oaXRUb2xlcmFuY2UsXG5cdFx0XHRcdFx0ZmlsbDogdHJ1ZSxcblx0XHRcdFx0XHRzdHJva2U6IHRydWVcblx0XHRcdFx0fSksXG5cdFx0XHRcdGl0ZW0gPSBoaXQgJiYgaGl0Lml0ZW0sXG5cdFx0XHRcdHN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRkYmxDbGljayA9IGxhc3RJdGVtID09IGl0ZW0gJiYgKERhdGUubm93KCkgLSBjbGlja1RpbWUgPCAzMDApO1xuXHRcdFx0XHRkb3duSXRlbSA9IGxhc3RJdGVtID0gaXRlbTtcblx0XHRcdFx0ZG93blBvaW50ID0gbGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdGRyYWdJdGVtID0gIXN0b3BwZWQgJiYgaXRlbTtcblx0XHRcdFx0d2hpbGUgKGRyYWdJdGVtICYmICFkcmFnSXRlbS5yZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdFx0ZHJhZ0l0ZW0gPSBkcmFnSXRlbS5fcGFyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSwgZG93blBvaW50KTtcblx0XHRcdFx0aWYgKGRyYWdJdGVtKSB7XG5cdFx0XHRcdFx0aWYgKGxhc3RQb2ludCAmJiAhbGFzdFBvaW50LmVxdWFscyhwb2ludCkpXG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCwgZHJhZ0l0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBvaW50KTtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQsIGl0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdG9wcGVkICYmIGl0ZW0gJiYgaXRlbSA9PT0gZG93bkl0ZW0pIHtcblx0XHRcdFx0XHRjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCBkYmxDbGljayAmJiBkb3duSXRlbS5yZXNwb25kcygnZG91YmxlY2xpY2snKVxuXHRcdFx0XHRcdFx0XHQ/ICdkb3VibGVjbGljaycgOiAnY2xpY2snLCBldmVudCwgZG93blBvaW50LCBpdGVtKTtcblx0XHRcdFx0XHRkYmxDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvd25JdGVtID0gZHJhZ0l0ZW0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRcdGlmIChkcmFnSXRlbSlcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsICdtb3VzZWRyYWcnLCBldmVudCwgcG9pbnQsXG5cdFx0XHRcdFx0XHRcdGRyYWdJdGVtLCBsYXN0UG9pbnQpO1xuXHRcdFx0XHRpZiAoIXN0b3BwZWQpIHtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pXG5cdFx0XHRcdFx0XHRvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0aWYgKGl0ZW0gIT09IG92ZXJJdGVtKSB7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50LCBvdmVySXRlbSk7XG5cdFx0XHRcdFx0b3Zlckl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RvcHBlZDtcblx0XHR9XG5cdH07XG59KTtcblxudmFyIEV2ZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gRXZlbnQoZXZlbnQpIHtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0aXNQcmV2ZW50ZWQ6IGZhbHNlLFxuXHRpc1N0b3BwZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzUHJldmVudGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdHRoaXMucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRnZXRNb2RpZmllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBLZXkubW9kaWZpZXJzO1xuXHR9XG59KTtcblxudmFyIEtleUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnS2V5RXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkge1xuXHRcdEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdHRoaXMudHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnO1xuXHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywga2V5OiAnXCIgKyB0aGlzLmtleVxuXHRcdFx0XHQrIFwiJywgY2hhcmFjdGVyOiAnXCIgKyB0aGlzLmNoYXJhY3RlclxuXHRcdFx0XHQrIFwiJywgbW9kaWZpZXJzOiBcIiArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyBcIiB9XCI7XG5cdH1cbn0pO1xuXG52YXIgS2V5ID0gbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBzcGVjaWFsS2V5cyA9IHtcblx0XHQ4OiAnYmFja3NwYWNlJyxcblx0XHQ5OiAndGFiJyxcblx0XHQxMzogJ2VudGVyJyxcblx0XHQxNjogJ3NoaWZ0Jyxcblx0XHQxNzogJ2NvbnRyb2wnLFxuXHRcdDE4OiAnb3B0aW9uJyxcblx0XHQxOTogJ3BhdXNlJyxcblx0XHQyMDogJ2NhcHMtbG9jaycsXG5cdFx0Mjc6ICdlc2NhcGUnLFxuXHRcdDMyOiAnc3BhY2UnLFxuXHRcdDM1OiAnZW5kJyxcblx0XHQzNjogJ2hvbWUnLFxuXHRcdDM3OiAnbGVmdCcsXG5cdFx0Mzg6ICd1cCcsXG5cdFx0Mzk6ICdyaWdodCcsXG5cdFx0NDA6ICdkb3duJyxcblx0XHQ0NjogJ2RlbGV0ZScsXG5cdFx0OTE6ICdjb21tYW5kJyxcblx0XHQ5MzogJ2NvbW1hbmQnLCBcblx0XHQyMjQ6ICdjb21tYW5kJyAgXG5cdH0sXG5cblx0c3BlY2lhbENoYXJzID0ge1xuXHRcdDk6IHRydWUsIFxuXHRcdDEzOiB0cnVlLCBcblx0XHQzMjogdHJ1ZSBcblx0fSxcblxuXHRtb2RpZmllcnMgPSBuZXcgQmFzZSh7XG5cdFx0c2hpZnQ6IGZhbHNlLFxuXHRcdGNvbnRyb2w6IGZhbHNlLFxuXHRcdG9wdGlvbjogZmFsc2UsXG5cdFx0Y29tbWFuZDogZmFsc2UsXG5cdFx0Y2Fwc0xvY2s6IGZhbHNlLFxuXHRcdHNwYWNlOiBmYWxzZVxuXHR9KSxcblxuXHRjaGFyQ29kZU1hcCA9IHt9LCBcblx0a2V5TWFwID0ge30sIFxuXHRkb3duQ29kZTsgXG5cblx0ZnVuY3Rpb24gaGFuZGxlS2V5KGRvd24sIGtleUNvZGUsIGNoYXJDb2RlLCBldmVudCkge1xuXHRcdHZhciBjaGFyYWN0ZXIgPSBjaGFyQ29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpIDogJycsXG5cdFx0XHRzcGVjaWFsS2V5ID0gc3BlY2lhbEtleXNba2V5Q29kZV0sXG5cdFx0XHRrZXkgPSBzcGVjaWFsS2V5IHx8IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0dHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLFxuXHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRzY29wZSA9IHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSAmJiB2aWV3Ll9zY29wZSxcblx0XHRcdHRvb2wgPSBzY29wZSAmJiBzY29wZS50b29sLFxuXHRcdFx0bmFtZTtcblx0XHRrZXlNYXBba2V5XSA9IGRvd247XG5cdFx0aWYgKHNwZWNpYWxLZXkgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKHNwZWNpYWxLZXkpKSBpbiBtb2RpZmllcnMpXG5cdFx0XHRtb2RpZmllcnNbbmFtZV0gPSBkb3duO1xuXHRcdGlmIChkb3duKSB7XG5cdFx0XHRjaGFyQ29kZU1hcFtrZXlDb2RlXSA9IGNoYXJDb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgY2hhckNvZGVNYXBba2V5Q29kZV07XG5cdFx0fVxuXHRcdGlmICh0b29sICYmIHRvb2wucmVzcG9uZHModHlwZSkpIHtcblx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHR0b29sLmZpcmUodHlwZSwgbmV3IEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkpO1xuXHRcdFx0aWYgKHZpZXcpXG5cdFx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0RG9tRXZlbnQuYWRkKGRvY3VtZW50LCB7XG5cdFx0a2V5ZG93bjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblx0XHRcdGlmIChjb2RlIGluIHNwZWNpYWxLZXlzIHx8IG1vZGlmaWVycy5jb21tYW5kKSB7XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBjb2RlLFxuXHRcdFx0XHRcdFx0Y29kZSBpbiBzcGVjaWFsQ2hhcnMgfHwgbW9kaWZpZXJzLmNvbW1hbmQgPyBjb2RlIDogMCxcblx0XHRcdFx0XHRcdGV2ZW50KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRvd25Db2RlID0gY29kZTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5cHJlc3M6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZG93bkNvZGUgIT0gbnVsbCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgZG93bkNvZGUsIGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGUsIGV2ZW50KTtcblx0XHRcdFx0ZG93bkNvZGUgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXl1cDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdHZhciBjb2RlID0gZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZTtcblx0XHRcdGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Ymx1cjogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGZvciAodmFyIGNvZGUgaW4gY2hhckNvZGVNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgY29kZSwgY2hhckNvZGVNYXBbY29kZV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0bW9kaWZpZXJzOiBtb2RpZmllcnMsXG5cblx0XHRpc0Rvd246IGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0cmV0dXJuICEha2V5TWFwW2tleV07XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIE1vdXNlRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdNb3VzZUV2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNb3VzZUV2ZW50KHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBkZWx0YSkge1xuXHRcdEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5wb2ludCA9IHBvaW50O1xuXHRcdHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuXHRcdHRoaXMuZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFwieyB0eXBlOiAnXCIgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyBcIicsIHBvaW50OiBcIiArIHRoaXMucG9pbnRcblx0XHRcdFx0KyAnLCB0YXJnZXQ6ICcgKyB0aGlzLnRhcmdldFxuXHRcdFx0XHQrICh0aGlzLmRlbHRhID8gJywgZGVsdGE6ICcgKyB0aGlzLmRlbHRhIDogJycpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG4gQmFzZS5leHRlbmQoQ2FsbGJhY2ssIHtcblx0X2NsYXNzOiAnUGFsZXR0ZScsXG5cdF9ldmVudHM6IFsgJ29uQ2hhbmdlJyBdLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhbGV0dGUodGl0bGUsIGNvbXBvbmVudHMsIHZhbHVlcykge1xuXHRcdHZhciBwYXJlbnQgPSBEb21FbGVtZW50LmZpbmQoJy5wYWxldHRlanMtcGFuZWwnKVxuXHRcdFx0fHwgRG9tRWxlbWVudC5maW5kKCdib2R5JykuYXBwZW5kQ2hpbGQoXG5cdFx0XHRcdERvbUVsZW1lbnQuY3JlYXRlKCdkaXYnLCB7ICdjbGFzcyc6ICdwYWxldHRlanMtcGFuZWwnIH0pKTtcblx0XHR0aGlzLl9lbGVtZW50ID0gcGFyZW50LmFwcGVuZENoaWxkKFxuXHRcdFx0RG9tRWxlbWVudC5jcmVhdGUoJ3RhYmxlJywgeyAnY2xhc3MnOiAncGFsZXR0ZWpzLXBhbmUnIH0pKTtcblx0XHR0aGlzLl90aXRsZSA9IHRpdGxlO1xuXHRcdGlmICghdmFsdWVzKVxuXHRcdFx0dmFsdWVzID0ge307XG5cdFx0Zm9yICh2YXIgbmFtZSBpbiAodGhpcy5jb21wb25lbnRzID0gY29tcG9uZW50cykpIHtcblx0XHRcdHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW25hbWVdO1xuXHRcdFx0aWYgKCEoY29tcG9uZW50IGluc3RhbmNlb2YgQ29tcG9uZW50KSkge1xuXHRcdFx0XHRpZiAoY29tcG9uZW50LnZhbHVlID09IG51bGwpXG5cdFx0XHRcdFx0Y29tcG9uZW50LnZhbHVlID0gdmFsdWVzW25hbWVdO1xuXHRcdFx0XHRjb21wb25lbnQubmFtZSA9IG5hbWU7XG5cdFx0XHRcdGNvbXBvbmVudCA9IGNvbXBvbmVudHNbbmFtZV0gPSBuZXcgQ29tcG9uZW50KGNvbXBvbmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9lbGVtZW50LmFwcGVuZENoaWxkKGNvbXBvbmVudC5fZWxlbWVudCk7XG5cdFx0XHRjb21wb25lbnQuX3BhbGV0dGUgPSB0aGlzO1xuXHRcdFx0aWYgKHZhbHVlc1tuYW1lXSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHR2YWx1ZXNbbmFtZV0gPSBjb21wb25lbnQudmFsdWU7XG5cdFx0fVxuXHRcdHRoaXMudmFsdWVzID0gQmFzZS5lYWNoKHZhbHVlcywgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHZhciBjb21wb25lbnQgPSBjb21wb25lbnRzW25hbWVdO1xuXHRcdFx0aWYgKGNvbXBvbmVudCkge1xuXHRcdFx0XHRCYXNlLmRlZmluZSh2YWx1ZXMsIG5hbWUsIHtcblx0XHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGNvbXBvbmVudC5fdmFsdWU7XG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0XHRzZXQ6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50LnNldFZhbHVlKHZhbCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRpZiAod2luZG93LnBhcGVyKVxuXHRcdFx0cGFwZXIucGFsZXR0ZXMucHVzaCh0aGlzKTtcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLmNvbXBvbmVudHMpXG5cdFx0XHR0aGlzLmNvbXBvbmVudHNbaV0ucmVzZXQoKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdERvbUVsZW1lbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQpO1xuXHR9XG59KTtcblxudmFyIENvbXBvbmVudCA9IEJhc2UuZXh0ZW5kKENhbGxiYWNrLCB7XG5cdF9jbGFzczogJ0NvbXBvbmVudCcsXG5cdF9ldmVudHM6IFsgJ29uQ2hhbmdlJywgJ29uQ2xpY2snIF0sXG5cblx0X3R5cGVzOiB7XG5cdFx0J2Jvb2xlYW4nOiB7XG5cdFx0XHR0eXBlOiAnY2hlY2tib3gnLFxuXHRcdFx0dmFsdWU6ICdjaGVja2VkJ1xuXHRcdH0sXG5cblx0XHRzdHJpbmc6IHtcblx0XHRcdHR5cGU6ICd0ZXh0J1xuXHRcdH0sXG5cblx0XHRudW1iZXI6IHtcblx0XHRcdHR5cGU6ICdudW1iZXInLFxuXHRcdFx0bnVtYmVyOiB0cnVlXG5cdFx0fSxcblxuXHRcdGJ1dHRvbjoge1xuXHRcdFx0dHlwZTogJ2J1dHRvbidcblx0XHR9LFxuXG5cdFx0dGV4dDoge1xuXHRcdFx0dGFnOiAnZGl2Jyxcblx0XHRcdHZhbHVlOiAndGV4dCdcblx0XHR9LFxuXG5cdFx0c2xpZGVyOiB7XG5cdFx0XHR0eXBlOiAncmFuZ2UnLFxuXHRcdFx0bnVtYmVyOiB0cnVlXG5cdFx0fSxcblxuXHRcdGxpc3Q6IHtcblx0XHRcdHRhZzogJ3NlbGVjdCcsXG5cblx0XHRcdHNldE9wdGlvbnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHREb21FbGVtZW50LnJlbW92ZUNoaWxkcmVuKHRoaXMuX2lucHV0KTtcblx0XHRcdFx0RG9tRWxlbWVudC5jcmVhdGUoQmFzZS5lYWNoKHRoaXMuX29wdGlvbnMsIGZ1bmN0aW9uKG9wdGlvbikge1xuXHRcdFx0XHRcdHRoaXMucHVzaCgnb3B0aW9uJywgeyB2YWx1ZTogb3B0aW9uLCB0ZXh0OiBvcHRpb24gfSk7XG5cdFx0XHRcdH0sIFtdKSwgdGhpcy5faW5wdXQpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjb2xvcjoge1xuXHRcdFx0dHlwZTogJ2NvbG9yJyxcblxuXHRcdFx0Z2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsdWUpO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0VmFsdWU6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IodmFsdWUpLnRvQ1NTKFxuXHRcdFx0XHRcdFx0RG9tRWxlbWVudC5nZXQodGhpcy5faW5wdXQsICd0eXBlJykgPT09ICdjb2xvcicpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb25lbnQob2JqKSB7XG5cdFx0dGhpcy5faWQgPSBDb21wb25lbnQuX2lkID0gKENvbXBvbmVudC5faWQgfHwgMCkgKyAxO1xuXHRcdHRoaXMuX3R5cGUgPSBvYmoudHlwZSBpbiB0aGlzLl90eXBlc1xuXHRcdFx0PyBvYmoudHlwZVxuXHRcdFx0OiAnb3B0aW9ucycgaW4gb2JqXG5cdFx0XHRcdD8gJ2xpc3QnXG5cdFx0XHRcdDogJ29uQ2xpY2snIGluIG9ialxuXHRcdFx0XHRcdD8gJ2J1dHRvbidcblx0XHRcdFx0XHQ6IHR5cGVvZiBvYmoudmFsdWU7XG5cdFx0dGhpcy5fbWV0YSA9IHRoaXMuX3R5cGVzW3RoaXMuX3R5cGVdIHx8IHsgdHlwZTogdGhpcy5fdHlwZSB9O1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdGlkID0gJ2NvbXBvbmVudC0nICsgdGhpcy5faWQ7XG5cdFx0dGhpcy5fZG9udEZpcmUgPSB0cnVlO1xuXHRcdHRoaXMuX2lucHV0ID0gRG9tRWxlbWVudC5jcmVhdGUodGhpcy5fbWV0YS50YWcgfHwgJ2lucHV0Jywge1xuXHRcdFx0aWQ6IGlkLFxuXHRcdFx0dHlwZTogdGhpcy5fbWV0YS50eXBlLFxuXHRcdFx0ZXZlbnRzOiB7XG5cdFx0XHRcdGNoYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5zZXRWYWx1ZShcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0KHRoaXMsIHRoYXQuX21ldGEudmFsdWUgfHwgJ3ZhbHVlJykpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbGljazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5maXJlKCdjbGljaycpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0dGhpcy5hdHRhY2goJ2NoYW5nZScsIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2RvbnRGaXJlKVxuXHRcdFx0XHR0aGlzLl9wYWxldHRlLmZpcmUoJ2NoYW5nZScsIHRoaXMsIHRoaXMubmFtZSwgdmFsdWUpO1xuXHRcdH0pO1xuXHRcdHRoaXMuX2VsZW1lbnQgPSBEb21FbGVtZW50LmNyZWF0ZSgndHInLCBbXG5cdFx0XHQndGQnLCBbdGhpcy5fbGFiZWwgPSBEb21FbGVtZW50LmNyZWF0ZSgnbGFiZWwnLCB7ICdmb3InOiBpZCB9KV0sXG5cdFx0XHQndGQnLCBbdGhpcy5faW5wdXRdXG5cdFx0XSk7XG5cdFx0QmFzZS5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0dGhpc1trZXldID0gdmFsdWU7XG5cdFx0fSwgdGhpcyk7XG5cdFx0dGhpcy5fZGVmYXVsdFZhbHVlID0gdGhpcy5fdmFsdWU7XG5cdFx0dGhpcy5fZG9udEZpcmUgPSBmYWxzZTtcblx0fSxcblxuXHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fSxcblxuXHRnZXRMYWJlbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX19sYWJlbDtcblx0fSxcblxuXHRzZXRMYWJlbDogZnVuY3Rpb24obGFiZWwpIHtcblx0XHR0aGlzLl9fbGFiZWwgPSBsYWJlbDtcblx0XHREb21FbGVtZW50LnNldCh0aGlzLl9sYWJlbCwgJ3RleHQnLCBsYWJlbCArICc6Jyk7XG5cdH0sXG5cblx0Z2V0T3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX29wdGlvbnM7XG5cdH0sXG5cblx0c2V0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHRoaXMuX29wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHZhciBzZXRPcHRpb25zID0gdGhpcy5fbWV0YS5zZXRPcHRpb25zO1xuXHRcdGlmIChzZXRPcHRpb25zKVxuXHRcdFx0c2V0T3B0aW9ucy5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdGdldFZhbHVlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZSxcblx0XHRcdGdldFZhbHVlID0gdGhpcy5fbWV0YS5nZXRWYWx1ZTtcblx0XHRyZXR1cm4gZ2V0VmFsdWUgPyBnZXRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKSA6IHZhbHVlO1xuXHR9LFxuXG5cdHNldFZhbHVlOiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHZhciBrZXkgPSB0aGlzLl9tZXRhLnZhbHVlIHx8ICd2YWx1ZScsXG5cdFx0XHRzZXRWYWx1ZSA9IHRoaXMuX21ldGEuc2V0VmFsdWU7XG5cdFx0aWYgKHNldFZhbHVlKVxuXHRcdFx0dmFsdWUgPSBzZXRWYWx1ZS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHREb21FbGVtZW50LnNldCh0aGlzLl9pbnB1dCwga2V5LCB2YWx1ZSk7XG5cdFx0dmFsdWUgPSBEb21FbGVtZW50LmdldCh0aGlzLl9pbnB1dCwga2V5KTtcblx0XHRpZiAodGhpcy5fbWV0YS5udW1iZXIpXG5cdFx0XHR2YWx1ZSA9IHBhcnNlRmxvYXQodmFsdWUsIDEwKTtcblx0XHRpZiAodGhpcy5fdmFsdWUgIT09IHZhbHVlKSB7XG5cdFx0XHR0aGlzLl92YWx1ZSA9IHZhbHVlO1xuXHRcdFx0aWYgKCF0aGlzLl9kb250RmlyZSlcblx0XHRcdFx0dGhpcy5maXJlKCdjaGFuZ2UnLCB0aGlzLmdldFZhbHVlKCkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRSYW5nZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFtwYXJzZUZsb2F0KERvbUVsZW1lbnQuZ2V0KHRoaXMuX2lucHV0LCAnbWluJykpLFxuXHRcdFx0XHRwYXJzZUZsb2F0KERvbUVsZW1lbnQuZ2V0KHRoaXMuX2lucHV0LCAnbWF4JykpXTtcblx0fSxcblxuXHRzZXRSYW5nZTogZnVuY3Rpb24obWluLCBtYXgpIHtcblx0XHR2YXIgcmFuZ2UgPSBBcnJheS5pc0FycmF5KG1pbikgPyBtaW4gOiBbbWluLCBtYXhdO1xuXHRcdERvbUVsZW1lbnQuc2V0KHRoaXMuX2lucHV0LCB7IG1pbjogcmFuZ2VbMF0sIG1heDogcmFuZ2VbMV0gfSk7XG5cdH0sXG5cblx0Z2V0TWluOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRSYW5nZSgpWzBdO1xuXHR9LFxuXG5cdHNldE1pbjogZnVuY3Rpb24obWluKSB7XG5cdFx0dGhpcy5zZXRSYW5nZShtaW4sIHRoaXMuZ2V0TWF4KCkpO1xuXHR9LFxuXG5cdGdldE1heDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UmFuZ2UoKVsxXTtcblx0fSxcblxuXHRzZXRNYXg6IGZ1bmN0aW9uKG1heCkge1xuXHRcdHRoaXMuc2V0UmFuZ2UodGhpcy5nZXRNaW4oKSwgbWF4KTtcblx0fSxcblxuXHRnZXRTdGVwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gcGFyc2VGbG9hdChEb21FbGVtZW50LmdldCh0aGlzLl9pbnB1dCwgJ3N0ZXAnKSk7XG5cdH0sXG5cblx0c2V0U3RlcDogZnVuY3Rpb24oc3RlcCkge1xuXHRcdERvbUVsZW1lbnQuc2V0KHRoaXMuX2lucHV0LCAnc3RlcCcsIHN0ZXApO1xuXHR9LFxuXG5cdHJlc2V0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNldFZhbHVlKHRoaXMuX2RlZmF1bHRWYWx1ZSk7XG5cdH1cbn0pO1xuXG52YXIgVG9vbEV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnVG9vbEV2ZW50Jyxcblx0X2l0ZW06IG51bGwsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVG9vbEV2ZW50KHRvb2wsIHR5cGUsIGV2ZW50KSB7XG5cdFx0dGhpcy50b29sID0gdG9vbDtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRfY2hvb3NlUG9pbnQ6IGZ1bmN0aW9uKHBvaW50LCB0b29sUG9pbnQpIHtcblx0XHRyZXR1cm4gcG9pbnQgPyBwb2ludCA6IHRvb2xQb2ludCA/IHRvb2xQb2ludC5jbG9uZSgpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX3BvaW50LCB0aGlzLnRvb2wuX3BvaW50KTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50O1xuXHR9LFxuXG5cdGdldExhc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2xhc3RQb2ludCwgdGhpcy50b29sLl9sYXN0UG9pbnQpO1xuXHR9LFxuXG5cdHNldExhc3RQb2ludDogZnVuY3Rpb24obGFzdFBvaW50KSB7XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gbGFzdFBvaW50O1xuXHR9LFxuXG5cdGdldERvd25Qb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nob29zZVBvaW50KHRoaXMuX2Rvd25Qb2ludCwgdGhpcy50b29sLl9kb3duUG9pbnQpO1xuXHR9LFxuXG5cdHNldERvd25Qb2ludDogZnVuY3Rpb24oZG93blBvaW50KSB7XG5cdFx0dGhpcy5fZG93blBvaW50ID0gZG93blBvaW50O1xuXHR9LFxuXG5cdGdldE1pZGRsZVBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX21pZGRsZVBvaW50ICYmIHRoaXMudG9vbC5fbGFzdFBvaW50KSB7XG5cdFx0XHRyZXR1cm4gdGhpcy50b29sLl9wb2ludC5hZGQodGhpcy50b29sLl9sYXN0UG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX21pZGRsZVBvaW50O1xuXHR9LFxuXG5cdHNldE1pZGRsZVBvaW50OiBmdW5jdGlvbihtaWRkbGVQb2ludCkge1xuXHRcdHRoaXMuX21pZGRsZVBvaW50ID0gbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0Z2V0RGVsdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZGVsdGEgJiYgdGhpcy50b29sLl9sYXN0UG9pbnRcblx0XHQgXHRcdD8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcblx0XHRcdFx0OiB0aGlzLl9kZWx0YTtcblx0fSxcblxuXHRzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLl9kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdGdldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKVxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fZG93bkNvdW50XG5cdFx0XHRcdDogdGhpcy50b29sLl9jb3VudDtcblx0fSxcblxuXHRzZXRDb3VudDogZnVuY3Rpb24oY291bnQpIHtcblx0XHR0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J11cblx0XHRcdD0gY291bnQ7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9pdGVtKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy50b29sLl9zY29wZS5wcm9qZWN0LmhpdFRlc3QodGhpcy5nZXRQb2ludCgpKTtcblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSByZXN1bHQuaXRlbSxcblx0XHRcdFx0XHRwYXJlbnQgPSBpdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlICgvXihHcm91cHxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSkge1xuXHRcdFx0XHRcdGl0ZW0gPSBwYXJlbnQ7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd7IHR5cGU6ICcgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKVxuXHRcdFx0XHQrICcsIGNvdW50OiAnICsgdGhpcy5nZXRDb3VudCgpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2wnLFxuXHRfbGlzdDogJ3Rvb2xzJyxcblx0X3JlZmVyZW5jZTogJ3Rvb2wnLFxuXHRfZXZlbnRzOiBbICdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJyxcblx0XHRcdCdvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25Nb3VzZU1vdmUnLFxuXHRcdFx0J29uS2V5RG93bicsICdvbktleVVwJyBdLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0dGhpcy5fY291bnQgPSAwO1xuXHRcdHRoaXMuX2Rvd25Db3VudCA9IDA7XG5cdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0fSxcblxuXHRnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiB0aGlzLl9taW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IHRoaXMuX21pbkRpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiB0aGlzLl9tYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2Vcblx0XHRcdD8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuXHR9LFxuXG5cdHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHR9LFxuXG5cdF91cGRhdGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSwgc3RhcnQsXG5cdFx0XHRuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdGlmICghc3RhcnQpIHtcblx0XHRcdGlmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIG1pbkRpc3QgPSBtaW5EaXN0YW5jZSAhPSBudWxsID8gbWluRGlzdGFuY2UgOiAwLFxuXHRcdFx0XHRcdHZlY3RvciA9IHBvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSxcblx0XHRcdFx0XHRkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcblx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdHZhciBtYXhEaXN0ID0gbWF4RGlzdGFuY2UgIT0gbnVsbCA/IG1heERpc3RhbmNlIDogMDtcblx0XHRcdFx0aWYgKG1heERpc3QgIT0gMCkge1xuXHRcdFx0XHRcdGlmIChkaXN0YW5jZSA+IG1heERpc3QpIHtcblx0XHRcdFx0XHRcdHBvaW50ID0gdGhpcy5fcG9pbnQuYWRkKHZlY3Rvci5ub3JtYWxpemUobWF4RGlzdCkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5lZWRzQ2hhbmdlICYmIHBvaW50LmVxdWFscyh0aGlzLl9wb2ludCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gc3RhcnQgJiYgdHlwZSA9PSAnbW91c2Vtb3ZlJyA/IHBvaW50IDogdGhpcy5fcG9pbnQ7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0dGhpcy5fZG93blBvaW50ID0gdGhpcy5fcG9pbnQ7XG5cdFx0XHR0aGlzLl9kb3duQ291bnQrKztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMuX2NvdW50ID0gc3RhcnQgPyAwIDogdGhpcy5fY291bnQgKyAxO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIHNldHMgPSBwYXBlci5wcm9qZWN0Ll9yZW1vdmVTZXRzO1xuXHRcdGlmIChzZXRzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNldXAnKVxuXHRcdFx0XHRzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG5cdFx0XHR2YXIgc2V0ID0gc2V0c1t0eXBlXTtcblx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gc2V0KSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBzZXRbaWRdO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBzZXRzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3RoZXIgPSBzZXRzW2tleV07XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgJiYgb3RoZXIgIT0gc2V0KVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldHNbdHlwZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5yZXNwb25kcyh0eXBlKVxuXHRcdFx0XHQmJiB0aGlzLmZpcmUodHlwZSwgbmV3IFRvb2xFdmVudCh0aGlzLCB0eXBlLCBldmVudCkpO1xuXHR9LFxuXG5cdF9oYW5kbGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIGV2ZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlZHJhZyc6XG5cdFx0XHR2YXIgbmVlZHNDaGFuZ2UgPSBmYWxzZSxcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdG5lZWRzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGlmICghcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KVxuXHRcdFx0XHRcdCYmIHRoaXMuX3VwZGF0ZUV2ZW50KCdtb3VzZWRyYWcnLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KCdtb3VzZWRyYWcnLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgdGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCB0aGlzLl9maXJzdE1vdmUsIHRydWUsIGZhbHNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKGNhbGxlZClcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIGNhbGxlZDtcblx0fVxuXG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBjYWxsYmFjaykge1xuXHRcdHZhciB4aHIgPSBuZXcgKHdpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IFhNTEh0dHBSZXF1ZXN0KShcblx0XHRcdFx0XHQnTWljcm9zb2Z0LlhNTEhUVFAnKTtcblx0XHR4aHIub3BlbihtZXRob2QudG9VcHBlckNhc2UoKSwgdXJsLCB0cnVlKTtcblx0XHRpZiAoJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluJyk7XG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG5cdFx0XHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXHRcdFx0XHRpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh4aHIsIHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgJyArIHVybCArICcgKEVycm9yICdcblx0XHRcdFx0XHRcdFx0KyBzdGF0dXMgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4geGhyLnNlbmQobnVsbCk7XG5cdH1cbn07XG5cbnZhciBDYW52YXNQcm92aWRlciA9IHtcblx0Y2FudmFzZXM6IFtdLFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbykge1xuXHRcdHZhciBjYW52YXMsXG5cdFx0XHRpbml0ID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0cGl4ZWxSYXRpbyA9IGhlaWdodDtcblx0XHRcdGhlaWdodCA9IHdpZHRoLmhlaWdodDtcblx0XHRcdHdpZHRoID0gd2lkdGgud2lkdGg7XG5cdFx0fVxuXHRcdGlmICghcGl4ZWxSYXRpbykge1xuXHRcdFx0cGl4ZWxSYXRpbyA9IDE7XG5cdFx0fSBlbHNlIGlmIChwaXhlbFJhdGlvICE9PSAxKSB7XG5cdFx0XHR3aWR0aCAqPSBwaXhlbFJhdGlvO1xuXHRcdFx0aGVpZ2h0ICo9IHBpeGVsUmF0aW87XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNhbnZhc2VzLmxlbmd0aCkge1xuXHRcdFx0Y2FudmFzID0gdGhpcy5jYW52YXNlcy5wb3AoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcblx0XHRcdGlmIChpbml0KVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSlcblx0XHRcdGN0eC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQsIHBpeGVsUmF0aW8pIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCwgcGl4ZWxSYXRpbykuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqLmNhbnZhcyA/IG9iai5jYW52YXMgOiBvYmo7XG5cdFx0Y2FudmFzLmdldENvbnRleHQoJzJkJykucmVzdG9yZSgpO1xuXHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHR9XG59O1xuXG52YXIgQmxlbmRNb2RlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWluID0gTWF0aC5taW4sXG5cdFx0bWF4ID0gTWF0aC5tYXgsXG5cdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0c3IsIHNnLCBzYiwgc2EsIFxuXHRcdGJyLCBiZywgYmIsIGJhLCBcblx0XHRkciwgZGcsIGRiOyAgICAgXG5cblx0ZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG5cdFx0dmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuXHRcdGRyID0gciArIGQ7XG5cdFx0ZGcgPSBnICsgZDtcblx0XHRkYiA9IGIgKyBkO1xuXHRcdHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuXHRcdFx0bW4gPSBtaW4oZHIsIGRnLCBkYiksXG5cdFx0XHRteCA9IG1heChkciwgZGcsIGRiKTtcblx0XHRpZiAobW4gPCAwKSB7XG5cdFx0XHR2YXIgbG1uID0gbCAtIG1uO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuXHRcdH1cblx0XHRpZiAobXggPiAyNTUpIHtcblx0XHRcdHZhciBsbiA9IDI1NSAtIGwsXG5cdFx0XHRcdG14bCA9IG14IC0gbDtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuXHRcdHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuXHRcdHZhciBjb2wgPSBbciwgZywgYl0sXG5cdFx0XHRteCA9IG1heChyLCBnLCBiKSwgXG5cdFx0XHRtbiA9IG1pbihyLCBnLCBiKSwgXG5cdFx0XHRtZDsgXG5cdFx0bW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuXHRcdG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcblx0XHRtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cdFx0aWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG5cdFx0XHRjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuXHRcdFx0Y29sW214XSA9IHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbFttZF0gPSBjb2xbbXhdID0gMDtcblx0XHR9XG5cdFx0Y29sW21uXSA9IDA7XG5cdFx0ZHIgPSBjb2xbMF07XG5cdFx0ZGcgPSBjb2xbMV07XG5cdFx0ZGIgPSBjb2xbMl07XG5cdH1cblxuXHR2YXIgbW9kZXMgPSB7XG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAqIHNyIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyAqIHNnIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiAqIHNiIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyIC0gKGJyICogc3IgLyAyNTUpO1xuXHRcdFx0ZGcgPSBiZyArIHNnIC0gKGJnICogc2cgLyAyNTUpO1xuXHRcdFx0ZGIgPSBiYiArIHNiIC0gKGJiICogc2IgLyAyNTUpO1xuXHRcdH0sXG5cblx0XHRvdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J3NvZnQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0ID0gc3IgKiBiciAvIDI1NTtcblx0XHRcdGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2cgKiBiZyAvIDI1NTtcblx0XHRcdGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2IgKiBiYiAvIDI1NTtcblx0XHRcdGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdoYXJkLWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcblx0XHRcdGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG5cdFx0XHRkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuXHRcdH0sXG5cblx0XHQnY29sb3ItYnVybic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG5cdFx0XHRkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcblx0XHRcdGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuXHRcdH0sXG5cblx0XHRkYXJrZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRsaWdodGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0ZGlmZmVyZW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIC0gc3I7XG5cdFx0XHRpZiAoZHIgPCAwKVxuXHRcdFx0XHRkciA9IC1kcjtcblx0XHRcdGRnID0gYmcgLSBzZztcblx0XHRcdGlmIChkZyA8IDApXG5cdFx0XHRcdGRnID0gLWRnO1xuXHRcdFx0ZGIgPSBiYiAtIHNiO1xuXHRcdFx0aWYgKGRiIDwgMClcblx0XHRcdFx0ZGIgPSAtZGI7XG5cdFx0fSxcblxuXHRcdGV4Y2x1c2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdGh1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRzYXR1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGx1bWlub3NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG5cdFx0fSxcblxuXHRcdGNvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcblx0XHRcdGRnID0gbWluKGJnICsgc2csIDI1NSk7XG5cdFx0XHRkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1heChiciAtIHNyLCAwKTtcblx0XHRcdGRnID0gbWF4KGJnIC0gc2csIDApO1xuXHRcdFx0ZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG5cdFx0fSxcblxuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAoYnIgKyBzcikgLyAyO1xuXHRcdFx0ZGcgPSAoYmcgKyBzZykgLyAyO1xuXHRcdFx0ZGIgPSAoYmIgKyBzYikgLyAyO1xuXHRcdH0sXG5cblx0XHRuZWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcblx0XHRcdGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuXHRcdFx0ZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goW1xuXHRcdCdzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsXG5cdFx0J2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0Jyxcblx0XHQnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvcidcblx0XSwgZnVuY3Rpb24obW9kZSkge1xuXHRcdHRoaXNbbW9kZV0gPSB0cnVlO1xuXHR9LCB7fSk7XG5cblx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdEJhc2UuZWFjaChtb2RlcywgZnVuY3Rpb24oZnVuYywgbW9kZSkge1xuXHRcdHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR0cnkge1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjMzAwJyA6ICcjYTAwJztcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0aWYgKGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPT09IG1vZGUpIHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjYTAwJyA6ICcjMzAwJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRvayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVswXSAhPT0gZGFya2VuID8gMTcwIDogNTE7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG5hdGl2ZU1vZGVzW21vZGVdID0gb2s7XG5cdH0pO1xuXHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cblx0dGhpcy5wcm9jZXNzID0gZnVuY3Rpb24obW9kZSwgc3JjQ29udGV4dCwgZHN0Q29udGV4dCwgYWxwaGEsIG9mZnNldCkge1xuXHRcdHZhciBzcmNDYW52YXMgPSBzcmNDb250ZXh0LmNhbnZhcyxcblx0XHRcdG5vcm1hbCA9IG1vZGUgPT09ICdub3JtYWwnO1xuXHRcdGlmIChub3JtYWwgfHwgbmF0aXZlTW9kZXNbbW9kZV0pIHtcblx0XHRcdGRzdENvbnRleHQuc2F2ZSgpO1xuXHRcdFx0ZHN0Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHRkc3RDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAoIW5vcm1hbClcblx0XHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0ZHN0Q29udGV4dC5kcmF3SW1hZ2Uoc3JjQ2FudmFzLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdFx0ZHN0Q29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwcm9jZXNzID0gbW9kZXNbbW9kZV07XG5cdFx0XHRpZiAoIXByb2Nlc3MpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBkc3REYXRhID0gZHN0Q29udGV4dC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCksXG5cdFx0XHRcdGRzdCAgPSBkc3REYXRhLmRhdGEsXG5cdFx0XHRcdHNyYyAgPSBzcmNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0XHRzciA9IHNyY1tpXTtcblx0XHRcdFx0YnIgPSBkc3RbaV07XG5cdFx0XHRcdHNnID0gc3JjW2kgKyAxXTtcblx0XHRcdFx0YmcgPSBkc3RbaSArIDFdO1xuXHRcdFx0XHRzYiA9IHNyY1tpICsgMl07XG5cdFx0XHRcdGJiID0gZHN0W2kgKyAyXTtcblx0XHRcdFx0c2EgPSBzcmNbaSArIDNdO1xuXHRcdFx0XHRiYSA9IGRzdFtpICsgM107XG5cdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0dmFyIGExID0gc2EgKiBhbHBoYSAvIDI1NSxcblx0XHRcdFx0XHRhMiA9IDEgLSBhMTtcblx0XHRcdFx0ZHN0W2ldID0gYTEgKiBkciArIGEyICogYnI7XG5cdFx0XHRcdGRzdFtpICsgMV0gPSBhMSAqIGRnICsgYTIgKiBiZztcblx0XHRcdFx0ZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuXHRcdFx0XHRkc3RbaSArIDNdID0gc2EgKiBhbHBoYSArIGEyICogYmE7XG5cdFx0XHR9XG5cdFx0XHRkc3RDb250ZXh0LnB1dEltYWdlRGF0YShkc3REYXRhLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBTVkdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcblx0c3Ryb2tlV2lkdGg6IFsnc3Ryb2tlLXdpZHRoJywgJ251bWJlciddLFxuXHRzdHJva2VDYXA6IFsnc3Ryb2tlLWxpbmVjYXAnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuXHRtaXRlckxpbWl0OiBbJ3N0cm9rZS1taXRlcmxpbWl0JywgJ251bWJlciddLFxuXHRkYXNoQXJyYXk6IFsnc3Ryb2tlLWRhc2hhcnJheScsICdhcnJheSddLFxuXHRkYXNoT2Zmc2V0OiBbJ3N0cm9rZS1kYXNob2Zmc2V0JywgJ251bWJlciddLFxuXHRmb250RmFtaWx5OiBbJ2ZvbnQtZmFtaWx5JywgJ3N0cmluZyddLFxuXHRmb250V2VpZ2h0OiBbJ2ZvbnQtd2VpZ2h0JywgJ3N0cmluZyddLFxuXHRmb250U2l6ZTogWydmb250LXNpemUnLCAnbnVtYmVyJ10sXG5cdGp1c3RpZmljYXRpb246IFsndGV4dC1hbmNob3InLCAnbG9va3VwJywge1xuXHRcdGxlZnQ6ICdzdGFydCcsXG5cdFx0Y2VudGVyOiAnbWlkZGxlJyxcblx0XHRyaWdodDogJ2VuZCdcblx0fV0sXG5cdG9wYWNpdHk6IFsnb3BhY2l0eScsICdudW1iZXInXSxcblx0YmxlbmRNb2RlOiBbJ21peC1ibGVuZC1tb2RlJywgJ3N0cmluZyddXG59LCBmdW5jdGlvbihlbnRyeSwga2V5KSB7XG5cdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0bG9va3VwID0gZW50cnlbMl07XG5cdHRoaXNba2V5XSA9IHtcblx0XHR0eXBlOiBlbnRyeVsxXSxcblx0XHRwcm9wZXJ0eToga2V5LFxuXHRcdGF0dHJpYnV0ZTogZW50cnlbMF0sXG5cdFx0dG9TVkc6IGxvb2t1cCxcblx0XHRmcm9tU1ZHOiBsb29rdXAgJiYgQmFzZS5lYWNoKGxvb2t1cCwgZnVuY3Rpb24odmFsdWUsIG5hbWUpIHtcblx0XHRcdHRoaXNbdmFsdWVdID0gbmFtZTtcblx0XHR9LCB7fSksXG5cdFx0Z2V0OiAnZ2V0JyArIHBhcnQsXG5cdFx0c2V0OiAnc2V0JyArIHBhcnRcblx0fTtcbn0sIHt9KTtcblxudmFyIFNWR05hbWVzcGFjZXMgPSB7XG5cdGhyZWY6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJ1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZm9ybWF0dGVyO1xuXG5cdGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHZhciB2YWwgPSBhdHRyc1trZXldLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW2tleV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHZhbCA9IGZvcm1hdHRlci5udW1iZXIodmFsKTtcblx0XHRcdGlmIChuYW1lc3BhY2UpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGtleSwgdmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpIHtcblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhcblx0XHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0oaXRlbSwgY29vcmRpbmF0ZXMsIGNlbnRlcikge1xuXHRcdHZhciBtYXRyaXggPSBpdGVtLl9tYXRyaXgsXG5cdFx0XHR0cmFucyA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpLFxuXHRcdFx0YXR0cnMgPSB7fTtcblx0XHRpZiAoY29vcmRpbmF0ZXMpIHtcblx0XHRcdG1hdHJpeCA9IG1hdHJpeC5zaGlmdGxlc3MoKTtcblx0XHRcdHZhciBwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0cmFucyk7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3gnIDogJ3gnXSA9IHBvaW50Lng7XG5cdFx0XHRhdHRyc1tjZW50ZXIgPyAnY3knIDogJ3knXSA9IHBvaW50Lnk7XG5cdFx0XHR0cmFucyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmICghbWF0cml4LmlzSWRlbnRpdHkoKSkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0XHRpZiAoZGVjb21wb3NlZCAmJiAhZGVjb21wb3NlZC5zaGVhcmluZykge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdFx0XHRhbmdsZSA9IGRlY29tcG9zZWQucm90YXRpb24sXG5cdFx0XHRcdFx0c2NhbGUgPSBkZWNvbXBvc2VkLnNjYWxpbmc7XG5cdFx0XHRcdGlmICh0cmFucyAmJiAhdHJhbnMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgndHJhbnNsYXRlKCcgKyBmb3JtYXR0ZXIucG9pbnQodHJhbnMpICsgJyknKTtcblx0XHRcdFx0aWYgKGFuZ2xlKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuXHRcdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueCAtIDEpXG5cdFx0XHRcdFx0XHR8fCAhTnVtZXJpY2FsLmlzWmVybyhzY2FsZS55IC0gMSkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgnc2NhbGUoJyArIGZvcm1hdHRlci5wb2ludChzY2FsZSkgKycpJyk7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnRyYW5zZm9ybSA9ICdtYXRyaXgoJyArIG1hdHJpeC5nZXRWYWx1ZXMoKS5qb2luKCcsJykgKyAnKSc7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBhdHRycztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydEdyb3VwKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbSksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgnZycsIGF0dHJzKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKTtcblx0XHRcdFx0XHRjbGlwLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdFx0c2V0RGVmaW5pdGlvbihjaGlsZCwgY2xpcCwgJ2NsaXAnKTtcblx0XHRcdFx0XHRzZXRBdHRyaWJ1dGVzKG5vZGUsIHtcblx0XHRcdFx0XHRcdCdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0sIHRydWUpLFxuXHRcdFx0c2l6ZSA9IGl0ZW0uZ2V0U2l6ZSgpO1xuXHRcdGF0dHJzLnggLT0gc2l6ZS53aWR0aCAvIDI7XG5cdFx0YXR0cnMueSAtPSBzaXplLmhlaWdodCAvIDI7XG5cdFx0YXR0cnMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGF0dHJzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdGF0dHJzLmhyZWYgPSBpdGVtLnRvRGF0YVVSTCgpO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCdpbWFnZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLm1hdGNoU2hhcGVzKSB7XG5cdFx0XHR2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuXHRcdFx0aWYgKHNoYXBlKVxuXHRcdFx0XHRyZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHR2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRhdHRycztcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKGl0ZW0uaXNQb2x5Z29uKCkpIHtcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPj0gMykge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvcihpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKGZvcm1hdHRlci5wb2ludChzZWdtZW50c1tpXS5fcG9pbnQpKTtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0cG9pbnRzOiBwYXJ0cy5qb2luKCcgJylcblx0XHRcdFx0fTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRsYXN0ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uX3BvaW50O1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHR4MTogZmlyc3QueCxcblx0XHRcdFx0XHR5MTogZmlyc3QueSxcblx0XHRcdFx0XHR4MjogbGFzdC54LFxuXHRcdFx0XHRcdHkyOiBsYXN0Lnlcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdHZhciBkYXRhID0gaXRlbS5nZXRQYXRoRGF0YSgpO1xuXHRcdFx0YXR0cnMgPSBkYXRhICYmIHsgZDogZGF0YSB9O1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCh0eXBlLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTaGFwZShpdGVtKSB7XG5cdFx0dmFyIHR5cGUgPSBpdGVtLl90eXBlLFxuXHRcdFx0cmFkaXVzID0gaXRlbS5fcmFkaXVzLFxuXHRcdFx0YXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbSwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0JzsgXG5cdFx0XHR2YXIgc2l6ZSA9IGl0ZW0uX3NpemUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRhdHRycy54IC09IHdpZHRoIC8gMjtcblx0XHRcdGF0dHJzLnkgLT0gaGVpZ2h0IC8gMjtcblx0XHRcdGF0dHJzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRhdHRycy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRyYWRpdXMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0YXR0cnMuciA9IHJhZGl1cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnJ4ID0gcmFkaXVzLndpZHRoO1xuXHRcdFx0XHRhdHRycy5yeSA9IHJhZGl1cy5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydENvbXBvdW5kUGF0aChpdGVtKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0sIHRydWUpO1xuXHRcdHZhciBkYXRhID0gaXRlbS5nZXRQYXRoRGF0YSgpO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQbGFjZWRTeW1ib2woaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLCB0cnVlKSxcblx0XHRcdHN5bWJvbCA9IGl0ZW0uZ2V0U3ltYm9sKCksXG5cdFx0XHRzeW1ib2xOb2RlID0gZ2V0RGVmaW5pdGlvbihzeW1ib2wsICdzeW1ib2wnKSxcblx0XHRcdGRlZmluaXRpb24gPSBzeW1ib2wuZ2V0RGVmaW5pdGlvbigpLFxuXHRcdFx0Ym91bmRzID0gZGVmaW5pdGlvbi5nZXRCb3VuZHMoKTtcblx0XHRpZiAoIXN5bWJvbE5vZGUpIHtcblx0XHRcdHN5bWJvbE5vZGUgPSBjcmVhdGVFbGVtZW50KCdzeW1ib2wnLCB7XG5cdFx0XHRcdHZpZXdCb3g6IGZvcm1hdHRlci5yZWN0YW5nbGUoYm91bmRzKVxuXHRcdFx0fSk7XG5cdFx0XHRzeW1ib2xOb2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhkZWZpbml0aW9uLCBvcHRpb25zKSk7XG5cdFx0XHRzZXREZWZpbml0aW9uKHN5bWJvbCwgc3ltYm9sTm9kZSwgJ3N5bWJvbCcpO1xuXHRcdH1cblx0XHRhdHRycy5ocmVmID0gJyMnICsgc3ltYm9sTm9kZS5pZDtcblx0XHRhdHRycy54ICs9IGJvdW5kcy54O1xuXHRcdGF0dHJzLnkgKz0gYm91bmRzLnk7XG5cdFx0YXR0cnMud2lkdGggPSBmb3JtYXR0ZXIubnVtYmVyKGJvdW5kcy53aWR0aCk7XG5cdFx0YXR0cnMuaGVpZ2h0ID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMuaGVpZ2h0KTtcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgndXNlJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0R3JhZGllbnQoY29sb3IpIHtcblx0XHR2YXIgZ3JhZGllbnROb2RlID0gZ2V0RGVmaW5pdGlvbihjb2xvciwgJ2NvbG9yJyk7XG5cdFx0aWYgKCFncmFkaWVudE5vZGUpIHtcblx0XHRcdHZhciBncmFkaWVudCA9IGNvbG9yLmdldEdyYWRpZW50KCksXG5cdFx0XHRcdHJhZGlhbCA9IGdyYWRpZW50Ll9yYWRpYWwsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbG9yLmdldE9yaWdpbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbG9yLmdldERlc3RpbmF0aW9uKCkudHJhbnNmb3JtKCksXG5cdFx0XHRcdGF0dHJzO1xuXHRcdFx0aWYgKHJhZGlhbCkge1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHRjeDogb3JpZ2luLngsXG5cdFx0XHRcdFx0Y3k6IG9yaWdpbi55LFxuXHRcdFx0XHRcdHI6IG9yaWdpbi5nZXREaXN0YW5jZShkZXN0aW5hdGlvbilcblx0XHRcdFx0fTtcblx0XHRcdFx0dmFyIGhpZ2hsaWdodCA9IGNvbG9yLmdldEhpZ2hsaWdodCgpO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gaGlnaGxpZ2h0LnRyYW5zZm9ybSgpO1xuXHRcdFx0XHRcdGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG5cdFx0XHRcdFx0YXR0cnMuZnkgPSBoaWdobGlnaHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IG9yaWdpbi54LFxuXHRcdFx0XHRcdHkxOiBvcmlnaW4ueSxcblx0XHRcdFx0XHR4MjogZGVzdGluYXRpb24ueCxcblx0XHRcdFx0XHR5MjogZGVzdGluYXRpb24ueVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0YXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG5cdFx0XHRncmFkaWVudE5vZGUgPSBjcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdChyYWRpYWwgPyAncmFkaWFsJyA6ICdsaW5lYXInKSArICdHcmFkaWVudCcsIGF0dHJzKTtcblx0XHRcdHZhciBzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV0sXG5cdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcC5fY29sb3IsXG5cdFx0XHRcdFx0YWxwaGEgPSBzdG9wQ29sb3IuZ2V0QWxwaGEoKTtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0J3N0b3AtY29sb3InOiBzdG9wQ29sb3IudG9DU1ModHJ1ZSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0Z3JhZGllbnROb2RlLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3N0b3AnLCBhdHRycykpO1xuXHRcdFx0fVxuXHRcdFx0c2V0RGVmaW5pdGlvbihjb2xvciwgZ3JhZGllbnROb2RlLCAnY29sb3InKTtcblx0XHR9XG5cdFx0cmV0dXJuICd1cmwoIycgKyBncmFkaWVudE5vZGUuaWQgKyAnKSc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRUZXh0KGl0ZW0pIHtcblx0XHR2YXIgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbSwgdHJ1ZSkpO1xuXHRcdG5vZGUudGV4dENvbnRlbnQgPSBpdGVtLl9jb250ZW50O1xuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0dmFyIGV4cG9ydGVycyA9IHtcblx0XHRHcm91cDogZXhwb3J0R3JvdXAsXG5cdFx0TGF5ZXI6IGV4cG9ydEdyb3VwLFxuXHRcdFJhc3RlcjogZXhwb3J0UmFzdGVyLFxuXHRcdFBhdGg6IGV4cG9ydFBhdGgsXG5cdFx0U2hhcGU6IGV4cG9ydFNoYXBlLFxuXHRcdENvbXBvdW5kUGF0aDogZXhwb3J0Q29tcG91bmRQYXRoLFxuXHRcdFBsYWNlZFN5bWJvbDogZXhwb3J0UGxhY2VkU3ltYm9sLFxuXHRcdFBvaW50VGV4dDogZXhwb3J0VGV4dFxuXHR9O1xuXG5cdGZ1bmN0aW9uIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSkge1xuXHRcdHZhciBhdHRycyA9IHt9LFxuXHRcdFx0cGFyZW50ID0gaXRlbS5nZXRQYXJlbnQoKTtcblxuXHRcdGlmIChpdGVtLl9uYW1lICE9IG51bGwpXG5cdFx0XHRhdHRycy5pZCA9IGl0ZW0uX25hbWU7XG5cblx0XHRCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdFx0dmFyIGdldCA9IGVudHJ5LmdldCxcblx0XHRcdFx0dHlwZSA9IGVudHJ5LnR5cGUsXG5cdFx0XHRcdHZhbHVlID0gaXRlbVtnZXRdKCk7XG5cdFx0XHRpZiAoIXBhcmVudCB8fCAhQmFzZS5lcXVhbHMocGFyZW50W2dldF0oKSwgdmFsdWUpKSB7XG5cdFx0XHRcdGlmICh0eXBlID09PSAnY29sb3InICYmIHZhbHVlICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgYWxwaGEgPSB2YWx1ZS5nZXRBbHBoYSgpO1xuXHRcdFx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGUgKyAnLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZV0gPSB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdFx0PyAnbm9uZSdcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGZvcm1hdHRlci5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5ncmFkaWVudFxuXHRcdFx0XHRcdFx0XHRcdD8gZXhwb3J0R3JhZGllbnQodmFsdWUsIGl0ZW0pXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZS50b0NTUyh0cnVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmpvaW4oJywnKVxuXHRcdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2xvb2t1cCdcblx0XHRcdFx0XHRcdFx0XHRcdD8gZW50cnkudG9TVkdbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0aWYgKGF0dHJzLm9wYWNpdHkgPT09IDEpXG5cdFx0XHRkZWxldGUgYXR0cnMub3BhY2l0eTtcblxuXHRcdGlmIChpdGVtLl92aXNpYmlsaXR5ICE9IG51bGwgJiYgIWl0ZW0uX3Zpc2liaWxpdHkpXG5cdFx0XHRhdHRycy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycyk7XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnM7XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24oaXRlbSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRkZWZpbml0aW9ucyA9IHsgaWRzOiB7fSwgc3Znczoge30gfTtcblx0XHRyZXR1cm4gaXRlbSAmJiBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciBpZCA9IGRlZmluaXRpb25zLmlkc1t0eXBlXSA9IChkZWZpbml0aW9ucy5pZHNbdHlwZV0gfHwgMCkgKyAxO1xuXHRcdG5vZGUuaWQgPSB0eXBlICsgJy0nICsgaWQ7XG5cdFx0ZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdID0gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3ZnID0gbm9kZSxcblx0XHRcdGRlZnMgPSBudWxsO1xuXHRcdGlmIChkZWZpbml0aW9ucykge1xuXHRcdFx0c3ZnID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBub2RlO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBkZWZpbml0aW9ucy5zdmdzKSB7XG5cdFx0XHRcdGlmICghZGVmcykge1xuXHRcdFx0XHRcdGlmICghc3ZnKSB7XG5cdFx0XHRcdFx0XHRzdmcgPSBjcmVhdGVFbGVtZW50KCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoY3JlYXRlRWxlbWVudCgnZGVmcycpLFxuXHRcdFx0XHRcdFx0XHRzdmcuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmcy5hcHBlbmRDaGlsZChkZWZpbml0aW9ucy5zdmdzW2ldKTtcblx0XHRcdH1cblx0XHRcdGRlZmluaXRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXNTdHJpbmdcblx0XHRcdFx0PyBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBleHBvcnRlciA9IGV4cG9ydGVyc1tpdGVtLl9jbGFzc10sXG5cdFx0XHRub2RlID0gZXhwb3J0ZXIgJiYgZXhwb3J0ZXIoaXRlbSwgb3B0aW9ucyk7XG5cdFx0aWYgKG5vZGUgJiYgaXRlbS5fZGF0YSkge1xuXHRcdFx0dmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShpdGVtLl9kYXRhKTtcblx0XHRcdGlmIChkYXRhICE9PSAne30nKVxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJywgZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlICYmIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRPcHRpb25zKG9wdGlvbnMpIHtcblx0XHRpZiAoIW9wdGlvbnMpXG5cdFx0XHRvcHRpb25zID0ge307XG5cdFx0Zm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhleHBvcnRTVkcodGhpcywgb3B0aW9ucyksIG9wdGlvbnMpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHR2YXIgbGF5ZXJzID0gdGhpcy5sYXllcnMsXG5cdFx0XHRcdHNpemUgPSB0aGlzLmdldFZpZXcoKS5nZXRTaXplKCksXG5cdFx0XHRcdG5vZGUgPSBjcmVhdGVFbGVtZW50KCdzdmcnLCB7XG5cdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc2l6ZS5oZWlnaHQsXG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdFx0J3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG5cdFx0XHRcdH0pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXllcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhsYXllcnNbaV0sIG9wdGlvbnMpKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwpIHtcblx0XHR2YXIgbmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0aWYgKHZhbHVlID09PSAnbnVsbCcpXG5cdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0cmV0dXJuIHZhbHVlID09IG51bGxcblx0XHRcdFx0PyBhbGxvd051bGxcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0XHQ/ICcnXG5cdFx0XHRcdFx0XHQ6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsKSB7XG5cdFx0eCA9IGdldFZhbHVlKG5vZGUsIHgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHkgPSBnZXRWYWx1ZShub2RlLCB5LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCkge1xuXHRcdHcgPSBnZXRWYWx1ZShub2RlLCB3LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRoID0gZ2V0VmFsdWUobm9kZSwgaCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFNpemUodywgaCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0PyBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5J1xuXHRcdFx0XHRcdFx0PyB2YWx1ZSA/IHZhbHVlLnNwbGl0KC9bXFxzLF0rL2cpLm1hcChwYXJzZUZsb2F0KSA6IFtdXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0PyBsb29rdXBbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIGlzUm9vdCwgb3B0aW9ucykge1xuXHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG5cdFx0XHRpdGVtID0gbmV3IEdyb3VwKCksXG5cdFx0XHRwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcblx0XHRcdGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcblx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0aWYgKCFpc0NsaXApIHtcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGl0ZW0uX3N0eWxlLmNsb25lKCk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG5cdFx0XHRcdGNoaWxkO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMVxuXHRcdFx0XHRcdCYmIChjaGlsZCA9IGltcG9ydFNWRyhjaGlsZE5vZGUsIGZhbHNlLCBvcHRpb25zKSlcblx0XHRcdFx0XHQmJiAhKGNoaWxkIGluc3RhbmNlb2YgU3ltYm9sKSlcblx0XHRcdFx0Y2hpbGRyZW4ucHVzaChjaGlsZCk7XG5cdFx0fVxuXHRcdGl0ZW0uYWRkQ2hpbGRyZW4oY2hpbGRyZW4pO1xuXHRcdGlmIChpc0NsaXApXG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0ucmVkdWNlKCksIG5vZGUsIGlzUm9vdCk7XG5cdFx0cHJvamVjdC5fY3VycmVudFN0eWxlID0gY3VycmVudFN0eWxlO1xuXHRcdGlmIChpc0NsaXAgfHwgdHlwZSA9PT0gJ2RlZnMnKSB7XG5cdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0aXRlbSA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UG9seShub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5vZGUuZ2V0QXR0cmlidXRlKCdwb2ludHMnKS5tYXRjaChcblx0XHRcdFx0XHQvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvb3Jkcy5sZW5ndGg7IGkgPCBsOyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaV0pLFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2kgKyAxXSkpKTtcblx0XHR2YXIgcGF0aCA9IG5ldyBQYXRoKHBvaW50cyk7XG5cdFx0aWYgKHR5cGUgPT09ICdwb2x5Z29uJylcblx0XHRcdHBhdGguY2xvc2VQYXRoKCk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQYXRoKG5vZGUpIHtcblx0XHR2YXIgZGF0YSA9IG5vZGUuZ2V0QXR0cmlidXRlKCdkJyksXG5cdFx0XHRwYXJhbSA9IHsgcGF0aERhdGE6IGRhdGEgfTtcblx0XHRyZXR1cm4gZGF0YS5tYXRjaCgvbS9naSkubGVuZ3RoID4gMSB8fCAvelxcUysvaS50ZXN0KGRhdGEpXG5cdFx0XHRcdD8gbmV3IENvbXBvdW5kUGF0aChwYXJhbSlcblx0XHRcdFx0OiBuZXcgUGF0aChwYXJhbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdGlzUmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgaXNSYWRpYWwpO1xuXHRcdH1cblx0XHR2YXIgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0O1xuXHRcdGlmIChpc1JhZGlhbCkge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5Jyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicpO1xuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIGlzUm9vdCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoY2hpbGQsIGlzUm9vdCwgb3B0aW9ucyk7XG5cdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnOiBpbXBvcnRHcm91cCxcblx0XHRzdmc6IGltcG9ydEdyb3VwLFxuXHRcdGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcblx0XHRwb2x5Z29uOiBpbXBvcnRQb2x5LFxuXHRcdHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuXHRcdHBhdGg6IGltcG9ydFBhdGgsXG5cdFx0bGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXHRcdHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG5cdFx0XHRyYXN0ZXIuYXR0YWNoKCdsb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0Jyk7XG5cdFx0XHRcdHRoaXMuc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneCcsICd5JykuYWRkKHNpemUuZGl2aWRlKDIpKSk7XG5cdFx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByYXN0ZXI7XG5cdFx0fSxcblxuXHRcdHN5bWJvbDogZnVuY3Rpb24obm9kZSwgdHlwZSwgaXNSb290LCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN5bWJvbChpbXBvcnRHcm91cChub2RlLCB0eXBlLCBpc1Jvb3QsIG9wdGlvbnMpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZGVmczogaW1wb3J0R3JvdXAsXG5cblx0XHR1c2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG5cdFx0XHRcdHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpO1xuXHRcdFx0cmV0dXJuIGRlZmluaXRpb25cblx0XHRcdFx0XHQ/IGRlZmluaXRpb24gaW5zdGFuY2VvZiBTeW1ib2xcblx0XHRcdFx0XHRcdD8gZGVmaW5pdGlvbi5wbGFjZShwb2ludClcblx0XHRcdFx0XHRcdDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludClcblx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdGNpcmNsZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InKSk7XG5cdFx0fSxcblxuXHRcdGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG5cdFx0XHRcdGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwb2ludCA9IGdldFBvaW50KG5vZGUsICd4JywgJ3knKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpLFxuXHRcdFx0XHRyYWRpdXMgPSBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpO1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShwb2ludCwgc2l6ZSksIHJhZGl1cyk7XG5cdFx0fSxcblxuXHRcdGxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgUGF0aC5MaW5lKGdldFBvaW50KG5vZGUsICd4MScsICd5MScpLFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4MicsICd5MicpKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHRleHQgPSBuZXcgUG9pbnRUZXh0KGdldFBvaW50KG5vZGUsICd4JywgJ3knKVxuXHRcdFx0XHRcdC5hZGQoZ2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcblx0XHRcdHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUpIHtcblx0XHR2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG5cdFx0XHRpZiAoIXRyYW5zZm9ybSlcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoJygnKSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRzWzBdLFxuXHRcdFx0XHR2ID0gcGFydHNbMV0uc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuXHRcdFx0XHR2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblx0XHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0bWF0cml4LmNvbmNhdGVuYXRlKFxuXHRcdFx0XHRcdFx0bmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0bWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdLCB2WzJdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0bWF0cml4LnNjYWxlKHYpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NrZXdYJzpcblx0XHRcdFx0bWF0cml4LnNrZXcodlswXSwgMCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1knOlxuXHRcdFx0XHRtYXRyaXguc2tldygwLCB2WzBdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcblx0XHR2YXIgY29sb3IgPSBpdGVtW25hbWUgPT09ICdmaWxsLW9wYWNpdHknID8gJ2dldEZpbGxDb2xvcidcblx0XHRcdFx0OiAnZ2V0U3Ryb2tlQ29sb3InXSgpO1xuXHRcdGlmIChjb2xvcilcblx0XHRcdGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gQmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHR0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXHRcdFx0aWYgKGVudHJ5LnR5cGUgPT09ICdjb2xvcicgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXHRcdFx0XHRpZiAoY29sb3IpXG5cdFx0XHRcdFx0Y29sb3IudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdGl0ZW0uZ2V0UG9zaXRpb24odHJ1ZSkubmVnYXRlKCkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LCB7XG5cdFx0aWQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRkZWZpbml0aW9uc1t2YWx1ZV0gPSBpdGVtO1xuXHRcdFx0aWYgKGl0ZW0uc2V0TmFtZSlcblx0XHRcdFx0aXRlbS5zZXROYW1lKHZhbHVlKTtcblx0XHR9LFxuXG5cdFx0J2NsaXAtcGF0aCc6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgY2xpcCA9IGdldERlZmluaXRpb24odmFsdWUpO1xuXHRcdFx0aWYgKGNsaXApIHtcblx0XHRcdFx0Y2xpcCA9IGNsaXAuY2xvbmUoKTtcblx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkge1xuXHRcdFx0XHRcdGl0ZW0uaW5zZXJ0Q2hpbGQoMCwgY2xpcCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBHcm91cChjbGlwLCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRncmFkaWVudFRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cdFx0dHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblxuXHRcdCdmaWxsLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cdFx0J3N0cm9rZS1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXG5cdFx0dmlzaWJpbGl0eTogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGl0ZW0uc2V0VmlzaWJsZSh2YWx1ZSA9PT0gJ3Zpc2libGUnKTtcblx0XHR9LFxuXG5cdFx0J3N0b3AtY29sb3InOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uc2V0Q29sb3IpXG5cdFx0XHRcdGl0ZW0uc2V0Q29sb3IodmFsdWUpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1vcGFjaXR5JzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLl9jb2xvcilcblx0XHRcdFx0aXRlbS5fY29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHRvZmZzZXQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgcGVyY2VudGFnZSA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcblx0XHRcdGl0ZW0uc2V0UmFtcFBvaW50KHBlcmNlbnRhZ2Vcblx0XHRcdFx0XHQ/IHBlcmNlbnRhZ2VbMV0gLyAxMDBcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0dmlld0JveDogZnVuY3Rpb24oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykge1xuXHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgJ2FycmF5JykpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JywgdHJ1ZSk7XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IHNpemUgPyByZWN0LmdldFNpemUoKS5kaXZpZGUoc2l6ZSkgOiAxLFxuXHRcdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpKS5zY2FsZShzY2FsZSk7XG5cdFx0XHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeC5pbnZlcnRlZCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuXHRcdFx0XHRpZiAoc2l6ZSlcblx0XHRcdFx0XHRyZWN0LnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdHZhciBjbGlwID0gZ2V0QXR0cmlidXRlKG5vZGUsICdvdmVyZmxvdycsIHN0eWxlcykgIT0gJ3Zpc2libGUnLFxuXHRcdFx0XHRcdGdyb3VwID0gaXRlbS5fZGVmaW5pdGlvbjtcblx0XHRcdFx0aWYgKGNsaXAgJiYgIXJlY3QuY29udGFpbnMoZ3JvdXAuZ2V0Qm91bmRzKCkpKSB7XG5cdFx0XHRcdFx0Y2xpcCA9IG5ldyBTaGFwZS5SZWN0YW5nbGUocmVjdCkudHJhbnNmb3JtKGdyb3VwLl9tYXRyaXgpO1xuXHRcdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdFx0Z3JvdXAuYWRkQ2hpbGQoY2xpcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpIHtcblx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuXHRcdGlmICghdmFsdWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IEJhc2UuY2FtZWxpemUobmFtZSk7XG5cdFx0XHR2YWx1ZSA9IG5vZGUuc3R5bGVbc3R5bGVdO1xuXHRcdFx0aWYgKCF2YWx1ZSAmJiBzdHlsZXMubm9kZVtzdHlsZV0gIT09IHN0eWxlcy5wYXJlbnRbc3R5bGVdKVxuXHRcdFx0XHR2YWx1ZSA9IHN0eWxlcy5ub2RlW3N0eWxlXTtcblx0XHR9XG5cdFx0cmV0dXJuICF2YWx1ZVxuXHRcdFx0XHQ/IHVuZGVmaW5lZFxuXHRcdFx0XHQ6IHZhbHVlID09PSAnbm9uZSdcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBzdHlsZXMgPSB7XG5cdFx0XHRub2RlOiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlKSB8fCB7fSxcblx0XHRcdHBhcmVudDogIWlzUm9vdCAmJiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlLnBhcmVudE5vZGUpIHx8IHt9XG5cdFx0fTtcblx0XHRCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0gPSBCYXNlLnBpY2soYXBwbHkoaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcyksIGl0ZW0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zID0ge307XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24odmFsdWUpIHtcblx0XHR2YXIgbWF0Y2ggPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXFwoKD86I3wpKFteKSddKykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggJiYgZGVmaW5pdGlvbnNbbWF0Y2hbMV1dO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgaXNSb290LCBvcHRpb25zKSB7XG5cdFx0aWYgKCFzb3VyY2UpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvcHRpb25zID0geyBvbkxvYWQ6IG9wdGlvbnMgfTtcblx0XHR9XG5cblx0XHR2YXIgbm9kZSA9IHNvdXJjZSxcblx0XHRcdHNjb3BlID0gcGFwZXI7XG5cblx0XHRmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayhzdmcpIHtcblx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHR2YXIgaXRlbSA9IGltcG9ydFNWRyhzdmcsIGlzUm9vdCwgb3B0aW9ucyksXG5cdFx0XHRcdG9uTG9hZCA9IG9wdGlvbnMub25Mb2FkLFxuXHRcdFx0XHR2aWV3ID0gc2NvcGUucHJvamVjdCAmJiBzY29wZS5nZXRWaWV3KCk7XG5cdFx0XHRpZiAob25Mb2FkKVxuXHRcdFx0XHRvbkxvYWQuY2FsbCh0aGlzLCBpdGVtKTtcblx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmICEvXi4qPC8udGVzdChzb3VyY2UpKSB7XG5cdFx0XHRcdG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdHNvdXJjZSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEh0dHAucmVxdWVzdCgnZ2V0Jywgc291cmNlLCBvbkxvYWRDYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcblx0XHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRvbkxvYWRDYWxsYmFjayhyZWFkZXIucmVzdWx0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNUZXh0KHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKVxuXHRcdFx0bm9kZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc291cmNlLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuXHRcdGlmICghbm9kZS5ub2RlTmFtZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgU1ZHIHNvdXJjZTogJyArIHNvdXJjZSk7XG5cdFx0dmFyIHR5cGUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRpbXBvcnRlciA9IGltcG9ydGVyc1t0eXBlXSxcblx0XHRcdGl0ZW0sXG5cdFx0XHRkYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpLFxuXHRcdFx0c2V0dGluZ3MgPSBzY29wZS5zZXR0aW5ncyxcblx0XHRcdHByZXZBcHBseU1hdHJpeCA9IHNldHRpbmdzLmFwcGx5TWF0cml4O1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gZmFsc2U7XG5cdFx0aXRlbSA9IGltcG9ydGVyICYmIGltcG9ydGVyKG5vZGUsIHR5cGUsIGlzUm9vdCwgb3B0aW9ucykgfHwgbnVsbDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IHByZXZBcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKCEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0aWYgKG9wdGlvbnMuZXhwYW5kU2hhcGVzICYmIGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSkge1xuXHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRpdGVtID0gaXRlbS50b1BhdGgoKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRhKVxuXHRcdFx0XHRpdGVtLl9kYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0XHR9XG5cdFx0aWYgKGlzUm9vdClcblx0XHRcdGRlZmluaXRpb25zID0ge307XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRJdGVtLmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hZGRDaGlsZChpbXBvcnRTVkcobm9kZSwgdHJ1ZSwgb3B0aW9ucykpO1xuXHRcdH1cblx0fSk7XG5cblx0UHJvamVjdC5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdFx0cmV0dXJuIGltcG9ydFNWRyhub2RlLCB0cnVlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxuQmFzZS5leHBvcnRzLlBhcGVyU2NyaXB0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgZXhwb3J0cywgZGVmaW5lLFxuXHRcdHNjb3BlID0gdGhpcztcbiFmdW5jdGlvbihlLHIpe3JldHVyblwib2JqZWN0XCI9PXR5cGVvZiBleHBvcnRzJiZcIm9iamVjdFwiPT10eXBlb2YgbW9kdWxlP3IoZXhwb3J0cyk6XCJmdW5jdGlvblwiPT10eXBlb2YgZGVmaW5lJiZkZWZpbmUuYW1kP2RlZmluZShbXCJleHBvcnRzXCJdLHIpOihyKGUuYWNvcm58fChlLmFjb3JuPXt9KSksdm9pZCAwKX0odGhpcyxmdW5jdGlvbihlKXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiByKGUpe2ZyPWV8fHt9O2Zvcih2YXIgciBpbiBocilPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZnIscil8fChmcltyXT1ocltyXSk7bXI9ZnIuc291cmNlRmlsZXx8bnVsbH1mdW5jdGlvbiB0KGUscil7dmFyIHQ9dnIocHIsZSk7cis9XCIgKFwiK3QubGluZStcIjpcIit0LmNvbHVtbitcIilcIjt2YXIgbj1uZXcgU3ludGF4RXJyb3Iocik7dGhyb3cgbi5wb3M9ZSxuLmxvYz10LG4ucmFpc2VkQXQ9YnIsbn1mdW5jdGlvbiBuKGUpe2Z1bmN0aW9uIHIoZSl7aWYoMT09ZS5sZW5ndGgpcmV0dXJuIHQrPVwicmV0dXJuIHN0ciA9PT0gXCIrSlNPTi5zdHJpbmdpZnkoZVswXSkrXCI7XCI7dCs9XCJzd2l0Y2goc3RyKXtcIjtmb3IodmFyIHI9MDtyPGUubGVuZ3RoOysrcil0Kz1cImNhc2UgXCIrSlNPTi5zdHJpbmdpZnkoZVtyXSkrXCI6XCI7dCs9XCJyZXR1cm4gdHJ1ZX1yZXR1cm4gZmFsc2U7XCJ9ZT1lLnNwbGl0KFwiIFwiKTt2YXIgdD1cIlwiLG49W107ZTpmb3IodmFyIGE9MDthPGUubGVuZ3RoOysrYSl7Zm9yKHZhciBvPTA7bzxuLmxlbmd0aDsrK28paWYobltvXVswXS5sZW5ndGg9PWVbYV0ubGVuZ3RoKXtuW29dLnB1c2goZVthXSk7Y29udGludWUgZX1uLnB1c2goW2VbYV1dKX1pZihuLmxlbmd0aD4zKXtuLnNvcnQoZnVuY3Rpb24oZSxyKXtyZXR1cm4gci5sZW5ndGgtZS5sZW5ndGh9KSx0Kz1cInN3aXRjaChzdHIubGVuZ3RoKXtcIjtmb3IodmFyIGE9MDthPG4ubGVuZ3RoOysrYSl7dmFyIGk9blthXTt0Kz1cImNhc2UgXCIraVswXS5sZW5ndGgrXCI6XCIscihpKX10Kz1cIn1cIn1lbHNlIHIoZSk7cmV0dXJuIG5ldyBGdW5jdGlvbihcInN0clwiLHQpfWZ1bmN0aW9uIGEoKXt0aGlzLmxpbmU9QXIsdGhpcy5jb2x1bW49YnItU3J9ZnVuY3Rpb24gbygpe0FyPTEsYnI9U3I9MCxFcj0hMCx1KCl9ZnVuY3Rpb24gaShlLHIpe2dyPWJyLGZyLmxvY2F0aW9ucyYmKGtyPW5ldyBhKSx3cj1lLHUoKSxDcj1yLEVyPWUuYmVmb3JlRXhwcn1mdW5jdGlvbiBzKCl7dmFyIGU9ZnIub25Db21tZW50JiZmci5sb2NhdGlvbnMmJm5ldyBhLHI9YnIsbj1wci5pbmRleE9mKFwiKi9cIixicis9Mik7aWYoLTE9PT1uJiZ0KGJyLTIsXCJVbnRlcm1pbmF0ZWQgY29tbWVudFwiKSxicj1uKzIsZnIubG9jYXRpb25zKXtLdC5sYXN0SW5kZXg9cjtmb3IodmFyIG87KG89S3QuZXhlYyhwcikpJiZvLmluZGV4PGJyOykrK0FyLFNyPW8uaW5kZXgrb1swXS5sZW5ndGh9ZnIub25Db21tZW50JiZmci5vbkNvbW1lbnQoITAscHIuc2xpY2UocisyLG4pLHIsYnIsZSxmci5sb2NhdGlvbnMmJm5ldyBhKX1mdW5jdGlvbiBjKCl7Zm9yKHZhciBlPWJyLHI9ZnIub25Db21tZW50JiZmci5sb2NhdGlvbnMmJm5ldyBhLHQ9cHIuY2hhckNvZGVBdChicis9Mik7ZHI+YnImJjEwIT09dCYmMTMhPT10JiY4MjMyIT09dCYmODMyOSE9PXQ7KSsrYnIsdD1wci5jaGFyQ29kZUF0KGJyKTtmci5vbkNvbW1lbnQmJmZyLm9uQ29tbWVudCghMSxwci5zbGljZShlKzIsYnIpLGUsYnIscixmci5sb2NhdGlvbnMmJm5ldyBhKX1mdW5jdGlvbiB1KCl7Zm9yKDtkcj5icjspe3ZhciBlPXByLmNoYXJDb2RlQXQoYnIpO2lmKDMyPT09ZSkrK2JyO2Vsc2UgaWYoMTM9PT1lKXsrK2JyO3ZhciByPXByLmNoYXJDb2RlQXQoYnIpOzEwPT09ciYmKyticixmci5sb2NhdGlvbnMmJigrK0FyLFNyPWJyKX1lbHNlIGlmKDEwPT09ZSkrK2JyLCsrQXIsU3I9YnI7ZWxzZSBpZigxND5lJiZlPjgpKyticjtlbHNlIGlmKDQ3PT09ZSl7dmFyIHI9cHIuY2hhckNvZGVBdChicisxKTtpZig0Mj09PXIpcygpO2Vsc2V7aWYoNDchPT1yKWJyZWFrO2MoKX19ZWxzZSBpZigxNjA9PT1lKSsrYnI7ZWxzZXtpZighKGU+PTU3NjAmJkp0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSkpKWJyZWFrOysrYnJ9fX1mdW5jdGlvbiBsKCl7dmFyIGU9cHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gZT49NDgmJjU3Pj1lP0UoITApOigrK2JyLGkoeHQpKX1mdW5jdGlvbiBmKCl7dmFyIGU9cHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gRXI/KCsrYnIsaygpKTo2MT09PWU/eChFdCwyKTp4KHd0LDEpfWZ1bmN0aW9uIHAoKXt2YXIgZT1wci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiA2MT09PWU/eChFdCwyKTp4KEZ0LDEpfWZ1bmN0aW9uIGQoZSl7dmFyIHI9cHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gcj09PWU/eCgxMjQ9PT1lP0x0OlV0LDIpOjYxPT09cj94KEV0LDIpOngoMTI0PT09ZT9SdDpWdCwxKX1mdW5jdGlvbiBtKCl7dmFyIGU9cHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1lP3goRXQsMik6eChUdCwxKX1mdW5jdGlvbiBoKGUpe3ZhciByPXByLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIHI9PT1lP3goU3QsMik6NjE9PT1yP3goRXQsMik6eChBdCwxKX1mdW5jdGlvbiB2KGUpe3ZhciByPXByLmNoYXJDb2RlQXQoYnIrMSksdD0xO3JldHVybiByPT09ZT8odD02Mj09PWUmJjYyPT09cHIuY2hhckNvZGVBdChicisyKT8zOjIsNjE9PT1wci5jaGFyQ29kZUF0KGJyK3QpP3goRXQsdCsxKTp4KGp0LHQpKTooNjE9PT1yJiYodD02MT09PXByLmNoYXJDb2RlQXQoYnIrMik/MzoyKSx4KE90LHQpKX1mdW5jdGlvbiBiKGUpe3ZhciByPXByLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09cj94KHF0LDYxPT09cHIuY2hhckNvZGVBdChicisyKT8zOjIpOngoNjE9PT1lP0N0Okl0LDEpfWZ1bmN0aW9uIHkoZSl7c3dpdGNoKGUpe2Nhc2UgNDY6cmV0dXJuIGwoKTtjYXNlIDQwOnJldHVybisrYnIsaShodCk7Y2FzZSA0MTpyZXR1cm4rK2JyLGkodnQpO2Nhc2UgNTk6cmV0dXJuKyticixpKHl0KTtjYXNlIDQ0OnJldHVybisrYnIsaShidCk7Y2FzZSA5MTpyZXR1cm4rK2JyLGkoZnQpO2Nhc2UgOTM6cmV0dXJuKyticixpKHB0KTtjYXNlIDEyMzpyZXR1cm4rK2JyLGkoZHQpO2Nhc2UgMTI1OnJldHVybisrYnIsaShtdCk7Y2FzZSA1ODpyZXR1cm4rK2JyLGkoZ3QpO2Nhc2UgNjM6cmV0dXJuKyticixpKGt0KTtjYXNlIDQ4OnZhciByPXByLmNoYXJDb2RlQXQoYnIrMSk7aWYoMTIwPT09cnx8ODg9PT1yKXJldHVybiBDKCk7Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6cmV0dXJuIEUoITEpO2Nhc2UgMzQ6Y2FzZSAzOTpyZXR1cm4gQShlKTtjYXNlIDQ3OnJldHVybiBmKGUpO2Nhc2UgMzc6Y2FzZSA0MjpyZXR1cm4gcCgpO2Nhc2UgMTI0OmNhc2UgMzg6cmV0dXJuIGQoZSk7Y2FzZSA5NDpyZXR1cm4gbSgpO2Nhc2UgNDM6Y2FzZSA0NTpyZXR1cm4gaChlKTtjYXNlIDYwOmNhc2UgNjI6cmV0dXJuIHYoZSk7Y2FzZSA2MTpjYXNlIDMzOnJldHVybiBiKGUpO2Nhc2UgMTI2OnJldHVybiB4KEl0LDEpfXJldHVybiExfWZ1bmN0aW9uIGcoZSl7aWYoZT9icj15cisxOnlyPWJyLGZyLmxvY2F0aW9ucyYmKHhyPW5ldyBhKSxlKXJldHVybiBrKCk7aWYoYnI+PWRyKXJldHVybiBpKEJyKTt2YXIgcj1wci5jaGFyQ29kZUF0KGJyKTtpZihRdChyKXx8OTI9PT1yKXJldHVybiBMKCk7dmFyIG49eShyKTtpZihuPT09ITEpe3ZhciBvPVN0cmluZy5mcm9tQ2hhckNvZGUocik7aWYoXCJcXFxcXCI9PT1vfHwkdC50ZXN0KG8pKXJldHVybiBMKCk7dChicixcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIitvK1wiJ1wiKX1yZXR1cm4gbn1mdW5jdGlvbiB4KGUscil7dmFyIHQ9cHIuc2xpY2UoYnIsYnIrcik7YnIrPXIsaShlLHQpfWZ1bmN0aW9uIGsoKXtmb3IodmFyIGUscixuPVwiXCIsYT1icjs7KXticj49ZHImJnQoYSxcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7dmFyIG89cHIuY2hhckF0KGJyKTtpZihHdC50ZXN0KG8pJiZ0KGEsXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpLGUpZT0hMTtlbHNle2lmKFwiW1wiPT09bylyPSEwO2Vsc2UgaWYoXCJdXCI9PT1vJiZyKXI9ITE7ZWxzZSBpZihcIi9cIj09PW8mJiFyKWJyZWFrO2U9XCJcXFxcXCI9PT1vfSsrYnJ9dmFyIG49cHIuc2xpY2UoYSxicik7Kyticjt2YXIgcz1JKCk7cmV0dXJuIHMmJiEvXltnbXNpeV0qJC8udGVzdChzKSYmdChhLFwiSW52YWxpZCByZWdleHAgZmxhZ1wiKSxpKGpyLG5ldyBSZWdFeHAobixzKSl9ZnVuY3Rpb24gdyhlLHIpe2Zvcih2YXIgdD1icixuPTAsYT0wLG89bnVsbD09cj8xLzA6cjtvPmE7KythKXt2YXIgaSxzPXByLmNoYXJDb2RlQXQoYnIpO2lmKGk9cz49OTc/cy05NysxMDpzPj02NT9zLTY1KzEwOnM+PTQ4JiY1Nz49cz9zLTQ4OjEvMCxpPj1lKWJyZWFrOysrYnIsbj1uKmUraX1yZXR1cm4gYnI9PT10fHxudWxsIT1yJiZici10IT09cj9udWxsOm59ZnVuY3Rpb24gQygpe2JyKz0yO3ZhciBlPXcoMTYpO3JldHVybiBudWxsPT1lJiZ0KHlyKzIsXCJFeHBlY3RlZCBoZXhhZGVjaW1hbCBudW1iZXJcIiksUXQocHIuY2hhckNvZGVBdChicikpJiZ0KGJyLFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIiksaShPcixlKX1mdW5jdGlvbiBFKGUpe3ZhciByPWJyLG49ITEsYT00OD09PXByLmNoYXJDb2RlQXQoYnIpO2V8fG51bGwhPT13KDEwKXx8dChyLFwiSW52YWxpZCBudW1iZXJcIiksNDY9PT1wci5jaGFyQ29kZUF0KGJyKSYmKCsrYnIsdygxMCksbj0hMCk7dmFyIG89cHIuY2hhckNvZGVBdChicik7KDY5PT09b3x8MTAxPT09bykmJihvPXByLmNoYXJDb2RlQXQoKyticiksKDQzPT09b3x8NDU9PT1vKSYmKyticixudWxsPT09dygxMCkmJnQocixcIkludmFsaWQgbnVtYmVyXCIpLG49ITApLFF0KHByLmNoYXJDb2RlQXQoYnIpKSYmdChicixcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO3ZhciBzLGM9cHIuc2xpY2Uocixicik7cmV0dXJuIG4/cz1wYXJzZUZsb2F0KGMpOmEmJjEhPT1jLmxlbmd0aD8vWzg5XS8udGVzdChjKXx8VnI/dChyLFwiSW52YWxpZCBudW1iZXJcIik6cz1wYXJzZUludChjLDgpOnM9cGFyc2VJbnQoYywxMCksaShPcixzKX1mdW5jdGlvbiBBKGUpe2JyKys7Zm9yKHZhciByPVwiXCI7Oyl7YnI+PWRyJiZ0KHlyLFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTt2YXIgbj1wci5jaGFyQ29kZUF0KGJyKTtpZihuPT09ZSlyZXR1cm4rK2JyLGkoRnIscik7aWYoOTI9PT1uKXtuPXByLmNoYXJDb2RlQXQoKyticik7dmFyIGE9L15bMC03XSsvLmV4ZWMocHIuc2xpY2UoYnIsYnIrMykpO2ZvcihhJiYoYT1hWzBdKTthJiZwYXJzZUludChhLDgpPjI1NTspYT1hLnNsaWNlKDAsYS5sZW5ndGgtMSk7aWYoXCIwXCI9PT1hJiYoYT1udWxsKSwrK2JyLGEpVnImJnQoYnItMixcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIikscis9U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChhLDgpKSxicis9YS5sZW5ndGgtMTtlbHNlIHN3aXRjaChuKXtjYXNlIDExMDpyKz1cIlxcblwiO2JyZWFrO2Nhc2UgMTE0OnIrPVwiXFxyXCI7YnJlYWs7Y2FzZSAxMjA6cis9U3RyaW5nLmZyb21DaGFyQ29kZShTKDIpKTticmVhaztjYXNlIDExNzpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoNCkpO2JyZWFrO2Nhc2UgODU6cis9U3RyaW5nLmZyb21DaGFyQ29kZShTKDgpKTticmVhaztjYXNlIDExNjpyKz1cIlx0XCI7YnJlYWs7Y2FzZSA5ODpyKz1cIlxcYlwiO2JyZWFrO2Nhc2UgMTE4OnIrPVwiXHUwMDBiXCI7YnJlYWs7Y2FzZSAxMDI6cis9XCJcXGZcIjticmVhaztjYXNlIDQ4OnIrPVwiXFwwXCI7YnJlYWs7Y2FzZSAxMzoxMD09PXByLmNoYXJDb2RlQXQoYnIpJiYrK2JyO2Nhc2UgMTA6ZnIubG9jYXRpb25zJiYoU3I9YnIsKytBcik7YnJlYWs7ZGVmYXVsdDpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pfX1lbHNlKDEzPT09bnx8MTA9PT1ufHw4MjMyPT09bnx8ODMyOT09PW4pJiZ0KHlyLFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKSxyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pLCsrYnJ9fWZ1bmN0aW9uIFMoZSl7dmFyIHI9dygxNixlKTtyZXR1cm4gbnVsbD09PXImJnQoeXIsXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKSxyfWZ1bmN0aW9uIEkoKXtCdD0hMTtmb3IodmFyIGUscj0hMCxuPWJyOzspe3ZhciBhPXByLmNoYXJDb2RlQXQoYnIpO2lmKFl0KGEpKUJ0JiYoZSs9cHIuY2hhckF0KGJyKSksKyticjtlbHNle2lmKDkyIT09YSlicmVhaztCdHx8KGU9cHIuc2xpY2UobixicikpLEJ0PSEwLDExNyE9cHIuY2hhckNvZGVBdCgrK2JyKSYmdChicixcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIiksKyticjt2YXIgbz1TKDQpLGk9U3RyaW5nLmZyb21DaGFyQ29kZShvKTtpfHx0KGJyLTEsXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpLChyP1F0KG8pOll0KG8pKXx8dChici00LFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKSxlKz1pfXI9ITF9cmV0dXJuIEJ0P2U6cHIuc2xpY2Uobixicil9ZnVuY3Rpb24gTCgpe3ZhciBlPUkoKSxyPURyO3JldHVybiBCdHx8KFd0KGUpP3I9bHRbZV06KGZyLmZvcmJpZFJlc2VydmVkJiYoMz09PWZyLmVjbWFWZXJzaW9uP010Onp0KShlKXx8VnImJlh0KGUpKSYmdCh5cixcIlRoZSBrZXl3b3JkICdcIitlK1wiJyBpcyByZXNlcnZlZFwiKSksaShyLGUpfWZ1bmN0aW9uIFUoKXtJcj15cixMcj1ncixVcj1rcixnKCl9ZnVuY3Rpb24gUihlKXtmb3IoVnI9ZSxicj1McjtTcj5icjspU3I9cHIubGFzdEluZGV4T2YoXCJcXG5cIixTci0yKSsxLC0tQXI7dSgpLGcoKX1mdW5jdGlvbiBUKCl7dGhpcy50eXBlPW51bGwsdGhpcy5zdGFydD15cix0aGlzLmVuZD1udWxsfWZ1bmN0aW9uIFYoKXt0aGlzLnN0YXJ0PXhyLHRoaXMuZW5kPW51bGwsbnVsbCE9PW1yJiYodGhpcy5zb3VyY2U9bXIpfWZ1bmN0aW9uIHEoKXt2YXIgZT1uZXcgVDtyZXR1cm4gZnIubG9jYXRpb25zJiYoZS5sb2M9bmV3IFYpLGZyLnJhbmdlcyYmKGUucmFuZ2U9W3lyLDBdKSxlfWZ1bmN0aW9uIE8oZSl7dmFyIHI9bmV3IFQ7cmV0dXJuIHIuc3RhcnQ9ZS5zdGFydCxmci5sb2NhdGlvbnMmJihyLmxvYz1uZXcgVixyLmxvYy5zdGFydD1lLmxvYy5zdGFydCksZnIucmFuZ2VzJiYoci5yYW5nZT1bZS5yYW5nZVswXSwwXSkscn1mdW5jdGlvbiBqKGUscil7cmV0dXJuIGUudHlwZT1yLGUuZW5kPUxyLGZyLmxvY2F0aW9ucyYmKGUubG9jLmVuZD1VciksZnIucmFuZ2VzJiYoZS5yYW5nZVsxXT1MciksZX1mdW5jdGlvbiBGKGUpe3JldHVybiBmci5lY21hVmVyc2lvbj49NSYmXCJFeHByZXNzaW9uU3RhdGVtZW50XCI9PT1lLnR5cGUmJlwiTGl0ZXJhbFwiPT09ZS5leHByZXNzaW9uLnR5cGUmJlwidXNlIHN0cmljdFwiPT09ZS5leHByZXNzaW9uLnZhbHVlfWZ1bmN0aW9uIEQoZSl7cmV0dXJuIHdyPT09ZT8oVSgpLCEwKTp2b2lkIDB9ZnVuY3Rpb24gQigpe3JldHVybiFmci5zdHJpY3RTZW1pY29sb25zJiYod3I9PT1Ccnx8d3I9PT1tdHx8R3QudGVzdChwci5zbGljZShMcix5cikpKX1mdW5jdGlvbiBNKCl7RCh5dCl8fEIoKXx8WCgpfWZ1bmN0aW9uIHooZSl7d3I9PT1lP1UoKTpYKCl9ZnVuY3Rpb24gWCgpe3QoeXIsXCJVbmV4cGVjdGVkIHRva2VuXCIpfWZ1bmN0aW9uIE4oZSl7XCJJZGVudGlmaWVyXCIhPT1lLnR5cGUmJlwiTWVtYmVyRXhwcmVzc2lvblwiIT09ZS50eXBlJiZ0KGUuc3RhcnQsXCJBc3NpZ25pbmcgdG8gcnZhbHVlXCIpLFZyJiZcIklkZW50aWZpZXJcIj09PWUudHlwZSYmTnQoZS5uYW1lKSYmdChlLnN0YXJ0LFwiQXNzaWduaW5nIHRvIFwiK2UubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiKX1mdW5jdGlvbiBXKGUpe0lyPUxyPWJyLGZyLmxvY2F0aW9ucyYmKFVyPW5ldyBhKSxScj1Wcj1udWxsLFRyPVtdLGcoKTt2YXIgcj1lfHxxKCksdD0hMDtmb3IoZXx8KHIuYm9keT1bXSk7d3IhPT1Ccjspe3ZhciBuPUooKTtyLmJvZHkucHVzaChuKSx0JiZGKG4pJiZSKCEwKSx0PSExfXJldHVybiBqKHIsXCJQcm9ncmFtXCIpfWZ1bmN0aW9uIEooKXt3cj09PXd0JiZnKCEwKTt2YXIgZT13cixyPXEoKTtzd2l0Y2goZSl7Y2FzZSBNcjpjYXNlIE5yOlUoKTt2YXIgbj1lPT09TXI7RCh5dCl8fEIoKT9yLmxhYmVsPW51bGw6d3IhPT1Ecj9YKCk6KHIubGFiZWw9bHIoKSxNKCkpO2Zvcih2YXIgYT0wO2E8VHIubGVuZ3RoOysrYSl7dmFyIG89VHJbYV07aWYobnVsbD09ci5sYWJlbHx8by5uYW1lPT09ci5sYWJlbC5uYW1lKXtpZihudWxsIT1vLmtpbmQmJihufHxcImxvb3BcIj09PW8ua2luZCkpYnJlYWs7aWYoci5sYWJlbCYmbilicmVha319cmV0dXJuIGE9PT1Uci5sZW5ndGgmJnQoci5zdGFydCxcIlVuc3ludGFjdGljIFwiK2Uua2V5d29yZCksaihyLG4/XCJCcmVha1N0YXRlbWVudFwiOlwiQ29udGludWVTdGF0ZW1lbnRcIik7Y2FzZSBXcjpyZXR1cm4gVSgpLE0oKSxqKHIsXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtjYXNlIFByOnJldHVybiBVKCksVHIucHVzaChadCksci5ib2R5PUooKSxUci5wb3AoKSx6KHR0KSxyLnRlc3Q9UCgpLE0oKSxqKHIsXCJEb1doaWxlU3RhdGVtZW50XCIpO2Nhc2UgX3I6aWYoVSgpLFRyLnB1c2goWnQpLHooaHQpLHdyPT09eXQpcmV0dXJuICQocixudWxsKTtpZih3cj09PXJ0KXt2YXIgaT1xKCk7cmV0dXJuIFUoKSxHKGksITApLDE9PT1pLmRlY2xhcmF0aW9ucy5sZW5ndGgmJkQodXQpP18ocixpKTokKHIsaSl9dmFyIGk9SyghMSwhMCk7cmV0dXJuIEQodXQpPyhOKGkpLF8ocixpKSk6JChyLGkpO2Nhc2UgR3I6cmV0dXJuIFUoKSxjcihyLCEwKTtjYXNlIEtyOnJldHVybiBVKCksci50ZXN0PVAoKSxyLmNvbnNlcXVlbnQ9SigpLHIuYWx0ZXJuYXRlPUQoSHIpP0ooKTpudWxsLGoocixcIklmU3RhdGVtZW50XCIpO2Nhc2UgUXI6cmV0dXJuIFJyfHx0KHlyLFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKSxVKCksRCh5dCl8fEIoKT9yLmFyZ3VtZW50PW51bGw6KHIuYXJndW1lbnQ9SygpLE0oKSksaihyLFwiUmV0dXJuU3RhdGVtZW50XCIpO2Nhc2UgWXI6VSgpLHIuZGlzY3JpbWluYW50PVAoKSxyLmNhc2VzPVtdLHooZHQpLFRyLnB1c2goZW4pO2Zvcih2YXIgcyxjO3dyIT1tdDspaWYod3I9PT16cnx8d3I9PT1Kcil7dmFyIHU9d3I9PT16cjtzJiZqKHMsXCJTd2l0Y2hDYXNlXCIpLHIuY2FzZXMucHVzaChzPXEoKSkscy5jb25zZXF1ZW50PVtdLFUoKSx1P3MudGVzdD1LKCk6KGMmJnQoSXIsXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIiksYz0hMCxzLnRlc3Q9bnVsbCkseihndCl9ZWxzZSBzfHxYKCkscy5jb25zZXF1ZW50LnB1c2goSigpKTtyZXR1cm4gcyYmaihzLFwiU3dpdGNoQ2FzZVwiKSxVKCksVHIucG9wKCksaihyLFwiU3dpdGNoU3RhdGVtZW50XCIpO2Nhc2UgWnI6cmV0dXJuIFUoKSxHdC50ZXN0KHByLnNsaWNlKExyLHlyKSkmJnQoTHIsXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIiksci5hcmd1bWVudD1LKCksTSgpLGoocixcIlRocm93U3RhdGVtZW50XCIpO2Nhc2UgZXQ6aWYoVSgpLHIuYmxvY2s9SCgpLHIuaGFuZGxlcj1udWxsLHdyPT09WHIpe3ZhciBsPXEoKTtVKCkseihodCksbC5wYXJhbT1scigpLFZyJiZOdChsLnBhcmFtLm5hbWUpJiZ0KGwucGFyYW0uc3RhcnQsXCJCaW5kaW5nIFwiK2wucGFyYW0ubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiKSx6KHZ0KSxsLmd1YXJkPW51bGwsbC5ib2R5PUgoKSxyLmhhbmRsZXI9aihsLFwiQ2F0Y2hDbGF1c2VcIil9cmV0dXJuIHIuZ3VhcmRlZEhhbmRsZXJzPXFyLHIuZmluYWxpemVyPUQoJHIpP0goKTpudWxsLHIuaGFuZGxlcnx8ci5maW5hbGl6ZXJ8fHQoci5zdGFydCxcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIiksaihyLFwiVHJ5U3RhdGVtZW50XCIpO2Nhc2UgcnQ6cmV0dXJuIFUoKSxyPUcociksTSgpLHI7Y2FzZSB0dDpyZXR1cm4gVSgpLHIudGVzdD1QKCksVHIucHVzaChadCksci5ib2R5PUooKSxUci5wb3AoKSxqKHIsXCJXaGlsZVN0YXRlbWVudFwiKTtjYXNlIG50OnJldHVybiBWciYmdCh5cixcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKSxVKCksci5vYmplY3Q9UCgpLHIuYm9keT1KKCksaihyLFwiV2l0aFN0YXRlbWVudFwiKTtjYXNlIGR0OnJldHVybiBIKCk7Y2FzZSB5dDpyZXR1cm4gVSgpLGoocixcIkVtcHR5U3RhdGVtZW50XCIpO2RlZmF1bHQ6dmFyIGY9Q3IscD1LKCk7aWYoZT09PURyJiZcIklkZW50aWZpZXJcIj09PXAudHlwZSYmRChndCkpe2Zvcih2YXIgYT0wO2E8VHIubGVuZ3RoOysrYSlUclthXS5uYW1lPT09ZiYmdChwLnN0YXJ0LFwiTGFiZWwgJ1wiK2YrXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7dmFyIGQ9d3IuaXNMb29wP1wibG9vcFwiOndyPT09WXI/XCJzd2l0Y2hcIjpudWxsO3JldHVybiBUci5wdXNoKHtuYW1lOmYsa2luZDpkfSksci5ib2R5PUooKSxUci5wb3AoKSxyLmxhYmVsPXAsaihyLFwiTGFiZWxlZFN0YXRlbWVudFwiKX1yZXR1cm4gci5leHByZXNzaW9uPXAsTSgpLGoocixcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIil9fWZ1bmN0aW9uIFAoKXt6KGh0KTt2YXIgZT1LKCk7cmV0dXJuIHoodnQpLGV9ZnVuY3Rpb24gSChlKXt2YXIgcix0PXEoKSxuPSEwLGE9ITE7Zm9yKHQuYm9keT1bXSx6KGR0KTshRChtdCk7KXt2YXIgbz1KKCk7dC5ib2R5LnB1c2gobyksbiYmZSYmRihvKSYmKHI9YSxSKGE9ITApKSxuPSExfXJldHVybiBhJiYhciYmUighMSksaih0LFwiQmxvY2tTdGF0ZW1lbnRcIil9ZnVuY3Rpb24gJChlLHIpe3JldHVybiBlLmluaXQ9cix6KHl0KSxlLnRlc3Q9d3I9PT15dD9udWxsOksoKSx6KHl0KSxlLnVwZGF0ZT13cj09PXZ0P251bGw6SygpLHoodnQpLGUuYm9keT1KKCksVHIucG9wKCksaihlLFwiRm9yU3RhdGVtZW50XCIpfWZ1bmN0aW9uIF8oZSxyKXtyZXR1cm4gZS5sZWZ0PXIsZS5yaWdodD1LKCkseih2dCksZS5ib2R5PUooKSxUci5wb3AoKSxqKGUsXCJGb3JJblN0YXRlbWVudFwiKX1mdW5jdGlvbiBHKGUscil7Zm9yKGUuZGVjbGFyYXRpb25zPVtdLGUua2luZD1cInZhclwiOzspe3ZhciBuPXEoKTtpZihuLmlkPWxyKCksVnImJk50KG4uaWQubmFtZSkmJnQobi5pZC5zdGFydCxcIkJpbmRpbmcgXCIrbi5pZC5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLG4uaW5pdD1EKEN0KT9LKCEwLHIpOm51bGwsZS5kZWNsYXJhdGlvbnMucHVzaChqKG4sXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpLCFEKGJ0KSlicmVha31yZXR1cm4gaihlLFwiVmFyaWFibGVEZWNsYXJhdGlvblwiKX1mdW5jdGlvbiBLKGUscil7dmFyIHQ9UShyKTtpZighZSYmd3I9PT1idCl7dmFyIG49Tyh0KTtmb3Iobi5leHByZXNzaW9ucz1bdF07RChidCk7KW4uZXhwcmVzc2lvbnMucHVzaChRKHIpKTtyZXR1cm4gaihuLFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpfXJldHVybiB0fWZ1bmN0aW9uIFEoZSl7dmFyIHI9WShlKTtpZih3ci5pc0Fzc2lnbil7dmFyIHQ9TyhyKTtyZXR1cm4gdC5vcGVyYXRvcj1Dcix0LmxlZnQ9cixVKCksdC5yaWdodD1RKGUpLE4ociksaih0LFwiQXNzaWdubWVudEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWShlKXt2YXIgcj1aKGUpO2lmKEQoa3QpKXt2YXIgdD1PKHIpO3JldHVybiB0LnRlc3Q9cix0LmNvbnNlcXVlbnQ9SyghMCkseihndCksdC5hbHRlcm5hdGU9SyghMCxlKSxqKHQsXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWihlKXtyZXR1cm4gZXIocnIoKSwtMSxlKX1mdW5jdGlvbiBlcihlLHIsdCl7dmFyIG49d3IuYmlub3A7aWYobnVsbCE9biYmKCF0fHx3ciE9PXV0KSYmbj5yKXt2YXIgYT1PKGUpO2EubGVmdD1lLGEub3BlcmF0b3I9Q3IsVSgpLGEucmlnaHQ9ZXIocnIoKSxuLHQpO3ZhciBhPWooYSwvJiZ8XFx8XFx8Ly50ZXN0KGEub3BlcmF0b3IpP1wiTG9naWNhbEV4cHJlc3Npb25cIjpcIkJpbmFyeUV4cHJlc3Npb25cIik7cmV0dXJuIGVyKGEscix0KX1yZXR1cm4gZX1mdW5jdGlvbiBycigpe2lmKHdyLnByZWZpeCl7dmFyIGU9cSgpLHI9d3IuaXNVcGRhdGU7cmV0dXJuIGUub3BlcmF0b3I9Q3IsZS5wcmVmaXg9ITAsVSgpLGUuYXJndW1lbnQ9cnIoKSxyP04oZS5hcmd1bWVudCk6VnImJlwiZGVsZXRlXCI9PT1lLm9wZXJhdG9yJiZcIklkZW50aWZpZXJcIj09PWUuYXJndW1lbnQudHlwZSYmdChlLnN0YXJ0LFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIiksaihlLHI/XCJVcGRhdGVFeHByZXNzaW9uXCI6XCJVbmFyeUV4cHJlc3Npb25cIil9Zm9yKHZhciBuPXRyKCk7d3IucG9zdGZpeCYmIUIoKTspe3ZhciBlPU8obik7ZS5vcGVyYXRvcj1DcixlLnByZWZpeD0hMSxlLmFyZ3VtZW50PW4sTihuKSxVKCksbj1qKGUsXCJVcGRhdGVFeHByZXNzaW9uXCIpfXJldHVybiBufWZ1bmN0aW9uIHRyKCl7cmV0dXJuIG5yKGFyKCkpfWZ1bmN0aW9uIG5yKGUscil7aWYoRCh4dCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQub2JqZWN0PWUsdC5wcm9wZXJ0eT1scighMCksdC5jb21wdXRlZD0hMSxucihqKHQsXCJNZW1iZXJFeHByZXNzaW9uXCIpLHIpfWlmKEQoZnQpKXt2YXIgdD1PKGUpO3JldHVybiB0Lm9iamVjdD1lLHQucHJvcGVydHk9SygpLHQuY29tcHV0ZWQ9ITAseihwdCksbnIoaih0LFwiTWVtYmVyRXhwcmVzc2lvblwiKSxyKX1pZighciYmRChodCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQuY2FsbGVlPWUsdC5hcmd1bWVudHM9dXIodnQsITEpLG5yKGoodCxcIkNhbGxFeHByZXNzaW9uXCIpLHIpfXJldHVybiBlfWZ1bmN0aW9uIGFyKCl7c3dpdGNoKHdyKXtjYXNlIG90OnZhciBlPXEoKTtyZXR1cm4gVSgpLGooZSxcIlRoaXNFeHByZXNzaW9uXCIpO2Nhc2UgRHI6cmV0dXJuIGxyKCk7Y2FzZSBPcjpjYXNlIEZyOmNhc2UganI6dmFyIGU9cSgpO3JldHVybiBlLnZhbHVlPUNyLGUucmF3PXByLnNsaWNlKHlyLGdyKSxVKCksaihlLFwiTGl0ZXJhbFwiKTtjYXNlIGl0OmNhc2Ugc3Q6Y2FzZSBjdDp2YXIgZT1xKCk7cmV0dXJuIGUudmFsdWU9d3IuYXRvbVZhbHVlLGUucmF3PXdyLmtleXdvcmQsVSgpLGooZSxcIkxpdGVyYWxcIik7Y2FzZSBodDp2YXIgcj14cix0PXlyO1UoKTt2YXIgbj1LKCk7cmV0dXJuIG4uc3RhcnQ9dCxuLmVuZD1ncixmci5sb2NhdGlvbnMmJihuLmxvYy5zdGFydD1yLG4ubG9jLmVuZD1rciksZnIucmFuZ2VzJiYobi5yYW5nZT1bdCxncl0pLHoodnQpLG47Y2FzZSBmdDp2YXIgZT1xKCk7cmV0dXJuIFUoKSxlLmVsZW1lbnRzPXVyKHB0LCEwLCEwKSxqKGUsXCJBcnJheUV4cHJlc3Npb25cIik7Y2FzZSBkdDpyZXR1cm4gaXIoKTtjYXNlIEdyOnZhciBlPXEoKTtyZXR1cm4gVSgpLGNyKGUsITEpO2Nhc2UgYXQ6cmV0dXJuIG9yKCk7ZGVmYXVsdDpYKCl9fWZ1bmN0aW9uIG9yKCl7dmFyIGU9cSgpO3JldHVybiBVKCksZS5jYWxsZWU9bnIoYXIoKSwhMCksZS5hcmd1bWVudHM9RChodCk/dXIodnQsITEpOnFyLGooZSxcIk5ld0V4cHJlc3Npb25cIil9ZnVuY3Rpb24gaXIoKXt2YXIgZT1xKCkscj0hMCxuPSExO2ZvcihlLnByb3BlcnRpZXM9W10sVSgpOyFEKG10KTspe2lmKHIpcj0hMTtlbHNlIGlmKHooYnQpLGZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkQobXQpKWJyZWFrO3ZhciBhLG89e2tleTpzcigpfSxpPSExO2lmKEQoZ3QpPyhvLnZhbHVlPUsoITApLGE9by5raW5kPVwiaW5pdFwiKTpmci5lY21hVmVyc2lvbj49NSYmXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoXCJnZXRcIj09PW8ua2V5Lm5hbWV8fFwic2V0XCI9PT1vLmtleS5uYW1lKT8oaT1uPSEwLGE9by5raW5kPW8ua2V5Lm5hbWUsby5rZXk9c3IoKSx3ciE9PWh0JiZYKCksby52YWx1ZT1jcihxKCksITEpKTpYKCksXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoVnJ8fG4pKWZvcih2YXIgcz0wO3M8ZS5wcm9wZXJ0aWVzLmxlbmd0aDsrK3Mpe3ZhciBjPWUucHJvcGVydGllc1tzXTtpZihjLmtleS5uYW1lPT09by5rZXkubmFtZSl7dmFyIHU9YT09Yy5raW5kfHxpJiZcImluaXRcIj09PWMua2luZHx8XCJpbml0XCI9PT1hJiYoXCJnZXRcIj09PWMua2luZHx8XCJzZXRcIj09PWMua2luZCk7dSYmIVZyJiZcImluaXRcIj09PWEmJlwiaW5pdFwiPT09Yy5raW5kJiYodT0hMSksdSYmdChvLmtleS5zdGFydCxcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKX19ZS5wcm9wZXJ0aWVzLnB1c2gobyl9cmV0dXJuIGooZSxcIk9iamVjdEV4cHJlc3Npb25cIil9ZnVuY3Rpb24gc3IoKXtyZXR1cm4gd3I9PT1Pcnx8d3I9PT1Gcj9hcigpOmxyKCEwKX1mdW5jdGlvbiBjcihlLHIpe3dyPT09RHI/ZS5pZD1scigpOnI/WCgpOmUuaWQ9bnVsbCxlLnBhcmFtcz1bXTt2YXIgbj0hMDtmb3IoeihodCk7IUQodnQpOyluP249ITE6eihidCksZS5wYXJhbXMucHVzaChscigpKTt2YXIgYT1ScixvPVRyO2lmKFJyPSEwLFRyPVtdLGUuYm9keT1IKCEwKSxScj1hLFRyPW8sVnJ8fGUuYm9keS5ib2R5Lmxlbmd0aCYmRihlLmJvZHkuYm9keVswXSkpZm9yKHZhciBpPWUuaWQ/LTE6MDtpPGUucGFyYW1zLmxlbmd0aDsrK2kpe3ZhciBzPTA+aT9lLmlkOmUucGFyYW1zW2ldO2lmKChYdChzLm5hbWUpfHxOdChzLm5hbWUpKSYmdChzLnN0YXJ0LFwiRGVmaW5pbmcgJ1wiK3MubmFtZStcIicgaW4gc3RyaWN0IG1vZGVcIiksaT49MClmb3IodmFyIGM9MDtpPmM7KytjKXMubmFtZT09PWUucGFyYW1zW2NdLm5hbWUmJnQocy5zdGFydCxcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIil9cmV0dXJuIGooZSxyP1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHVyKGUscix0KXtmb3IodmFyIG49W10sYT0hMDshRChlKTspe2lmKGEpYT0hMTtlbHNlIGlmKHooYnQpLHImJmZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkQoZSkpYnJlYWs7dCYmd3I9PT1idD9uLnB1c2gobnVsbCk6bi5wdXNoKEsoITApKX1yZXR1cm4gbn1mdW5jdGlvbiBscihlKXt2YXIgcj1xKCk7cmV0dXJuIHIubmFtZT13cj09PURyP0NyOmUmJiFmci5mb3JiaWRSZXNlcnZlZCYmd3Iua2V5d29yZHx8WCgpLFUoKSxqKHIsXCJJZGVudGlmaWVyXCIpfWUudmVyc2lvbj1cIjAuMy4yXCI7dmFyIGZyLHByLGRyLG1yO2UucGFyc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gcHI9U3RyaW5nKGUpLGRyPXByLmxlbmd0aCxyKHQpLG8oKSxXKGZyLnByb2dyYW0pfTt2YXIgaHI9ZS5kZWZhdWx0T3B0aW9ucz17ZWNtYVZlcnNpb246NSxzdHJpY3RTZW1pY29sb25zOiExLGFsbG93VHJhaWxpbmdDb21tYXM6ITAsZm9yYmlkUmVzZXJ2ZWQ6ITEsbG9jYXRpb25zOiExLG9uQ29tbWVudDpudWxsLHJhbmdlczohMSxwcm9ncmFtOm51bGwsc291cmNlRmlsZTpudWxsfSx2cj1lLmdldExpbmVJbmZvPWZ1bmN0aW9uKGUscil7Zm9yKHZhciB0PTEsbj0wOzspe0t0Lmxhc3RJbmRleD1uO3ZhciBhPUt0LmV4ZWMoZSk7aWYoIShhJiZhLmluZGV4PHIpKWJyZWFrOysrdCxuPWEuaW5kZXgrYVswXS5sZW5ndGh9cmV0dXJue2xpbmU6dCxjb2x1bW46ci1ufX07ZS50b2tlbml6ZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGcoZSksYS5zdGFydD15cixhLmVuZD1ncixhLnN0YXJ0TG9jPXhyLGEuZW5kTG9jPWtyLGEudHlwZT13cixhLnZhbHVlPUNyLGF9cHI9U3RyaW5nKGUpLGRyPXByLmxlbmd0aCxyKHQpLG8oKTt2YXIgYT17fTtyZXR1cm4gbi5qdW1wVG89ZnVuY3Rpb24oZSxyKXtpZihicj1lLGZyLmxvY2F0aW9ucyl7QXI9MSxTcj1LdC5sYXN0SW5kZXg9MDtmb3IodmFyIHQ7KHQ9S3QuZXhlYyhwcikpJiZ0LmluZGV4PGU7KSsrQXIsU3I9dC5pbmRleCt0WzBdLmxlbmd0aH1Fcj1yLHUoKX0sbn07dmFyIGJyLHlyLGdyLHhyLGtyLHdyLENyLEVyLEFyLFNyLElyLExyLFVyLFJyLFRyLFZyLHFyPVtdLE9yPXt0eXBlOlwibnVtXCJ9LGpyPXt0eXBlOlwicmVnZXhwXCJ9LEZyPXt0eXBlOlwic3RyaW5nXCJ9LERyPXt0eXBlOlwibmFtZVwifSxCcj17dHlwZTpcImVvZlwifSxNcj17a2V5d29yZDpcImJyZWFrXCJ9LHpyPXtrZXl3b3JkOlwiY2FzZVwiLGJlZm9yZUV4cHI6ITB9LFhyPXtrZXl3b3JkOlwiY2F0Y2hcIn0sTnI9e2tleXdvcmQ6XCJjb250aW51ZVwifSxXcj17a2V5d29yZDpcImRlYnVnZ2VyXCJ9LEpyPXtrZXl3b3JkOlwiZGVmYXVsdFwifSxQcj17a2V5d29yZDpcImRvXCIsaXNMb29wOiEwfSxIcj17a2V5d29yZDpcImVsc2VcIixiZWZvcmVFeHByOiEwfSwkcj17a2V5d29yZDpcImZpbmFsbHlcIn0sX3I9e2tleXdvcmQ6XCJmb3JcIixpc0xvb3A6ITB9LEdyPXtrZXl3b3JkOlwiZnVuY3Rpb25cIn0sS3I9e2tleXdvcmQ6XCJpZlwifSxRcj17a2V5d29yZDpcInJldHVyblwiLGJlZm9yZUV4cHI6ITB9LFlyPXtrZXl3b3JkOlwic3dpdGNoXCJ9LFpyPXtrZXl3b3JkOlwidGhyb3dcIixiZWZvcmVFeHByOiEwfSxldD17a2V5d29yZDpcInRyeVwifSxydD17a2V5d29yZDpcInZhclwifSx0dD17a2V5d29yZDpcIndoaWxlXCIsaXNMb29wOiEwfSxudD17a2V5d29yZDpcIndpdGhcIn0sYXQ9e2tleXdvcmQ6XCJuZXdcIixiZWZvcmVFeHByOiEwfSxvdD17a2V5d29yZDpcInRoaXNcIn0saXQ9e2tleXdvcmQ6XCJudWxsXCIsYXRvbVZhbHVlOm51bGx9LHN0PXtrZXl3b3JkOlwidHJ1ZVwiLGF0b21WYWx1ZTohMH0sY3Q9e2tleXdvcmQ6XCJmYWxzZVwiLGF0b21WYWx1ZTohMX0sdXQ9e2tleXdvcmQ6XCJpblwiLGJpbm9wOjcsYmVmb3JlRXhwcjohMH0sbHQ9e1wiYnJlYWtcIjpNcixcImNhc2VcIjp6cixcImNhdGNoXCI6WHIsXCJjb250aW51ZVwiOk5yLFwiZGVidWdnZXJcIjpXcixcImRlZmF1bHRcIjpKcixcImRvXCI6UHIsXCJlbHNlXCI6SHIsXCJmaW5hbGx5XCI6JHIsXCJmb3JcIjpfcixcImZ1bmN0aW9uXCI6R3IsXCJpZlwiOktyLFwicmV0dXJuXCI6UXIsXCJzd2l0Y2hcIjpZcixcInRocm93XCI6WnIsXCJ0cnlcIjpldCxcInZhclwiOnJ0LFwid2hpbGVcIjp0dCxcIndpdGhcIjpudCxcIm51bGxcIjppdCxcInRydWVcIjpzdCxcImZhbHNlXCI6Y3QsXCJuZXdcIjphdCxcImluXCI6dXQsXCJpbnN0YW5jZW9mXCI6e2tleXdvcmQ6XCJpbnN0YW5jZW9mXCIsYmlub3A6NyxiZWZvcmVFeHByOiEwfSxcInRoaXNcIjpvdCxcInR5cGVvZlwiOntrZXl3b3JkOlwidHlwZW9mXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFwidm9pZFwiOntrZXl3b3JkOlwidm9pZFwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxcImRlbGV0ZVwiOntrZXl3b3JkOlwiZGVsZXRlXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9fSxmdD17dHlwZTpcIltcIixiZWZvcmVFeHByOiEwfSxwdD17dHlwZTpcIl1cIn0sZHQ9e3R5cGU6XCJ7XCIsYmVmb3JlRXhwcjohMH0sbXQ9e3R5cGU6XCJ9XCJ9LGh0PXt0eXBlOlwiKFwiLGJlZm9yZUV4cHI6ITB9LHZ0PXt0eXBlOlwiKVwifSxidD17dHlwZTpcIixcIixiZWZvcmVFeHByOiEwfSx5dD17dHlwZTpcIjtcIixiZWZvcmVFeHByOiEwfSxndD17dHlwZTpcIjpcIixiZWZvcmVFeHByOiEwfSx4dD17dHlwZTpcIi5cIn0sa3Q9e3R5cGU6XCI/XCIsYmVmb3JlRXhwcjohMH0sd3Q9e2Jpbm9wOjEwLGJlZm9yZUV4cHI6ITB9LEN0PXtpc0Fzc2lnbjohMCxiZWZvcmVFeHByOiEwfSxFdD17aXNBc3NpZ246ITAsYmVmb3JlRXhwcjohMH0sQXQ9e2Jpbm9wOjkscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFN0PXtwb3N0Zml4OiEwLHByZWZpeDohMCxpc1VwZGF0ZTohMH0sSXQ9e3ByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxMdD17Ymlub3A6MSxiZWZvcmVFeHByOiEwfSxVdD17Ymlub3A6MixiZWZvcmVFeHByOiEwfSxSdD17Ymlub3A6MyxiZWZvcmVFeHByOiEwfSxUdD17Ymlub3A6NCxiZWZvcmVFeHByOiEwfSxWdD17Ymlub3A6NSxiZWZvcmVFeHByOiEwfSxxdD17Ymlub3A6NixiZWZvcmVFeHByOiEwfSxPdD17Ymlub3A6NyxiZWZvcmVFeHByOiEwfSxqdD17Ymlub3A6OCxiZWZvcmVFeHByOiEwfSxGdD17Ymlub3A6MTAsYmVmb3JlRXhwcjohMH07ZS50b2tUeXBlcz17YnJhY2tldEw6ZnQsYnJhY2tldFI6cHQsYnJhY2VMOmR0LGJyYWNlUjptdCxwYXJlbkw6aHQscGFyZW5SOnZ0LGNvbW1hOmJ0LHNlbWk6eXQsY29sb246Z3QsZG90Onh0LHF1ZXN0aW9uOmt0LHNsYXNoOnd0LGVxOkN0LG5hbWU6RHIsZW9mOkJyLG51bTpPcixyZWdleHA6anIsc3RyaW5nOkZyfTtmb3IodmFyIER0IGluIGx0KWUudG9rVHlwZXNbXCJfXCIrRHRdPWx0W0R0XTt2YXIgQnQsTXQ9bihcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIiksenQ9bihcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIpLFh0PW4oXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIpLE50PW4oXCJldmFsIGFyZ3VtZW50c1wiKSxXdD1uKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCIpLEp0PS9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDI4XFx1MjAyOVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcdWZlZmZdLyxQdD1cIlxceGFhXFx4YjVcXHhiYVxceGMwLVxceGQ2XFx4ZDgtXFx4ZjZcXHhmOC1cXHUwMmMxXFx1MDJjNi1cXHUwMmQxXFx1MDJlMC1cXHUwMmU0XFx1MDJlY1xcdTAyZWVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN2EtXFx1MDM3ZFxcdTAzODZcXHUwMzg4LVxcdTAzOGFcXHUwMzhjXFx1MDM4ZS1cXHUwM2ExXFx1MDNhMy1cXHUwM2Y1XFx1MDNmNy1cXHUwNDgxXFx1MDQ4YS1cXHUwNTI3XFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1ZDAtXFx1MDVlYVxcdTA1ZjAtXFx1MDVmMlxcdTA2MjAtXFx1MDY0YVxcdTA2NmVcXHUwNjZmXFx1MDY3MS1cXHUwNmQzXFx1MDZkNVxcdTA2ZTVcXHUwNmU2XFx1MDZlZVxcdTA2ZWZcXHUwNmZhLVxcdTA2ZmNcXHUwNmZmXFx1MDcxMFxcdTA3MTItXFx1MDcyZlxcdTA3NGQtXFx1MDdhNVxcdTA3YjFcXHUwN2NhLVxcdTA3ZWFcXHUwN2Y0XFx1MDdmNVxcdTA3ZmFcXHUwODAwLVxcdTA4MTVcXHUwODFhXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOGEwXFx1MDhhMi1cXHUwOGFjXFx1MDkwNC1cXHUwOTM5XFx1MDkzZFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5NzdcXHUwOTc5LVxcdTA5N2ZcXHUwOTg1LVxcdTA5OGNcXHUwOThmXFx1MDk5MFxcdTA5OTMtXFx1MDlhOFxcdTA5YWEtXFx1MDliMFxcdTA5YjJcXHUwOWI2LVxcdTA5YjlcXHUwOWJkXFx1MDljZVxcdTA5ZGNcXHUwOWRkXFx1MDlkZi1cXHUwOWUxXFx1MDlmMFxcdTA5ZjFcXHUwYTA1LVxcdTBhMGFcXHUwYTBmXFx1MGExMFxcdTBhMTMtXFx1MGEyOFxcdTBhMmEtXFx1MGEzMFxcdTBhMzJcXHUwYTMzXFx1MGEzNVxcdTBhMzZcXHUwYTM4XFx1MGEzOVxcdTBhNTktXFx1MGE1Y1xcdTBhNWVcXHUwYTcyLVxcdTBhNzRcXHUwYTg1LVxcdTBhOGRcXHUwYThmLVxcdTBhOTFcXHUwYTkzLVxcdTBhYThcXHUwYWFhLVxcdTBhYjBcXHUwYWIyXFx1MGFiM1xcdTBhYjUtXFx1MGFiOVxcdTBhYmRcXHUwYWQwXFx1MGFlMFxcdTBhZTFcXHUwYjA1LVxcdTBiMGNcXHUwYjBmXFx1MGIxMFxcdTBiMTMtXFx1MGIyOFxcdTBiMmEtXFx1MGIzMFxcdTBiMzJcXHUwYjMzXFx1MGIzNS1cXHUwYjM5XFx1MGIzZFxcdTBiNWNcXHUwYjVkXFx1MGI1Zi1cXHUwYjYxXFx1MGI3MVxcdTBiODNcXHUwYjg1LVxcdTBiOGFcXHUwYjhlLVxcdTBiOTBcXHUwYjkyLVxcdTBiOTVcXHUwYjk5XFx1MGI5YVxcdTBiOWNcXHUwYjllXFx1MGI5ZlxcdTBiYTNcXHUwYmE0XFx1MGJhOC1cXHUwYmFhXFx1MGJhZS1cXHUwYmI5XFx1MGJkMFxcdTBjMDUtXFx1MGMwY1xcdTBjMGUtXFx1MGMxMFxcdTBjMTItXFx1MGMyOFxcdTBjMmEtXFx1MGMzM1xcdTBjMzUtXFx1MGMzOVxcdTBjM2RcXHUwYzU4XFx1MGM1OVxcdTBjNjBcXHUwYzYxXFx1MGM4NS1cXHUwYzhjXFx1MGM4ZS1cXHUwYzkwXFx1MGM5Mi1cXHUwY2E4XFx1MGNhYS1cXHUwY2IzXFx1MGNiNS1cXHUwY2I5XFx1MGNiZFxcdTBjZGVcXHUwY2UwXFx1MGNlMVxcdTBjZjFcXHUwY2YyXFx1MGQwNS1cXHUwZDBjXFx1MGQwZS1cXHUwZDEwXFx1MGQxMi1cXHUwZDNhXFx1MGQzZFxcdTBkNGVcXHUwZDYwXFx1MGQ2MVxcdTBkN2EtXFx1MGQ3ZlxcdTBkODUtXFx1MGQ5NlxcdTBkOWEtXFx1MGRiMVxcdTBkYjMtXFx1MGRiYlxcdTBkYmRcXHUwZGMwLVxcdTBkYzZcXHUwZTAxLVxcdTBlMzBcXHUwZTMyXFx1MGUzM1xcdTBlNDAtXFx1MGU0NlxcdTBlODFcXHUwZTgyXFx1MGU4NFxcdTBlODdcXHUwZTg4XFx1MGU4YVxcdTBlOGRcXHUwZTk0LVxcdTBlOTdcXHUwZTk5LVxcdTBlOWZcXHUwZWExLVxcdTBlYTNcXHUwZWE1XFx1MGVhN1xcdTBlYWFcXHUwZWFiXFx1MGVhZC1cXHUwZWIwXFx1MGViMlxcdTBlYjNcXHUwZWJkXFx1MGVjMC1cXHUwZWM0XFx1MGVjNlxcdTBlZGMtXFx1MGVkZlxcdTBmMDBcXHUwZjQwLVxcdTBmNDdcXHUwZjQ5LVxcdTBmNmNcXHUwZjg4LVxcdTBmOGNcXHUxMDAwLVxcdTEwMmFcXHUxMDNmXFx1MTA1MC1cXHUxMDU1XFx1MTA1YS1cXHUxMDVkXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2ZS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4ZVxcdTEwYTAtXFx1MTBjNVxcdTEwYzdcXHUxMGNkXFx1MTBkMC1cXHUxMGZhXFx1MTBmYy1cXHUxMjQ4XFx1MTI0YS1cXHUxMjRkXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNWEtXFx1MTI1ZFxcdTEyNjAtXFx1MTI4OFxcdTEyOGEtXFx1MTI4ZFxcdTEyOTAtXFx1MTJiMFxcdTEyYjItXFx1MTJiNVxcdTEyYjgtXFx1MTJiZVxcdTEyYzBcXHUxMmMyLVxcdTEyYzVcXHUxMmM4LVxcdTEyZDZcXHUxMmQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNWFcXHUxMzgwLVxcdTEzOGZcXHUxM2EwLVxcdTEzZjRcXHUxNDAxLVxcdTE2NmNcXHUxNjZmLVxcdTE2N2ZcXHUxNjgxLVxcdTE2OWFcXHUxNmEwLVxcdTE2ZWFcXHUxNmVlLVxcdTE2ZjBcXHUxNzAwLVxcdTE3MGNcXHUxNzBlLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NmNcXHUxNzZlLVxcdTE3NzBcXHUxNzgwLVxcdTE3YjNcXHUxN2Q3XFx1MTdkY1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThhOFxcdTE4YWFcXHUxOGIwLVxcdTE4ZjVcXHUxOTAwLVxcdTE5MWNcXHUxOTUwLVxcdTE5NmRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5YWJcXHUxOWMxLVxcdTE5YzdcXHUxYTAwLVxcdTFhMTZcXHUxYTIwLVxcdTFhNTRcXHUxYWE3XFx1MWIwNS1cXHUxYjMzXFx1MWI0NS1cXHUxYjRiXFx1MWI4My1cXHUxYmEwXFx1MWJhZVxcdTFiYWZcXHUxYmJhLVxcdTFiZTVcXHUxYzAwLVxcdTFjMjNcXHUxYzRkLVxcdTFjNGZcXHUxYzVhLVxcdTFjN2RcXHUxY2U5LVxcdTFjZWNcXHUxY2VlLVxcdTFjZjFcXHUxY2Y1XFx1MWNmNlxcdTFkMDAtXFx1MWRiZlxcdTFlMDAtXFx1MWYxNVxcdTFmMTgtXFx1MWYxZFxcdTFmMjAtXFx1MWY0NVxcdTFmNDgtXFx1MWY0ZFxcdTFmNTAtXFx1MWY1N1xcdTFmNTlcXHUxZjViXFx1MWY1ZFxcdTFmNWYtXFx1MWY3ZFxcdTFmODAtXFx1MWZiNFxcdTFmYjYtXFx1MWZiY1xcdTFmYmVcXHUxZmMyLVxcdTFmYzRcXHUxZmM2LVxcdTFmY2NcXHUxZmQwLVxcdTFmZDNcXHUxZmQ2LVxcdTFmZGJcXHUxZmUwLVxcdTFmZWNcXHUxZmYyLVxcdTFmZjRcXHUxZmY2LVxcdTFmZmNcXHUyMDcxXFx1MjA3ZlxcdTIwOTAtXFx1MjA5Y1xcdTIxMDJcXHUyMTA3XFx1MjEwYS1cXHUyMTEzXFx1MjExNVxcdTIxMTktXFx1MjExZFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMmEtXFx1MjEyZFxcdTIxMmYtXFx1MjEzOVxcdTIxM2MtXFx1MjEzZlxcdTIxNDUtXFx1MjE0OVxcdTIxNGVcXHUyMTYwLVxcdTIxODhcXHUyYzAwLVxcdTJjMmVcXHUyYzMwLVxcdTJjNWVcXHUyYzYwLVxcdTJjZTRcXHUyY2ViLVxcdTJjZWVcXHUyY2YyXFx1MmNmM1xcdTJkMDAtXFx1MmQyNVxcdTJkMjdcXHUyZDJkXFx1MmQzMC1cXHUyZDY3XFx1MmQ2ZlxcdTJkODAtXFx1MmQ5NlxcdTJkYTAtXFx1MmRhNlxcdTJkYTgtXFx1MmRhZVxcdTJkYjAtXFx1MmRiNlxcdTJkYjgtXFx1MmRiZVxcdTJkYzAtXFx1MmRjNlxcdTJkYzgtXFx1MmRjZVxcdTJkZDAtXFx1MmRkNlxcdTJkZDgtXFx1MmRkZVxcdTJlMmZcXHUzMDA1LVxcdTMwMDdcXHUzMDIxLVxcdTMwMjlcXHUzMDMxLVxcdTMwMzVcXHUzMDM4LVxcdTMwM2NcXHUzMDQxLVxcdTMwOTZcXHUzMDlkLVxcdTMwOWZcXHUzMGExLVxcdTMwZmFcXHUzMGZjLVxcdTMwZmZcXHUzMTA1LVxcdTMxMmRcXHUzMTMxLVxcdTMxOGVcXHUzMWEwLVxcdTMxYmFcXHUzMWYwLVxcdTMxZmZcXHUzNDAwLVxcdTRkYjVcXHU0ZTAwLVxcdTlmY2NcXHVhMDAwLVxcdWE0OGNcXHVhNGQwLVxcdWE0ZmRcXHVhNTAwLVxcdWE2MGNcXHVhNjEwLVxcdWE2MWZcXHVhNjJhXFx1YTYyYlxcdWE2NDAtXFx1YTY2ZVxcdWE2N2YtXFx1YTY5N1xcdWE2YTAtXFx1YTZlZlxcdWE3MTctXFx1YTcxZlxcdWE3MjItXFx1YTc4OFxcdWE3OGItXFx1YTc4ZVxcdWE3OTAtXFx1YTc5M1xcdWE3YTAtXFx1YTdhYVxcdWE3ZjgtXFx1YTgwMVxcdWE4MDMtXFx1YTgwNVxcdWE4MDctXFx1YTgwYVxcdWE4MGMtXFx1YTgyMlxcdWE4NDAtXFx1YTg3M1xcdWE4ODItXFx1YThiM1xcdWE4ZjItXFx1YThmN1xcdWE4ZmJcXHVhOTBhLVxcdWE5MjVcXHVhOTMwLVxcdWE5NDZcXHVhOTYwLVxcdWE5N2NcXHVhOTg0LVxcdWE5YjJcXHVhOWNmXFx1YWEwMC1cXHVhYTI4XFx1YWE0MC1cXHVhYTQyXFx1YWE0NC1cXHVhYTRiXFx1YWE2MC1cXHVhYTc2XFx1YWE3YVxcdWFhODAtXFx1YWFhZlxcdWFhYjFcXHVhYWI1XFx1YWFiNlxcdWFhYjktXFx1YWFiZFxcdWFhYzBcXHVhYWMyXFx1YWFkYi1cXHVhYWRkXFx1YWFlMC1cXHVhYWVhXFx1YWFmMi1cXHVhYWY0XFx1YWIwMS1cXHVhYjA2XFx1YWIwOS1cXHVhYjBlXFx1YWIxMS1cXHVhYjE2XFx1YWIyMC1cXHVhYjI2XFx1YWIyOC1cXHVhYjJlXFx1YWJjMC1cXHVhYmUyXFx1YWMwMC1cXHVkN2EzXFx1ZDdiMC1cXHVkN2M2XFx1ZDdjYi1cXHVkN2ZiXFx1ZjkwMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIwMC1cXHVmYjA2XFx1ZmIxMy1cXHVmYjE3XFx1ZmIxZFxcdWZiMWYtXFx1ZmIyOFxcdWZiMmEtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwXFx1ZmI0MVxcdWZiNDNcXHVmYjQ0XFx1ZmI0Ni1cXHVmYmIxXFx1ZmJkMy1cXHVmZDNkXFx1ZmQ1MC1cXHVmZDhmXFx1ZmQ5Mi1cXHVmZGM3XFx1ZmRmMC1cXHVmZGZiXFx1ZmU3MC1cXHVmZTc0XFx1ZmU3Ni1cXHVmZWZjXFx1ZmYyMS1cXHVmZjNhXFx1ZmY0MS1cXHVmZjVhXFx1ZmY2Ni1cXHVmZmJlXFx1ZmZjMi1cXHVmZmM3XFx1ZmZjYS1cXHVmZmNmXFx1ZmZkMi1cXHVmZmQ3XFx1ZmZkYS1cXHVmZmRjXCIsSHQ9XCJcXHUwMzAwLVxcdTAzNmZcXHUwNDgzLVxcdTA0ODdcXHUwNTkxLVxcdTA1YmRcXHUwNWJmXFx1MDVjMVxcdTA1YzJcXHUwNWM0XFx1MDVjNVxcdTA1YzdcXHUwNjEwLVxcdTA2MWFcXHUwNjIwLVxcdTA2NDlcXHUwNjcyLVxcdTA2ZDNcXHUwNmU3LVxcdTA2ZThcXHUwNmZiLVxcdTA2ZmNcXHUwNzMwLVxcdTA3NGFcXHUwODAwLVxcdTA4MTRcXHUwODFiLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MmRcXHUwODQwLVxcdTA4NTdcXHUwOGU0LVxcdTA4ZmVcXHUwOTAwLVxcdTA5MDNcXHUwOTNhLVxcdTA5M2NcXHUwOTNlLVxcdTA5NGZcXHUwOTUxLVxcdTA5NTdcXHUwOTYyLVxcdTA5NjNcXHUwOTY2LVxcdTA5NmZcXHUwOTgxLVxcdTA5ODNcXHUwOWJjXFx1MDliZS1cXHUwOWM0XFx1MDljN1xcdTA5YzhcXHUwOWQ3XFx1MDlkZi1cXHUwOWUwXFx1MGEwMS1cXHUwYTAzXFx1MGEzY1xcdTBhM2UtXFx1MGE0MlxcdTBhNDdcXHUwYTQ4XFx1MGE0Yi1cXHUwYTRkXFx1MGE1MVxcdTBhNjYtXFx1MGE3MVxcdTBhNzVcXHUwYTgxLVxcdTBhODNcXHUwYWJjXFx1MGFiZS1cXHUwYWM1XFx1MGFjNy1cXHUwYWM5XFx1MGFjYi1cXHUwYWNkXFx1MGFlMi1cXHUwYWUzXFx1MGFlNi1cXHUwYWVmXFx1MGIwMS1cXHUwYjAzXFx1MGIzY1xcdTBiM2UtXFx1MGI0NFxcdTBiNDdcXHUwYjQ4XFx1MGI0Yi1cXHUwYjRkXFx1MGI1NlxcdTBiNTdcXHUwYjVmLVxcdTBiNjBcXHUwYjY2LVxcdTBiNmZcXHUwYjgyXFx1MGJiZS1cXHUwYmMyXFx1MGJjNi1cXHUwYmM4XFx1MGJjYS1cXHUwYmNkXFx1MGJkN1xcdTBiZTYtXFx1MGJlZlxcdTBjMDEtXFx1MGMwM1xcdTBjNDYtXFx1MGM0OFxcdTBjNGEtXFx1MGM0ZFxcdTBjNTVcXHUwYzU2XFx1MGM2Mi1cXHUwYzYzXFx1MGM2Ni1cXHUwYzZmXFx1MGM4MlxcdTBjODNcXHUwY2JjXFx1MGNiZS1cXHUwY2M0XFx1MGNjNi1cXHUwY2M4XFx1MGNjYS1cXHUwY2NkXFx1MGNkNVxcdTBjZDZcXHUwY2UyLVxcdTBjZTNcXHUwY2U2LVxcdTBjZWZcXHUwZDAyXFx1MGQwM1xcdTBkNDYtXFx1MGQ0OFxcdTBkNTdcXHUwZDYyLVxcdTBkNjNcXHUwZDY2LVxcdTBkNmZcXHUwZDgyXFx1MGQ4M1xcdTBkY2FcXHUwZGNmLVxcdTBkZDRcXHUwZGQ2XFx1MGRkOC1cXHUwZGRmXFx1MGRmMlxcdTBkZjNcXHUwZTM0LVxcdTBlM2FcXHUwZTQwLVxcdTBlNDVcXHUwZTUwLVxcdTBlNTlcXHUwZWI0LVxcdTBlYjlcXHUwZWM4LVxcdTBlY2RcXHUwZWQwLVxcdTBlZDlcXHUwZjE4XFx1MGYxOVxcdTBmMjAtXFx1MGYyOVxcdTBmMzVcXHUwZjM3XFx1MGYzOVxcdTBmNDEtXFx1MGY0N1xcdTBmNzEtXFx1MGY4NFxcdTBmODYtXFx1MGY4N1xcdTBmOGQtXFx1MGY5N1xcdTBmOTktXFx1MGZiY1xcdTBmYzZcXHUxMDAwLVxcdTEwMjlcXHUxMDQwLVxcdTEwNDlcXHUxMDY3LVxcdTEwNmRcXHUxMDcxLVxcdTEwNzRcXHUxMDgyLVxcdTEwOGRcXHUxMDhmLVxcdTEwOWRcXHUxMzVkLVxcdTEzNWZcXHUxNzBlLVxcdTE3MTBcXHUxNzIwLVxcdTE3MzBcXHUxNzQwLVxcdTE3NTBcXHUxNzcyXFx1MTc3M1xcdTE3ODAtXFx1MTdiMlxcdTE3ZGRcXHUxN2UwLVxcdTE3ZTlcXHUxODBiLVxcdTE4MGRcXHUxODEwLVxcdTE4MTlcXHUxOTIwLVxcdTE5MmJcXHUxOTMwLVxcdTE5M2JcXHUxOTUxLVxcdTE5NmRcXHUxOWIwLVxcdTE5YzBcXHUxOWM4LVxcdTE5YzlcXHUxOWQwLVxcdTE5ZDlcXHUxYTAwLVxcdTFhMTVcXHUxYTIwLVxcdTFhNTNcXHUxYTYwLVxcdTFhN2NcXHUxYTdmLVxcdTFhODlcXHUxYTkwLVxcdTFhOTlcXHUxYjQ2LVxcdTFiNGJcXHUxYjUwLVxcdTFiNTlcXHUxYjZiLVxcdTFiNzNcXHUxYmIwLVxcdTFiYjlcXHUxYmU2LVxcdTFiZjNcXHUxYzAwLVxcdTFjMjJcXHUxYzQwLVxcdTFjNDlcXHUxYzViLVxcdTFjN2RcXHUxY2QwLVxcdTFjZDJcXHUxZDAwLVxcdTFkYmVcXHUxZTAxLVxcdTFmMTVcXHUyMDBjXFx1MjAwZFxcdTIwM2ZcXHUyMDQwXFx1MjA1NFxcdTIwZDAtXFx1MjBkY1xcdTIwZTFcXHUyMGU1LVxcdTIwZjBcXHUyZDgxLVxcdTJkOTZcXHUyZGUwLVxcdTJkZmZcXHUzMDIxLVxcdTMwMjhcXHUzMDk5XFx1MzA5YVxcdWE2NDAtXFx1YTY2ZFxcdWE2NzQtXFx1YTY3ZFxcdWE2OWZcXHVhNmYwLVxcdWE2ZjFcXHVhN2Y4LVxcdWE4MDBcXHVhODA2XFx1YTgwYlxcdWE4MjMtXFx1YTgyN1xcdWE4ODAtXFx1YTg4MVxcdWE4YjQtXFx1YThjNFxcdWE4ZDAtXFx1YThkOVxcdWE4ZjMtXFx1YThmN1xcdWE5MDAtXFx1YTkwOVxcdWE5MjYtXFx1YTkyZFxcdWE5MzAtXFx1YTk0NVxcdWE5ODAtXFx1YTk4M1xcdWE5YjMtXFx1YTljMFxcdWFhMDAtXFx1YWEyN1xcdWFhNDAtXFx1YWE0MVxcdWFhNGMtXFx1YWE0ZFxcdWFhNTAtXFx1YWE1OVxcdWFhN2JcXHVhYWUwLVxcdWFhZTlcXHVhYWYyLVxcdWFhZjNcXHVhYmMwLVxcdWFiZTFcXHVhYmVjXFx1YWJlZFxcdWFiZjAtXFx1YWJmOVxcdWZiMjAtXFx1ZmIyOFxcdWZlMDAtXFx1ZmUwZlxcdWZlMjAtXFx1ZmUyNlxcdWZlMzNcXHVmZTM0XFx1ZmU0ZC1cXHVmZTRmXFx1ZmYxMC1cXHVmZjE5XFx1ZmYzZlwiLCR0PW5ldyBSZWdFeHAoXCJbXCIrUHQrXCJdXCIpLF90PW5ldyBSZWdFeHAoXCJbXCIrUHQrSHQrXCJdXCIpLEd0PS9bXFxuXFxyXFx1MjAyOFxcdTIwMjldLyxLdD0vXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vZyxRdD1lLmlzSWRlbnRpZmllclN0YXJ0PWZ1bmN0aW9uKGUpe3JldHVybiA2NT5lPzM2PT09ZTo5MT5lPyEwOjk3PmU/OTU9PT1lOjEyMz5lPyEwOmU+PTE3MCYmJHQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX0sWXQ9ZS5pc0lkZW50aWZpZXJDaGFyPWZ1bmN0aW9uKGUpe3JldHVybiA0OD5lPzM2PT09ZTo1OD5lPyEwOjY1PmU/ITE6OTE+ZT8hMDo5Nz5lPzk1PT09ZToxMjM+ZT8hMDplPj0xNzAmJl90LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9LFp0PXtraW5kOlwibG9vcFwifSxlbj17a2luZDpcInN3aXRjaFwifX0pO1xuXG5cdHZhciBiaW5hcnlPcGVyYXRvcnMgPSB7XG5cdFx0JysnOiAnX19hZGQnLFxuXHRcdCctJzogJ19fc3VidHJhY3QnLFxuXHRcdCcqJzogJ19fbXVsdGlwbHknLFxuXHRcdCcvJzogJ19fZGl2aWRlJyxcblx0XHQnJSc6ICdfX21vZHVsbycsXG5cdFx0Jz09JzogJ2VxdWFscycsXG5cdFx0JyE9JzogJ2VxdWFscydcblx0fTtcblxuXHR2YXIgdW5hcnlPcGVyYXRvcnMgPSB7XG5cdFx0Jy0nOiAnX19uZWdhdGUnLFxuXHRcdCcrJzogbnVsbFxuXHR9O1xuXG5cdHZhciBmaWVsZHMgPSBCYXNlLmVhY2goXG5cdFx0WydhZGQnLCAnc3VidHJhY3QnLCAnbXVsdGlwbHknLCAnZGl2aWRlJywgJ21vZHVsbycsICduZWdhdGUnXSxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzWydfXycgKyBuYW1lXSA9ICcjJyArIG5hbWU7XG5cdFx0fSxcblx0XHR7fVxuXHQpO1xuXHRQb2ludC5pbmplY3QoZmllbGRzKTtcblx0U2l6ZS5pbmplY3QoZmllbGRzKTtcblx0Q29sb3IuaW5qZWN0KGZpZWxkcyk7XG5cblx0ZnVuY3Rpb24gXyRfKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHZhciBoYW5kbGVyID0gYmluYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAobGVmdCAmJiBsZWZ0W2hhbmRsZXJdKSB7XG5cdFx0XHR2YXIgcmVzID0gbGVmdFtoYW5kbGVyXShyaWdodCk7XG5cdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09ICchPScgPyAhcmVzIDogcmVzO1xuXHRcdH1cblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG5cdFx0Y2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cdFx0Y2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cdFx0Y2FzZSAnJSc6IHJldHVybiBsZWZ0ICUgcmlnaHQ7XG5cdFx0Y2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PSByaWdodDtcblx0XHRjYXNlICchPSc6IHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uICRfKG9wZXJhdG9yLCB2YWx1ZSkge1xuXHRcdHZhciBoYW5kbGVyID0gdW5hcnlPcGVyYXRvcnNbb3BlcmF0b3JdO1xuXHRcdGlmIChoYW5kbGVyICYmIHZhbHVlICYmIHZhbHVlW2hhbmRsZXJdKVxuXHRcdFx0cmV0dXJuIHZhbHVlW2hhbmRsZXJdKCk7XG5cdFx0c3dpdGNoIChvcGVyYXRvcikge1xuXHRcdGNhc2UgJysnOiByZXR1cm4gK3ZhbHVlO1xuXHRcdGNhc2UgJy0nOiByZXR1cm4gLXZhbHVlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBpbGUoY29kZSkge1xuXG5cdFx0dmFyIGluc2VydGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGdldE9mZnNldChvZmZzZXQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGluc2VydGlvbiA9IGluc2VydGlvbnNbaV07XG5cdFx0XHRcdGlmIChpbnNlcnRpb25bMF0gPj0gb2Zmc2V0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5zZXJ0aW9uWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb2RlKG5vZGUpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlQ29kZShub2RlLCBzdHIpIHtcblx0XHRcdHZhciBzdGFydCA9IGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcblx0XHRcdFx0ZW5kID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pLFxuXHRcdFx0XHRpbnNlcnQgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluc2VydGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHN0YXJ0ID4gaW5zZXJ0aW9uc1tpXVswXSkge1xuXHRcdFx0XHRcdGluc2VydCA9IGkgKyAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbnNlcnRpb25zLnNwbGljZShpbnNlcnQsIDAsIFtzdGFydCwgc3RyLmxlbmd0aCAtIGVuZCArIHN0YXJ0XSk7XG5cdFx0XHRjb2RlID0gY29kZS5zdWJzdHJpbmcoMCwgc3RhcnQpICsgc3RyICsgY29kZS5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3YWxrQVNUKG5vZGUsIHBhcmVudCkge1xuXHRcdFx0aWYgKCFub2RlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAncmFuZ2UnKVxuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBub2RlW2tleV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdFx0d2Fsa0FTVCh2YWx1ZVtpXSwgbm9kZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdHdhbGtBU1QodmFsdWUsIG5vZGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2ggKG5vZGUgJiYgbm9kZS50eXBlKSB7XG5cdFx0XHRjYXNlICdVbmFyeUV4cHJlc3Npb24nOiBcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gdW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUuYXJndW1lbnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGFyZyA9IGdldENvZGUobm9kZS5hcmd1bWVudCk7XG5cdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgJyRfKFwiJyArIG5vZGUub3BlcmF0b3IgKyAnXCIsICdcblx0XHRcdFx0XHRcdFx0KyBhcmcgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6IFxuXHRcdFx0XHRpZiAobm9kZS5vcGVyYXRvciBpbiBiaW5hcnlPcGVyYXRvcnNcblx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHR2YXIgbGVmdCA9IGdldENvZGUobm9kZS5sZWZ0KSxcblx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KTtcblx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCAnXyRfKCcgKyBsZWZ0ICsgJywgXCInICsgbm9kZS5vcGVyYXRvclxuXHRcdFx0XHRcdFx0XHQrICdcIiwgJyArIHJpZ2h0ICsgJyknKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ1VwZGF0ZUV4cHJlc3Npb24nOiBcblx0XHRcdGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzogXG5cdFx0XHRcdGlmICghKHBhcmVudCAmJiAoXG5cdFx0XHRcdFx0XHRwYXJlbnQudHlwZSA9PT0gJ0ZvclN0YXRlbWVudCdcblx0XHRcdFx0XHRcdHx8IHBhcmVudC50eXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdFx0JiYgL15bPSE8Pl0vLnRlc3QocGFyZW50Lm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0fHwgcGFyZW50LnR5cGUgPT09ICdNZW1iZXJFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0XHQmJiBwYXJlbnQuY29tcHV0ZWQpKSkge1xuXHRcdFx0XHRcdGlmIChub2RlLnR5cGUgPT09ICdVcGRhdGVFeHByZXNzaW9uJykge1xuXHRcdFx0XHRcdFx0aWYgKCFub2RlLnByZWZpeCkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KTtcblx0XHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgYXJnICsgJyA9IF8kXygnICsgYXJnICsgJywgXCInXG5cdFx0XHRcdFx0XHRcdFx0XHQrIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsIDEpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIHsgXG5cdFx0XHRcdFx0XHRpZiAoL14uPSQvLnRlc3Qobm9kZS5vcGVyYXRvcilcblx0XHRcdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuXHRcdFx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KTtcblx0XHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgbGVmdCArICcgPSBfJF8oJyArIGxlZnQgKyAnLCBcIidcblx0XHRcdFx0XHRcdFx0XHRcdCsgbm9kZS5vcGVyYXRvclswXSArICdcIiwgJyArIHJpZ2h0ICsgJyknKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdhbGtBU1Qoc2NvcGUuYWNvcm4ucGFyc2UoY29kZSwgeyByYW5nZXM6IHRydWUgfSkpO1xuXHRcdHJldHVybiBjb2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhlY3V0ZShjb2RlLCBzY29wZSkge1xuXHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0dmFyIHZpZXcgPSBzY29wZS5nZXRWaWV3KCksXG5cdFx0XHR0b29sID0gL1xccytvbig/OktleXxNb3VzZSkoPzpVcHxEb3dufE1vdmV8RHJhZylcXGIvLnRlc3QoY29kZSlcblx0XHRcdFx0XHQ/IG5ldyBUb29sKClcblx0XHRcdFx0XHQ6IG51bGwsXG5cdFx0XHR0b29sSGFuZGxlcnMgPSB0b29sID8gdG9vbC5fZXZlbnRzIDogW10sXG5cdFx0XHRoYW5kbGVycyA9IFsnb25GcmFtZScsICdvblJlc2l6ZSddLmNvbmNhdCh0b29sSGFuZGxlcnMpLFxuXHRcdFx0cGFyYW1zID0gW10sXG5cdFx0XHRhcmdzID0gW10sXG5cdFx0XHRmdW5jO1xuXHRcdGNvZGUgPSBjb21waWxlKGNvZGUpO1xuXHRcdGZ1bmN0aW9uIGV4cG9zZShzY29wZSwgaGlkZGVuKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NvcGUpIHtcblx0XHRcdFx0aWYgKChoaWRkZW4gfHwgIS9eXy8udGVzdChrZXkpKSAmJiBuZXcgUmVnRXhwKFxuXHRcdFx0XHRcdFx0J1xcXFxiJyArIGtleS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJykgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnB1c2goa2V5KTtcblx0XHRcdFx0XHRhcmdzLnB1c2goc2NvcGVba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXhwb3NlKHsgXyRfOiBfJF8sICRfOiAkXywgdmlldzogdmlldywgdG9vbDogdG9vbCB9LCB0cnVlKTtcblx0XHRleHBvc2Uoc2NvcGUpO1xuXHRcdGhhbmRsZXJzID0gQmFzZS5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdGlmIChuZXcgUmVnRXhwKCdcXFxccysnICsga2V5ICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRwYXJhbXMucHVzaChrZXkpO1xuXHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArIGtleSk7XG5cdFx0XHR9XG5cdFx0fSwgW10pLmpvaW4oJywgJyk7XG5cdFx0aWYgKGhhbmRsZXJzKVxuXHRcdFx0Y29kZSArPSAnXFxucmV0dXJuIHsgJyArIGhhbmRsZXJzICsgJyB9Oyc7XG5cdFx0dmFyIGZpcmVmb3ggPSB3aW5kb3cuSW5zdGFsbFRyaWdnZXI7XG5cdFx0aWYgKGZpcmVmb3ggfHwgd2luZG93LmNocm9tZSkge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuXHRcdFx0XHRoZWFkID0gZG9jdW1lbnQuaGVhZDtcblx0XHRcdGlmIChmaXJlZm94KVxuXHRcdFx0XHRjb2RlID0gJ1xcbicgKyBjb2RlO1xuXHRcdFx0c2NyaXB0LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFxuXHRcdFx0XHQncGFwZXIuX2V4ZWN1dGUgPSBmdW5jdGlvbignICsgcGFyYW1zICsgJykgeycgKyBjb2RlICsgJ1xcbn0nXG5cdFx0XHQpKTtcblx0XHRcdGhlYWQuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcblx0XHRcdGZ1bmMgPSBwYXBlci5fZXhlY3V0ZTtcblx0XHRcdGRlbGV0ZSBwYXBlci5fZXhlY3V0ZTtcblx0XHRcdGhlYWQucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZnVuYyA9IEZ1bmN0aW9uKHBhcmFtcywgY29kZSk7XG5cdFx0fVxuXHRcdHZhciByZXMgPSBmdW5jLmFwcGx5KHNjb3BlLCBhcmdzKSB8fCB7fTtcblx0XHRCYXNlLmVhY2godG9vbEhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHJlc1trZXldO1xuXHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHR0b29sW2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRpZiAodmlldykge1xuXHRcdFx0aWYgKHJlcy5vblJlc2l6ZSlcblx0XHRcdFx0dmlldy5zZXRPblJlc2l6ZShyZXMub25SZXNpemUpO1xuXHRcdFx0dmlldy5maXJlKCdyZXNpemUnLCB7XG5cdFx0XHRcdHNpemU6IHZpZXcuc2l6ZSxcblx0XHRcdFx0ZGVsdGE6IG5ldyBQb2ludCgpXG5cdFx0XHR9KTtcblx0XHRcdGlmIChyZXMub25GcmFtZSlcblx0XHRcdFx0dmlldy5zZXRPbkZyYW1lKHJlcy5vbkZyYW1lKTtcblx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZCgpIHtcblx0XHRCYXNlLmVhY2goZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLCBmdW5jdGlvbihzY3JpcHQpIHtcblx0XHRcdGlmICgvXnRleHRcXC8oPzp4LXwpcGFwZXJzY3JpcHQkLy50ZXN0KHNjcmlwdC50eXBlKVxuXHRcdFx0XHRcdCYmICFzY3JpcHQuZ2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWlnbm9yZScpKSB7XG5cdFx0XHRcdHZhciBjYW52YXMgPSBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShzY3JpcHQsICdjYW52YXMnKSxcblx0XHRcdFx0XHRzY29wZSA9IFBhcGVyU2NvcGUuZ2V0KGNhbnZhcylcblx0XHRcdFx0XHRcdFx0fHwgbmV3IFBhcGVyU2NvcGUoc2NyaXB0KS5zZXR1cChjYW52YXMpLFxuXHRcdFx0XHRcdHNyYyA9IHNjcmlwdC5zcmM7XG5cdFx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0XHRIdHRwLnJlcXVlc3QoJ2dldCcsIHNyYywgZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRcdFx0ZXhlY3V0ZShjb2RlLCBzY29wZSk7XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZXhlY3V0ZShzY3JpcHQuaW5uZXJIVE1MLCBzY29wZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0c2NyaXB0LnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1pZ25vcmUnLCB0cnVlKTtcblx0XHRcdH1cblx0XHR9LCB0aGlzKTtcblx0fVxuXG5cdGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG5cdFx0c2V0VGltZW91dChsb2FkKTtcblx0fSBlbHNlIHtcblx0XHREb21FdmVudC5hZGQod2luZG93LCB7IGxvYWQ6IGxvYWQgfSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNvbXBpbGU6IGNvbXBpbGUsXG5cdFx0ZXhlY3V0ZTogZXhlY3V0ZSxcblx0XHRsb2FkOiBsb2FkLFxuXHRcdGxpbmVOdW1iZXJCYXNlOiAwXG5cdH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbnBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0QmFzZTogQmFzZSxcblx0TnVtZXJpY2FsOiBOdW1lcmljYWwsXG5cdERvbUVsZW1lbnQ6IERvbUVsZW1lbnQsXG5cdERvbUV2ZW50OiBEb21FdmVudCxcblx0SHR0cDogSHR0cCxcblx0S2V5OiBLZXlcbn0pKSgpO1xuXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRkZWZpbmUoJ3BhcGVyJywgcGFwZXIpO1xuXG5yZXR1cm4gcGFwZXI7XG59O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAvKlxuICAgKiBDb21waWxlciBwYXNzZXMuXG4gICAqXG4gICAqIEVhY2ggcGFzcyBpcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcGFzc2VkIHRoZSBBU1QuIEl0IGNhbiBwZXJmb3JtIGNoZWNrcyBvbiBpdFxuICAgKiBvciBtb2RpZnkgaXQgYXMgbmVlZGVkLiBJZiB0aGUgcGFzcyBlbmNvdW50ZXJzIGEgc2VtYW50aWMgZXJyb3IsIGl0IHRocm93c1xuICAgKiB8UEVHLkdyYW1tYXJFcnJvcnwuXG4gICAqL1xuICBwYXNzZXM6IHtcbiAgICBjaGVjazoge1xuICAgICAgcmVwb3J0TWlzc2luZ1J1bGVzOiAgcmVxdWlyZShcIi4vY29tcGlsZXIvcGFzc2VzL3JlcG9ydC1taXNzaW5nLXJ1bGVzXCIpLFxuICAgICAgcmVwb3J0TGVmdFJlY3Vyc2lvbjogcmVxdWlyZShcIi4vY29tcGlsZXIvcGFzc2VzL3JlcG9ydC1sZWZ0LXJlY3Vyc2lvblwiKVxuICAgIH0sXG4gICAgdHJhbnNmb3JtOiB7XG4gICAgICByZW1vdmVQcm94eVJ1bGVzOiAgICByZXF1aXJlKFwiLi9jb21waWxlci9wYXNzZXMvcmVtb3ZlLXByb3h5LXJ1bGVzXCIpXG4gICAgfSxcbiAgICBnZW5lcmF0ZToge1xuICAgICAgZ2VuZXJhdGVCeXRlY29kZTogICAgcmVxdWlyZShcIi4vY29tcGlsZXIvcGFzc2VzL2dlbmVyYXRlLWJ5dGVjb2RlXCIpLFxuICAgICAgZ2VuZXJhdGVKYXZhc2NyaXB0OiAgcmVxdWlyZShcIi4vY29tcGlsZXIvcGFzc2VzL2dlbmVyYXRlLWphdmFzY3JpcHRcIilcbiAgICB9XG4gIH0sXG5cbiAgLypcbiAgICogR2VuZXJhdGVzIGEgcGFyc2VyIGZyb20gYSBzcGVjaWZpZWQgZ3JhbW1hciBBU1QuIFRocm93cyB8UEVHLkdyYW1tYXJFcnJvcnxcbiAgICogaWYgdGhlIEFTVCBjb250YWlucyBhIHNlbWFudGljIGVycm9yLiBOb3RlIHRoYXQgbm90IGFsbCBlcnJvcnMgYXJlIGRldGVjdGVkXG4gICAqIGR1cmluZyB0aGUgZ2VuZXJhdGlvbiBhbmQgc29tZSBtYXkgcHJvdHJ1ZGUgdG8gdGhlIGdlbmVyYXRlZCBwYXJzZXIgYW5kXG4gICAqIGNhdXNlIGl0cyBtYWxmdW5jdGlvbi5cbiAgICovXG4gIGNvbXBpbGU6IGZ1bmN0aW9uKGFzdCwgcGFzc2VzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IHV0aWxzLmNsb25lKGFyZ3VtZW50c1syXSkgOiB7fSxcbiAgICAgICAgc3RhZ2U7XG5cbiAgICAvKlxuICAgICAqIEV4dHJhY3RlZCBpbnRvIGEgZnVuY3Rpb24ganVzdCB0byBzaWxlbmNlIEpTSGludCBjb21wbGFpbmluZyBhYm91dFxuICAgICAqIGNyZWF0aW5nIGZ1bmN0aW9ucyBpbiBhIGxvb3AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcnVuUGFzcyhwYXNzKSB7XG4gICAgICBwYXNzKGFzdCwgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdXRpbHMuZGVmYXVsdHMob3B0aW9ucywge1xuICAgICAgYWxsb3dlZFN0YXJ0UnVsZXM6ICBbYXN0LnJ1bGVzWzBdLm5hbWVdLFxuICAgICAgY2FjaGU6ICAgICAgICAgICAgICBmYWxzZSxcbiAgICAgIG9wdGltaXplOiAgICAgICAgICAgXCJzcGVlZFwiLFxuICAgICAgb3V0cHV0OiAgICAgICAgICAgICBcInBhcnNlclwiXG4gICAgfSk7XG5cbiAgICBmb3IgKHN0YWdlIGluIHBhc3Nlcykge1xuICAgICAgaWYgKHBhc3Nlcy5oYXNPd25Qcm9wZXJ0eShzdGFnZSkpIHtcbiAgICAgICAgdXRpbHMuZWFjaChwYXNzZXNbc3RhZ2VdLCBydW5QYXNzKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzd2l0Y2ggKG9wdGlvbnMub3V0cHV0KSB7XG4gICAgICBjYXNlIFwicGFyc2VyXCI6IHJldHVybiBldmFsKGFzdC5jb2RlKTtcbiAgICAgIGNhc2UgXCJzb3VyY2VcIjogcmV0dXJuIGFzdC5jb2RlO1xuICAgIH1cbiAgfVxufTtcbiIsIi8qIEJ5dGVjb2RlIGluc3RydWN0aW9uIG9wY29kZXMuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyogU3RhY2sgTWFuaXB1bGF0aW9uICovXG5cbiAgUFVTSDogICAgICAgICAgICAgMCwgICAgLy8gUFVTSCBjXG4gIFBVU0hfQ1VSUl9QT1M6ICAgIDEsICAgIC8vIFBVU0hfQ1VSUl9QT1NcbiAgUE9QOiAgICAgICAgICAgICAgMiwgICAgLy8gUE9QXG4gIFBPUF9DVVJSX1BPUzogICAgIDMsICAgIC8vIFBPUF9DVVJSX1BPU1xuICBQT1BfTjogICAgICAgICAgICA0LCAgICAvLyBQT1BfTiBuXG4gIE5JUDogICAgICAgICAgICAgIDUsICAgIC8vIE5JUFxuICBBUFBFTkQ6ICAgICAgICAgICA2LCAgICAvLyBBUFBFTkRcbiAgV1JBUDogICAgICAgICAgICAgNywgICAgLy8gV1JBUCBuXG4gIFRFWFQ6ICAgICAgICAgICAgIDgsICAgIC8vIFRFWFRcblxuICAvKiBDb25kaXRpb25zIGFuZCBMb29wcyAqL1xuXG4gIElGOiAgICAgICAgICAgICAgIDksICAgIC8vIElGIHQsIGZcbiAgSUZfRVJST1I6ICAgICAgICAgMTAsICAgLy8gSUZfRVJST1IgdCwgZlxuICBJRl9OT1RfRVJST1I6ICAgICAxMSwgICAvLyBJRl9OT1RfRVJST1IgdCwgZlxuICBXSElMRV9OT1RfRVJST1I6ICAxMiwgICAvLyBXSElMRV9OT1RfRVJST1IgYlxuXG4gIC8qIE1hdGNoaW5nICovXG5cbiAgTUFUQ0hfQU5ZOiAgICAgICAgMTMsICAgLy8gTUFUQ0hfQU5ZIGEsIGYsIC4uLlxuICBNQVRDSF9TVFJJTkc6ICAgICAxNCwgICAvLyBNQVRDSF9TVFJJTkcgcywgYSwgZiwgLi4uXG4gIE1BVENIX1NUUklOR19JQzogIDE1LCAgIC8vIE1BVENIX1NUUklOR19JQyBzLCBhLCBmLCAuLi5cbiAgTUFUQ0hfUkVHRVhQOiAgICAgMTYsICAgLy8gTUFUQ0hfUkVHRVhQIHIsIGEsIGYsIC4uLlxuICBBQ0NFUFRfTjogICAgICAgICAxNywgICAvLyBBQ0NFUFRfTiBuXG4gIEFDQ0VQVF9TVFJJTkc6ICAgIDE4LCAgIC8vIEFDQ0VQVF9TVFJJTkcgc1xuICBGQUlMOiAgICAgICAgICAgICAxOSwgICAvLyBGQUlMIGVcblxuICAvKiBDYWxscyAqL1xuXG4gIFJFUE9SVF9TQVZFRF9QT1M6IDIwLCAgIC8vIFJFUE9SVF9TQVZFRF9QT1MgcFxuICBSRVBPUlRfQ1VSUl9QT1M6ICAyMSwgICAvLyBSRVBPUlRfQ1VSUl9QT1NcbiAgQ0FMTDogICAgICAgICAgICAgMjIsICAgLy8gQ0FMTCBmLCBuLCBwYywgcDEsIHAyLCAuLi4sIHBOXG5cbiAgLyogUnVsZXMgKi9cblxuICBSVUxFOiAgICAgICAgICAgICAyMywgICAvLyBSVUxFIHJcblxuICAvKiBGYWlsdXJlIFJlcG9ydGluZyAqL1xuXG4gIFNJTEVOVF9GQUlMU19PTjogIDI0LCAgIC8vIFNJTEVOVF9GQUlMU19PTlxuICBTSUxFTlRfRkFJTFNfT0ZGOiAyNSAgICAvLyBTSUxFTlRfRkFJTFNfRkZcbn07XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIiksXG4gICAgb3AgICAgPSByZXF1aXJlKFwiLi4vb3Bjb2Rlc1wiKTtcblxuLyogR2VuZXJhdGVzIGJ5dGVjb2RlLlxuICpcbiAqIEluc3RydWN0aW9uc1xuICogPT09PT09PT09PT09XG4gKlxuICogU3RhY2sgTWFuaXB1bGF0aW9uXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS1cbiAqXG4gKiAgWzBdIFBVU0ggY1xuICpcbiAqICAgICAgICBzdGFjay5wdXNoKGNvbnN0c1tjXSk7XG4gKlxuICogIFsxXSBQVVNIX0NVUlJfUE9TXG4gKlxuICogICAgICAgIHN0YWNrLnB1c2goY3VyclBvcyk7XG4gKlxuICogIFsyXSBQT1BcbiAqXG4gKiAgICAgICAgc3RhY2sucG9wKCk7XG4gKlxuICogIFszXSBQT1BfQ1VSUl9QT1NcbiAqXG4gKiAgICAgICAgY3VyclBvcyA9IHN0YWNrLnBvcCgpO1xuICpcbiAqICBbNF0gUE9QX04gblxuICpcbiAqICAgICAgICBzdGFjay5wb3Aobik7XG4gKlxuICogIFs1XSBOSVBcbiAqXG4gKiAgICAgICAgdmFsdWUgPSBzdGFjay5wb3AoKTtcbiAqICAgICAgICBzdGFjay5wb3AoKTtcbiAqICAgICAgICBzdGFjay5wdXNoKHZhbHVlKTtcbiAqXG4gKiAgWzZdIEFQUEVORFxuICpcbiAqICAgICAgICB2YWx1ZSA9IHN0YWNrLnBvcCgpO1xuICogICAgICAgIGFycmF5ID0gc3RhY2sucG9wKCk7XG4gKiAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSk7XG4gKiAgICAgICAgc3RhY2sucHVzaChhcnJheSk7XG4gKlxuICogIFs3XSBXUkFQIG5cbiAqXG4gKiAgICAgICAgc3RhY2sucHVzaChzdGFjay5wb3AobikpO1xuICpcbiAqICBbOF0gVEVYVFxuICpcbiAqICAgICAgICBzdGFjay5wb3AoKTtcbiAqICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhzdGFjay50b3AoKSwgY3VyclBvcykpO1xuICpcbiAqIENvbmRpdGlvbnMgYW5kIExvb3BzXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqICBbOV0gSUYgdCwgZlxuICpcbiAqICAgICAgICBpZiAoc3RhY2sudG9wKCkpIHtcbiAqICAgICAgICAgIGludGVycHJldChpcCArIDMsIGlwICsgMyArIHQpO1xuICogICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICBpbnRlcnByZXQoaXAgKyAzICsgdCwgaXAgKyAzICsgdCArIGYpO1xuICogICAgICAgIH1cbiAqXG4gKiBbMTBdIElGX0VSUk9SIHQsIGZcbiAqXG4gKiAgICAgICAgaWYgKHN0YWNrLnRvcCgpID09PSBGQUlMRUQpIHtcbiAqICAgICAgICAgIGludGVycHJldChpcCArIDMsIGlwICsgMyArIHQpO1xuICogICAgICAgIH0gZWxzZSB7XG4gKiAgICAgICAgICBpbnRlcnByZXQoaXAgKyAzICsgdCwgaXAgKyAzICsgdCArIGYpO1xuICogICAgICAgIH1cbiAqXG4gKiBbMTFdIElGX05PVF9FUlJPUiB0LCBmXG4gKlxuICogICAgICAgIGlmIChzdGFjay50b3AoKSAhPT0gRkFJTEVEKSB7XG4gKiAgICAgICAgICBpbnRlcnByZXQoaXAgKyAzLCBpcCArIDMgKyB0KTtcbiAqICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgaW50ZXJwcmV0KGlwICsgMyArIHQsIGlwICsgMyArIHQgKyBmKTtcbiAqICAgICAgICB9XG4gKlxuICogWzEyXSBXSElMRV9OT1RfRVJST1IgYlxuICpcbiAqICAgICAgICB3aGlsZShzdGFjay50b3AoKSAhPT0gRkFJTEVEKSB7XG4gKiAgICAgICAgICBpbnRlcnByZXQoaXAgKyAyLCBpcCArIDIgKyBiKTtcbiAqICAgICAgICB9XG4gKlxuICogTWF0Y2hpbmdcbiAqIC0tLS0tLS0tXG4gKlxuICogWzEzXSBNQVRDSF9BTlkgYSwgZiwgLi4uXG4gKlxuICogICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBjdXJyUG9zKSB7XG4gKiAgICAgICAgICBpbnRlcnByZXQoaXAgKyAzLCBpcCArIDMgKyBhKTtcbiAqICAgICAgICB9IGVsc2Uge1xuICogICAgICAgICAgaW50ZXJwcmV0KGlwICsgMyArIGEsIGlwICsgMyArIGEgKyBmKTtcbiAqICAgICAgICB9XG4gKlxuICogWzE0XSBNQVRDSF9TVFJJTkcgcywgYSwgZiwgLi4uXG4gKlxuICogICAgICAgIGlmIChpbnB1dC5zdWJzdHIoY3VyclBvcywgY29uc3RzW3NdLmxlbmd0aCkgPT09IGNvbnN0c1tzXSkge1xuICogICAgICAgICAgaW50ZXJwcmV0KGlwICsgNCwgaXAgKyA0ICsgYSk7XG4gKiAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgIGludGVycHJldChpcCArIDQgKyBhLCBpcCArIDQgKyBhICsgZik7XG4gKiAgICAgICAgfVxuICpcbiAqIFsxNV0gTUFUQ0hfU1RSSU5HX0lDIHMsIGEsIGYsIC4uLlxuICpcbiAqICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKGN1cnJQb3MsIGNvbnN0c1tzXS5sZW5ndGgpLnRvTG93ZXJDYXNlKCkgPT09IGNvbnN0c1tzXSkge1xuICogICAgICAgICAgaW50ZXJwcmV0KGlwICsgNCwgaXAgKyA0ICsgYSk7XG4gKiAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgIGludGVycHJldChpcCArIDQgKyBhLCBpcCArIDQgKyBhICsgZik7XG4gKiAgICAgICAgfVxuICpcbiAqIFsxNl0gTUFUQ0hfUkVHRVhQIHIsIGEsIGYsIC4uLlxuICpcbiAqICAgICAgICBpZiAoY29uc3RzW3JdLnRlc3QoaW5wdXQuY2hhckF0KGN1cnJQb3MpKSkge1xuICogICAgICAgICAgaW50ZXJwcmV0KGlwICsgNCwgaXAgKyA0ICsgYSk7XG4gKiAgICAgICAgfSBlbHNlIHtcbiAqICAgICAgICAgIGludGVycHJldChpcCArIDQgKyBhLCBpcCArIDQgKyBhICsgZik7XG4gKiAgICAgICAgfVxuICpcbiAqIFsxN10gQUNDRVBUX04gblxuICpcbiAqICAgICAgICBzdGFjay5wdXNoKGlucHV0LnN1YnN0cmluZyhjdXJyUG9zLCBuKSk7XG4gKiAgICAgICAgY3VyclBvcyArPSBuO1xuICpcbiAqIFsxOF0gQUNDRVBUX1NUUklORyBzXG4gKlxuICogICAgICAgIHN0YWNrLnB1c2goY29uc3RzW3NdKTtcbiAqICAgICAgICBjdXJyUG9zICs9IGNvbnN0c1tzXS5sZW5ndGg7XG4gKlxuICogWzE5XSBGQUlMIGVcbiAqXG4gKiAgICAgICAgc3RhY2sucHVzaChGQUlMRUQpO1xuICogICAgICAgIGZhaWwoY29uc3RzW2VdKTtcbiAqXG4gKiBDYWxsc1xuICogLS0tLS1cbiAqXG4gKiBbMjBdIFJFUE9SVF9TQVZFRF9QT1MgcFxuICpcbiAqICAgICAgICByZXBvcnRlZFBvcyA9IHN0YWNrW3BdO1xuICpcbiAqIFsyMV0gUkVQT1JUX0NVUlJfUE9TXG4gKlxuICogICAgICAgIHJlcG9ydGVkUG9zID0gY3VyclBvcztcbiAqXG4gKiBbMjJdIENBTEwgZiwgbiwgcGMsIHAxLCBwMiwgLi4uLCBwTlxuICpcbiAqICAgICAgICB2YWx1ZSA9IGNvbnN0c1tmXShzdGFja1twMV0sIC4uLiwgc3RhY2tbcE5dKTtcbiAqICAgICAgICBzdGFjay5wb3Aobik7XG4gKiAgICAgICAgc3RhY2sucHVzaCh2YWx1ZSk7XG4gKlxuICogUnVsZXNcbiAqIC0tLS0tXG4gKlxuICogWzIzXSBSVUxFIHJcbiAqXG4gKiAgICAgICAgc3RhY2sucHVzaChwYXJzZVJ1bGUocikpO1xuICpcbiAqIEZhaWx1cmUgUmVwb3J0aW5nXG4gKiAtLS0tLS0tLS0tLS0tLS0tLVxuICpcbiAqIFsyNF0gU0lMRU5UX0ZBSUxTX09OXG4gKlxuICogICAgICAgIHNpbGVudEZhaWxzKys7XG4gKlxuICogWzI1XSBTSUxFTlRfRkFJTFNfT0ZGXG4gKlxuICogICAgICAgIHNpbGVudEZhaWxzLS07XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXN0KSB7XG4gIHZhciBjb25zdHMgPSBbXTtcblxuICBmdW5jdGlvbiBhZGRDb25zdCh2YWx1ZSkge1xuICAgIHZhciBpbmRleCA9IHV0aWxzLmluZGV4T2YoY29uc3RzLCBmdW5jdGlvbihjKSB7IHJldHVybiBjID09PSB2YWx1ZTsgfSk7XG5cbiAgICByZXR1cm4gaW5kZXggPT09IC0xID8gY29uc3RzLnB1c2godmFsdWUpIC0gMSA6IGluZGV4O1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRnVuY3Rpb25Db25zdChwYXJhbXMsIGNvZGUpIHtcbiAgICByZXR1cm4gYWRkQ29uc3QoXG4gICAgICBcImZ1bmN0aW9uKFwiICsgcGFyYW1zLmpvaW4oXCIsIFwiKSArIFwiKSB7XCIgKyBjb2RlICsgXCJ9XCJcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRTZXF1ZW5jZSgpIHtcbiAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLmNvbmNhdC5hcHBseShbXSwgYXJndW1lbnRzKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ29uZGl0aW9uKGNvbmRDb2RlLCB0aGVuQ29kZSwgZWxzZUNvZGUpIHtcbiAgICByZXR1cm4gY29uZENvZGUuY29uY2F0KFxuICAgICAgW3RoZW5Db2RlLmxlbmd0aCwgZWxzZUNvZGUubGVuZ3RoXSxcbiAgICAgIHRoZW5Db2RlLFxuICAgICAgZWxzZUNvZGVcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gYnVpbGRMb29wKGNvbmRDb2RlLCBib2R5Q29kZSkge1xuICAgIHJldHVybiBjb25kQ29kZS5jb25jYXQoW2JvZHlDb2RlLmxlbmd0aF0sIGJvZHlDb2RlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQ2FsbChmdW5jdGlvbkluZGV4LCBkZWx0YSwgZW52LCBzcCkge1xuICAgIHZhciBwYXJhbXMgPSB1dGlscy5tYXAoIHV0aWxzLnZhbHVlcyhlbnYpLCBmdW5jdGlvbihwKSB7IHJldHVybiBzcCAtIHA7IH0pO1xuXG4gICAgcmV0dXJuIFtvcC5DQUxMLCBmdW5jdGlvbkluZGV4LCBkZWx0YSwgcGFyYW1zLmxlbmd0aF0uY29uY2F0KHBhcmFtcyk7XG4gIH1cblxuICBmdW5jdGlvbiBidWlsZFNpbXBsZVByZWRpY2F0ZShleHByZXNzaW9uLCBuZWdhdGl2ZSwgY29udGV4dCkge1xuICAgIHZhciB1bmRlZmluZWRJbmRleCA9IGFkZENvbnN0KCd2b2lkIDAnKSxcbiAgICAgICAgZmFpbGVkSW5kZXggICAgPSBhZGRDb25zdCgncGVnJEZBSUxFRCcpO1xuXG4gICAgcmV0dXJuIGJ1aWxkU2VxdWVuY2UoXG4gICAgICBbb3AuUFVTSF9DVVJSX1BPU10sXG4gICAgICBbb3AuU0lMRU5UX0ZBSUxTX09OXSxcbiAgICAgIGdlbmVyYXRlKGV4cHJlc3Npb24sIHtcbiAgICAgICAgc3A6ICAgICBjb250ZXh0LnNwICsgMSxcbiAgICAgICAgZW52OiAgICB7IH0sXG4gICAgICAgIGFjdGlvbjogbnVsbFxuICAgICAgfSksXG4gICAgICBbb3AuU0lMRU5UX0ZBSUxTX09GRl0sXG4gICAgICBidWlsZENvbmRpdGlvbihcbiAgICAgICAgW25lZ2F0aXZlID8gb3AuSUZfRVJST1IgOiBvcC5JRl9OT1RfRVJST1JdLFxuICAgICAgICBidWlsZFNlcXVlbmNlKFxuICAgICAgICAgIFtvcC5QT1BdLFxuICAgICAgICAgIFtuZWdhdGl2ZSA/IG9wLlBPUCA6IG9wLlBPUF9DVVJSX1BPU10sXG4gICAgICAgICAgW29wLlBVU0gsIHVuZGVmaW5lZEluZGV4XVxuICAgICAgICApLFxuICAgICAgICBidWlsZFNlcXVlbmNlKFxuICAgICAgICAgIFtvcC5QT1BdLFxuICAgICAgICAgIFtuZWdhdGl2ZSA/IG9wLlBPUF9DVVJSX1BPUyA6IG9wLlBPUF0sXG4gICAgICAgICAgW29wLlBVU0gsIGZhaWxlZEluZGV4XVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkU2VtYW50aWNQcmVkaWNhdGUoY29kZSwgbmVnYXRpdmUsIGNvbnRleHQpIHtcbiAgICB2YXIgZnVuY3Rpb25JbmRleCAgPSBhZGRGdW5jdGlvbkNvbnN0KHV0aWxzLmtleXMoY29udGV4dC5lbnYpLCBjb2RlKSxcbiAgICAgICAgdW5kZWZpbmVkSW5kZXggPSBhZGRDb25zdCgndm9pZCAwJyksXG4gICAgICAgIGZhaWxlZEluZGV4ICAgID0gYWRkQ29uc3QoJ3BlZyRGQUlMRUQnKTtcblxuICAgIHJldHVybiBidWlsZFNlcXVlbmNlKFxuICAgICAgW29wLlJFUE9SVF9DVVJSX1BPU10sXG4gICAgICBidWlsZENhbGwoZnVuY3Rpb25JbmRleCwgMCwgY29udGV4dC5lbnYsIGNvbnRleHQuc3ApLFxuICAgICAgYnVpbGRDb25kaXRpb24oXG4gICAgICAgIFtvcC5JRl0sXG4gICAgICAgIGJ1aWxkU2VxdWVuY2UoXG4gICAgICAgICAgW29wLlBPUF0sXG4gICAgICAgICAgW29wLlBVU0gsIG5lZ2F0aXZlID8gZmFpbGVkSW5kZXggOiB1bmRlZmluZWRJbmRleF1cbiAgICAgICAgKSxcbiAgICAgICAgYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgICBbb3AuUE9QXSxcbiAgICAgICAgICBbb3AuUFVTSCwgbmVnYXRpdmUgPyB1bmRlZmluZWRJbmRleCA6IGZhaWxlZEluZGV4XVxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGJ1aWxkQXBwZW5kTG9vcChleHByZXNzaW9uQ29kZSkge1xuICAgIHJldHVybiBidWlsZExvb3AoXG4gICAgICBbb3AuV0hJTEVfTk9UX0VSUk9SXSxcbiAgICAgIGJ1aWxkU2VxdWVuY2UoW29wLkFQUEVORF0sIGV4cHJlc3Npb25Db2RlKVxuICAgICk7XG4gIH1cblxuICB2YXIgZ2VuZXJhdGUgPSB1dGlscy5idWlsZE5vZGVWaXNpdG9yKHtcbiAgICBncmFtbWFyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB1dGlscy5lYWNoKG5vZGUucnVsZXMsIGdlbmVyYXRlKTtcblxuICAgICAgbm9kZS5jb25zdHMgPSBjb25zdHM7XG4gICAgfSxcblxuICAgIHJ1bGU6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIG5vZGUuYnl0ZWNvZGUgPSBnZW5lcmF0ZShub2RlLmV4cHJlc3Npb24sIHtcbiAgICAgICAgc3A6ICAgICAtMSwgIC8vIHN0YWNrIHBvaW50ZXJcbiAgICAgICAgZW52OiAgICB7IH0sIC8vIG1hcHBpbmcgb2YgbGFiZWwgbmFtZXMgdG8gc3RhY2sgcG9zaXRpb25zXG4gICAgICAgIGFjdGlvbjogbnVsbCAvLyBhY3Rpb24gbm9kZXMgcGFzcyB0aGVtc2VsdmVzIHRvIGNoaWxkcmVuIGhlcmVcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBuYW1lZDogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgdmFyIG5hbWVJbmRleCA9IGFkZENvbnN0KFxuICAgICAgICAneyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiAnICsgdXRpbHMucXVvdGUobm9kZS5uYW1lKSArICcgfSdcbiAgICAgICk7XG5cbiAgICAgIC8qXG4gICAgICAgKiBUaGUgY29kZSBnZW5lcmF0ZWQgYmVsb3cgaXMgc2xpZ2h0bHkgc3Vib3B0aW1hbCBiZWNhdXNlIHxGQUlMfCBwdXNoZXNcbiAgICAgICAqIHRvIHRoZSBzdGFjaywgc28gd2UgbmVlZCB0byBzdGljayBhIHxQT1B8IGluIGZyb250IG9mIGl0LiBXZSBsYWNrIGFcbiAgICAgICAqIGRlZGljYXRlZCBpbnN0cnVjdGlvbiB0aGF0IHdvdWxkIGp1c3QgcmVwb3J0IHRoZSBmYWlsdXJlIGFuZCBub3QgdG91Y2hcbiAgICAgICAqIHRoZSBzdGFjay5cbiAgICAgICAqL1xuICAgICAgcmV0dXJuIGJ1aWxkU2VxdWVuY2UoXG4gICAgICAgIFtvcC5TSUxFTlRfRkFJTFNfT05dLFxuICAgICAgICBnZW5lcmF0ZShub2RlLmV4cHJlc3Npb24sIGNvbnRleHQpLFxuICAgICAgICBbb3AuU0lMRU5UX0ZBSUxTX09GRl0sXG4gICAgICAgIGJ1aWxkQ29uZGl0aW9uKFtvcC5JRl9FUlJPUl0sIFtvcC5GQUlMLCBuYW1lSW5kZXhdLCBbXSlcbiAgICAgICk7XG4gICAgfSxcblxuICAgIGNob2ljZTogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgZnVuY3Rpb24gYnVpbGRBbHRlcm5hdGl2ZXNDb2RlKGFsdGVybmF0aXZlcywgY29udGV4dCkge1xuICAgICAgICByZXR1cm4gYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgICBnZW5lcmF0ZShhbHRlcm5hdGl2ZXNbMF0sIHtcbiAgICAgICAgICAgIHNwOiAgICAgY29udGV4dC5zcCxcbiAgICAgICAgICAgIGVudjogICAgeyB9LFxuICAgICAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICAgICAgfSksXG4gICAgICAgICAgYWx0ZXJuYXRpdmVzLmxlbmd0aCA+IDFcbiAgICAgICAgICAgID8gYnVpbGRDb25kaXRpb24oXG4gICAgICAgICAgICAgICAgW29wLklGX0VSUk9SXSxcbiAgICAgICAgICAgICAgICBidWlsZFNlcXVlbmNlKFxuICAgICAgICAgICAgICAgICAgW29wLlBPUF0sXG4gICAgICAgICAgICAgICAgICBidWlsZEFsdGVybmF0aXZlc0NvZGUoYWx0ZXJuYXRpdmVzLnNsaWNlKDEpLCBjb250ZXh0KVxuICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgW11cbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBbXVxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnVpbGRBbHRlcm5hdGl2ZXNDb2RlKG5vZGUuYWx0ZXJuYXRpdmVzLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgYWN0aW9uOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW52ICAgICAgICAgICAgPSB7IH0sXG4gICAgICAgICAgZW1pdENhbGwgICAgICAgPSBub2RlLmV4cHJlc3Npb24udHlwZSAhPT0gXCJzZXF1ZW5jZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICB8fCBub2RlLmV4cHJlc3Npb24uZWxlbWVudHMubGVuZ3RoID09PSAwLFxuICAgICAgICAgIGV4cHJlc3Npb25Db2RlID0gZ2VuZXJhdGUobm9kZS5leHByZXNzaW9uLCB7XG4gICAgICAgICAgICBzcDogICAgIGNvbnRleHQuc3AgKyAoZW1pdENhbGwgPyAxIDogMCksXG4gICAgICAgICAgICBlbnY6ICAgIGVudixcbiAgICAgICAgICAgIGFjdGlvbjogbm9kZVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIGZ1bmN0aW9uSW5kZXggID0gYWRkRnVuY3Rpb25Db25zdCh1dGlscy5rZXlzKGVudiksIG5vZGUuY29kZSk7XG5cbiAgICAgIHJldHVybiBlbWl0Q2FsbFxuICAgICAgICA/IGJ1aWxkU2VxdWVuY2UoXG4gICAgICAgICAgICBbb3AuUFVTSF9DVVJSX1BPU10sXG4gICAgICAgICAgICBleHByZXNzaW9uQ29kZSxcbiAgICAgICAgICAgIGJ1aWxkQ29uZGl0aW9uKFxuICAgICAgICAgICAgICBbb3AuSUZfTk9UX0VSUk9SXSxcbiAgICAgICAgICAgICAgYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgICAgICAgICBbb3AuUkVQT1JUX1NBVkVEX1BPUywgMV0sXG4gICAgICAgICAgICAgICAgYnVpbGRDYWxsKGZ1bmN0aW9uSW5kZXgsIDEsIGVudiwgY29udGV4dC5zcCArIDIpXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIFtdXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgW29wLk5JUF1cbiAgICAgICAgICApXG4gICAgICAgIDogZXhwcmVzc2lvbkNvZGU7XG4gICAgfSxcblxuICAgIHNlcXVlbmNlOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgZW1wdHlBcnJheUluZGV4O1xuXG4gICAgICBmdW5jdGlvbiBidWlsZEVsZW1lbnRzQ29kZShlbGVtZW50cywgY29udGV4dCkge1xuICAgICAgICB2YXIgcHJvY2Vzc2VkQ291bnQsIGZ1bmN0aW9uSW5kZXg7XG5cbiAgICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBwcm9jZXNzZWRDb3VudCA9IG5vZGUuZWxlbWVudHMubGVuZ3RoIC0gZWxlbWVudHMuc2xpY2UoMSkubGVuZ3RoO1xuXG4gICAgICAgICAgcmV0dXJuIGJ1aWxkU2VxdWVuY2UoXG4gICAgICAgICAgICBnZW5lcmF0ZShlbGVtZW50c1swXSwge1xuICAgICAgICAgICAgICBzcDogICAgIGNvbnRleHQuc3AsXG4gICAgICAgICAgICAgIGVudjogICAgY29udGV4dC5lbnYsXG4gICAgICAgICAgICAgIGFjdGlvbjogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBidWlsZENvbmRpdGlvbihcbiAgICAgICAgICAgICAgW29wLklGX05PVF9FUlJPUl0sXG4gICAgICAgICAgICAgIGJ1aWxkRWxlbWVudHNDb2RlKGVsZW1lbnRzLnNsaWNlKDEpLCB7XG4gICAgICAgICAgICAgICAgc3A6ICAgICBjb250ZXh0LnNwICsgMSxcbiAgICAgICAgICAgICAgICBlbnY6ICAgIGNvbnRleHQuZW52LFxuICAgICAgICAgICAgICAgIGFjdGlvbjogY29udGV4dC5hY3Rpb25cbiAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgIGJ1aWxkU2VxdWVuY2UoXG4gICAgICAgICAgICAgICAgcHJvY2Vzc2VkQ291bnQgPiAxID8gW29wLlBPUF9OLCBwcm9jZXNzZWRDb3VudF0gOiBbb3AuUE9QXSxcbiAgICAgICAgICAgICAgICBbb3AuUE9QX0NVUlJfUE9TXSxcbiAgICAgICAgICAgICAgICBbb3AuUFVTSCwgZmFpbGVkSW5kZXhdXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChjb250ZXh0LmFjdGlvbikge1xuICAgICAgICAgICAgZnVuY3Rpb25JbmRleCA9IGFkZEZ1bmN0aW9uQ29uc3QoXG4gICAgICAgICAgICAgIHV0aWxzLmtleXMoY29udGV4dC5lbnYpLFxuICAgICAgICAgICAgICBjb250ZXh0LmFjdGlvbi5jb2RlXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICByZXR1cm4gYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgICAgICAgW29wLlJFUE9SVF9TQVZFRF9QT1MsIG5vZGUuZWxlbWVudHMubGVuZ3RoXSxcbiAgICAgICAgICAgICAgYnVpbGRDYWxsKFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uSW5kZXgsXG4gICAgICAgICAgICAgICAgbm9kZS5lbGVtZW50cy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgY29udGV4dC5lbnYsXG4gICAgICAgICAgICAgICAgY29udGV4dC5zcFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBbb3AuTklQXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGJ1aWxkU2VxdWVuY2UoW29wLldSQVAsIG5vZGUuZWxlbWVudHMubGVuZ3RoXSwgW29wLk5JUF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAobm9kZS5lbGVtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZhaWxlZEluZGV4ID0gYWRkQ29uc3QoJ3BlZyRGQUlMRUQnKTtcblxuICAgICAgICByZXR1cm4gYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgICBbb3AuUFVTSF9DVVJSX1BPU10sXG4gICAgICAgICAgYnVpbGRFbGVtZW50c0NvZGUobm9kZS5lbGVtZW50cywge1xuICAgICAgICAgICAgc3A6ICAgICBjb250ZXh0LnNwICsgMSxcbiAgICAgICAgICAgIGVudjogICAgY29udGV4dC5lbnYsXG4gICAgICAgICAgICBhY3Rpb246IGNvbnRleHQuYWN0aW9uXG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVtcHR5QXJyYXlJbmRleCA9IGFkZENvbnN0KCdbXScpO1xuXG4gICAgICAgIHJldHVybiBbb3AuUFVTSCwgZW1wdHlBcnJheUluZGV4XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgbGFiZWxlZDogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgY29udGV4dC5lbnZbbm9kZS5sYWJlbF0gPSBjb250ZXh0LnNwICsgMTtcblxuICAgICAgcmV0dXJuIGdlbmVyYXRlKG5vZGUuZXhwcmVzc2lvbiwge1xuICAgICAgICBzcDogICAgIGNvbnRleHQuc3AsXG4gICAgICAgIGVudjogICAgeyB9LFxuICAgICAgICBhY3Rpb246IG51bGxcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICB0ZXh0OiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgW29wLlBVU0hfQ1VSUl9QT1NdLFxuICAgICAgICBnZW5lcmF0ZShub2RlLmV4cHJlc3Npb24sIHtcbiAgICAgICAgICBzcDogICAgIGNvbnRleHQuc3AgKyAxLFxuICAgICAgICAgIGVudjogICAgeyB9LFxuICAgICAgICAgIGFjdGlvbjogbnVsbFxuICAgICAgICB9KSxcbiAgICAgICAgYnVpbGRDb25kaXRpb24oW29wLklGX05PVF9FUlJPUl0sIFtvcC5URVhUXSwgW10pLFxuICAgICAgICBbb3AuTklQXVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgc2ltcGxlX2FuZDogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIGJ1aWxkU2ltcGxlUHJlZGljYXRlKG5vZGUuZXhwcmVzc2lvbiwgZmFsc2UsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBzaW1wbGVfbm90OiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gYnVpbGRTaW1wbGVQcmVkaWNhdGUobm9kZS5leHByZXNzaW9uLCB0cnVlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc2VtYW50aWNfYW5kOiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gYnVpbGRTZW1hbnRpY1ByZWRpY2F0ZShub2RlLmNvZGUsIGZhbHNlLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gICAgc2VtYW50aWNfbm90OiBmdW5jdGlvbihub2RlLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gYnVpbGRTZW1hbnRpY1ByZWRpY2F0ZShub2RlLmNvZGUsIHRydWUsIGNvbnRleHQpO1xuICAgIH0sXG5cbiAgICBvcHRpb25hbDogZnVuY3Rpb24obm9kZSwgY29udGV4dCkge1xuICAgICAgdmFyIG51bGxJbmRleCA9IGFkZENvbnN0KCdudWxsJyk7XG5cbiAgICAgIHJldHVybiBidWlsZFNlcXVlbmNlKFxuICAgICAgICBnZW5lcmF0ZShub2RlLmV4cHJlc3Npb24sIHtcbiAgICAgICAgICBzcDogICAgIGNvbnRleHQuc3AsXG4gICAgICAgICAgZW52OiAgICB7IH0sXG4gICAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICAgIH0pLFxuICAgICAgICBidWlsZENvbmRpdGlvbihcbiAgICAgICAgICBbb3AuSUZfRVJST1JdLFxuICAgICAgICAgIGJ1aWxkU2VxdWVuY2UoW29wLlBPUF0sIFtvcC5QVVNILCBudWxsSW5kZXhdKSxcbiAgICAgICAgICBbXVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG5cbiAgICB6ZXJvX29yX21vcmU6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbXB0eUFycmF5SW5kZXggPSBhZGRDb25zdCgnW10nKTtcbiAgICAgICAgICBleHByZXNzaW9uQ29kZSAgPSBnZW5lcmF0ZShub2RlLmV4cHJlc3Npb24sIHtcbiAgICAgICAgICAgIHNwOiAgICAgY29udGV4dC5zcCArIDEsXG4gICAgICAgICAgICBlbnY6ICAgIHsgfSxcbiAgICAgICAgICAgIGFjdGlvbjogbnVsbFxuICAgICAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYnVpbGRTZXF1ZW5jZShcbiAgICAgICAgW29wLlBVU0gsIGVtcHR5QXJyYXlJbmRleF0sXG4gICAgICAgIGV4cHJlc3Npb25Db2RlLFxuICAgICAgICBidWlsZEFwcGVuZExvb3AoZXhwcmVzc2lvbkNvZGUpLFxuICAgICAgICBbb3AuUE9QXVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgb25lX29yX21vcmU6IGZ1bmN0aW9uKG5vZGUsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlbXB0eUFycmF5SW5kZXggPSBhZGRDb25zdCgnW10nKTtcbiAgICAgICAgICBmYWlsZWRJbmRleCAgICAgPSBhZGRDb25zdCgncGVnJEZBSUxFRCcpO1xuICAgICAgICAgIGV4cHJlc3Npb25Db2RlICA9IGdlbmVyYXRlKG5vZGUuZXhwcmVzc2lvbiwge1xuICAgICAgICAgICAgc3A6ICAgICBjb250ZXh0LnNwICsgMSxcbiAgICAgICAgICAgIGVudjogICAgeyB9LFxuICAgICAgICAgICAgYWN0aW9uOiBudWxsXG4gICAgICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBidWlsZFNlcXVlbmNlKFxuICAgICAgICBbb3AuUFVTSCwgZW1wdHlBcnJheUluZGV4XSxcbiAgICAgICAgZXhwcmVzc2lvbkNvZGUsXG4gICAgICAgIGJ1aWxkQ29uZGl0aW9uKFxuICAgICAgICAgIFtvcC5JRl9OT1RfRVJST1JdLFxuICAgICAgICAgIGJ1aWxkU2VxdWVuY2UoYnVpbGRBcHBlbmRMb29wKGV4cHJlc3Npb25Db2RlKSwgW29wLlBPUF0pLFxuICAgICAgICAgIGJ1aWxkU2VxdWVuY2UoW29wLlBPUF0sIFtvcC5QT1BdLCBbb3AuUFVTSCwgZmFpbGVkSW5kZXhdKVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0sXG5cbiAgICBydWxlX3JlZjogZnVuY3Rpb24obm9kZSkge1xuICAgICAgcmV0dXJuIFtvcC5SVUxFLCB1dGlscy5pbmRleE9mUnVsZUJ5TmFtZShhc3QsIG5vZGUubmFtZSldO1xuICAgIH0sXG5cbiAgICBsaXRlcmFsOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgc3RyaW5nSW5kZXgsIGV4cGVjdGVkSW5kZXg7XG5cbiAgICAgIGlmIChub2RlLnZhbHVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RyaW5nSW5kZXggPSBhZGRDb25zdChub2RlLmlnbm9yZUNhc2VcbiAgICAgICAgICA/IHV0aWxzLnF1b3RlKG5vZGUudmFsdWUudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgICA6IHV0aWxzLnF1b3RlKG5vZGUudmFsdWUpXG4gICAgICAgICk7XG4gICAgICAgIGV4cGVjdGVkSW5kZXggPSBhZGRDb25zdChbXG4gICAgICAgICAgJ3snLFxuICAgICAgICAgICd0eXBlOiBcImxpdGVyYWxcIiwnLFxuICAgICAgICAgICd2YWx1ZTogJyArIHV0aWxzLnF1b3RlKG5vZGUudmFsdWUpICsgJywnLFxuICAgICAgICAgICdkZXNjcmlwdGlvbjogJyArIHV0aWxzLnF1b3RlKHV0aWxzLnF1b3RlKG5vZGUudmFsdWUpKSxcbiAgICAgICAgICAnfSdcbiAgICAgICAgXS5qb2luKCcgJykpO1xuXG4gICAgICAgIC8qXG4gICAgICAgICAqIEZvciBjYXNlLXNlbnNpdGl2ZSBzdHJpbmdzIHRoZSB2YWx1ZSBtdXN0IG1hdGNoIHRoZSBiZWdpbm5pbmcgb2YgdGhlXG4gICAgICAgICAqIHJlbWFpbmluZyBpbnB1dCBleGFjdGx5LiBBcyBhIHJlc3VsdCwgd2UgY2FuIHVzZSB8QUNDRVBUX1NUUklOR3wgYW5kXG4gICAgICAgICAqIHNhdmUgb25lIHxzdWJzdHJ8IGNhbGwgdGhhdCB3b3VsZCBiZSBuZWVkZWQgaWYgd2UgdXNlZCB8QUNDRVBUX058LlxuICAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuIGJ1aWxkQ29uZGl0aW9uKFxuICAgICAgICAgIG5vZGUuaWdub3JlQ2FzZVxuICAgICAgICAgICAgPyBbb3AuTUFUQ0hfU1RSSU5HX0lDLCBzdHJpbmdJbmRleF1cbiAgICAgICAgICAgIDogW29wLk1BVENIX1NUUklORywgc3RyaW5nSW5kZXhdLFxuICAgICAgICAgIG5vZGUuaWdub3JlQ2FzZVxuICAgICAgICAgICAgPyBbb3AuQUNDRVBUX04sIG5vZGUudmFsdWUubGVuZ3RoXVxuICAgICAgICAgICAgOiBbb3AuQUNDRVBUX1NUUklORywgc3RyaW5nSW5kZXhdLFxuICAgICAgICAgIFtvcC5GQUlMLCBleHBlY3RlZEluZGV4XVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RyaW5nSW5kZXggPSBhZGRDb25zdCgnXCJcIicpO1xuXG4gICAgICAgIHJldHVybiBbb3AuUFVTSCwgc3RyaW5nSW5kZXhdO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBcImNsYXNzXCI6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHZhciByZWdleHAsIHJlZ2V4cEluZGV4LCBleHBlY3RlZEluZGV4O1xuXG4gICAgICBpZiAobm9kZS5wYXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJlZ2V4cCA9ICcvXlsnXG4gICAgICAgICAgKyAobm9kZS5pbnZlcnRlZCA/ICdeJyA6ICcnKVxuICAgICAgICAgICsgdXRpbHMubWFwKG5vZGUucGFydHMsIGZ1bmN0aW9uKHBhcnQpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gdXRpbHMucXVvdGVGb3JSZWdleHBDbGFzcyhwYXJ0WzBdKVxuICAgICAgICAgICAgICAgICAgKyAnLSdcbiAgICAgICAgICAgICAgICAgICsgdXRpbHMucXVvdGVGb3JSZWdleHBDbGFzcyhwYXJ0WzFdKVxuICAgICAgICAgICAgICAgIDogdXRpbHMucXVvdGVGb3JSZWdleHBDbGFzcyhwYXJ0KTtcbiAgICAgICAgICAgIH0pLmpvaW4oJycpXG4gICAgICAgICAgKyAnXS8nICsgKG5vZGUuaWdub3JlQ2FzZSA/ICdpJyA6ICcnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIElFIGNvbnNpZGVycyByZWdleHBzIC9bXS8gYW5kIC9bXl0vIGFzIHN5bnRhY3RpY2FsbHkgaW52YWxpZCwgc28gd2VcbiAgICAgICAgICogdHJhbnNsYXRlIHRoZW0gaW50byBldXFpdmFsZW50cyBpdCBjYW4gaGFuZGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVnZXhwID0gbm9kZS5pbnZlcnRlZCA/ICcvXltcXFxcU1xcXFxzXS8nIDogJy9eKD8hKS8nO1xuICAgICAgfVxuXG4gICAgICByZWdleHBJbmRleCAgID0gYWRkQ29uc3QocmVnZXhwKTtcbiAgICAgIGV4cGVjdGVkSW5kZXggPSBhZGRDb25zdChbXG4gICAgICAgICd7JyxcbiAgICAgICAgJ3R5cGU6IFwiY2xhc3NcIiwnLFxuICAgICAgICAndmFsdWU6ICcgKyB1dGlscy5xdW90ZShub2RlLnJhd1RleHQpICsgJywnLFxuICAgICAgICAnZGVzY3JpcHRpb246ICcgKyB1dGlscy5xdW90ZShub2RlLnJhd1RleHQpLFxuICAgICAgICAnfSdcbiAgICAgIF0uam9pbignICcpKTtcblxuICAgICAgcmV0dXJuIGJ1aWxkQ29uZGl0aW9uKFxuICAgICAgICBbb3AuTUFUQ0hfUkVHRVhQLCByZWdleHBJbmRleF0sXG4gICAgICAgIFtvcC5BQ0NFUFRfTiwgMV0sXG4gICAgICAgIFtvcC5GQUlMLCBleHBlY3RlZEluZGV4XVxuICAgICAgKTtcbiAgICB9LFxuXG4gICAgYW55OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBleHBlY3RlZEluZGV4ID0gYWRkQ29uc3QoJ3sgdHlwZTogXCJhbnlcIiwgZGVzY3JpcHRpb246IFwiYW55IGNoYXJhY3RlclwiIH0nKTtcblxuICAgICAgcmV0dXJuIGJ1aWxkQ29uZGl0aW9uKFxuICAgICAgICBbb3AuTUFUQ0hfQU5ZXSxcbiAgICAgICAgW29wLkFDQ0VQVF9OLCAxXSxcbiAgICAgICAgW29wLkZBSUwsIGV4cGVjdGVkSW5kZXhdXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgZ2VuZXJhdGUoYXN0KTtcbn07XG4iLCJ2YXIgdXRpbHMgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIiksXG4gICAgb3AgICAgPSByZXF1aXJlKFwiLi4vb3Bjb2Rlc1wiKTtcblxuLyogR2VuZXJhdGVzIHBhcnNlciBKYXZhU2NyaXB0IGNvZGUuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFzdCwgb3B0aW9ucykge1xuICAvKiBUaGVzZSBvbmx5IGluZGVudCBub24tZW1wdHkgbGluZXMgdG8gYXZvaWQgdHJhaWxpbmcgd2hpdGVzcGFjZS4gKi9cbiAgZnVuY3Rpb24gaW5kZW50Mihjb2RlKSAgeyByZXR1cm4gY29kZS5yZXBsYWNlKC9eKC4rKSQvZ20sICcgICQxJyk7ICAgICAgICAgfVxuICBmdW5jdGlvbiBpbmRlbnQ0KGNvZGUpICB7IHJldHVybiBjb2RlLnJlcGxhY2UoL14oLispJC9nbSwgJyAgICAkMScpOyAgICAgICB9XG4gIGZ1bmN0aW9uIGluZGVudDgoY29kZSkgIHsgcmV0dXJuIGNvZGUucmVwbGFjZSgvXiguKykkL2dtLCAnICAgICAgICAkMScpOyAgIH1cbiAgZnVuY3Rpb24gaW5kZW50MTAoY29kZSkgeyByZXR1cm4gY29kZS5yZXBsYWNlKC9eKC4rKSQvZ20sICcgICAgICAgICAgJDEnKTsgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVGFibGVzKCkge1xuICAgIGlmIChvcHRpb25zLm9wdGltaXplID09PSBcInNpemVcIikge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ3BlZyRjb25zdHMgPSBbJyxcbiAgICAgICAgICAgaW5kZW50Mihhc3QuY29uc3RzLmpvaW4oJyxcXG4nKSksXG4gICAgICAgICddLCcsXG4gICAgICAgICcnLFxuICAgICAgICAncGVnJGJ5dGVjb2RlID0gWycsXG4gICAgICAgICAgIGluZGVudDIodXRpbHMubWFwKFxuICAgICAgICAgICAgIGFzdC5ydWxlcyxcbiAgICAgICAgICAgICBmdW5jdGlvbihydWxlKSB7XG4gICAgICAgICAgICAgICByZXR1cm4gJ3BlZyRkZWNvZGUoJ1xuICAgICAgICAgICAgICAgICAgICAgKyB1dGlscy5xdW90ZSh1dGlscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgcnVsZS5ieXRlY29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihiKSB7IHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKGIgKyAzMik7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgKS5qb2luKCcnKSlcbiAgICAgICAgICAgICAgICAgICAgICsgJyknO1xuICAgICAgICAgICAgIH1cbiAgICAgICAgICAgKS5qb2luKCcsXFxuJykpLFxuICAgICAgICAnXSwnXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdXRpbHMubWFwKFxuICAgICAgICBhc3QuY29uc3RzLFxuICAgICAgICBmdW5jdGlvbihjLCBpKSB7IHJldHVybiAncGVnJGMnICsgaSArICcgPSAnICsgYyArICcsJzsgfVxuICAgICAgKS5qb2luKCdcXG4nKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZUNhY2hlSGVhZGVyKHJ1bGVJbmRleENvZGUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgJ3ZhciBrZXkgICAgPSBwZWckY3VyclBvcyAqICcgKyBhc3QucnVsZXMubGVuZ3RoICsgJyArICcgKyBydWxlSW5kZXhDb2RlICsgJywnLFxuICAgICAgJyAgICBjYWNoZWQgPSBwZWckY2FjaGVba2V5XTsnLFxuICAgICAgJycsXG4gICAgICAnaWYgKGNhY2hlZCkgeycsXG4gICAgICAnICBwZWckY3VyclBvcyA9IGNhY2hlZC5uZXh0UG9zOycsXG4gICAgICAnICByZXR1cm4gY2FjaGVkLnJlc3VsdDsnLFxuICAgICAgJ30nLFxuICAgICAgJydcbiAgICBdLmpvaW4oJ1xcbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gZ2VuZXJhdGVDYWNoZUZvb3RlcihyZXN1bHRDb2RlKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICcnLFxuICAgICAgJ3BlZyRjYWNoZVtrZXldID0geyBuZXh0UG9zOiBwZWckY3VyclBvcywgcmVzdWx0OiAnICsgcmVzdWx0Q29kZSArICcgfTsnXG4gICAgXS5qb2luKCdcXG4nKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdlbmVyYXRlSW50ZXJwcmV0ZXIoKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICBmdW5jdGlvbiBnZW5lcmF0ZUNvbmRpdGlvbihjb25kLCBhcmdzTGVuZ3RoKSB7XG4gICAgICB2YXIgYmFzZUxlbmd0aCAgICAgID0gYXJnc0xlbmd0aCArIDMsXG4gICAgICAgICAgdGhlbkxlbmd0aENvZGUgPSAnYmNbaXAgKyAnICsgKGJhc2VMZW5ndGggLSAyKSArICddJyxcbiAgICAgICAgICBlbHNlTGVuZ3RoQ29kZSA9ICdiY1tpcCArICcgKyAoYmFzZUxlbmd0aCAtIDEpICsgJ10nO1xuXG4gICAgICByZXR1cm4gW1xuICAgICAgICAnZW5kcy5wdXNoKGVuZCk7JyxcbiAgICAgICAgJ2lwcy5wdXNoKGlwICsgJyArIGJhc2VMZW5ndGggKyAnICsgJyArIHRoZW5MZW5ndGhDb2RlICsgJyArICcgKyBlbHNlTGVuZ3RoQ29kZSArICcpOycsXG4gICAgICAgICcnLFxuICAgICAgICAnaWYgKCcgKyBjb25kICsgJykgeycsXG4gICAgICAgICcgIGVuZCA9IGlwICsgJyArIGJhc2VMZW5ndGggKyAnICsgJyArIHRoZW5MZW5ndGhDb2RlICsgJzsnLFxuICAgICAgICAnICBpcCArPSAnICsgYmFzZUxlbmd0aCArICc7JyxcbiAgICAgICAgJ30gZWxzZSB7JyxcbiAgICAgICAgJyAgZW5kID0gaXAgKyAnICsgYmFzZUxlbmd0aCArICcgKyAnICsgdGhlbkxlbmd0aENvZGUgKyAnICsgJyArIGVsc2VMZW5ndGhDb2RlICsgJzsnLFxuICAgICAgICAnICBpcCArPSAnICsgYmFzZUxlbmd0aCArICcgKyAnICsgdGhlbkxlbmd0aENvZGUgKyAnOycsXG4gICAgICAgICd9JyxcbiAgICAgICAgJycsXG4gICAgICAgICdicmVhazsnXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdlbmVyYXRlTG9vcChjb25kKSB7XG4gICAgICB2YXIgYmFzZUxlbmd0aCAgICAgPSAyLFxuICAgICAgICAgIGJvZHlMZW5ndGhDb2RlID0gJ2JjW2lwICsgJyArIChiYXNlTGVuZ3RoIC0gMSkgKyAnXSc7XG5cbiAgICAgIHJldHVybiBbXG4gICAgICAgICdpZiAoJyArIGNvbmQgKyAnKSB7JyxcbiAgICAgICAgJyAgZW5kcy5wdXNoKGVuZCk7JyxcbiAgICAgICAgJyAgaXBzLnB1c2goaXApOycsXG4gICAgICAgICcnLFxuICAgICAgICAnICBlbmQgPSBpcCArICcgKyBiYXNlTGVuZ3RoICsgJyArICcgKyBib2R5TGVuZ3RoQ29kZSArICc7JyxcbiAgICAgICAgJyAgaXAgKz0gJyArIGJhc2VMZW5ndGggKyAnOycsXG4gICAgICAgICd9IGVsc2UgeycsXG4gICAgICAgICcgIGlwICs9ICcgKyBiYXNlTGVuZ3RoICsgJyArICcgKyBib2R5TGVuZ3RoQ29kZSArICc7JyxcbiAgICAgICAgJ30nLFxuICAgICAgICAnJyxcbiAgICAgICAgJ2JyZWFrOydcbiAgICAgIF0uam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2VuZXJhdGVDYWxsKCkge1xuICAgICAgdmFyIGJhc2VMZW5ndGggICAgICAgPSA0LFxuICAgICAgICAgIHBhcmFtc0xlbmd0aENvZGUgPSAnYmNbaXAgKyAnICsgKGJhc2VMZW5ndGggLSAxKSArICddJztcblxuICAgICAgcmV0dXJuIFtcbiAgICAgICAgJ3BhcmFtcyA9IGJjLnNsaWNlKGlwICsgJyArIGJhc2VMZW5ndGggKyAnLCBpcCArICcgKyBiYXNlTGVuZ3RoICsgJyArICcgKyBwYXJhbXNMZW5ndGhDb2RlICsgJyk7JyxcbiAgICAgICAgJ2ZvciAoaSA9IDA7IGkgPCAnICsgcGFyYW1zTGVuZ3RoQ29kZSArICc7IGkrKykgeycsXG4gICAgICAgICcgIHBhcmFtc1tpXSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBwYXJhbXNbaV1dOycsXG4gICAgICAgICd9JyxcbiAgICAgICAgJycsXG4gICAgICAgICdzdGFjay5zcGxpY2UoJyxcbiAgICAgICAgJyAgc3RhY2subGVuZ3RoIC0gYmNbaXAgKyAyXSwnLFxuICAgICAgICAnICBiY1tpcCArIDJdLCcsXG4gICAgICAgICcgIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0uYXBwbHkobnVsbCwgcGFyYW1zKScsXG4gICAgICAgICcpOycsXG4gICAgICAgICcnLFxuICAgICAgICAnaXAgKz0gJyArIGJhc2VMZW5ndGggKyAnICsgJyArIHBhcmFtc0xlbmd0aENvZGUgKyAnOycsXG4gICAgICAgICdicmVhazsnXG4gICAgICBdLmpvaW4oJ1xcbicpO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2goW1xuICAgICAgJ2Z1bmN0aW9uIHBlZyRkZWNvZGUocykgeycsXG4gICAgICAnICB2YXIgYmMgPSBuZXcgQXJyYXkocy5sZW5ndGgpLCBpOycsXG4gICAgICAnJyxcbiAgICAgICcgIGZvciAoaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7JyxcbiAgICAgICcgICAgYmNbaV0gPSBzLmNoYXJDb2RlQXQoaSkgLSAzMjsnLFxuICAgICAgJyAgfScsXG4gICAgICAnJyxcbiAgICAgICcgIHJldHVybiBiYzsnLFxuICAgICAgJ30nLFxuICAgICAgJycsXG4gICAgICAnZnVuY3Rpb24gcGVnJHBhcnNlUnVsZShpbmRleCkgeycsXG4gICAgICAnICB2YXIgYmMgICAgPSBwZWckYnl0ZWNvZGVbaW5kZXhdLCcsXG4gICAgICAnICAgICAgaXAgICAgPSAwLCcsXG4gICAgICAnICAgICAgaXBzICAgPSBbXSwnLFxuICAgICAgJyAgICAgIGVuZCAgID0gYmMubGVuZ3RoLCcsXG4gICAgICAnICAgICAgZW5kcyAgPSBbXSwnLFxuICAgICAgJyAgICAgIHN0YWNrID0gW10sJyxcbiAgICAgICcgICAgICBwYXJhbXMsIGk7JyxcbiAgICAgICcnXG4gICAgXS5qb2luKCdcXG4nKSk7XG5cbiAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgcGFydHMucHVzaChpbmRlbnQyKGdlbmVyYXRlQ2FjaGVIZWFkZXIoJ2luZGV4JykpKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKFtcbiAgICAgICcgIGZ1bmN0aW9uIHByb3RlY3Qob2JqZWN0KSB7JyxcbiAgICAgICcgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkob2JqZWN0KSA9PT0gXCJbb2JqZWN0IEFycmF5XVwiID8gW10gOiBvYmplY3Q7JyxcbiAgICAgICcgIH0nLFxuICAgICAgJycsXG4gICAgICAvKlxuICAgICAgICogVGhlIHBvaW50IG9mIHRoZSBvdXRlciBsb29wIGFuZCB0aGUgfGlwc3wgJiB8ZW5kc3wgc3RhY2tzIGlzIHRvIGF2b2lkXG4gICAgICAgKiByZWN1cnNpdmUgY2FsbHMgZm9yIGludGVycHJldGluZyBwYXJ0cyBvZiBieXRlY29kZS4gSW4gb3RoZXIgd29yZHMsIHdlXG4gICAgICAgKiBpbXBsZW1lbnQgdGhlIHxpbnRlcnByZXR8IG9wZXJhdGlvbiBvZiB0aGUgYWJzdHJhY3QgbWFjaGluZSB3aXRob3V0XG4gICAgICAgKiBmdW5jdGlvbiBjYWxscy4gU3VjaCBjYWxscyB3b3VsZCBsaWtlbHkgc2xvdyB0aGUgcGFyc2VyIGRvd24gYW5kIG1vcmVcbiAgICAgICAqIGltcG9ydGFudGx5IGNhdXNlIHN0YWNrIG92ZXJmbG93cyBmb3IgY29tcGxleCBncmFtbWFycy5cbiAgICAgICAqL1xuICAgICAgJyAgd2hpbGUgKHRydWUpIHsnLFxuICAgICAgJyAgICB3aGlsZSAoaXAgPCBlbmQpIHsnLFxuICAgICAgJyAgICAgIHN3aXRjaCAoYmNbaXBdKSB7JyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLlBVU0ggKyAnOicsICAgICAgICAgICAgIC8vIFBVU0ggY1xuICAgICAgLypcbiAgICAgICAqIEhhY2s6IE9uZSBvZiB0aGUgY29uc3RhbnRzIGNhbiBiZSBhbiBlbXB0eSBhcnJheS4gSXQgbmVlZHMgdG8gYmUgY2xvbmVkXG4gICAgICAgKiBiZWNhdXNlIGl0IGNhbiBiZSBtb2RpZmllZCBsYXRlciBvbiB0aGUgc3RhY2sgYnkgfEFQUEVORHwuXG4gICAgICAgKi9cbiAgICAgICcgICAgICAgICAgc3RhY2sucHVzaChwcm90ZWN0KHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pKTsnLFxuICAgICAgJyAgICAgICAgICBpcCArPSAyOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLlBVU0hfQ1VSUl9QT1MgKyAnOicsICAgIC8vIFBVU0hfQ1VSUl9QT1NcbiAgICAgICcgICAgICAgICAgc3RhY2sucHVzaChwZWckY3VyclBvcyk7JyxcbiAgICAgICcgICAgICAgICAgaXArKzsnLFxuICAgICAgJyAgICAgICAgICBicmVhazsnLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5QT1AgKyAnOicsICAgICAgICAgICAgICAvLyBQT1BcbiAgICAgICcgICAgICAgICAgc3RhY2sucG9wKCk7JyxcbiAgICAgICcgICAgICAgICAgaXArKzsnLFxuICAgICAgJyAgICAgICAgICBicmVhazsnLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5QT1BfQ1VSUl9QT1MgKyAnOicsICAgICAvLyBQT1BfQ1VSUl9QT1NcbiAgICAgICcgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzdGFjay5wb3AoKTsnLFxuICAgICAgJyAgICAgICAgICBpcCsrOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLlBPUF9OICsgJzonLCAgICAgICAgICAgIC8vIFBPUF9OIG5cbiAgICAgICcgICAgICAgICAgc3RhY2subGVuZ3RoIC09IGJjW2lwICsgMV07JyxcbiAgICAgICcgICAgICAgICAgaXAgKz0gMjsnLFxuICAgICAgJyAgICAgICAgICBicmVhazsnLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5OSVAgKyAnOicsICAgICAgICAgICAgICAvLyBOSVBcbiAgICAgICcgICAgICAgICAgc3RhY2suc3BsaWNlKC0yLCAxKTsnLFxuICAgICAgJyAgICAgICAgICBpcCsrOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLkFQUEVORCArICc6JywgICAgICAgICAgIC8vIEFQUEVORFxuICAgICAgJyAgICAgICAgICBzdGFja1tzdGFjay5sZW5ndGggLSAyXS5wdXNoKHN0YWNrLnBvcCgpKTsnLFxuICAgICAgJyAgICAgICAgICBpcCsrOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLldSQVAgKyAnOicsICAgICAgICAgICAgIC8vIFdSQVAgblxuICAgICAgJyAgICAgICAgICBzdGFjay5wdXNoKHN0YWNrLnNwbGljZShzdGFjay5sZW5ndGggLSBiY1tpcCArIDFdLCBiY1tpcCArIDFdKSk7JyxcbiAgICAgICcgICAgICAgICAgaXAgKz0gMjsnLFxuICAgICAgJyAgICAgICAgICBicmVhazsnLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5URVhUICsgJzonLCAgICAgICAgICAgICAvLyBURVhUXG4gICAgICAnICAgICAgICAgIHN0YWNrLnBvcCgpOycsXG4gICAgICAnICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyaW5nKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdLCBwZWckY3VyclBvcykpOycsXG4gICAgICAnICAgICAgICAgIGlwKys7JyxcbiAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuSUYgKyAnOicsICAgICAgICAgICAgICAgLy8gSUYgdCwgZlxuICAgICAgICAgICAgICAgICBpbmRlbnQxMChnZW5lcmF0ZUNvbmRpdGlvbignc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0nLCAwKSksXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLklGX0VSUk9SICsgJzonLCAgICAgICAgIC8vIElGX0VSUk9SIHQsIGZcbiAgICAgICAgICAgICAgICAgaW5kZW50MTAoZ2VuZXJhdGVDb25kaXRpb24oXG4gICAgICAgICAgICAgICAgICAgJ3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBwZWckRkFJTEVEJyxcbiAgICAgICAgICAgICAgICAgICAwXG4gICAgICAgICAgICAgICAgICkpLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5JRl9OT1RfRVJST1IgKyAnOicsICAgICAvLyBJRl9OT1RfRVJST1IgdCwgZlxuICAgICAgICAgICAgICAgICBpbmRlbnQxMChcbiAgICAgICAgICAgICAgICAgICBnZW5lcmF0ZUNvbmRpdGlvbignc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQnLFxuICAgICAgICAgICAgICAgICAgIDBcbiAgICAgICAgICAgICAgICAgKSksXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLldISUxFX05PVF9FUlJPUiArICc6JywgIC8vIFdISUxFX05PVF9FUlJPUiBiXG4gICAgICAgICAgICAgICAgIGluZGVudDEwKGdlbmVyYXRlTG9vcCgnc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gIT09IHBlZyRGQUlMRUQnKSksXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLk1BVENIX0FOWSArICc6JywgICAgICAgIC8vIE1BVENIX0FOWSBhLCBmLCAuLi5cbiAgICAgICAgICAgICAgICAgaW5kZW50MTAoZ2VuZXJhdGVDb25kaXRpb24oJ2lucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zJywgMCkpLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5NQVRDSF9TVFJJTkcgKyAnOicsICAgICAvLyBNQVRDSF9TVFJJTkcgcywgYSwgZiwgLi4uXG4gICAgICAgICAgICAgICAgIGluZGVudDEwKGdlbmVyYXRlQ29uZGl0aW9uKFxuICAgICAgICAgICAgICAgICAgICdpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXScsXG4gICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICApKSxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuTUFUQ0hfU1RSSU5HX0lDICsgJzonLCAgLy8gTUFUQ0hfU1RSSU5HX0lDIHMsIGEsIGYsIC4uLlxuICAgICAgICAgICAgICAgICBpbmRlbnQxMChnZW5lcmF0ZUNvbmRpdGlvbihcbiAgICAgICAgICAgICAgICAgICAnaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBwZWckY29uc3RzW2JjW2lwICsgMV1dLmxlbmd0aCkudG9Mb3dlckNhc2UoKSA9PT0gcGVnJGNvbnN0c1tiY1tpcCArIDFdXScsXG4gICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICApKSxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuTUFUQ0hfUkVHRVhQICsgJzonLCAgICAgLy8gTUFUQ0hfUkVHRVhQIHIsIGEsIGYsIC4uLlxuICAgICAgICAgICAgICAgICBpbmRlbnQxMChnZW5lcmF0ZUNvbmRpdGlvbihcbiAgICAgICAgICAgICAgICAgICAncGVnJGNvbnN0c1tiY1tpcCArIDFdXS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpJyxcbiAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICkpLFxuICAgICAgJycsXG4gICAgICAnICAgICAgICBjYXNlICcgKyBvcC5BQ0NFUFRfTiArICc6JywgICAgICAgICAvLyBBQ0NFUFRfTiBuXG4gICAgICAnICAgICAgICAgIHN0YWNrLnB1c2goaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCBiY1tpcCArIDFdKSk7JyxcbiAgICAgICcgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gYmNbaXAgKyAxXTsnLFxuICAgICAgJyAgICAgICAgICBpcCArPSAyOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLkFDQ0VQVF9TVFJJTkcgKyAnOicsICAgIC8vIEFDQ0VQVF9TVFJJTkcgc1xuICAgICAgJyAgICAgICAgICBzdGFjay5wdXNoKHBlZyRjb25zdHNbYmNbaXAgKyAxXV0pOycsXG4gICAgICAnICAgICAgICAgIHBlZyRjdXJyUG9zICs9IHBlZyRjb25zdHNbYmNbaXAgKyAxXV0ubGVuZ3RoOycsXG4gICAgICAnICAgICAgICAgIGlwICs9IDI7JyxcbiAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuRkFJTCArICc6JywgICAgICAgICAgICAgLy8gRkFJTCBlXG4gICAgICAnICAgICAgICAgIHN0YWNrLnB1c2gocGVnJEZBSUxFRCk7JyxcbiAgICAgICcgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeycsXG4gICAgICAnICAgICAgICAgICAgcGVnJGZhaWwocGVnJGNvbnN0c1tiY1tpcCArIDFdXSk7JyxcbiAgICAgICcgICAgICAgICAgfScsXG4gICAgICAnICAgICAgICAgIGlwICs9IDI7JyxcbiAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuUkVQT1JUX1NBVkVEX1BPUyArICc6JywgLy8gUkVQT1JUX1NBVkVEX1BPUyBwXG4gICAgICAnICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDEgLSBiY1tpcCArIDFdXTsnLFxuICAgICAgJyAgICAgICAgICBpcCArPSAyOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLlJFUE9SVF9DVVJSX1BPUyArICc6JywgIC8vIFJFUE9SVF9DVVJSX1BPU1xuICAgICAgJyAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBwZWckY3VyclBvczsnLFxuICAgICAgJyAgICAgICAgICBpcCsrOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLkNBTEwgKyAnOicsICAgICAgICAgICAgIC8vIENBTEwgZiwgbiwgcGMsIHAxLCBwMiwgLi4uLCBwTlxuICAgICAgICAgICAgICAgICBpbmRlbnQxMChnZW5lcmF0ZUNhbGwoKSksXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGNhc2UgJyArIG9wLlJVTEUgKyAnOicsICAgICAgICAgICAgIC8vIFJVTEUgclxuICAgICAgJyAgICAgICAgICBzdGFjay5wdXNoKHBlZyRwYXJzZVJ1bGUoYmNbaXAgKyAxXSkpOycsXG4gICAgICAnICAgICAgICAgIGlwICs9IDI7JyxcbiAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuU0lMRU5UX0ZBSUxTX09OICsgJzonLCAgLy8gU0lMRU5UX0ZBSUxTX09OXG4gICAgICAnICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrOycsXG4gICAgICAnICAgICAgICAgIGlwKys7JyxcbiAgICAgICcgICAgICAgICAgYnJlYWs7JyxcbiAgICAgICcnLFxuICAgICAgJyAgICAgICAgY2FzZSAnICsgb3AuU0lMRU5UX0ZBSUxTX09GRiArICc6JywgLy8gU0lMRU5UX0ZBSUxTX09GRlxuICAgICAgJyAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTsnLFxuICAgICAgJyAgICAgICAgICBpcCsrOycsXG4gICAgICAnICAgICAgICAgIGJyZWFrOycsXG4gICAgICAnJyxcbiAgICAgICcgICAgICAgIGRlZmF1bHQ6JyxcbiAgICAgICcgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBvcGNvZGU6IFwiICsgYmNbaXBdICsgXCIuXCIpOycsXG4gICAgICAnICAgICAgfScsXG4gICAgICAnICAgIH0nLFxuICAgICAgJycsXG4gICAgICAnICAgIGlmIChlbmRzLmxlbmd0aCA+IDApIHsnLFxuICAgICAgJyAgICAgIGVuZCA9IGVuZHMucG9wKCk7JyxcbiAgICAgICcgICAgICBpcCA9IGlwcy5wb3AoKTsnLFxuICAgICAgJyAgICB9IGVsc2UgeycsXG4gICAgICAnICAgICAgYnJlYWs7JyxcbiAgICAgICcgICAgfScsXG4gICAgICAnICB9J1xuICAgIF0uam9pbignXFxuJykpO1xuXG4gICAgaWYgKG9wdGlvbnMuY2FjaGUpIHtcbiAgICAgIHBhcnRzLnB1c2goaW5kZW50MihnZW5lcmF0ZUNhY2hlRm9vdGVyKCdzdGFja1swXScpKSk7XG4gICAgfVxuXG4gICAgcGFydHMucHVzaChbXG4gICAgICAnJyxcbiAgICAgICcgIHJldHVybiBzdGFja1swXTsnLFxuICAgICAgJ30nXG4gICAgXS5qb2luKCdcXG4nKSk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH1cblxuICBmdW5jdGlvbiBnZW5lcmF0ZVJ1bGVGdW5jdGlvbihydWxlKSB7XG4gICAgdmFyIHBhcnRzID0gW10sIGNvZGU7XG5cbiAgICBmdW5jdGlvbiBjKGkpIHsgcmV0dXJuIFwicGVnJGNcIiArIGk7IH0gLy8gfGNvbnN0c1tpXXwgb2YgdGhlIGFic3RyYWN0IG1hY2hpbmVcbiAgICBmdW5jdGlvbiBzKGkpIHsgcmV0dXJuIFwic1wiICAgICArIGk7IH0gLy8gfHN0YWNrW2ldfCBvZiB0aGUgYWJzdHJhY3QgbWFjaGluZVxuXG4gICAgdmFyIHN0YWNrID0ge1xuICAgICAgICAgIHNwOiAgICAtMSxcbiAgICAgICAgICBtYXhTcDogLTEsXG5cbiAgICAgICAgICBwdXNoOiBmdW5jdGlvbihleHByQ29kZSkge1xuICAgICAgICAgICAgdmFyIGNvZGUgPSBzKCsrdGhpcy5zcCkgKyAnID0gJyArIGV4cHJDb2RlICsgJzsnO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5zcCA+IHRoaXMubWF4U3ApIHsgdGhpcy5tYXhTcCA9IHRoaXMuc3A7IH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHBvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbiwgdmFsdWVzO1xuXG4gICAgICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICByZXR1cm4gcyh0aGlzLnNwLS0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbiA9IGFyZ3VtZW50c1swXTtcbiAgICAgICAgICAgICAgdmFsdWVzID0gdXRpbHMubWFwKHV0aWxzLnJhbmdlKHRoaXMuc3AgLSBuICsgMSwgdGhpcy5zcCArIDEpLCBzKTtcbiAgICAgICAgICAgICAgdGhpcy5zcCAtPSBuO1xuXG4gICAgICAgICAgICAgIHJldHVybiB2YWx1ZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSxcblxuICAgICAgICAgIHRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcyh0aGlzLnNwKTtcbiAgICAgICAgICB9LFxuXG4gICAgICAgICAgaW5kZXg6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgICAgIHJldHVybiBzKHRoaXMuc3AgLSBpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICBmdW5jdGlvbiBjb21waWxlKGJjKSB7XG4gICAgICB2YXIgaXAgICAgPSAwLFxuICAgICAgICAgIGVuZCAgID0gYmMubGVuZ3RoLFxuICAgICAgICAgIHBhcnRzID0gW10sXG4gICAgICAgICAgdmFsdWU7XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVDb25kaXRpb24oY29uZCwgYXJnQ291bnQpIHtcbiAgICAgICAgdmFyIGJhc2VMZW5ndGggPSBhcmdDb3VudCArIDMsXG4gICAgICAgICAgICB0aGVuTGVuZ3RoID0gYmNbaXAgKyBiYXNlTGVuZ3RoIC0gMl0sXG4gICAgICAgICAgICBlbHNlTGVuZ3RoID0gYmNbaXAgKyBiYXNlTGVuZ3RoIC0gMV0sXG4gICAgICAgICAgICBiYXNlU3AgICAgID0gc3RhY2suc3AsXG4gICAgICAgICAgICB0aGVuQ29kZSwgZWxzZUNvZGUsIHRoZW5TcCwgZWxzZVNwO1xuXG4gICAgICAgIGlwICs9IGJhc2VMZW5ndGg7XG4gICAgICAgIHRoZW5Db2RlID0gY29tcGlsZShiYy5zbGljZShpcCwgaXAgKyB0aGVuTGVuZ3RoKSk7XG4gICAgICAgIHRoZW5TcCA9IHN0YWNrLnNwO1xuICAgICAgICBpcCArPSB0aGVuTGVuZ3RoO1xuXG4gICAgICAgIGlmIChlbHNlTGVuZ3RoID4gMCkge1xuICAgICAgICAgIHN0YWNrLnNwID0gYmFzZVNwO1xuICAgICAgICAgIGVsc2VDb2RlID0gY29tcGlsZShiYy5zbGljZShpcCwgaXAgKyBlbHNlTGVuZ3RoKSk7XG4gICAgICAgICAgZWxzZVNwID0gc3RhY2suc3A7XG4gICAgICAgICAgaXAgKz0gZWxzZUxlbmd0aDtcblxuICAgICAgICAgIGlmICh0aGVuU3AgIT09IGVsc2VTcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBcIkJyYW5jaGVzIG9mIGEgY29uZGl0aW9uIG11c3QgbW92ZSB0aGUgc3RhY2sgcG9pbnRlciBpbiB0aGUgc2FtZSB3YXkuXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcGFydHMucHVzaCgnaWYgKCcgKyBjb25kICsgJykgeycpO1xuICAgICAgICBwYXJ0cy5wdXNoKGluZGVudDIodGhlbkNvZGUpKTtcbiAgICAgICAgaWYgKGVsc2VMZW5ndGggPiAwKSB7XG4gICAgICAgICAgcGFydHMucHVzaCgnfSBlbHNlIHsnKTtcbiAgICAgICAgICBwYXJ0cy5wdXNoKGluZGVudDIoZWxzZUNvZGUpKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJ0cy5wdXNoKCd9Jyk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNvbXBpbGVMb29wKGNvbmQpIHtcbiAgICAgICAgdmFyIGJhc2VMZW5ndGggPSAyLFxuICAgICAgICAgICAgYm9keUxlbmd0aCA9IGJjW2lwICsgYmFzZUxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgYmFzZVNwICAgICA9IHN0YWNrLnNwLFxuICAgICAgICAgICAgYm9keUNvZGUsIGJvZHlTcDtcblxuICAgICAgICBpcCArPSBiYXNlTGVuZ3RoO1xuICAgICAgICBib2R5Q29kZSA9IGNvbXBpbGUoYmMuc2xpY2UoaXAsIGlwICsgYm9keUxlbmd0aCkpO1xuICAgICAgICBib2R5U3AgPSBzdGFjay5zcDtcbiAgICAgICAgaXAgKz0gYm9keUxlbmd0aDtcblxuICAgICAgICBpZiAoYm9keVNwICE9PSBiYXNlU3ApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCb2R5IG9mIGEgbG9vcCBjYW4ndCBtb3ZlIHRoZSBzdGFjayBwb2ludGVyLlwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcnRzLnB1c2goJ3doaWxlICgnICsgY29uZCArICcpIHsnKTtcbiAgICAgICAgcGFydHMucHVzaChpbmRlbnQyKGJvZHlDb2RlKSk7XG4gICAgICAgIHBhcnRzLnB1c2goJ30nKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY29tcGlsZUNhbGwoKSB7XG4gICAgICAgIHZhciBiYXNlTGVuZ3RoICAgPSA0LFxuICAgICAgICAgICAgcGFyYW1zTGVuZ3RoID0gYmNbaXAgKyBiYXNlTGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIHZhbHVlID0gYyhiY1tpcCArIDFdKSArICcoJ1xuICAgICAgICAgICAgICArIHV0aWxzLm1hcChcbiAgICAgICAgICAgICAgICAgIGJjLnNsaWNlKGlwICsgYmFzZUxlbmd0aCwgaXAgKyBiYXNlTGVuZ3RoICsgcGFyYW1zTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgIHN0YWNrSW5kZXhcbiAgICAgICAgICAgICAgICApLmpvaW4oJywgJylcbiAgICAgICAgICAgICAgKyAnKSc7XG4gICAgICAgIHN0YWNrLnBvcChiY1tpcCArIDJdKTtcbiAgICAgICAgcGFydHMucHVzaChzdGFjay5wdXNoKHZhbHVlKSk7XG4gICAgICAgIGlwICs9IGJhc2VMZW5ndGggKyBwYXJhbXNMZW5ndGg7XG4gICAgICB9XG5cbiAgICAgIC8qXG4gICAgICAgKiBFeHRyYWN0ZWQgaW50byBhIGZ1bmN0aW9uIGp1c3QgdG8gc2lsZW5jZSBKU0hpbnQgY29tcGxhaW5pbmcgYWJvdXRcbiAgICAgICAqIGNyZWF0aW5nIGZ1bmN0aW9ucyBpbiBhIGxvb3AuXG4gICAgICAgKi9cbiAgICAgIGZ1bmN0aW9uIHN0YWNrSW5kZXgocCkge1xuICAgICAgICByZXR1cm4gc3RhY2suaW5kZXgocCk7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChpcCA8IGVuZCkge1xuICAgICAgICBzd2l0Y2ggKGJjW2lwXSkge1xuICAgICAgICAgIGNhc2Ugb3AuUFVTSDogICAgICAgICAgICAgLy8gUFVTSCBjXG4gICAgICAgICAgICAvKlxuICAgICAgICAgICAgICogSGFjazogT25lIG9mIHRoZSBjb25zdGFudHMgY2FuIGJlIGFuIGVtcHR5IGFycmF5LiBJdCBuZWVkcyB0byBiZVxuICAgICAgICAgICAgICogaGFuZGxlZCBzcGVjaWFsbHkgYmVjYXVzZSBpdCBjYW4gYmUgbW9kaWZpZWQgbGF0ZXIgb24gdGhlIHN0YWNrXG4gICAgICAgICAgICAgKiBieSB8QVBQRU5EfC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcGFydHMucHVzaChcbiAgICAgICAgICAgICAgc3RhY2sucHVzaChhc3QuY29uc3RzW2JjW2lwICsgMV1dID09PSBcIltdXCIgPyBcIltdXCIgOiBjKGJjW2lwICsgMV0pKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuUFVTSF9DVVJSX1BPUzogICAgLy8gUFVTSF9DVVJSX1BPU1xuICAgICAgICAgICAgcGFydHMucHVzaChzdGFjay5wdXNoKCdwZWckY3VyclBvcycpKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuUE9QOiAgICAgICAgICAgICAgLy8gUE9QXG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuUE9QX0NVUlJfUE9TOiAgICAgLy8gUE9QX0NVUlJfUE9TXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdwZWckY3VyclBvcyA9ICcgKyBzdGFjay5wb3AoKSArICc7Jyk7XG4gICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLlBPUF9OOiAgICAgICAgICAgIC8vIFBPUF9OIG5cbiAgICAgICAgICAgIHN0YWNrLnBvcChiY1tpcCArIDFdKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuTklQOiAgICAgICAgICAgICAgLy8gTklQXG4gICAgICAgICAgICB2YWx1ZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHN0YWNrLnB1c2godmFsdWUpKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuQVBQRU5EOiAgICAgICAgICAgLy8gQVBQRU5EXG4gICAgICAgICAgICB2YWx1ZSA9IHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgcGFydHMucHVzaChzdGFjay50b3AoKSArICcucHVzaCgnICsgdmFsdWUgKyAnKTsnKTtcbiAgICAgICAgICAgIGlwKys7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuV1JBUDogICAgICAgICAgICAgLy8gV1JBUCBuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICBzdGFjay5wdXNoKCdbJyArIHN0YWNrLnBvcChiY1tpcCArIDFdKS5qb2luKCcsICcpICsgJ10nKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuVEVYVDogICAgICAgICAgICAgLy8gVEVYVFxuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKFxuICAgICAgICAgICAgICBzdGFjay5wdXNoKCdpbnB1dC5zdWJzdHJpbmcoJyArIHN0YWNrLnRvcCgpICsgJywgcGVnJGN1cnJQb3MpJylcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLklGOiAgICAgICAgICAgICAgIC8vIElGIHQsIGZcbiAgICAgICAgICAgIGNvbXBpbGVDb25kaXRpb24oc3RhY2sudG9wKCksIDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLklGX0VSUk9SOiAgICAgICAgIC8vIElGX0VSUk9SIHQsIGZcbiAgICAgICAgICAgIGNvbXBpbGVDb25kaXRpb24oc3RhY2sudG9wKCkgKyAnID09PSBwZWckRkFJTEVEJywgMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuSUZfTk9UX0VSUk9SOiAgICAgLy8gSUZfTk9UX0VSUk9SIHQsIGZcbiAgICAgICAgICAgIGNvbXBpbGVDb25kaXRpb24oc3RhY2sudG9wKCkgKyAnICE9PSBwZWckRkFJTEVEJywgMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuV0hJTEVfTk9UX0VSUk9SOiAgLy8gV0hJTEVfTk9UX0VSUk9SIGJcbiAgICAgICAgICAgIGNvbXBpbGVMb29wKHN0YWNrLnRvcCgpICsgJyAhPT0gcGVnJEZBSUxFRCcsIDApO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLk1BVENIX0FOWTogICAgICAgIC8vIE1BVENIX0FOWSBhLCBmLCAuLi5cbiAgICAgICAgICAgIGNvbXBpbGVDb25kaXRpb24oJ2lucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zJywgMCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuTUFUQ0hfU1RSSU5HOiAgICAgLy8gTUFUQ0hfU1RSSU5HIHMsIGEsIGYsIC4uLlxuICAgICAgICAgICAgY29tcGlsZUNvbmRpdGlvbihcbiAgICAgICAgICAgICAgZXZhbChhc3QuY29uc3RzW2JjW2lwICsgMV1dKS5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgPyAnaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAnXG4gICAgICAgICAgICAgICAgICAgICsgZXZhbChhc3QuY29uc3RzW2JjW2lwICsgMV1dKS5sZW5ndGhcbiAgICAgICAgICAgICAgICAgICAgKyAnKSA9PT0gJ1xuICAgICAgICAgICAgICAgICAgICArIGMoYmNbaXAgKyAxXSlcbiAgICAgICAgICAgICAgICA6ICdpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gJ1xuICAgICAgICAgICAgICAgICAgICArIGV2YWwoYXN0LmNvbnN0c1tiY1tpcCArIDFdXSkuY2hhckNvZGVBdCgwKSxcbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBvcC5NQVRDSF9TVFJJTkdfSUM6ICAvLyBNQVRDSF9TVFJJTkdfSUMgcywgYSwgZiwgLi4uXG4gICAgICAgICAgICBjb21waWxlQ29uZGl0aW9uKFxuICAgICAgICAgICAgICAnaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAnXG4gICAgICAgICAgICAgICAgKyBldmFsKGFzdC5jb25zdHNbYmNbaXAgKyAxXV0pLmxlbmd0aFxuICAgICAgICAgICAgICAgICsgJykudG9Mb3dlckNhc2UoKSA9PT0gJ1xuICAgICAgICAgICAgICAgICsgYyhiY1tpcCArIDFdKSxcbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBvcC5NQVRDSF9SRUdFWFA6ICAgICAvLyBNQVRDSF9SRUdFWFAgciwgYSwgZiwgLi4uXG4gICAgICAgICAgICBjb21waWxlQ29uZGl0aW9uKFxuICAgICAgICAgICAgICBjKGJjW2lwICsgMV0pICsgJy50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpJyxcbiAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBvcC5BQ0NFUFRfTjogICAgICAgICAvLyBBQ0NFUFRfTiBuXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHN0YWNrLnB1c2goXG4gICAgICAgICAgICAgIGJjW2lwICsgMV0gPiAxXG4gICAgICAgICAgICAgICAgPyAnaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAnICsgYmNbaXAgKyAxXSArICcpJ1xuICAgICAgICAgICAgICAgIDogJ2lucHV0LmNoYXJBdChwZWckY3VyclBvcyknXG4gICAgICAgICAgICApKTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgICAgIGJjW2lwICsgMV0gPiAxXG4gICAgICAgICAgICAgICAgPyAncGVnJGN1cnJQb3MgKz0gJyArIGJjW2lwICsgMV0gKyAnOydcbiAgICAgICAgICAgICAgICA6ICdwZWckY3VyclBvcysrOydcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLkFDQ0VQVF9TVFJJTkc6ICAgIC8vIEFDQ0VQVF9TVFJJTkcgc1xuICAgICAgICAgICAgcGFydHMucHVzaChzdGFjay5wdXNoKGMoYmNbaXAgKyAxXSkpKTtcbiAgICAgICAgICAgIHBhcnRzLnB1c2goXG4gICAgICAgICAgICAgIGV2YWwoYXN0LmNvbnN0c1tiY1tpcCArIDFdXSkubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8gJ3BlZyRjdXJyUG9zICs9ICcgKyBldmFsKGFzdC5jb25zdHNbYmNbaXAgKyAxXV0pLmxlbmd0aCArICc7J1xuICAgICAgICAgICAgICAgIDogJ3BlZyRjdXJyUG9zKys7J1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuRkFJTDogICAgICAgICAgICAgLy8gRkFJTCBlXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHN0YWNrLnB1c2goJ3BlZyRGQUlMRUQnKSk7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKCcgKyBjKGJjW2lwICsgMV0pICsgJyk7IH0nKTtcbiAgICAgICAgICAgIGlwICs9IDI7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuUkVQT1JUX1NBVkVEX1BPUzogLy8gUkVQT1JUX1NBVkVEX1BPUyBwXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCdwZWckcmVwb3J0ZWRQb3MgPSAnICsgc3RhY2suaW5kZXgoYmNbaXAgKyAxXSkgKyAnOycpO1xuICAgICAgICAgICAgaXAgKz0gMjtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBvcC5SRVBPUlRfQ1VSUl9QT1M6ICAvLyBSRVBPUlRfQ1VSUl9QT1NcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ3BlZyRyZXBvcnRlZFBvcyA9IHBlZyRjdXJyUG9zOycpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSBvcC5DQUxMOiAgICAgICAgICAgICAvLyBDQUxMIGYsIG4sIHBjLCBwMSwgcDIsIC4uLiwgcE5cbiAgICAgICAgICAgIGNvbXBpbGVDYWxsKCk7XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgIGNhc2Ugb3AuUlVMRTogICAgICAgICAgICAgLy8gUlVMRSByXG4gICAgICAgICAgICBwYXJ0cy5wdXNoKHN0YWNrLnB1c2goXCJwZWckcGFyc2VcIiArIGFzdC5ydWxlc1tiY1tpcCArIDFdXS5uYW1lICsgXCIoKVwiKSk7XG4gICAgICAgICAgICBpcCArPSAyO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLlNJTEVOVF9GQUlMU19PTjogIC8vIFNJTEVOVF9GQUlMU19PTlxuICAgICAgICAgICAgcGFydHMucHVzaCgncGVnJHNpbGVudEZhaWxzKys7Jyk7XG4gICAgICAgICAgICBpcCsrO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIG9wLlNJTEVOVF9GQUlMU19PRkY6IC8vIFNJTEVOVF9GQUlMU19PRkZcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJ3BlZyRzaWxlbnRGYWlscy0tOycpO1xuICAgICAgICAgICAgaXArKztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgb3Bjb2RlOiBcIiArIGJjW2lwXSArIFwiLlwiKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gICAgfVxuXG4gICAgY29kZSA9IGNvbXBpbGUocnVsZS5ieXRlY29kZSk7XG5cbiAgICBwYXJ0cy5wdXNoKFtcbiAgICAgICdmdW5jdGlvbiBwZWckcGFyc2UnICsgcnVsZS5uYW1lICsgJygpIHsnLFxuICAgICAgJyAgdmFyICcgKyB1dGlscy5tYXAodXRpbHMucmFuZ2UoMCwgc3RhY2subWF4U3AgKyAxKSwgcykuam9pbignLCAnKSArICc7JyxcbiAgICAgICcnXG4gICAgXS5qb2luKCdcXG4nKSk7XG5cbiAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgcGFydHMucHVzaChpbmRlbnQyKFxuICAgICAgICBnZW5lcmF0ZUNhY2hlSGVhZGVyKHV0aWxzLmluZGV4T2ZSdWxlQnlOYW1lKGFzdCwgcnVsZS5uYW1lKSlcbiAgICAgICkpO1xuICAgIH1cblxuICAgIHBhcnRzLnB1c2goaW5kZW50Mihjb2RlKSk7XG5cbiAgICBpZiAob3B0aW9ucy5jYWNoZSkge1xuICAgICAgcGFydHMucHVzaChpbmRlbnQyKGdlbmVyYXRlQ2FjaGVGb290ZXIocygwKSkpKTtcbiAgICB9XG5cbiAgICBwYXJ0cy5wdXNoKFtcbiAgICAgICcnLFxuICAgICAgJyAgcmV0dXJuICcgKyBzKDApICsgJzsnLFxuICAgICAgJ30nXG4gICAgXS5qb2luKCdcXG4nKSk7XG5cbiAgICByZXR1cm4gcGFydHMuam9pbignXFxuJyk7XG4gIH1cblxuICB2YXIgcGFydHMgPSBbXSxcbiAgICAgIHN0YXJ0UnVsZUluZGljZXMsICAgc3RhcnRSdWxlSW5kZXgsXG4gICAgICBzdGFydFJ1bGVGdW5jdGlvbnMsIHN0YXJ0UnVsZUZ1bmN0aW9uO1xuXG4gIHBhcnRzLnB1c2goW1xuICAgICcoZnVuY3Rpb24oKSB7JyxcbiAgICAnICAvKicsXG4gICAgJyAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjguMC4nLFxuICAgICcgICAqJyxcbiAgICAnICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovJyxcbiAgICAnICAgKi8nLFxuICAgICcnLFxuICAgICcgIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7JyxcbiAgICAnICAgIGZ1bmN0aW9uIGN0b3IoKSB7IHRoaXMuY29uc3RydWN0b3IgPSBjaGlsZDsgfScsXG4gICAgJyAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7JyxcbiAgICAnICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7JyxcbiAgICAnICB9JyxcbiAgICAnJyxcbiAgICAnICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7JyxcbiAgICAnICAgIHRoaXMubWVzc2FnZSAgPSBtZXNzYWdlOycsXG4gICAgJyAgICB0aGlzLmV4cGVjdGVkID0gZXhwZWN0ZWQ7JyxcbiAgICAnICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDsnLFxuICAgICcgICAgdGhpcy5vZmZzZXQgICA9IG9mZnNldDsnLFxuICAgICcgICAgdGhpcy5saW5lICAgICA9IGxpbmU7JyxcbiAgICAnICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47JyxcbiAgICAnJyxcbiAgICAnICAgIHRoaXMubmFtZSAgICAgPSBcIlN5bnRheEVycm9yXCI7JyxcbiAgICAnICB9JyxcbiAgICAnJyxcbiAgICAnICBwZWckc3ViY2xhc3MoU3ludGF4RXJyb3IsIEVycm9yKTsnLFxuICAgICcnLFxuICAgICcgIGZ1bmN0aW9uIHBhcnNlKGlucHV0KSB7JyxcbiAgICAnICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB7fSwnLFxuICAgICcnLFxuICAgICcgICAgICAgIHBlZyRGQUlMRUQgPSB7fSwnLFxuICAgICcnXG4gIF0uam9pbignXFxuJykpO1xuXG4gIGlmIChvcHRpb25zLm9wdGltaXplID09PSBcInNpemVcIikge1xuICAgIHN0YXJ0UnVsZUluZGljZXMgPSAneyAnXG4gICAgICAgICAgICAgICAgICAgICArIHV0aWxzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmFsbG93ZWRTdGFydFJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKHIpIHsgcmV0dXJuIHIgKyAnOiAnICsgdXRpbHMuaW5kZXhPZlJ1bGVCeU5hbWUoYXN0LCByKTsgfVxuICAgICAgICAgICAgICAgICAgICAgICApLmpvaW4oJywgJylcbiAgICAgICAgICAgICAgICAgICAgICsgJyB9JztcbiAgICBzdGFydFJ1bGVJbmRleCA9IHV0aWxzLmluZGV4T2ZSdWxlQnlOYW1lKGFzdCwgb3B0aW9ucy5hbGxvd2VkU3RhcnRSdWxlc1swXSk7XG5cbiAgICBwYXJ0cy5wdXNoKFtcbiAgICAgICcgICAgICAgIHBlZyRzdGFydFJ1bGVJbmRpY2VzID0gJyArIHN0YXJ0UnVsZUluZGljZXMgKyAnLCcsXG4gICAgICAnICAgICAgICBwZWckc3RhcnRSdWxlSW5kZXggICA9ICcgKyBzdGFydFJ1bGVJbmRleCArICcsJ1xuICAgIF0uam9pbignXFxuJykpO1xuICB9IGVsc2Uge1xuICAgIHN0YXJ0UnVsZUZ1bmN0aW9ucyA9ICd7ICdcbiAgICAgICAgICAgICAgICAgICAgICsgdXRpbHMubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dlZFN0YXJ0UnVsZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24ocikgeyByZXR1cm4gciArICc6IHBlZyRwYXJzZScgKyByOyB9XG4gICAgICAgICAgICAgICAgICAgICAgICkuam9pbignLCAnKVxuICAgICAgICAgICAgICAgICAgICAgKyAnIH0nO1xuICAgIHN0YXJ0UnVsZUZ1bmN0aW9uID0gJ3BlZyRwYXJzZScgKyBvcHRpb25zLmFsbG93ZWRTdGFydFJ1bGVzWzBdO1xuXG4gICAgcGFydHMucHVzaChbXG4gICAgICAnICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb25zID0gJyArIHN0YXJ0UnVsZUZ1bmN0aW9ucyArICcsJyxcbiAgICAgICcgICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiAgPSAnICsgc3RhcnRSdWxlRnVuY3Rpb24gKyAnLCdcbiAgICBdLmpvaW4oJ1xcbicpKTtcbiAgfVxuXG4gIHBhcnRzLnB1c2goJycpO1xuXG4gIHBhcnRzLnB1c2goaW5kZW50OChnZW5lcmF0ZVRhYmxlcygpKSk7XG5cbiAgcGFydHMucHVzaChbXG4gICAgJycsXG4gICAgJyAgICAgICAgcGVnJGN1cnJQb3MgICAgICAgICAgPSAwLCcsXG4gICAgJyAgICAgICAgcGVnJHJlcG9ydGVkUG9zICAgICAgPSAwLCcsXG4gICAgJyAgICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLCcsXG4gICAgJyAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9LCcsXG4gICAgJyAgICAgICAgcGVnJG1heEZhaWxQb3MgICAgICAgPSAwLCcsXG4gICAgJyAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSwnLFxuICAgICcgICAgICAgIHBlZyRzaWxlbnRGYWlscyAgICAgID0gMCwnLCAvLyAwID0gcmVwb3J0IGZhaWx1cmVzLCA+IDAgPSBzaWxlbmNlIGZhaWx1cmVzXG4gICAgJydcbiAgXS5qb2luKCdcXG4nKSk7XG5cbiAgaWYgKG9wdGlvbnMuY2FjaGUpIHtcbiAgICBwYXJ0cy5wdXNoKCcgICAgICAgIHBlZyRjYWNoZSA9IHt9LCcpO1xuICB9XG5cbiAgcGFydHMucHVzaChbXG4gICAgJyAgICAgICAgcGVnJHJlc3VsdDsnLFxuICAgICcnXG4gIF0uam9pbignXFxuJykpO1xuXG4gIGlmIChvcHRpb25zLm9wdGltaXplID09PSBcInNpemVcIikge1xuICAgIHBhcnRzLnB1c2goW1xuICAgICAgJyAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7JyxcbiAgICAgICcgICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlSW5kaWNlcykpIHsnLFxuICAgICAgJyAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFxcXCIuXCIpOycsXG4gICAgICAnICAgICAgfScsXG4gICAgICAnJyxcbiAgICAgICcgICAgICBwZWckc3RhcnRSdWxlSW5kZXggPSBwZWckc3RhcnRSdWxlSW5kaWNlc1tvcHRpb25zLnN0YXJ0UnVsZV07JyxcbiAgICAgICcgICAgfSdcbiAgICBdLmpvaW4oJ1xcbicpKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKFtcbiAgICAgICcgICAgaWYgKFwic3RhcnRSdWxlXCIgaW4gb3B0aW9ucykgeycsXG4gICAgICAnICAgICAgaWYgKCEob3B0aW9ucy5zdGFydFJ1bGUgaW4gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9ucykpIHsnLFxuICAgICAgJyAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuXFwndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFxcXCJcIiArIG9wdGlvbnMuc3RhcnRSdWxlICsgXCJcXFxcXCIuXCIpOycsXG4gICAgICAnICAgICAgfScsXG4gICAgICAnJyxcbiAgICAgICcgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gPSBwZWckc3RhcnRSdWxlRnVuY3Rpb25zW29wdGlvbnMuc3RhcnRSdWxlXTsnLFxuICAgICAgJyAgICB9J1xuICAgIF0uam9pbignXFxuJykpO1xuICB9XG5cbiAgcGFydHMucHVzaChbXG4gICAgJycsXG4gICAgJyAgICBmdW5jdGlvbiB0ZXh0KCkgeycsXG4gICAgJyAgICAgIHJldHVybiBpbnB1dC5zdWJzdHJpbmcocGVnJHJlcG9ydGVkUG9zLCBwZWckY3VyclBvcyk7JyxcbiAgICAnICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgZnVuY3Rpb24gb2Zmc2V0KCkgeycsXG4gICAgJyAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7JyxcbiAgICAnICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgZnVuY3Rpb24gbGluZSgpIHsnLFxuICAgICcgICAgICByZXR1cm4gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBlZyRyZXBvcnRlZFBvcykubGluZTsnLFxuICAgICcgICAgfScsXG4gICAgJycsXG4gICAgJyAgICBmdW5jdGlvbiBjb2x1bW4oKSB7JyxcbiAgICAnICAgICAgcmV0dXJuIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwZWckcmVwb3J0ZWRQb3MpLmNvbHVtbjsnLFxuICAgICcgICAgfScsXG4gICAgJycsXG4gICAgJyAgICBmdW5jdGlvbiBleHBlY3RlZChkZXNjcmlwdGlvbikgeycsXG4gICAgJyAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbignLFxuICAgICcgICAgICAgIG51bGwsJyxcbiAgICAnICAgICAgICBbeyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBkZXNjcmlwdGlvbiB9XSwnLFxuICAgICcgICAgICAgIHBlZyRyZXBvcnRlZFBvcycsXG4gICAgJyAgICAgICk7JyxcbiAgICAnICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgZnVuY3Rpb24gZXJyb3IobWVzc2FnZSkgeycsXG4gICAgJyAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBudWxsLCBwZWckcmVwb3J0ZWRQb3MpOycsXG4gICAgJyAgICB9JyxcbiAgICAnJyxcbiAgICAnICAgIGZ1bmN0aW9uIHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpIHsnLFxuICAgICcgICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHsnLFxuICAgICcgICAgICAgIHZhciBwLCBjaDsnLFxuICAgICcnLFxuICAgICcgICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHsnLFxuICAgICcgICAgICAgICAgY2ggPSBpbnB1dC5jaGFyQXQocCk7JyxcbiAgICAnICAgICAgICAgIGlmIChjaCA9PT0gXCJcXFxcblwiKSB7JyxcbiAgICAnICAgICAgICAgICAgaWYgKCFkZXRhaWxzLnNlZW5DUikgeyBkZXRhaWxzLmxpbmUrKzsgfScsXG4gICAgJyAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTsnLFxuICAgICcgICAgICAgICAgICBkZXRhaWxzLnNlZW5DUiA9IGZhbHNlOycsXG4gICAgJyAgICAgICAgICB9IGVsc2UgaWYgKGNoID09PSBcIlxcXFxyXCIgfHwgY2ggPT09IFwiXFxcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFxcXHUyMDI5XCIpIHsnLFxuICAgICcgICAgICAgICAgICBkZXRhaWxzLmxpbmUrKzsnLFxuICAgICcgICAgICAgICAgICBkZXRhaWxzLmNvbHVtbiA9IDE7JyxcbiAgICAnICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSB0cnVlOycsXG4gICAgJyAgICAgICAgICB9IGVsc2UgeycsXG4gICAgJyAgICAgICAgICAgIGRldGFpbHMuY29sdW1uKys7JyxcbiAgICAnICAgICAgICAgICAgZGV0YWlscy5zZWVuQ1IgPSBmYWxzZTsnLFxuICAgICcgICAgICAgICAgfScsXG4gICAgJyAgICAgICAgfScsXG4gICAgJyAgICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgICBpZiAocGVnJGNhY2hlZFBvcyAhPT0gcG9zKSB7JyxcbiAgICAnICAgICAgICBpZiAocGVnJGNhY2hlZFBvcyA+IHBvcykgeycsXG4gICAgJyAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDsnLFxuICAgICcgICAgICAgICAgcGVnJGNhY2hlZFBvc0RldGFpbHMgPSB7IGxpbmU6IDEsIGNvbHVtbjogMSwgc2VlbkNSOiBmYWxzZSB9OycsXG4gICAgJyAgICAgICAgfScsXG4gICAgJyAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTsnLFxuICAgICcgICAgICAgIHBlZyRjYWNoZWRQb3MgPSBwb3M7JyxcbiAgICAnICAgICAgfScsXG4gICAgJycsXG4gICAgJyAgICAgIHJldHVybiBwZWckY2FjaGVkUG9zRGV0YWlsczsnLFxuICAgICcgICAgfScsXG4gICAgJycsXG4gICAgJyAgICBmdW5jdGlvbiBwZWckZmFpbChleHBlY3RlZCkgeycsXG4gICAgJyAgICAgIGlmIChwZWckY3VyclBvcyA8IHBlZyRtYXhGYWlsUG9zKSB7IHJldHVybjsgfScsXG4gICAgJycsXG4gICAgJyAgICAgIGlmIChwZWckY3VyclBvcyA+IHBlZyRtYXhGYWlsUG9zKSB7JyxcbiAgICAnICAgICAgICBwZWckbWF4RmFpbFBvcyA9IHBlZyRjdXJyUG9zOycsXG4gICAgJyAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdOycsXG4gICAgJyAgICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpOycsXG4gICAgJyAgICB9JyxcbiAgICAnJyxcbiAgICAnICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7JyxcbiAgICAnICAgICAgZnVuY3Rpb24gY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKSB7JyxcbiAgICAnICAgICAgICB2YXIgaSA9IDE7JyxcbiAgICAnJyxcbiAgICAnICAgICAgICBleHBlY3RlZC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsnLFxuICAgICcgICAgICAgICAgaWYgKGEuZGVzY3JpcHRpb24gPCBiLmRlc2NyaXB0aW9uKSB7JyxcbiAgICAnICAgICAgICAgICAgcmV0dXJuIC0xOycsXG4gICAgJyAgICAgICAgICB9IGVsc2UgaWYgKGEuZGVzY3JpcHRpb24gPiBiLmRlc2NyaXB0aW9uKSB7JyxcbiAgICAnICAgICAgICAgICAgcmV0dXJuIDE7JyxcbiAgICAnICAgICAgICAgIH0gZWxzZSB7JyxcbiAgICAnICAgICAgICAgICAgcmV0dXJuIDA7JyxcbiAgICAnICAgICAgICAgIH0nLFxuICAgICcgICAgICAgIH0pOycsXG4gICAgJycsXG4gICAgLypcbiAgICAgKiBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIGJ5dGVjb2RlIGdlbmVyYXRvciBndWFyYW50ZWVzIHRoYXQgZXZlcnlcbiAgICAgKiBleHBlY3RhdGlvbiBvYmplY3QgZXhpc3RzIG9ubHkgb25jZSwgc28gaXQncyBlbm91Z2ggdG8gdXNlIHw9PT18IGluc3RlYWRcbiAgICAgKiBvZiBkZWVwZXIgc3RydWN0dXJhbCBjb21wYXJpc29uLlxuICAgICAqL1xuICAgICcgICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7JyxcbiAgICAnICAgICAgICAgIGlmIChleHBlY3RlZFtpIC0gMV0gPT09IGV4cGVjdGVkW2ldKSB7JyxcbiAgICAnICAgICAgICAgICAgZXhwZWN0ZWQuc3BsaWNlKGksIDEpOycsXG4gICAgJyAgICAgICAgICB9IGVsc2UgeycsXG4gICAgJyAgICAgICAgICAgIGkrKzsnLFxuICAgICcgICAgICAgICAgfScsXG4gICAgJyAgICAgICAgfScsXG4gICAgJyAgICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7JyxcbiAgICAnICAgICAgICBmdW5jdGlvbiBzdHJpbmdFc2NhcGUocykgeycsXG4gICAgJyAgICAgICAgICBmdW5jdGlvbiBoZXgoY2gpIHsgcmV0dXJuIGNoLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCk7IH0nLFxuICAgICcnLFxuICAgIC8qXG4gICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhIHN0cmluZ1xuICAgICAqIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCwgY2FycmlhZ2VcbiAgICAgKiByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLiBBbnkgY2hhcmFjdGVyXG4gICAgICogbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUkgY2hhcmFjdGVycy5cbiAgICAgKiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZCBiZWNhdXNlIEpTSGludCBkb2VzXG4gICAgICogbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLlxuICAgICAqL1xuICAgICcgICAgICAgICAgcmV0dXJuIHMnLFxuICAgICcgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFwvZywgICBcXCdcXFxcXFxcXFxcXFxcXFxcXFwnKScsIC8vIGJhY2tzbGFzaFxuICAgICcgICAgICAgICAgICAucmVwbGFjZSgvXCIvZywgICAgXFwnXFxcXFxcXFxcIlxcJyknLCAgICAgIC8vIGNsb3NpbmcgZG91YmxlIHF1b3RlXG4gICAgJyAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxceDA4L2csIFxcJ1xcXFxcXFxcYlxcJyknLCAgICAgLy8gYmFja3NwYWNlXG4gICAgJyAgICAgICAgICAgIC5yZXBsYWNlKC9cXFxcdC9nLCAgIFxcJ1xcXFxcXFxcdFxcJyknLCAgICAgLy8gaG9yaXpvbnRhbCB0YWJcbiAgICAnICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxuL2csICAgXFwnXFxcXFxcXFxuXFwnKScsICAgICAvLyBsaW5lIGZlZWRcbiAgICAnICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxmL2csICAgXFwnXFxcXFxcXFxmXFwnKScsICAgICAvLyBmb3JtIGZlZWRcbiAgICAnICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxyL2csICAgXFwnXFxcXFxcXFxyXFwnKScsICAgICAvLyBjYXJyaWFnZSByZXR1cm5cbiAgICAnICAgICAgICAgICAgLnJlcGxhY2UoL1tcXFxceDAwLVxcXFx4MDdcXFxceDBCXFxcXHgwRVxcXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcXCdcXFxcXFxcXHgwXFwnICsgaGV4KGNoKTsgfSknLFxuICAgICcgICAgICAgICAgICAucmVwbGFjZSgvW1xcXFx4MTAtXFxcXHgxRlxcXFx4ODAtXFxcXHhGRl0vZywgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuIFxcJ1xcXFxcXFxceFxcJyAgKyBoZXgoY2gpOyB9KScsXG4gICAgJyAgICAgICAgICAgIC5yZXBsYWNlKC9bXFxcXHUwMTgwLVxcXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gXFwnXFxcXFxcXFx1MFxcJyArIGhleChjaCk7IH0pJyxcbiAgICAnICAgICAgICAgICAgLnJlcGxhY2UoL1tcXFxcdTEwODAtXFxcXHVGRkZGXS9nLCAgICAgICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiBcXCdcXFxcXFxcXHVcXCcgICsgaGV4KGNoKTsgfSk7JyxcbiAgICAnICAgICAgICB9JyxcbiAgICAnJyxcbiAgICAnICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLCcsXG4gICAgJyAgICAgICAgICAgIGV4cGVjdGVkRGVzYywgZm91bmREZXNjLCBpOycsXG4gICAgJycsXG4gICAgJyAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7JyxcbiAgICAnICAgICAgICAgIGV4cGVjdGVkRGVzY3NbaV0gPSBleHBlY3RlZFtpXS5kZXNjcmlwdGlvbjsnLFxuICAgICcgICAgICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgICAgIGV4cGVjdGVkRGVzYyA9IGV4cGVjdGVkLmxlbmd0aCA+IDEnLFxuICAgICcgICAgICAgICAgPyBleHBlY3RlZERlc2NzLnNsaWNlKDAsIC0xKS5qb2luKFwiLCBcIiknLFxuICAgICcgICAgICAgICAgICAgICsgXCIgb3IgXCInLFxuICAgICcgICAgICAgICAgICAgICsgZXhwZWN0ZWREZXNjc1tleHBlY3RlZC5sZW5ndGggLSAxXScsXG4gICAgJyAgICAgICAgICA6IGV4cGVjdGVkRGVzY3NbMF07JyxcbiAgICAnJyxcbiAgICAnICAgICAgICBmb3VuZERlc2MgPSBmb3VuZCA/IFwiXFxcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFxcXCJcIiA6IFwiZW5kIG9mIGlucHV0XCI7JyxcbiAgICAnJyxcbiAgICAnICAgICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkRGVzYyArIFwiIGJ1dCBcIiArIGZvdW5kRGVzYyArIFwiIGZvdW5kLlwiOycsXG4gICAgJyAgICAgIH0nLFxuICAgICcnLFxuICAgICcgICAgICB2YXIgcG9zRGV0YWlscyA9IHBlZyRjb21wdXRlUG9zRGV0YWlscyhwb3MpLCcsXG4gICAgJyAgICAgICAgICBmb3VuZCAgICAgID0gcG9zIDwgaW5wdXQubGVuZ3RoID8gaW5wdXQuY2hhckF0KHBvcykgOiBudWxsOycsXG4gICAgJycsXG4gICAgJyAgICAgIGlmIChleHBlY3RlZCAhPT0gbnVsbCkgeycsXG4gICAgJyAgICAgICAgY2xlYW51cEV4cGVjdGVkKGV4cGVjdGVkKTsnLFxuICAgICcgICAgICB9JyxcbiAgICAnJyxcbiAgICAnICAgICAgcmV0dXJuIG5ldyBTeW50YXhFcnJvcignLFxuICAgICcgICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksJyxcbiAgICAnICAgICAgICBleHBlY3RlZCwnLFxuICAgICcgICAgICAgIGZvdW5kLCcsXG4gICAgJyAgICAgICAgcG9zLCcsXG4gICAgJyAgICAgICAgcG9zRGV0YWlscy5saW5lLCcsXG4gICAgJyAgICAgICAgcG9zRGV0YWlscy5jb2x1bW4nLFxuICAgICcgICAgICApOycsXG4gICAgJyAgICB9JyxcbiAgICAnJ1xuICBdLmpvaW4oJ1xcbicpKTtcblxuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSA9PT0gXCJzaXplXCIpIHtcbiAgICBwYXJ0cy5wdXNoKGluZGVudDQoZ2VuZXJhdGVJbnRlcnByZXRlcigpKSk7XG4gICAgcGFydHMucHVzaCgnJyk7XG4gIH0gZWxzZSB7XG4gICAgdXRpbHMuZWFjaChhc3QucnVsZXMsIGZ1bmN0aW9uKHJ1bGUpIHtcbiAgICAgIHBhcnRzLnB1c2goaW5kZW50NChnZW5lcmF0ZVJ1bGVGdW5jdGlvbihydWxlKSkpO1xuICAgICAgcGFydHMucHVzaCgnJyk7XG4gICAgfSk7XG4gIH1cblxuICBpZiAoYXN0LmluaXRpYWxpemVyKSB7XG4gICAgcGFydHMucHVzaChpbmRlbnQ0KGFzdC5pbml0aWFsaXplci5jb2RlKSk7XG4gICAgcGFydHMucHVzaCgnJyk7XG4gIH1cblxuICBpZiAob3B0aW9ucy5vcHRpbWl6ZSA9PT0gXCJzaXplXCIpIHtcbiAgICBwYXJ0cy5wdXNoKCcgICAgcGVnJHJlc3VsdCA9IHBlZyRwYXJzZVJ1bGUocGVnJHN0YXJ0UnVsZUluZGV4KTsnKTtcbiAgfSBlbHNlIHtcbiAgICBwYXJ0cy5wdXNoKCcgICAgcGVnJHJlc3VsdCA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbigpOycpO1xuICB9XG5cbiAgcGFydHMucHVzaChbXG4gICAgJycsXG4gICAgJyAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7JyxcbiAgICAnICAgICAgcmV0dXJuIHBlZyRyZXN1bHQ7JyxcbiAgICAnICAgIH0gZWxzZSB7JyxcbiAgICAnICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHsnLFxuICAgICcgICAgICAgIHBlZyRmYWlsKHsgdHlwZTogXCJlbmRcIiwgZGVzY3JpcHRpb246IFwiZW5kIG9mIGlucHV0XCIgfSk7JyxcbiAgICAnICAgICAgfScsXG4gICAgJycsXG4gICAgJyAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihudWxsLCBwZWckbWF4RmFpbEV4cGVjdGVkLCBwZWckbWF4RmFpbFBvcyk7JyxcbiAgICAnICAgIH0nLFxuICAgICcgIH0nLFxuICAgICcnLFxuICAgICcgIHJldHVybiB7JyxcbiAgICAnICAgIFN5bnRheEVycm9yOiBTeW50YXhFcnJvciwnLFxuICAgICcgICAgcGFyc2U6ICAgICAgIHBhcnNlJyxcbiAgICAnICB9OycsXG4gICAgJ30pKCknXG4gIF0uam9pbignXFxuJykpO1xuXG4gIGFzdC5jb2RlID0gcGFydHMuam9pbignXFxuJyk7XG59O1xuIiwidmFyIHV0aWxzID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuXG4vKlxuICogUmVtb3ZlcyBwcm94eSBydWxlcyAtLSB0aGF0IGlzLCBydWxlcyB0aGF0IG9ubHkgZGVsZWdhdGUgdG8gb3RoZXIgcnVsZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihhc3QsIG9wdGlvbnMpIHtcbiAgZnVuY3Rpb24gaXNQcm94eVJ1bGUobm9kZSkge1xuICAgIHJldHVybiBub2RlLnR5cGUgPT09IFwicnVsZVwiICYmIG5vZGUuZXhwcmVzc2lvbi50eXBlID09PSBcInJ1bGVfcmVmXCI7XG4gIH1cblxuICBmdW5jdGlvbiByZXBsYWNlUnVsZVJlZnMoYXN0LCBmcm9tLCB0bykge1xuICAgIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgICBmdW5jdGlvbiByZXBsYWNlSW5FeHByZXNzaW9uKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgICByZXBsYWNlKG5vZGUuZXhwcmVzc2lvbiwgZnJvbSwgdG8pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlcGxhY2VJblN1Ym5vZGVzKHByb3BlcnR5TmFtZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUsIGZyb20sIHRvKSB7XG4gICAgICAgIHV0aWxzLmVhY2gobm9kZVtwcm9wZXJ0eU5hbWVdLCBmdW5jdGlvbihzdWJub2RlKSB7XG4gICAgICAgICAgcmVwbGFjZShzdWJub2RlLCBmcm9tLCB0byk7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgcmVwbGFjZSA9IHV0aWxzLmJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgICAgZ3JhbW1hcjogICAgICByZXBsYWNlSW5TdWJub2RlcyhcInJ1bGVzXCIpLFxuICAgICAgcnVsZTogICAgICAgICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgbmFtZWQ6ICAgICAgICByZXBsYWNlSW5FeHByZXNzaW9uLFxuICAgICAgY2hvaWNlOiAgICAgICByZXBsYWNlSW5TdWJub2RlcyhcImFsdGVybmF0aXZlc1wiKSxcbiAgICAgIHNlcXVlbmNlOiAgICAgcmVwbGFjZUluU3Vibm9kZXMoXCJlbGVtZW50c1wiKSxcbiAgICAgIGxhYmVsZWQ6ICAgICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgIHRleHQ6ICAgICAgICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9hbmQ6ICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgIHNpbXBsZV9ub3Q6ICAgcmVwbGFjZUluRXhwcmVzc2lvbixcbiAgICAgIHNlbWFudGljX2FuZDogbm9wLFxuICAgICAgc2VtYW50aWNfbm90OiBub3AsXG4gICAgICBvcHRpb25hbDogICAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICB6ZXJvX29yX21vcmU6IHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICBvbmVfb3JfbW9yZTogIHJlcGxhY2VJbkV4cHJlc3Npb24sXG4gICAgICBhY3Rpb246ICAgICAgIHJlcGxhY2VJbkV4cHJlc3Npb24sXG5cbiAgICAgIHJ1bGVfcmVmOlxuICAgICAgICBmdW5jdGlvbihub2RlLCBmcm9tLCB0bykge1xuICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IGZyb20pIHtcbiAgICAgICAgICAgIG5vZGUubmFtZSA9IHRvO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgICBcImNsYXNzXCI6ICAgICAgbm9wLFxuICAgICAgYW55OiAgICAgICAgICBub3BcbiAgICB9KTtcblxuICAgIHJlcGxhY2UoYXN0LCBmcm9tLCB0byk7XG4gIH1cblxuICB2YXIgaW5kaWNlcyA9IFtdO1xuXG4gIHV0aWxzLmVhY2goYXN0LnJ1bGVzLCBmdW5jdGlvbihydWxlLCBpKSB7XG4gICAgaWYgKGlzUHJveHlSdWxlKHJ1bGUpKSB7XG4gICAgICByZXBsYWNlUnVsZVJlZnMoYXN0LCBydWxlLm5hbWUsIHJ1bGUuZXhwcmVzc2lvbi5uYW1lKTtcbiAgICAgIGlmICghdXRpbHMuY29udGFpbnMob3B0aW9ucy5hbGxvd2VkU3RhcnRSdWxlcywgcnVsZS5uYW1lKSkge1xuICAgICAgICBpbmRpY2VzLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBpbmRpY2VzLnJldmVyc2UoKTtcblxuICB1dGlscy5lYWNoKGluZGljZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgYXN0LnJ1bGVzLnNwbGljZShpbmRleCwgMSk7XG4gIH0pO1xufTtcbiIsInZhciB1dGlscyAgICAgICAgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIiksXG4gICAgR3JhbW1hckVycm9yID0gcmVxdWlyZShcIi4uLy4uL2dyYW1tYXItZXJyb3JcIik7XG5cbi8qIENoZWNrcyB0aGF0IG5vIGxlZnQgcmVjdXJzaW9uIGlzIHByZXNlbnQuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGFzdCkge1xuICBmdW5jdGlvbiBub3AoKSB7fVxuXG4gIGZ1bmN0aW9uIGNoZWNrRXhwcmVzc2lvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICBjaGVjayhub2RlLmV4cHJlc3Npb24sIGFwcGxpZWRSdWxlcyk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1N1Ym5vZGVzKHByb3BlcnR5TmFtZSkge1xuICAgIHJldHVybiBmdW5jdGlvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgIHV0aWxzLmVhY2gobm9kZVtwcm9wZXJ0eU5hbWVdLCBmdW5jdGlvbihzdWJub2RlKSB7XG4gICAgICAgIGNoZWNrKHN1Ym5vZGUsIGFwcGxpZWRSdWxlcyk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgdmFyIGNoZWNrID0gdXRpbHMuYnVpbGROb2RlVmlzaXRvcih7XG4gICAgZ3JhbW1hcjogICAgIGNoZWNrU3Vibm9kZXMoXCJydWxlc1wiKSxcblxuICAgIHJ1bGU6XG4gICAgICBmdW5jdGlvbihub2RlLCBhcHBsaWVkUnVsZXMpIHtcbiAgICAgICAgY2hlY2sobm9kZS5leHByZXNzaW9uLCBhcHBsaWVkUnVsZXMuY29uY2F0KG5vZGUubmFtZSkpO1xuICAgICAgfSxcblxuICAgIG5hbWVkOiAgICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgY2hvaWNlOiAgICAgIGNoZWNrU3Vibm9kZXMoXCJhbHRlcm5hdGl2ZXNcIiksXG4gICAgYWN0aW9uOiAgICAgIGNoZWNrRXhwcmVzc2lvbixcblxuICAgIHNlcXVlbmNlOlxuICAgICAgZnVuY3Rpb24obm9kZSwgYXBwbGllZFJ1bGVzKSB7XG4gICAgICAgIGlmIChub2RlLmVsZW1lbnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBjaGVjayhub2RlLmVsZW1lbnRzWzBdLCBhcHBsaWVkUnVsZXMpO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgbGFiZWxlZDogICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgdGV4dDogICAgICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgc2ltcGxlX2FuZDogICBjaGVja0V4cHJlc3Npb24sXG4gICAgc2ltcGxlX25vdDogICBjaGVja0V4cHJlc3Npb24sXG4gICAgc2VtYW50aWNfYW5kOiBub3AsXG4gICAgc2VtYW50aWNfbm90OiBub3AsXG4gICAgb3B0aW9uYWw6ICAgICBjaGVja0V4cHJlc3Npb24sXG4gICAgemVyb19vcl9tb3JlOiBjaGVja0V4cHJlc3Npb24sXG4gICAgb25lX29yX21vcmU6ICBjaGVja0V4cHJlc3Npb24sXG5cbiAgICBydWxlX3JlZjpcbiAgICAgIGZ1bmN0aW9uKG5vZGUsIGFwcGxpZWRSdWxlcykge1xuICAgICAgICBpZiAodXRpbHMuY29udGFpbnMoYXBwbGllZFJ1bGVzLCBub2RlLm5hbWUpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEdyYW1tYXJFcnJvcihcbiAgICAgICAgICAgIFwiTGVmdCByZWN1cnNpb24gZGV0ZWN0ZWQgZm9yIHJ1bGUgXFxcIlwiICsgbm9kZS5uYW1lICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBjaGVjayh1dGlscy5maW5kUnVsZUJ5TmFtZShhc3QsIG5vZGUubmFtZSksIGFwcGxpZWRSdWxlcyk7XG4gICAgICB9LFxuXG4gICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgXCJjbGFzc1wiOiAgICAgIG5vcCxcbiAgICBhbnk6ICAgICAgICAgIG5vcFxuICB9KTtcblxuICBjaGVjayhhc3QsIFtdKTtcbn07XG4iLCJ2YXIgdXRpbHMgICAgICAgID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpLFxuICAgIEdyYW1tYXJFcnJvciA9IHJlcXVpcmUoXCIuLi8uLi9ncmFtbWFyLWVycm9yXCIpO1xuXG4vKiBDaGVja3MgdGhhdCBhbGwgcmVmZXJlbmNlZCBydWxlcyBleGlzdC4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oYXN0KSB7XG4gIGZ1bmN0aW9uIG5vcCgpIHt9XG5cbiAgZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uKG5vZGUpIHsgY2hlY2sobm9kZS5leHByZXNzaW9uKTsgfVxuXG4gIGZ1bmN0aW9uIGNoZWNrU3Vibm9kZXMocHJvcGVydHlOYW1lKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHsgdXRpbHMuZWFjaChub2RlW3Byb3BlcnR5TmFtZV0sIGNoZWNrKTsgfTtcbiAgfVxuXG4gIHZhciBjaGVjayA9IHV0aWxzLmJ1aWxkTm9kZVZpc2l0b3Ioe1xuICAgIGdyYW1tYXI6ICAgICAgY2hlY2tTdWJub2RlcyhcInJ1bGVzXCIpLFxuICAgIHJ1bGU6ICAgICAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgIG5hbWVkOiAgICAgICAgY2hlY2tFeHByZXNzaW9uLFxuICAgIGNob2ljZTogICAgICAgY2hlY2tTdWJub2RlcyhcImFsdGVybmF0aXZlc1wiKSxcbiAgICBhY3Rpb246ICAgICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICBzZXF1ZW5jZTogICAgIGNoZWNrU3Vibm9kZXMoXCJlbGVtZW50c1wiKSxcbiAgICBsYWJlbGVkOiAgICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICB0ZXh0OiAgICAgICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICBzaW1wbGVfYW5kOiAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICBzaW1wbGVfbm90OiAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICBzZW1hbnRpY19hbmQ6IG5vcCxcbiAgICBzZW1hbnRpY19ub3Q6IG5vcCxcbiAgICBvcHRpb25hbDogICAgIGNoZWNrRXhwcmVzc2lvbixcbiAgICB6ZXJvX29yX21vcmU6IGNoZWNrRXhwcmVzc2lvbixcbiAgICBvbmVfb3JfbW9yZTogIGNoZWNrRXhwcmVzc2lvbixcblxuICAgIHJ1bGVfcmVmOlxuICAgICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBpZiAoIXV0aWxzLmZpbmRSdWxlQnlOYW1lKGFzdCwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgIHRocm93IG5ldyBHcmFtbWFyRXJyb3IoXG4gICAgICAgICAgICBcIlJlZmVyZW5jZWQgcnVsZSBcXFwiXCIgKyBub2RlLm5hbWUgKyBcIlxcXCIgZG9lcyBub3QgZXhpc3QuXCJcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgbGl0ZXJhbDogICAgICBub3AsXG4gICAgXCJjbGFzc1wiOiAgICAgIG5vcCxcbiAgICBhbnk6ICAgICAgICAgIG5vcFxuICB9KTtcblxuICBjaGVjayhhc3QpO1xufTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG4vKiBUaHJvd24gd2hlbiB0aGUgZ3JhbW1hciBjb250YWlucyBhbiBlcnJvci4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICB0aGlzLm5hbWUgPSBcIkdyYW1tYXJFcnJvclwiO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufTtcblxudXRpbHMuc3ViY2xhc3MobW9kdWxlLmV4cG9ydHMsIEVycm9yKTtcbiIsIm1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuICB9XG5cbiAgcGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IGdyYW1tYXI6IHBlZyRwYXJzZWdyYW1tYXIgfSxcbiAgICAgICAgcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uICA9IHBlZyRwYXJzZWdyYW1tYXIsXG5cbiAgICAgICAgcGVnJGMwID0gcGVnJEZBSUxFRCxcbiAgICAgICAgcGVnJGMxID0gbnVsbCxcbiAgICAgICAgcGVnJGMyID0gW10sXG4gICAgICAgIHBlZyRjMyA9IGZ1bmN0aW9uKGluaXRpYWxpemVyLCBydWxlcykge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgICBcImdyYW1tYXJcIixcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplcjogaW5pdGlhbGl6ZXIsXG4gICAgICAgICAgICAgICAgcnVsZXM6ICAgICAgIHJ1bGVzXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzQgPSBmdW5jdGlvbihjb2RlKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJpbml0aWFsaXplclwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjNSA9IGZ1bmN0aW9uKG5hbWUsIGRpc3BsYXlOYW1lLCBleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgIFwicnVsZVwiLFxuICAgICAgICAgICAgICAgIG5hbWU6ICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246ICBkaXNwbGF5TmFtZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJuYW1lZFwiLFxuICAgICAgICAgICAgICAgICAgICAgIG5hbWU6ICAgICAgIGRpc3BsYXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgOiBleHByZXNzaW9uXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzYgPSBmdW5jdGlvbihoZWFkLCB0YWlsKSB7XG4gICAgICAgICAgICAgIGlmICh0YWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICB2YXIgYWx0ZXJuYXRpdmVzID0gW2hlYWRdLmNvbmNhdCh1dGlscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgIHRhaWwsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVsZW1lbnQpIHsgcmV0dXJuIGVsZW1lbnRbMV07IH1cbiAgICAgICAgICAgICAgICApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgdHlwZTogICAgICAgICBcImNob2ljZVwiLFxuICAgICAgICAgICAgICAgICAgYWx0ZXJuYXRpdmVzOiBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZWFkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzcgPSBmdW5jdGlvbihlbGVtZW50cywgY29kZSkge1xuICAgICAgICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IGVsZW1lbnRzLmxlbmd0aCAhPT0gMVxuICAgICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiAgICAgXCJzZXF1ZW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50czogZWxlbWVudHNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICA6IGVsZW1lbnRzWzBdO1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwiYWN0aW9uXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvbixcbiAgICAgICAgICAgICAgICBjb2RlOiAgICAgICBjb2RlXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzggPSBmdW5jdGlvbihlbGVtZW50cykge1xuICAgICAgICAgICAgICByZXR1cm4gZWxlbWVudHMubGVuZ3RoICE9PSAxXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICAgICBcInNlcXVlbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnRzOiBlbGVtZW50c1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDogZWxlbWVudHNbMF07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzkgPSBmdW5jdGlvbihsYWJlbCwgZXhwcmVzc2lvbikge1xuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICAgICAgIFwibGFiZWxlZFwiLFxuICAgICAgICAgICAgICAgIGxhYmVsOiAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTAgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJ0ZXh0XCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxMSA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlbWFudGljX2FuZFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTIgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJzaW1wbGVfYW5kXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxMyA9IGZ1bmN0aW9uKGNvZGUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInNlbWFudGljX25vdFwiLFxuICAgICAgICAgICAgICAgIGNvZGU6IGNvZGVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTQgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJzaW1wbGVfbm90XCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxNSA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcIm9wdGlvbmFsXCIsXG4gICAgICAgICAgICAgICAgZXhwcmVzc2lvbjogZXhwcmVzc2lvblxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxNiA9IGZ1bmN0aW9uKGV4cHJlc3Npb24pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0eXBlOiAgICAgICBcInplcm9fb3JfbW9yZVwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTcgPSBmdW5jdGlvbihleHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJvbmVfb3JfbW9yZVwiLFxuICAgICAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb25cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTggPSB2b2lkIDAsXG4gICAgICAgIHBlZyRjMTkgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJydWxlX3JlZlwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMjAgPSBmdW5jdGlvbigpIHsgcmV0dXJuIHsgdHlwZTogXCJhbnlcIiB9OyB9LFxuICAgICAgICBwZWckYzIxID0gZnVuY3Rpb24oZXhwcmVzc2lvbikgeyByZXR1cm4gZXhwcmVzc2lvbjsgfSxcbiAgICAgICAgcGVnJGMyMiA9IHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogXCJhY3Rpb25cIiB9LFxuICAgICAgICBwZWckYzIzID0gZnVuY3Rpb24oYnJhY2VkKSB7IHJldHVybiBicmFjZWQuc3Vic3RyKDEsIGJyYWNlZC5sZW5ndGggLSAyKTsgfSxcbiAgICAgICAgcGVnJGMyNCA9IFwie1wiLFxuICAgICAgICBwZWckYzI1ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwie1wiLCBkZXNjcmlwdGlvbjogXCJcXFwie1xcXCJcIiB9LFxuICAgICAgICBwZWckYzI2ID0gXCJ9XCIsXG4gICAgICAgIHBlZyRjMjcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ9XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ9XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMjggPSAvXltee31dLyxcbiAgICAgICAgcGVnJGMyOSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXnt9XVwiLCBkZXNjcmlwdGlvbjogXCJbXnt9XVwiIH0sXG4gICAgICAgIHBlZyRjMzAgPSBcIj1cIixcbiAgICAgICAgcGVnJGMzMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCI9XCI7IH0sXG4gICAgICAgIHBlZyRjMzMgPSBcIjpcIixcbiAgICAgICAgcGVnJGMzNCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjpcIiwgZGVzY3JpcHRpb246IFwiXFxcIjpcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCI6XCI7IH0sXG4gICAgICAgIHBlZyRjMzYgPSBcIjtcIixcbiAgICAgICAgcGVnJGMzNyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIjtcIiwgZGVzY3JpcHRpb246IFwiXFxcIjtcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzOCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCI7XCI7IH0sXG4gICAgICAgIHBlZyRjMzkgPSBcIi9cIixcbiAgICAgICAgcGVnJGM0MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi9cIiwgZGVzY3JpcHRpb246IFwiXFxcIi9cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0MSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIvXCI7IH0sXG4gICAgICAgIHBlZyRjNDIgPSBcIiZcIixcbiAgICAgICAgcGVnJGM0MyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiZcIiwgZGVzY3JpcHRpb246IFwiXFxcIiZcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0NCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCImXCI7IH0sXG4gICAgICAgIHBlZyRjNDUgPSBcIiFcIixcbiAgICAgICAgcGVnJGM0NiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiFcIiwgZGVzY3JpcHRpb246IFwiXFxcIiFcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0NyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIhXCI7IH0sXG4gICAgICAgIHBlZyRjNDggPSBcIiRcIixcbiAgICAgICAgcGVnJGM0OSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiRcIiwgZGVzY3JpcHRpb246IFwiXFxcIiRcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1MCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIkXCI7IH0sXG4gICAgICAgIHBlZyRjNTEgPSBcIj9cIixcbiAgICAgICAgcGVnJGM1MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj9cIiwgZGVzY3JpcHRpb246IFwiXFxcIj9cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1MyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCI/XCI7IH0sXG4gICAgICAgIHBlZyRjNTQgPSBcIipcIixcbiAgICAgICAgcGVnJGM1NSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIipcIiwgZGVzY3JpcHRpb246IFwiXFxcIipcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1NiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIqXCI7IH0sXG4gICAgICAgIHBlZyRjNTcgPSBcIitcIixcbiAgICAgICAgcGVnJGM1OCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIitcIiwgZGVzY3JpcHRpb246IFwiXFxcIitcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM1OSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIrXCI7IH0sXG4gICAgICAgIHBlZyRjNjAgPSBcIihcIixcbiAgICAgICAgcGVnJGM2MSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIihcIiwgZGVzY3JpcHRpb246IFwiXFxcIihcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2MiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIoXCI7IH0sXG4gICAgICAgIHBlZyRjNjMgPSBcIilcIixcbiAgICAgICAgcGVnJGM2NCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIilcIiwgZGVzY3JpcHRpb246IFwiXFxcIilcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2NSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIpXCI7IH0sXG4gICAgICAgIHBlZyRjNjYgPSBcIi5cIixcbiAgICAgICAgcGVnJGM2NyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2OCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCIuXCI7IH0sXG4gICAgICAgIHBlZyRjNjkgPSB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IFwiaWRlbnRpZmllclwiIH0sXG4gICAgICAgIHBlZyRjNzAgPSBcIl9cIixcbiAgICAgICAgcGVnJGM3MSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIl9cIiwgZGVzY3JpcHRpb246IFwiXFxcIl9cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3MiA9IGZ1bmN0aW9uKGNoYXJzKSB7IHJldHVybiBjaGFyczsgfSxcbiAgICAgICAgcGVnJGM3MyA9IHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogXCJsaXRlcmFsXCIgfSxcbiAgICAgICAgcGVnJGM3NCA9IFwiaVwiLFxuICAgICAgICBwZWckYzc1ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiaVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiaVxcXCJcIiB9LFxuICAgICAgICBwZWckYzc2ID0gZnVuY3Rpb24odmFsdWUsIGZsYWdzKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJsaXRlcmFsXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6ICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgICAgaWdub3JlQ2FzZTogZmxhZ3MgPT09IFwiaVwiXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzc3ID0geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBcInN0cmluZ1wiIH0sXG4gICAgICAgIHBlZyRjNzggPSBmdW5jdGlvbihzdHJpbmcpIHsgcmV0dXJuIHN0cmluZzsgfSxcbiAgICAgICAgcGVnJGM3OSA9IFwiXFxcIlwiLFxuICAgICAgICBwZWckYzgwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcIlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXCJcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM4MSA9IGZ1bmN0aW9uKGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9LFxuICAgICAgICBwZWckYzgyID0gXCJcXFxcXCIsXG4gICAgICAgIHBlZyRjODMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXFxcXCJcIiB9LFxuICAgICAgICBwZWckYzg0ID0geyB0eXBlOiBcImFueVwiLCBkZXNjcmlwdGlvbjogXCJhbnkgY2hhcmFjdGVyXCIgfSxcbiAgICAgICAgcGVnJGM4NSA9IGZ1bmN0aW9uKGNoYXJfKSB7IHJldHVybiBjaGFyXzsgfSxcbiAgICAgICAgcGVnJGM4NiA9IFwiJ1wiLFxuICAgICAgICBwZWckYzg3ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiJ1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiJ1xcXCJcIiB9LFxuICAgICAgICBwZWckYzg4ID0geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBcImNoYXJhY3RlciBjbGFzc1wiIH0sXG4gICAgICAgIHBlZyRjODkgPSBcIltcIixcbiAgICAgICAgcGVnJGM5MCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM5MSA9IFwiXlwiLFxuICAgICAgICBwZWckYzkyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXlxcXCJcIiB9LFxuICAgICAgICBwZWckYzkzID0gXCJdXCIsXG4gICAgICAgIHBlZyRjOTQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJdXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJdXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjOTUgPSBmdW5jdGlvbihpbnZlcnRlZCwgcGFydHMsIGZsYWdzKSB7XG4gICAgICAgICAgICAgIHZhciBwYXJ0c0NvbnZlcnRlZCA9IHV0aWxzLm1hcChwYXJ0cywgZnVuY3Rpb24ocGFydCkgeyByZXR1cm4gcGFydC5kYXRhOyB9KTtcbiAgICAgICAgICAgICAgdmFyIHJhd1RleHQgPSBcIltcIlxuICAgICAgICAgICAgICAgICsgKGludmVydGVkICE9PSBudWxsID8gaW52ZXJ0ZWQgOiBcIlwiKVxuICAgICAgICAgICAgICAgICsgdXRpbHMubWFwKHBhcnRzLCBmdW5jdGlvbihwYXJ0KSB7IHJldHVybiBwYXJ0LnJhd1RleHQ7IH0pLmpvaW4oXCJcIilcbiAgICAgICAgICAgICAgICArIFwiXVwiXG4gICAgICAgICAgICAgICAgKyAoZmxhZ3MgIT09IG51bGwgPyBmbGFncyA6IFwiXCIpO1xuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdHlwZTogICAgICAgXCJjbGFzc1wiLFxuICAgICAgICAgICAgICAgIHBhcnRzOiAgICAgIHBhcnRzQ29udmVydGVkLFxuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBHZXQgdGhlIHJhdyB0ZXh0IGZyb20gdGhlIGlucHV0IGRpcmVjdGx5LlxuICAgICAgICAgICAgICAgIHJhd1RleHQ6ICAgIHJhd1RleHQsXG4gICAgICAgICAgICAgICAgaW52ZXJ0ZWQ6ICAgaW52ZXJ0ZWQgPT09IFwiXlwiLFxuICAgICAgICAgICAgICAgIGlnbm9yZUNhc2U6IGZsYWdzID09PSBcImlcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGM5NiA9IFwiLVwiLFxuICAgICAgICBwZWckYzk3ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLVwiLCBkZXNjcmlwdGlvbjogXCJcXFwiLVxcXCJcIiB9LFxuICAgICAgICBwZWckYzk4ID0gZnVuY3Rpb24oYmVnaW4sIGVuZCkge1xuICAgICAgICAgICAgICBpZiAoYmVnaW4uZGF0YS5jaGFyQ29kZUF0KDApID4gZW5kLmRhdGEuY2hhckNvZGVBdCgwKSkge1xuICAgICAgICAgICAgICAgIGVycm9yKFxuICAgICAgICAgICAgICAgICAgXCJJbnZhbGlkIGNoYXJhY3RlciByYW5nZTogXCIgKyBiZWdpbi5yYXdUZXh0ICsgXCItXCIgKyBlbmQucmF3VGV4dCArIFwiLlwiXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogICAgW2JlZ2luLmRhdGEsIGVuZC5kYXRhXSxcbiAgICAgICAgICAgICAgICAvLyBGSVhNRTogR2V0IHRoZSByYXcgdGV4dCBmcm9tIHRoZSBpbnB1dCBkaXJlY3RseS5cbiAgICAgICAgICAgICAgICByYXdUZXh0OiBiZWdpbi5yYXdUZXh0ICsgXCItXCIgKyBlbmQucmF3VGV4dFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGM5OSA9IGZ1bmN0aW9uKGNoYXJfKSB7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZGF0YTogICAgY2hhcl8sXG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IEdldCB0aGUgcmF3IHRleHQgZnJvbSB0aGUgaW5wdXQgZGlyZWN0bHkuXG4gICAgICAgICAgICAgICAgcmF3VGV4dDogdXRpbHMucXVvdGVGb3JSZWdleHBDbGFzcyhjaGFyXylcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTAwID0gXCJ4XCIsXG4gICAgICAgIHBlZyRjMTAxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwieFwiLCBkZXNjcmlwdGlvbjogXCJcXFwieFxcXCJcIiB9LFxuICAgICAgICBwZWckYzEwMiA9IFwidVwiLFxuICAgICAgICBwZWckYzEwMyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInVcIiwgZGVzY3JpcHRpb246IFwiXFxcInVcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMDQgPSBmdW5jdGlvbihjaGFyXykge1xuICAgICAgICAgICAgICByZXR1cm4gY2hhcl9cbiAgICAgICAgICAgICAgICAucmVwbGFjZShcImJcIiwgXCJcXGJcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcImZcIiwgXCJcXGZcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcIm5cIiwgXCJcXG5cIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInJcIiwgXCJcXHJcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInRcIiwgXCJcXHRcIilcbiAgICAgICAgICAgICAgICAucmVwbGFjZShcInZcIiwgXCJcXHgwQlwiKTsgLy8gSUUgZG9lcyBub3QgcmVjb2duaXplIFwiXFx2XCIuXG4gICAgICAgICAgICB9LFxuICAgICAgICBwZWckYzEwNSA9IFwiXFxcXDBcIixcbiAgICAgICAgcGVnJGMxMDYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcMFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXFxcXFwwXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTA3ID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIlxceDAwXCI7IH0sXG4gICAgICAgIHBlZyRjMTA4ID0gXCJcXFxceFwiLFxuICAgICAgICBwZWckYzEwOSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcXFx4XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXHhcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMTAgPSBmdW5jdGlvbihkaWdpdHMpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoZGlnaXRzLCAxNikpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxMTEgPSBcIlxcXFx1XCIsXG4gICAgICAgIHBlZyRjMTEyID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiXFxcXHVcIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxcXFxcdVxcXCJcIiB9LFxuICAgICAgICBwZWckYzExMyA9IGZ1bmN0aW9uKGVvbCkgeyByZXR1cm4gZW9sOyB9LFxuICAgICAgICBwZWckYzExNCA9IC9eWzAtOV0vLFxuICAgICAgICBwZWckYzExNSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05XVwiLCBkZXNjcmlwdGlvbjogXCJbMC05XVwiIH0sXG4gICAgICAgIHBlZyRjMTE2ID0gL15bMC05YS1mQS1GXS8sXG4gICAgICAgIHBlZyRjMTE3ID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlswLTlhLWZBLUZdXCIsIGRlc2NyaXB0aW9uOiBcIlswLTlhLWZBLUZdXCIgfSxcbiAgICAgICAgcGVnJGMxMTggPSAvXlthLXpdLyxcbiAgICAgICAgcGVnJGMxMTkgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2Etel1cIiwgZGVzY3JpcHRpb246IFwiW2Etel1cIiB9LFxuICAgICAgICBwZWckYzEyMCA9IC9eW0EtWl0vLFxuICAgICAgICBwZWckYzEyMSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbQS1aXVwiLCBkZXNjcmlwdGlvbjogXCJbQS1aXVwiIH0sXG4gICAgICAgIHBlZyRjMTIyID0geyB0eXBlOiBcIm90aGVyXCIsIGRlc2NyaXB0aW9uOiBcImNvbW1lbnRcIiB9LFxuICAgICAgICBwZWckYzEyMyA9IFwiLy9cIixcbiAgICAgICAgcGVnJGMxMjQgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIvL1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiLy9cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMjUgPSBcIi8qXCIsXG4gICAgICAgIHBlZyRjMTI2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiLypcIiwgZGVzY3JpcHRpb246IFwiXFxcIi8qXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTI3ID0gXCIqL1wiLFxuICAgICAgICBwZWckYzEyOCA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIiovXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIqL1xcXCJcIiB9LFxuICAgICAgICBwZWckYzEyOSA9IHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgbGluZVwiIH0sXG4gICAgICAgIHBlZyRjMTMwID0gXCJcXG5cIixcbiAgICAgICAgcGVnJGMxMzEgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXG5cIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxuXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTMyID0gXCJcXHJcXG5cIixcbiAgICAgICAgcGVnJGMxMzMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXHJcXG5cIiwgZGVzY3JpcHRpb246IFwiXFxcIlxcXFxyXFxcXG5cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMzQgPSBcIlxcclwiLFxuICAgICAgICBwZWckYzEzNSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlxcclwiLCBkZXNjcmlwdGlvbjogXCJcXFwiXFxcXHJcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMzYgPSBcIlxcdTIwMjhcIixcbiAgICAgICAgcGVnJGMxMzcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXHUyMDI4XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcdTIwMjhcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMzggPSBcIlxcdTIwMjlcIixcbiAgICAgICAgcGVnJGMxMzkgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXHUyMDI5XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcdTIwMjlcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxNDAgPSAvXltcXG5cXHJcXHUyMDI4XFx1MjAyOV0vLFxuICAgICAgICBwZWckYzE0MSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbXFxcXG5cXFxcclxcXFx1MjAyOFxcXFx1MjAyOV1cIiwgZGVzY3JpcHRpb246IFwiW1xcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjldXCIgfSxcbiAgICAgICAgcGVnJGMxNDIgPSB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IFwid2hpdGVzcGFjZVwiIH0sXG4gICAgICAgIHBlZyRjMTQzID0gL15bIFxcdFxceDBCXFxmXFx4QTBcXHVGRUZGXFx1MTY4MFxcdTE4MEVcXHUyMDAwLVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTMwMDBdLyxcbiAgICAgICAgcGVnJGMxNDQgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiWyBcXFxcdFxcXFx4MEJcXFxcZlxcXFx4QTBcXFxcdUZFRkZcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDAtXFxcXHUyMDBBXFxcXHUyMDJGXFxcXHUyMDVGXFxcXHUzMDAwXVwiLCBkZXNjcmlwdGlvbjogXCJbIFxcXFx0XFxcXHgwQlxcXFxmXFxcXHhBMFxcXFx1RkVGRlxcXFx1MTY4MFxcXFx1MTgwRVxcXFx1MjAwMC1cXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBdXCIgfSxcblxuICAgICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWdyYW1tYXIoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VfXygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlaW5pdGlhbGl6ZXIoKTtcbiAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckYzE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZXJ1bGUoKTtcbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgICAgczQgPSBwZWckcGFyc2VydWxlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzMoczIsIHMzKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vpbml0aWFsaXplcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VhY3Rpb24oKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZXNlbWljb2xvbigpO1xuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNChzMSk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXJ1bGUoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlaWRlbnRpZmllcigpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJGMxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlZXF1YWxzKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWNob2ljZSgpO1xuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJHBhcnNlc2VtaWNvbG9uKCk7XG4gICAgICAgICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJGMxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM1KHMxLCBzMiwgczQpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VjaG9pY2UoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlc2VxdWVuY2UoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZXNsYXNoKCk7XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlc2VxdWVuY2UoKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZXNsYXNoKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRwYXJzZXNlcXVlbmNlKCk7XG4gICAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczQgPSBbczQsIHM1XTtcbiAgICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM2KHMxLCBzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXNlcXVlbmNlKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VsYWJlbGVkKCk7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlbGFiZWxlZCgpO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlYWN0aW9uKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM3KHMxLCBzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IFtdO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWxhYmVsZWQoKTtcbiAgICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VsYWJlbGVkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzgoczEpO1xuICAgICAgICB9XG4gICAgICAgIHMwID0gczE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VsYWJlbGVkKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VpZGVudGlmaWVyKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2Vjb2xvbigpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZXByZWZpeGVkKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM5KHMxLCBzMyk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlcHJlZml4ZWQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXByZWZpeGVkKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZWRvbGxhcigpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlc3VmZml4ZWQoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzEwKHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlYW5kKCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlYWN0aW9uKCk7XG4gICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMxMShzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWFuZCgpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VzdWZmaXhlZCgpO1xuICAgICAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMTIoczIpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vub3QoKTtcbiAgICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMiA9IHBlZyRwYXJzZWFjdGlvbigpO1xuICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTMoczIpO1xuICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2Vub3QoKTtcbiAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VzdWZmaXhlZCgpO1xuICAgICAgICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjMTQoczIpO1xuICAgICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlc3VmZml4ZWQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3VmZml4ZWQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlcHJpbWFyeSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlcXVlc3Rpb24oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzE1KHMxKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMxID0gcGVnJHBhcnNlcHJpbWFyeSgpO1xuICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZXN0YXIoKTtcbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzE2KHMxKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHMxID0gcGVnJHBhcnNlcHJpbWFyeSgpO1xuICAgICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIgPSBwZWckcGFyc2VwbHVzKCk7XG4gICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMxNyhzMSk7XG4gICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlcHJpbWFyeSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcHJpbWFyeSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VpZGVudGlmaWVyKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHM0ID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJGMxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlZXF1YWxzKCk7XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMTkoczEpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VsaXRlcmFsKCk7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJHBhcnNlY2xhc3MoKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICBzMSA9IHBlZyRwYXJzZWRvdCgpO1xuICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMjAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgczEgPSBwZWckcGFyc2VscGFyZW4oKTtcbiAgICAgICAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczIgPSBwZWckcGFyc2VjaG9pY2UoKTtcbiAgICAgICAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlcnBhcmVuKCk7XG4gICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICAgIHMxID0gcGVnJGMyMShzMik7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VhY3Rpb24oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VicmFjZWQoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMyMyhzMSk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzIyKTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlYnJhY2VkKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICBzMiA9IHBlZyRjMjQ7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMyNSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMyA9IFtdO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZWJyYWNlZCgpO1xuICAgICAgICBpZiAoczQgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZW5vbkJyYWNlQ2hhcmFjdGVycygpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzLnB1c2goczQpO1xuICAgICAgICAgIHM0ID0gcGVnJHBhcnNlYnJhY2VkKCk7XG4gICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZW5vbkJyYWNlQ2hhcmFjdGVycygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNSkge1xuICAgICAgICAgICAgczQgPSBwZWckYzI2O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczQgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI3KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMyID0gW3MyLCBzMywgczRdO1xuICAgICAgICAgICAgczEgPSBzMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgICAgIHMxID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgICAgIHMxID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IGlucHV0LnN1YnN0cmluZyhzMCwgcGVnJGN1cnJQb3MpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW5vbkJyYWNlQ2hhcmFjdGVycygpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gW107XG4gICAgICBzMSA9IHBlZyRwYXJzZW5vbkJyYWNlQ2hhcmFjdGVyKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAucHVzaChzMSk7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2Vub25CcmFjZUNoYXJhY3RlcigpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW5vbkJyYWNlQ2hhcmFjdGVyKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGMyOC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI5KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZXF1YWxzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYxKSB7XG4gICAgICAgIHMxID0gcGVnJGMzMDtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMxKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzMyKCk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNvbG9uKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgIHMxID0gcGVnJGMzMztcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzM1KCk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXNlbWljb2xvbigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA1OSkge1xuICAgICAgICBzMSA9IHBlZyRjMzY7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNyk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMzOCgpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzbGFzaCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICBzMSA9IHBlZyRjMzk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0MCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM0MSgpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VhbmQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzgpIHtcbiAgICAgICAgczEgPSBwZWckYzQyO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDMpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNDQoKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbm90KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDMzKSB7XG4gICAgICAgIHMxID0gcGVnJGM0NTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzQ3KCk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWRvbGxhcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNikge1xuICAgICAgICBzMSA9IHBlZyRjNDg7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM0OSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1MCgpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VxdWVzdGlvbigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA2Mykge1xuICAgICAgICBzMSA9IHBlZyRjNTE7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM1MygpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzdGFyKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQyKSB7XG4gICAgICAgIHMxID0gcGVnJGM1NDtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzU1KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzU2KCk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXBsdXMoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDMpIHtcbiAgICAgICAgczEgPSBwZWckYzU3O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNTgpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNTkoKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbHBhcmVuKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQwKSB7XG4gICAgICAgIHMxID0gcGVnJGM2MDtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzYxKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlX18oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzYyKCk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXJwYXJlbigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0MSkge1xuICAgICAgICBzMSA9IHBlZyRjNjM7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM2NCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM2NSgpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vkb3QoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDYpIHtcbiAgICAgICAgczEgPSBwZWckYzY2O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjcpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNjgoKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaWRlbnRpZmllcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQsIHM1O1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgIHMzID0gcGVnJHBhcnNlbGV0dGVyKCk7XG4gICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5NSkge1xuICAgICAgICAgIHMzID0gcGVnJGM3MDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzEpOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzNCA9IFtdO1xuICAgICAgICBzNSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNSA9IHBlZyRwYXJzZWRpZ2l0KCk7XG4gICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDk1KSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJGM3MDtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcxKTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNC5wdXNoKHM1KTtcbiAgICAgICAgICBzNSA9IHBlZyRwYXJzZWxldHRlcigpO1xuICAgICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczUgPSBwZWckcGFyc2VkaWdpdCgpO1xuICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTUpIHtcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRjNzA7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzcxKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gW3MzLCBzNF07XG4gICAgICAgICAgczIgPSBzMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICAgIHMyID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMyO1xuICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IGlucHV0LnN1YnN0cmluZyhzMSwgcGVnJGN1cnJQb3MpO1xuICAgICAgfVxuICAgICAgczEgPSBzMjtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM3MihzMSk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY5KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbGl0ZXJhbCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2Vkb3VibGVRdW90ZWRTdHJpbmcoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZXNpbmdsZVF1b3RlZFN0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTA1KSB7XG4gICAgICAgICAgczIgPSBwZWckYzc0O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3NSk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM3NihzMSwgczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzczKTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyaW5nKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlZG91YmxlUXVvdGVkU3RyaW5nKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckcGFyc2VzaW5nbGVRdW90ZWRTdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZV9fKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM3OChzMSk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzc3KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZG91YmxlUXVvdGVkU3RyaW5nKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICBzMSA9IHBlZyRjNzk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4MCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZWRvdWJsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWRvdWJsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGM3OTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4MCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGM4MShzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZG91YmxlUXVvdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBzMCA9IHBlZyRwYXJzZXNpbXBsZURvdWJsZVF1b3RlZENoYXJhY3RlcigpO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlc2ltcGxlRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2V6ZXJvRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlaGV4RXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZXVuaWNvZGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRwYXJzZWVvbEVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXNpbXBsZURvdWJsZVF1b3RlZENoYXJhY3RlcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICBzMiA9IHBlZyRjNzk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4MCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgICAgczIgPSBwZWckYzgyO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4Myk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZWVvbENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckYzE4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4NCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjODUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzaW5nbGVRdW90ZWRTdHJpbmcoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICAgIHMxID0gcGVnJGM4NjtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg3KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlc2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlc2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzOSkge1xuICAgICAgICAgICAgczMgPSBwZWckYzg2O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg3KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzgxKHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzaW5nbGVRdW90ZWRDaGFyYWN0ZXIoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNlc2ltcGxlU2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VzaW1wbGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRwYXJzZXplcm9Fc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckcGFyc2VoZXhFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNldW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlZW9sRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2ltcGxlU2luZ2xlUXVvdGVkQ2hhcmFjdGVyKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRjdXJyUG9zO1xuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM5KSB7XG4gICAgICAgIHMyID0gcGVnJGM4NjtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg3KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjODI7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgzKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJHBhcnNlZW9sQ2hhcigpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRjMTg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMxO1xuICAgICAgICBzMSA9IHBlZyRjMDtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg0KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGM4NShzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNsYXNzKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2O1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkxKSB7XG4gICAgICAgIHMxID0gcGVnJGM4OTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkwKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjOTE7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkyKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJGMxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gW107XG4gICAgICAgICAgczQgPSBwZWckcGFyc2VjbGFzc0NoYXJhY3RlclJhbmdlKCk7XG4gICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWNsYXNzQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWNsYXNzQ2hhcmFjdGVyUmFuZ2UoKTtcbiAgICAgICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWNsYXNzQ2hhcmFjdGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjOTM7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5NCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEwNSkge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJGM3NDtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzUpOyB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM1ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczUgPSBwZWckYzE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VfXygpO1xuICAgICAgICAgICAgICAgIGlmIChzNiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgICAgICBzMSA9IHBlZyRjOTUoczIsIHMzLCBzNSk7XG4gICAgICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODgpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VjbGFzc0NoYXJhY3RlclJhbmdlKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VjbGFzc0NoYXJhY3RlcigpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjOTY7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzk3KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlY2xhc3NDaGFyYWN0ZXIoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzk4KHMxLCBzMyk7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlY2xhc3NDaGFyYWN0ZXIoKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VicmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGM5OShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlYnJhY2tldERlbGltaXRlZENoYXJhY3RlcigpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgczAgPSBwZWckcGFyc2VzaW1wbGVCcmFja2V0RGVsaW1pdGVkQ2hhcmFjdGVyKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VzaW1wbGVFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMCA9IHBlZyRwYXJzZXplcm9Fc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczAgPSBwZWckcGFyc2VoZXhFc2NhcGVTZXF1ZW5jZSgpO1xuICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNldW5pY29kZUVzY2FwZVNlcXVlbmNlKCk7XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlZW9sRXNjYXBlU2VxdWVuY2UoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2ltcGxlQnJhY2tldERlbGltaXRlZENoYXJhY3RlcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckY3VyclBvcztcbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mykge1xuICAgICAgICBzMiA9IHBlZyRjOTM7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5NCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDkyKSB7XG4gICAgICAgICAgczIgPSBwZWckYzgyO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4Myk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRwYXJzZWVvbENoYXIoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckYzE4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMTtcbiAgICAgICAgczEgPSBwZWckYzA7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgczIgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4NCk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjODUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VzaW1wbGVFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgczEgPSBwZWckYzgyO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODMpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICAgIHMzID0gcGVnJHBhcnNlZGlnaXQoKTtcbiAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjApIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGMxMDA7XG4gICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTAxKTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTE3KSB7XG4gICAgICAgICAgICAgIHMzID0gcGVnJGMxMDI7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMDMpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczMgPSBwZWckcGFyc2Vlb2xDaGFyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgIHMzID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4NCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMxMDQoczMpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXplcm9Fc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzEwNSkge1xuICAgICAgICBzMSA9IHBlZyRjMTA1O1xuICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTA2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzMyA9IHBlZyRwYXJzZWRpZ2l0KCk7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMTg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICBzMiA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMTA3KCk7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWhleEVzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMxMDgpIHtcbiAgICAgICAgczEgPSBwZWckYzEwODtcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwOSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRwYXJzZWhleERpZ2l0KCk7XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBpbnB1dC5zdWJzdHJpbmcoczIsIHBlZyRjdXJyUG9zKTtcbiAgICAgICAgfVxuICAgICAgICBzMiA9IHMzO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMTEwKHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNldW5pY29kZUVzY2FwZVNlcXVlbmNlKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczUsIHM2LCBzNztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzExMSkge1xuICAgICAgICBzMSA9IHBlZyRjMTExO1xuICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTEyKTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHM0ID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczUgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xuICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczYgPSBwZWckcGFyc2VoZXhEaWdpdCgpO1xuICAgICAgICAgICAgaWYgKHM2ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgaWYgKHM3ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgczQgPSBbczQsIHM1LCBzNiwgczddO1xuICAgICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICBzMyA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IGlucHV0LnN1YnN0cmluZyhzMiwgcGVnJGN1cnJQb3MpO1xuICAgICAgICB9XG4gICAgICAgIHMyID0gczM7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMxMTAoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vlb2xFc2NhcGVTZXF1ZW5jZSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICBzMSA9IHBlZyRjODI7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4Myk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWVvbCgpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjMTEzKHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMwO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZGlnaXQoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChwZWckYzExNC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzExNSk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWhleERpZ2l0KCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGMxMTYudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMTcpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VsZXR0ZXIoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNlbG93ZXJDYXNlTGV0dGVyKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2V1cHBlckNhc2VMZXR0ZXIoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWxvd2VyQ2FzZUxldHRlcigpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKHBlZyRjMTE4LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTE5KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNldXBwZXJDYXNlTGV0dGVyKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGMxMjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMjEpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VfXygpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gW107XG4gICAgICBzMSA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRwYXJzZWVvbCgpO1xuICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWNvbW1lbnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwLnB1c2goczEpO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZXdoaXRlc3BhY2UoKTtcbiAgICAgICAgaWYgKHMxID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBwZWckcGFyc2Vlb2woKTtcbiAgICAgICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gcGVnJHBhcnNlY29tbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlY29tbWVudCgpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgczAgPSBwZWckcGFyc2VzaW5nbGVMaW5lQ29tbWVudCgpO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlbXVsdGlMaW5lQ29tbWVudCgpO1xuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTIyKTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc2luZ2xlTGluZUNvbW1lbnQoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDIpID09PSBwZWckYzEyMykge1xuICAgICAgICBzMSA9IHBlZyRjMTIzO1xuICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTI0KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHM0ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICBzNSA9IHBlZyRwYXJzZWVvbENoYXIoKTtcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHM0ID0gcGVnJGMxODtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHM0O1xuICAgICAgICAgIHM0ID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICAgICAgczUgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczUgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg0KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczUgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgIHBlZyRzaWxlbnRGYWlscysrO1xuICAgICAgICAgIHM1ID0gcGVnJHBhcnNlZW9sQ2hhcigpO1xuICAgICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckYzE4O1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHM0O1xuICAgICAgICAgICAgczQgPSBwZWckYzA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0Lmxlbmd0aCA+IHBlZyRjdXJyUG9zKSB7XG4gICAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg0KTsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gW3M0LCBzNV07XG4gICAgICAgICAgICAgIHMzID0gczQ7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgICAgICBzMyA9IHBlZyRjMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMSA9IFtzMSwgczJdO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VtdWx0aUxpbmVDb21tZW50KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNCwgczU7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMxMjUpIHtcbiAgICAgICAgczEgPSBwZWckYzEyNTtcbiAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEyNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IFtdO1xuICAgICAgICBzMyA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjMTI3KSB7XG4gICAgICAgICAgczUgPSBwZWckYzEyNztcbiAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTI4KTsgfVxuICAgICAgICB9XG4gICAgICAgIHBlZyRzaWxlbnRGYWlscy0tO1xuICAgICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzNCA9IHBlZyRjMTg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcbiAgICAgICAgICBzNCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBpZiAoaW5wdXQubGVuZ3RoID4gcGVnJGN1cnJQb3MpIHtcbiAgICAgICAgICAgIHM1ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4NCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xuICAgICAgICAgICAgczMgPSBzNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMzO1xuICAgICAgICAgIHMzID0gcGVnJGMwO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgczQgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMxMjcpIHtcbiAgICAgICAgICAgIHM1ID0gcGVnJGMxMjc7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTI4KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgICAgICBpZiAoczUgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJGMxODtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNDtcbiAgICAgICAgICAgIHM0ID0gcGVnJGMwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5sZW5ndGggPiBwZWckY3VyclBvcykge1xuICAgICAgICAgICAgICBzNSA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4NCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IFtzNCwgczVdO1xuICAgICAgICAgICAgICBzMyA9IHM0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMztcbiAgICAgICAgICAgICAgczMgPSBwZWckYzA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczM7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMikgPT09IHBlZyRjMTI3KSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRjMTI3O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEyOCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzXTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzA7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vlb2woKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gMTApIHtcbiAgICAgICAgczAgPSBwZWckYzEzMDtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEzMSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAyKSA9PT0gcGVnJGMxMzIpIHtcbiAgICAgICAgICBzMCA9IHBlZyRjMTMyO1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMzMpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMykge1xuICAgICAgICAgICAgczAgPSBwZWckYzEzNDtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMzUpOyB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA4MjMyKSB7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMxMzY7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMzcpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA4MjMzKSB7XG4gICAgICAgICAgICAgICAgczAgPSBwZWckYzEzODtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTM5KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMjkpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vlb2xDaGFyKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGMxNDAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNDEpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2V3aGl0ZXNwYWNlKCkge1xuICAgICAgdmFyIHMwLCBzMTtcblxuICAgICAgcGVnJHNpbGVudEZhaWxzKys7XG4gICAgICBpZiAocGVnJGMxNDMudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNDQpOyB9XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNDIpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cblxuICAgICAgdmFyIHV0aWxzID0gcmVxdWlyZShcIi4vdXRpbHNcIik7XG5cblxuICAgIHBlZyRyZXN1bHQgPSBwZWckc3RhcnRSdWxlRnVuY3Rpb24oKTtcblxuICAgIGlmIChwZWckcmVzdWx0ICE9PSBwZWckRkFJTEVEICYmIHBlZyRjdXJyUG9zID09PSBpbnB1dC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBwZWckcmVzdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA8IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICBwZWckZmFpbCh7IHR5cGU6IFwiZW5kXCIsIGRlc2NyaXB0aW9uOiBcImVuZCBvZiBpbnB1dFwiIH0pO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obnVsbCwgcGVnJG1heEZhaWxFeHBlY3RlZCwgcGVnJG1heEZhaWxQb3MpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgU3ludGF4RXJyb3I6IFN5bnRheEVycm9yLFxuICAgIHBhcnNlOiAgICAgICBwYXJzZVxuICB9O1xufSkoKTtcbiIsInZhciB1dGlscyA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgLyogUEVHLmpzIHZlcnNpb24gKHVzZXMgc2VtYW50aWMgdmVyc2lvbmluZykuICovXG4gIFZFUlNJT046IFwiMC44LjBcIixcblxuICBHcmFtbWFyRXJyb3I6IHJlcXVpcmUoXCIuL2dyYW1tYXItZXJyb3JcIiksXG4gIHBhcnNlcjogICAgICAgcmVxdWlyZShcIi4vcGFyc2VyXCIpLFxuICBjb21waWxlcjogICAgIHJlcXVpcmUoXCIuL2NvbXBpbGVyXCIpLFxuXG4gIC8qXG4gICAqIEdlbmVyYXRlcyBhIHBhcnNlciBmcm9tIGEgc3BlY2lmaWVkIGdyYW1tYXIgYW5kIHJldHVybnMgaXQuXG4gICAqXG4gICAqIFRoZSBncmFtbWFyIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGZvcm1hdCBkZXNjcmliZWQgYnkgdGhlIG1ldGFncmFtYXIgaW5cbiAgICogdGhlIHBhcnNlci5wZWdqcyBmaWxlLlxuICAgKlxuICAgKiBUaHJvd3MgfFBFRy5wYXJzZXIuU3ludGF4RXJyb3J8IGlmIHRoZSBncmFtbWFyIGNvbnRhaW5zIGEgc3ludGF4IGVycm9yIG9yXG4gICAqIHxQRUcuR3JhbW1hckVycm9yfCBpZiBpdCBjb250YWlucyBhIHNlbWFudGljIGVycm9yLiBOb3RlIHRoYXQgbm90IGFsbFxuICAgKiBlcnJvcnMgYXJlIGRldGVjdGVkIGR1cmluZyB0aGUgZ2VuZXJhdGlvbiBhbmQgc29tZSBtYXkgcHJvdHJ1ZGUgdG8gdGhlXG4gICAqIGdlbmVyYXRlZCBwYXJzZXIgYW5kIGNhdXNlIGl0cyBtYWxmdW5jdGlvbi5cbiAgICovXG4gIGJ1aWxkUGFyc2VyOiBmdW5jdGlvbihncmFtbWFyKSB7XG4gICAgZnVuY3Rpb24gY29udmVydFBhc3NlcyhwYXNzZXMpIHtcbiAgICAgIHZhciBjb252ZXJ0ZWQgPSB7fSwgc3RhZ2U7XG5cbiAgICAgIGZvciAoc3RhZ2UgaW4gcGFzc2VzKSB7XG4gICAgICAgIGlmIChwYXNzZXMuaGFzT3duUHJvcGVydHkoc3RhZ2UpKSB7XG4gICAgICAgICAgY29udmVydGVkW3N0YWdlXSA9IHV0aWxzLnZhbHVlcyhwYXNzZXNbc3RhZ2VdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gY29udmVydGVkO1xuICAgIH1cblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgPyB1dGlscy5jbG9uZShhcmd1bWVudHNbMV0pIDoge30sXG4gICAgICAgIHBsdWdpbnMgPSBcInBsdWdpbnNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5wbHVnaW5zIDogW10sXG4gICAgICAgIGNvbmZpZyAgPSB7XG4gICAgICAgICAgcGFyc2VyOiB0aGlzLnBhcnNlcixcbiAgICAgICAgICBwYXNzZXM6IGNvbnZlcnRQYXNzZXModGhpcy5jb21waWxlci5wYXNzZXMpXG4gICAgICAgIH07XG5cbiAgICB1dGlscy5lYWNoKHBsdWdpbnMsIGZ1bmN0aW9uKHApIHsgcC51c2UoY29uZmlnLCBvcHRpb25zKTsgfSk7XG5cbiAgICByZXR1cm4gdGhpcy5jb21waWxlci5jb21waWxlKFxuICAgICAgY29uZmlnLnBhcnNlci5wYXJzZShncmFtbWFyKSxcbiAgICAgIGNvbmZpZy5wYXNzZXMsXG4gICAgICBvcHRpb25zXG4gICAgKTtcbiAgfVxufTtcbiIsInZhciB1dGlscyA9IHtcbiAgLyogTGlrZSBQeXRob24ncyB8cmFuZ2V8LCBidXQgd2l0aG91dCB8c3RlcHwuICovXG4gIHJhbmdlOiBmdW5jdGlvbihzdGFydCwgc3RvcCkge1xuICAgIGlmIChzdG9wID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHN0b3AgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG5cbiAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KE1hdGgubWF4KDAsIHN0b3AgLSBzdGFydCkpO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gc3RhcnQ7IGogPCBzdG9wOyBpKyssIGorKykge1xuICAgICAgcmVzdWx0W2ldID0gajtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBmaW5kOiBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5W2ldO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICBpbmRleE9mOiBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChjYWxsYmFjayhhcnJheVtpXSkpIHtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfSxcblxuICBjb250YWluczogZnVuY3Rpb24oYXJyYXksIHZhbHVlKSB7XG4gICAgLypcbiAgICAgKiBTdHVwaWQgSUUgZG9lcyBub3QgaGF2ZSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZiwgb3RoZXJ3aXNlIHRoaXMgZnVuY3Rpb25cbiAgICAgKiB3b3VsZCBiZSBhIG9uZS1saW5lci5cbiAgICAgKi9cbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhcnJheVtpXSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuICBlYWNoOiBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2spIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGNhbGxiYWNrKGFycmF5W2ldLCBpKTtcbiAgICB9XG4gIH0sXG5cbiAgbWFwOiBmdW5jdGlvbihhcnJheSwgY2FsbGJhY2spIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbaV0gPSBjYWxsYmFjayhhcnJheVtpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgcGx1Y2s6IGZ1bmN0aW9uKGFycmF5LCBrZXkpIHtcbiAgICByZXR1cm4gdXRpbHMubWFwKGFycmF5LCBmdW5jdGlvbiAoZSkgeyByZXR1cm4gZVtrZXldOyB9KTtcbiAgfSxcblxuICBrZXlzOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgdmFsdWVzOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKG9iamVjdFtrZXldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICBjbG9uZTogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGlmIChvYmplY3QuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LFxuXG4gIGRlZmF1bHRzOiBmdW5jdGlvbihvYmplY3QsIGRlZmF1bHRzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRzKSB7XG4gICAgICBpZiAoZGVmYXVsdHMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICBpZiAoIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gZGVmYXVsdHNba2V5XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKlxuICAgKiBUaGUgY29kZSBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggdGhlIGNvZGUgdGVtcGxhdGUgaW4gdGhlIGNvbXBpbGF0aW9uXG4gICAqIGZ1bmN0aW9uIGZvciBcImFjdGlvblwiIG5vZGVzLlxuICAgKi9cbiAgc3ViY2xhc3M6IGZ1bmN0aW9uKGNoaWxkLCBwYXJlbnQpIHtcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gY2hpbGQ7IH1cbiAgICBjdG9yLnByb3RvdHlwZSA9IHBhcmVudC5wcm90b3R5cGU7XG4gICAgY2hpbGQucHJvdG90eXBlID0gbmV3IGN0b3IoKTtcbiAgfSxcblxuICAvKlxuICAgKiBSZXR1cm5zIGEgc3RyaW5nIHBhZGRlZCBvbiB0aGUgbGVmdCB0byBhIGRlc2lyZWQgbGVuZ3RoIHdpdGggYSBjaGFyYWN0ZXIuXG4gICAqXG4gICAqIFRoZSBjb2RlIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB0aGUgY29kZSB0ZW1wbGF0ZSBpbiB0aGUgY29tcGlsYXRpb25cbiAgICogZnVuY3Rpb24gZm9yIFwiYWN0aW9uXCIgbm9kZXMuXG4gICAqL1xuICBwYWRMZWZ0OiBmdW5jdGlvbihpbnB1dCwgcGFkZGluZywgbGVuZ3RoKSB7XG4gICAgdmFyIHJlc3VsdCA9IGlucHV0O1xuXG4gICAgdmFyIHBhZExlbmd0aCA9IGxlbmd0aCAtIGlucHV0Lmxlbmd0aDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHQgPSBwYWRkaW5nICsgcmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH0sXG5cbiAgLypcbiAgICogUmV0dXJucyBhbiBlc2NhcGUgc2VxdWVuY2UgZm9yIGdpdmVuIGNoYXJhY3Rlci4gVXNlcyBcXHggZm9yIGNoYXJhY3RlcnMgPD1cbiAgICogMHhGRiB0byBzYXZlIHNwYWNlLCBcXHUgZm9yIHRoZSByZXN0LlxuICAgKlxuICAgKiBUaGUgY29kZSBuZWVkcyB0byBiZSBpbiBzeW5jIHdpdGggdGhlIGNvZGUgdGVtcGxhdGUgaW4gdGhlIGNvbXBpbGF0aW9uXG4gICAqIGZ1bmN0aW9uIGZvciBcImFjdGlvblwiIG5vZGVzLlxuICAgKi9cbiAgZXNjYXBlOiBmdW5jdGlvbihjaCkge1xuICAgIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgdmFyIGVzY2FwZUNoYXI7XG4gICAgdmFyIGxlbmd0aDtcblxuICAgIGlmIChjaGFyQ29kZSA8PSAweEZGKSB7XG4gICAgICBlc2NhcGVDaGFyID0gJ3gnO1xuICAgICAgbGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgZXNjYXBlQ2hhciA9ICd1JztcbiAgICAgIGxlbmd0aCA9IDQ7XG4gICAgfVxuXG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZUNoYXIgKyB1dGlscy5wYWRMZWZ0KGNoYXJDb2RlLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLCAnMCcsIGxlbmd0aCk7XG4gIH0sXG5cbiAgLypcbiAgICogU3Vycm91bmRzIHRoZSBzdHJpbmcgd2l0aCBxdW90ZXMgYW5kIGVzY2FwZXMgY2hhcmFjdGVycyBpbnNpZGUgc28gdGhhdCB0aGVcbiAgICogcmVzdWx0IGlzIGEgdmFsaWQgSmF2YVNjcmlwdCBzdHJpbmcuXG4gICAqXG4gICAqIFRoZSBjb2RlIG5lZWRzIHRvIGJlIGluIHN5bmMgd2l0aCB0aGUgY29kZSB0ZW1wbGF0ZSBpbiB0aGUgY29tcGlsYXRpb25cbiAgICogZnVuY3Rpb24gZm9yIFwiYWN0aW9uXCIgbm9kZXMuXG4gICAqL1xuICBxdW90ZTogZnVuY3Rpb24ocykge1xuICAgIC8qXG4gICAgICogRUNNQS0yNjIsIDV0aCBlZC4sIDcuOC40OiBBbGwgY2hhcmFjdGVycyBtYXkgYXBwZWFyIGxpdGVyYWxseSBpbiBhIHN0cmluZ1xuICAgICAqIGxpdGVyYWwgZXhjZXB0IGZvciB0aGUgY2xvc2luZyBxdW90ZSBjaGFyYWN0ZXIsIGJhY2tzbGFzaCwgY2FycmlhZ2VcbiAgICAgKiByZXR1cm4sIGxpbmUgc2VwYXJhdG9yLCBwYXJhZ3JhcGggc2VwYXJhdG9yLCBhbmQgbGluZSBmZWVkLiBBbnkgY2hhcmFjdGVyXG4gICAgICogbWF5IGFwcGVhciBpbiB0aGUgZm9ybSBvZiBhbiBlc2NhcGUgc2VxdWVuY2UuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUkgY2hhcmFjdGVycy5cbiAgICAgKiBOb3RlIHRoYXQgXCJcXDBcIiBhbmQgXCJcXHZcIiBlc2NhcGUgc2VxdWVuY2VzIGFyZSBub3QgdXNlZCBiZWNhdXNlIEpTSGludCBkb2VzXG4gICAgICogbm90IGxpa2UgdGhlIGZpcnN0IGFuZCBJRSB0aGUgc2Vjb25kLlxuICAgICAqL1xuICAgIHJldHVybiAnXCInICsgc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgIC8vIGJhY2tzbGFzaFxuICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSAgICAvLyBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlclxuICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpIC8vIGJhY2tzcGFjZVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKSAgIC8vIGhvcml6b250YWwgdGFiXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICAgLy8gbGluZSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpICAgLy8gZm9ybSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRS1cXHgxRlxceDgwLVxcdUZGRkZdL2csIHV0aWxzLmVzY2FwZSlcbiAgICAgICsgJ1wiJztcbiAgfSxcblxuICAvKlxuICAgKiBFc2NhcGVzIGNoYXJhY3RlcnMgaW5zaWRlIHRoZSBzdHJpbmcgc28gdGhhdCBpdCBjYW4gYmUgdXNlZCBhcyBhIGxpc3Qgb2ZcbiAgICogY2hhcmFjdGVycyBpbiBhIGNoYXJhY3RlciBjbGFzcyBvZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbi5cbiAgICovXG4gIHF1b3RlRm9yUmVnZXhwQ2xhc3M6IGZ1bmN0aW9uKHMpIHtcbiAgICAvKlxuICAgICAqIEJhc2VkIG9uIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNSAmIDE1LjEwLjEuXG4gICAgICpcbiAgICAgKiBGb3IgcG9ydGFiaWxpdHksIHdlIGFsc28gZXNjYXBlIGFsbCBjb250cm9sIGFuZCBub24tQVNDSUkgY2hhcmFjdGVycy5cbiAgICAgKi9cbiAgICByZXR1cm4gc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgIC8vIGJhY2tzbGFzaFxuICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXFxcXC8nKSAgIC8vIGNsb3Npbmcgc2xhc2hcbiAgICAgIC5yZXBsYWNlKC9cXF0vZywgJ1xcXFxdJykgICAvLyBjbG9zaW5nIGJyYWNrZXRcbiAgICAgIC5yZXBsYWNlKC9cXF4vZywgJ1xcXFxeJykgICAvLyBjYXJldFxuICAgICAgLnJlcGxhY2UoLy0vZywgICdcXFxcLScpICAgLy8gZGFzaFxuICAgICAgLnJlcGxhY2UoL1xcMC9nLCAnXFxcXDAnKSAgIC8vIG51bGxcbiAgICAgIC5yZXBsYWNlKC9cXHQvZywgJ1xcXFx0JykgICAvLyBob3Jpem9udGFsIHRhYlxuICAgICAgLnJlcGxhY2UoL1xcbi9nLCAnXFxcXG4nKSAgIC8vIGxpbmUgZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcdi9nLCAnXFxcXHgwQicpIC8vIHZlcnRpY2FsIHRhYlxuICAgICAgLnJlcGxhY2UoL1xcZi9nLCAnXFxcXGYnKSAgIC8vIGZvcm0gZmVlZFxuICAgICAgLnJlcGxhY2UoL1xcci9nLCAnXFxcXHInKSAgIC8vIGNhcnJpYWdlIHJldHVyblxuICAgICAgLnJlcGxhY2UoL1tcXHgwMS1cXHgwOFxceDBFLVxceDFGXFx4ODAtXFx1RkZGRl0vZywgdXRpbHMuZXNjYXBlKTtcbiAgfSxcblxuICAvKlxuICAgKiBCdWlsZHMgYSBub2RlIHZpc2l0b3IgLS0gYSBmdW5jdGlvbiB3aGljaCB0YWtlcyBhIG5vZGUgYW5kIGFueSBudW1iZXIgb2ZcbiAgICogb3RoZXIgcGFyYW1ldGVycywgY2FsbHMgYW4gYXBwcm9wcmlhdGUgZnVuY3Rpb24gYWNjb3JkaW5nIHRvIHRoZSBub2RlIHR5cGUsXG4gICAqIHBhc3NlcyBpdCBhbGwgaXRzIHBhcmFtZXRlcnMgYW5kIHJldHVybnMgaXRzIHZhbHVlLiBUaGUgZnVuY3Rpb25zIGZvclxuICAgKiB2YXJpb3VzIG5vZGUgdHlwZXMgYXJlIHBhc3NlZCBpbiBhIHBhcmFtZXRlciB0byB8YnVpbGROb2RlVmlzaXRvcnwgYXMgYVxuICAgKiBoYXNoLlxuICAgKi9cbiAgYnVpbGROb2RlVmlzaXRvcjogZnVuY3Rpb24oZnVuY3Rpb25zKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbnNbbm9kZS50eXBlXS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH0sXG5cbiAgZmluZFJ1bGVCeU5hbWU6IGZ1bmN0aW9uKGFzdCwgbmFtZSkge1xuICAgIHJldHVybiB1dGlscy5maW5kKGFzdC5ydWxlcywgZnVuY3Rpb24ocikgeyByZXR1cm4gci5uYW1lID09PSBuYW1lOyB9KTtcbiAgfSxcblxuICBpbmRleE9mUnVsZUJ5TmFtZTogZnVuY3Rpb24oYXN0LCBuYW1lKSB7XG4gICAgcmV0dXJuIHV0aWxzLmluZGV4T2YoYXN0LnJ1bGVzLCBmdW5jdGlvbihyKSB7IHJldHVybiByLm5hbWUgPT09IG5hbWU7IH0pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHV0aWxzO1xuIiwiLypcbiAoYykgMjAxMywgVmxhZGltaXIgQWdhZm9ua2luXG4gUkJ1c2gsIGEgSmF2YVNjcmlwdCBsaWJyYXJ5IGZvciBoaWdoLXBlcmZvcm1hbmNlIDJEIHNwYXRpYWwgaW5kZXhpbmcgb2YgcG9pbnRzIGFuZCByZWN0YW5nbGVzLlxuIGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoXG4qL1xuXG4oZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuXG4gICAgLy8ganNoaW50IG5ld2NhcDogZmFsc2UsIHZhbGlkdGhpczogdHJ1ZVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHsgcmV0dXJuIG5ldyByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpOyB9XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKCF0aGlzLl9pbnRlcnNlY3RzKGJib3gsIG5vZGUuYmJveCkpIHsgcmV0dXJuIHJlc3VsdDsgfVxuXG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW10sXG4gICAgICAgICAgICBpLCBsZW4sIGNoaWxkLCBjaGlsZEJCb3g7XG5cbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdGhpcy50b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaGlsZCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGVzVG9TZWFyY2gucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHsgcmV0dXJuIHRoaXM7IH1cblxuICAgICAgICBpZiAoZGF0YS5sZW5ndGggPCB0aGlzLl9taW5FbnRyaWVzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZGF0YS5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0KGRhdGFbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cblxuICAgICAgICAvLyByZWN1cnNpdmVseSBidWlsZCB0aGUgdHJlZSB3aXRoIHRoZSBnaXZlbiBkYXRhIGZyb20gc3RyYXRjaCB1c2luZyBPTVQgYWxnb3JpdGhtXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fYnVpbGQoZGF0YS5zbGljZSgpLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkge1xuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5kYXRhID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgICAgIGJib3g6IHRoaXMuX2VtcHR5KCksXG4gICAgICAgICAgICBoZWlnaHQ6IDFcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtKSB7IHJldHVybiB0aGlzOyB9XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBub2RlLmNoaWxkcmVuLmluZGV4T2YoaXRlbSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiB0aGlzLl9jb250YWlucyhub2RlLmJib3gsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2UgeyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgICAgICAgICAgbm9kZSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYVswXSAtIGJbMF07IH0sXG4gICAgY29tcGFyZU1pblk6IGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhWzFdIC0gYlsxXTsgfSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2guYXBwbHkocmVzdWx0LCBub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoLmFwcGx5KG5vZGVzVG9TZWFyY2gsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxldmVsLCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IGl0ZW1zLmxlbmd0aCxcbiAgICAgICAgICAgIE0gPSB0aGlzLl9tYXhFbnRyaWVzLFxuICAgICAgICAgICAgbm9kZTtcblxuICAgICAgICBpZiAoTiA8PSBNKSB7XG4gICAgICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBpdGVtcyxcbiAgICAgICAgICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICAgICAgICAgIGhlaWdodDogMVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX2NhbGNCQm94KG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWxldmVsKSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcblxuICAgICAgICAgICAgaXRlbXMuc29ydCh0aGlzLmNvbXBhcmVNaW5YKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRPRE8gZWxpbWluYXRlIHJlY3Vyc2lvbj9cblxuICAgICAgICBub2RlID0ge1xuICAgICAgICAgICAgY2hpbGRyZW46IFtdLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICB2YXIgTjEgPSBNYXRoLmNlaWwoTiAvIE0pICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBjb21wYXJlID0gbGV2ZWwgJSAyID09PSAxID8gdGhpcy5jb21wYXJlTWluWCA6IHRoaXMuY29tcGFyZU1pblksXG4gICAgICAgICAgICBpLCBqLCBzbGljZSwgc2xpY2VMZW4sIGNoaWxkTm9kZTtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IE47IGkgKz0gTjEpIHtcbiAgICAgICAgICAgIHNsaWNlID0gaXRlbXMuc2xpY2UoaSwgaSArIE4xKS5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSAwLCBzbGljZUxlbiA9IHNsaWNlLmxlbmd0aDsgaiA8IHNsaWNlTGVuOyBqICs9IE4yKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFjayBlYWNoIGVudHJ5IHJlY3Vyc2l2ZWx5XG4gICAgICAgICAgICAgICAgY2hpbGROb2RlID0gdGhpcy5fYnVpbGQoc2xpY2Uuc2xpY2UoaiwgaiArIE4yKSwgbGV2ZWwgKyAxLCBoZWlnaHQgLSAxKTtcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goY2hpbGROb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NhbGNCQm94KG5vZGUpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIHsgYnJlYWs7IH1cblxuICAgICAgICAgICAgbWluQXJlYSA9IG1pbkVubGFyZ2VtZW50ID0gSW5maW5pdHk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDAsIGxlbiA9IG5vZGUuY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgYXJlYSA9IHRoaXMuX2FyZWEoY2hpbGQuYmJveCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSB0aGlzLl9lbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQuYmJveCkgLSBhcmVhO1xuXG4gICAgICAgICAgICAgICAgLy8gY2hvb3NlIGVudHJ5IHdpdGggdGhlIGxlYXN0IGFyZWEgZW5sYXJnZW1lbnRcbiAgICAgICAgICAgICAgICBpZiAoZW5sYXJnZW1lbnQgPCBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICBtaW5FbmxhcmdlbWVudCA9IGVubGFyZ2VtZW50O1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlbmxhcmdlbWVudCA9PT0gbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBvbmUgd2l0aCB0aGUgc21hbGxlc3QgYXJlYVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZSA9IGNoaWxkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBub2RlID0gdGFyZ2V0Tm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciBiYm94ID0gaXNOb2RlID8gaXRlbS5iYm94IDogdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBpbnNlcnRQYXRoID0gW107XG5cbiAgICAgICAgLy8gZmluZCB0aGUgYmVzdCBub2RlIGZvciBhY2NvbW1vZGF0aW5nIHRoZSBpdGVtLCBzYXZpbmcgYWxsIG5vZGVzIGFsb25nIHRoZSBwYXRoIHRvb1xuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2Nob29zZVN1YnRyZWUoYmJveCwgdGhpcy5kYXRhLCBsZXZlbCwgaW5zZXJ0UGF0aCk7XG5cbiAgICAgICAgLy8gcHV0IHRoZSBpdGVtIGludG8gdGhlIG5vZGVcbiAgICAgICAgbm9kZS5jaGlsZHJlbi5wdXNoKGl0ZW0pO1xuICAgICAgICB0aGlzLl9leHRlbmQobm9kZS5iYm94LCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgbmV3Tm9kZSA9IHtcbiAgICAgICAgICAgIGNoaWxkcmVuOiBub2RlLmNoaWxkcmVuLnNwbGljZSh0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pKSxcbiAgICAgICAgICAgIGhlaWdodDogbm9kZS5oZWlnaHRcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAobm9kZS5sZWFmKSB7XG4gICAgICAgICAgICBuZXdOb2RlLmxlYWYgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fY2FsY0JCb3gobm9kZSk7XG4gICAgICAgIHRoaXMuX2NhbGNCQm94KG5ld05vZGUpO1xuXG4gICAgICAgIGlmIChsZXZlbCkge1xuICAgICAgICAgICAgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX3NwbGl0Um9vdDogZnVuY3Rpb24gKG5vZGUsIG5ld05vZGUpIHtcbiAgICAgICAgLy8gc3BsaXQgcm9vdCBub2RlXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmRhdGEuY2hpbGRyZW4gPSBbbm9kZSwgbmV3Tm9kZV07XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuX2NhbGNCQm94KHRoaXMuZGF0YSk7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTcGxpdEluZGV4OiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBpLCBiYm94MSwgYmJveDIsIG92ZXJsYXAsIGFyZWEsIG1pbk92ZXJsYXAsIG1pbkFyZWEsIGluZGV4O1xuXG4gICAgICAgIG1pbk92ZXJsYXAgPSBtaW5BcmVhID0gSW5maW5pdHk7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8PSBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBiYm94MSA9IHRoaXMuX2Rpc3RCQm94KG5vZGUsIDAsIGkpO1xuICAgICAgICAgICAgYmJveDIgPSB0aGlzLl9kaXN0QkJveChub2RlLCBpLCBNKTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IHRoaXMuX2ludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSB0aGlzLl9hcmVhKGJib3gxKSArIHRoaXMuX2FyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiB0aGlzLl9jb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiB0aGlzLl9jb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG5cbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSB7XG4gICAgICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8vIHRvdGFsIG1hcmdpbiBvZiBhbGwgcG9zc2libGUgc3BsaXQgZGlzdHJpYnV0aW9ucyB3aGVyZSBlYWNoIG5vZGUgaXMgYXQgbGVhc3QgbSBmdWxsXG4gICAgX2FsbERpc3RNYXJnaW46IGZ1bmN0aW9uIChub2RlLCBtLCBNLCBjb21wYXJlKSB7XG5cbiAgICAgICAgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmUpO1xuXG4gICAgICAgIHZhciBsZWZ0QkJveCA9IHRoaXMuX2Rpc3RCQm94KG5vZGUsIDAsIG0pLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gdGhpcy5fZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0pLFxuICAgICAgICAgICAgbWFyZ2luID0gdGhpcy5fbWFyZ2luKGxlZnRCQm94KSArIHRoaXMuX21hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdGhpcy50b0JCb3goY2hpbGQpIDogY2hpbGQuYmJveCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gdGhpcy5fbWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRoaXMudG9CQm94KGNoaWxkKSA6IGNoaWxkLmJib3gpO1xuICAgICAgICAgICAgbWFyZ2luICs9IHRoaXMuX21hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbiAgICBfZGlzdEJCb3g6IGZ1bmN0aW9uIChub2RlLCBrLCBwKSB7XG4gICAgICAgIHZhciBiYm94ID0gdGhpcy5fZW1wdHkoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIHRoaXMuX2V4dGVuZChiYm94LCBub2RlLmxlYWYgPyB0aGlzLnRvQkJveChjaGlsZCkgOiBjaGlsZC5iYm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBiYm94O1xuICAgIH0sXG5cbiAgICAvLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG4gICAgX2NhbGNCQm94OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBub2RlLmJib3ggPSB0aGlzLl9kaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgdGhpcy5fZXh0ZW5kKHBhdGhbaV0uYmJveCwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWxjQkJveChwYXRoW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfY29udGFpbnM6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgcmV0dXJuIGFbMF0gPD0gYlswXSAmJlxuICAgICAgICAgICAgICAgYVsxXSA8PSBiWzFdICYmXG4gICAgICAgICAgICAgICBiWzJdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgICAgIGJbM10gPD0gYVszXTtcbiAgICB9LFxuXG4gICAgX2ludGVyc2VjdHM6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHJldHVybiBiWzBdIDw9IGFbMl0gJiZcbiAgICAgICAgICAgICAgIGJbMV0gPD0gYVszXSAmJlxuICAgICAgICAgICAgICAgYlsyXSA+PSBhWzBdICYmXG4gICAgICAgICAgICAgICBiWzNdID49IGFbMV07XG4gICAgfSxcblxuICAgIF9leHRlbmQ6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIGFbMF0gPSBNYXRoLm1pbihhWzBdLCBiWzBdKTtcbiAgICAgICAgYVsxXSA9IE1hdGgubWluKGFbMV0sIGJbMV0pO1xuICAgICAgICBhWzJdID0gTWF0aC5tYXgoYVsyXSwgYlsyXSk7XG4gICAgICAgIGFbM10gPSBNYXRoLm1heChhWzNdLCBiWzNdKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfSxcblxuICAgIF9hcmVhOiAgIGZ1bmN0aW9uIChhKSB7IHJldHVybiAoYVsyXSAtIGFbMF0pICogKGFbM10gLSBhWzFdKTsgfSxcbiAgICBfbWFyZ2luOiBmdW5jdGlvbiAoYSkgeyByZXR1cm4gKGFbMl0gLSBhWzBdKSArIChhWzNdIC0gYVsxXSk7IH0sXG5cbiAgICBfZW5sYXJnZWRBcmVhOiBmdW5jdGlvbiAoYSwgYikge1xuICAgICAgICByZXR1cm4gKE1hdGgubWF4KGJbMl0sIGFbMl0pIC0gTWF0aC5taW4oYlswXSwgYVswXSkpICpcbiAgICAgICAgICAgICAgIChNYXRoLm1heChiWzNdLCBhWzNdKSAtIE1hdGgubWluKGJbMV0sIGFbMV0pKTtcbiAgICB9LFxuXG4gICAgX2ludGVyc2VjdGlvbkFyZWE6IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYVswXSwgYlswXSksXG4gICAgICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYVsxXSwgYlsxXSksXG4gICAgICAgICAgICBtYXhYID0gTWF0aC5taW4oYVsyXSwgYlsyXSksXG4gICAgICAgICAgICBtYXhZID0gTWF0aC5taW4oYVszXSwgYlszXSk7XG5cbiAgICAgICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG4gICAgfSxcblxuICAgIF9lbXB0eTogZnVuY3Rpb24gKCkgeyByZXR1cm4gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldOyB9LFxuXG4gICAgX2NvbXBhcmVOb2RlTWluWDogZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuYmJveFswXSAtIGIuYmJveFswXTsgfSxcbiAgICBfY29tcGFyZU5vZGVNaW5ZOiBmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5iYm94WzFdIC0gYi5iYm94WzFdOyB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgLy8ganNoaW50IGV2aWw6IHRydWVcblxuICAgICAgICB2YXIgY29tcGFyZUFyciA9IFsncmV0dXJuIGEnLCAnIC0gYicsICc7J107XG5cbiAgICAgICAgdGhpcy5jb21wYXJlTWluWCA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFswXSkpO1xuICAgICAgICB0aGlzLmNvbXBhcmVNaW5ZID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzFdKSk7XG5cbiAgICAgICAgdGhpcy50b0JCb3ggPSBuZXcgRnVuY3Rpb24oJ2EnLCAncmV0dXJuIFthJyArIGZvcm1hdC5qb2luKCcsIGEnKSArICddOycpO1xuICAgIH1cbn07XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiByYnVzaDtcbiAgICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBzZWxmLnJidXNoID0gcmJ1c2g7XG59IGVsc2Uge1xuICAgIHdpbmRvdy5yYnVzaCA9IHJidXNoO1xufVxuXG59KSgpO1xuIiwicmVxdWlyZShcIi4vU01DLmpzXCIpO1xuLyoqXG4gKiBDbGFzcyBhYmxlIG9mIGNyZWF0aW5nIFNNQyBWaWV3ZXIgbGF5ZXIgb2JqZWN0cyBmcm9tIGNvbmZpZ3VyYXRpb24uXG4gKiBAY2xhc3NcbiAqIEBhYnN0cmFjdFxuICogQG1peGluIFNNQy5MYXllckxvYWRlclxuICogQGV4dGVuZHMgTC5DbGFzc1xuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLkxheWVyTG9hZGVyID0gTC5DbGFzcy5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLkxheWVyTG9hZGVyIyAqL1xuICAgIHtcblxuICAgICAgICBsb2FkZWRMYXllcnM6IHt9LFxuICAgICAgICBsYWJlbExheWVyczp7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlcyBsYXllcnMgZnJvbSBhIEphdmFzY3JpcHQgb2JqZWN0IChvciBpdHMgamF2YXNjcmlwdCByZXByc2VudGFudGlvbikgZGVmaW5pbmcgdGhlIHR5cGUgYW5kIG9wdGlvbnMgb2YgdGhlIGxheWVycyB0byBiZSBsb2FkZWQuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBtZXRob2RcbiAgICAgICAgICogQHBhcmFtIHsoT2JqZWN0fEpTT04pfSBsYXllcnNDb25maWcgLSBDb25maWd1cmF0aW9uIHRvIGxvYWQgYSBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZExheWVyczogZnVuY3Rpb24obGF5ZXJzQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIWxheWVyc0NvbmZpZykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMuTGF5ZXJMb2FkZXI6OmxvYWRMYXllcnM6IG5vIGxheWVycyBjb25maWcgcmVjZWl2ZWRcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGF5ZXJzQ29uZmlnID09PSBcIm9iamVjdFwiICYmIGxheWVyc0NvbmZpZy51cmwpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiBsYXllcnNDb25maWcudXJsLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGRhdGEsIHRleHRTdGF0dXMsIGpxWEhSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2FkSnNvbkFycmF5KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRKc29uQXJyYXkobGF5ZXJzQ29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfbG9hZEpzb25BcnJheTogZnVuY3Rpb24obGF5ZXJzQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGxheWVyc0NvbmZpZyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJzQ29uZmlnID0gSlNPTi5wYXJzZShsYXllcnNDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFMLlV0aWwuaXNBcnJheShsYXllcnNDb25maWcpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLmxheWVycy5MYXllckxvYWRlcjo6bG9hZExheWVyczogbGF5ZXJzIGNvbmZpZyBpcyBub3QgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVyc0NvbmZpZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckNvbmZpZyA9IGxheWVyc0NvbmZpZ1tpXTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX2xvYWRMYXllckNvbmZpZyhsYXllckNvbmZpZywgaSArIDEpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2xvYWRMYXllckNvbmZpZzogZnVuY3Rpb24obGF5ZXJDb25maWcsIGlkeCkge1xuICAgICAgICAgICAgdmFyIHR5cGUgPSBsYXllckNvbmZpZy50eXBlO1xuICAgICAgICAgICAgdmFyIGxheWVyID0gbnVsbDtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMuTGF5ZXJMb2FkZXI6Ol9sb2FkTGF5ZXJDb25maWc6IGxheWVyIGNvbmZpZyBpbiBwb3NpdGlvbiBcIiArIGlkeCArIFwiIGRvZXNuJ3QgZGVmaW5lIGEgdHlwZVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHR5cGUgIT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMuTGF5ZXJMb2FkZXI6Ol9sb2FkTGF5ZXJDb25maWc6IGxheWVyIGNvbmZpZyBpbiBwb3NpdGlvbiBcIiArIGlkeCArIFwiIGRvZXNuJ3QgZGVmaW5lIGEgdHlwZSBhcyBhIGNsYXNzIG5hbWUgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHBhcmFtcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHVybCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSAnJztcbiAgICAgICAgICAgIHZhciB0eXBlUGF0aHMgPSB0eXBlLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZVBhdGhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbGFiZWwgPSB0eXBlUGF0aHNbaV07XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKHR5cGUgPT09IFwiZm9sZGVyXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBGb2xkZXJzIGFyZSBhIHNwZWNpYWwgY2FzZSBpbiB3aGljaCB3ZSBhbGxvdyBhIHNob3J0Y3V0IHRvIGVhc2UgY29uZmlndXJhdGlvbi5cbiAgICAgICAgICAgICAgICBsYXllckNsYXNzID0gU01DLmxheWVycy5Gb2xkZXI7XG4gICAgICAgICAgICAgICAgaWYgKCFsYXllckNvbmZpZy5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLmxheWVycy5MYXllckxvYWRlcjo6X2xvYWRMYXllckNvbmZpZzogbGF5ZXIgY29uZmlnIGluIHBvc2l0aW9uIFwiICsgaWR4ICsgXCIgaXMgb2YgdHlwZSAnZm9sZGVyJyBidXQgZG9lc24ndCBkZWZpbmUgYSBsYXllcnMgYXJyYXkuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKmlmICghbGF5ZXJDb25maWcubGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLmxheWVycy5MYXllckxvYWRlcjo6X2xvYWRMYXllckNvbmZpZzogbGF5ZXIgY29uZmlnIGluIHBvc2l0aW9uIFwiICsgaWR4ICsgXCIgaXMgb2YgdHlwZSAnZm9sZGVyJyBidXQgZG9lc24ndCBkZWZpbmUgYSBsYWJlbCBwcm9wZXJ0eS5cIik7XG4gICAgICAgICAgICAgICAgfSovXG4gICAgICAgICAgICAgICAgcGFyYW1zID0gW3tcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzQ29uZmlnOiBsYXllckNvbmZpZy5sYXllcnMsXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiBsYXllckNvbmZpZy5sYWJlbCB8fCBsYWJlbFxuICAgICAgICAgICAgICAgIH1dO1xuXG4gICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIGlmIChsYXllckNvbmZpZy5wYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zID0gbGF5ZXJDb25maWcucGFyYW1zO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJDb25maWcudXJsKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IGxheWVyQ29uZmlnLnVybDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IEpTT04ucGFyc2UocGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihwYXJhbXMpe1xuICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zKSAmJiBwYXJhbXMubGVuZ3RoID4wKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZighcGFyYW1zWzBdLmxhYmVsKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1swXS5sYWJlbD0gbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKCFwYXJhbXMubGFiZWwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmxhYmVsPSBsYWJlbCAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoIWxheWVyQ29uZmlnLnBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGFiZWw6IGxheWVyQ29uZmlnLmxhYmVsIHx8IGxhYmVsXG4gICAgICAgICAgICAgICAgICAgIH1dO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghbGF5ZXJDb25maWcucGFyYW1zICYmIGxheWVyQ29uZmlnLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBbe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzQ29uZmlnOiBsYXllckNvbmZpZy5sYXllcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBsYWJlbDogbGF5ZXJDb25maWcubGFiZWwgfHwgbGFiZWwsXG4gICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IGxheWVyQ29uZmlnLmFjdGl2ZVxuICAgICAgICAgICAgICAgICAgICB9XTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBXZSB0cmF2ZXJzZSB0aGUgc3BlZmljaWVkIGNsYXNzICdwYWNrYWdlcycgZnJvbSB0aGUgcm9vdCAod2luZG93KSB0byBvYnRhaW4gdGhlIGFjdHVhbCBjbGFzcyBvYmplY3QuXG4gICAgICAgICAgICAgICAgbGF5ZXJDbGFzcyA9IFNNQy5VdGlsLmdldENsYXNzKHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBDbGFzcyBpbnN0YW50aWF0aW9uIGNvZGUgZnJvbSBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2MDY3OTcvdXNlLW9mLWFwcGx5LXdpdGgtbmV3LW9wZXJhdG9yLWlzLXRoaXMtcG9zc2libGVcbiAgICAgICAgICAgIHZhciBjb25zdHJ1Y3RvciA9IFNNQy5VdGlsLmdldENvbnN0cnVjdG9yKGxheWVyQ2xhc3MpO1xuXG4gICAgICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJhbXNbMF0udXJsID0gdXJsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9zZXRMYWJlbChwYXJhbXNbMF0ubGFiZWwpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2V0TGFiZWwocGFyYW1zLmxhYmVsKTsgICAgXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBcblxuICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zWzBdLmxhYmVsID0gdGhpcy5fc2V0TGFiZWwocGFyYW1zWzBdLmxhYmVsKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMubGFiZWwgPSB0aGlzLl9zZXRMYWJlbChwYXJhbXMubGFiZWwpOyAgICBcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGF5ZXIgPSBjb25zdHJ1Y3RvcihwYXJhbXMpO1xuXG4gICAgICAgICAgICBpZiAobGF5ZXJDb25maWcubGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgZXZlbnROYW1lIGluIGxheWVyQ29uZmlnLmxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgICAgICBsYXllci5vbihldmVudE5hbWUsIGxheWVyQ29uZmlnLmxpc3RlbmVyc1tldmVudE5hbWVdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgdHJpZ2dlcnMgYW5kIHRoZSBsYXllciBpcyByZWxvYWRhYmxlLCB3ZSBhZGQgdGhlIHRyaWdnZXJzLlxuICAgICAgICAgICAgaWYgKGxheWVyQ29uZmlnLnJlbG9hZFRyaWdnZXJzICYmICh0eXBlb2YgbGF5ZXIuYWRkUmVsb2FkVHJpZ2dlciA9PT0gXCJmdW5jdGlvblwiKSkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHRJZHggPSAwOyB0SWR4IDwgbGF5ZXJDb25maWcucmVsb2FkVHJpZ2dlcnMubGVuZ3RoOyB0SWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRyaWdnZXJDb25maWcgPSBsYXllckNvbmZpZy5yZWxvYWRUcmlnZ2Vyc1t0SWR4XTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuYWRkUmVsb2FkVHJpZ2dlcih0cmlnZ2VyQ29uZmlnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUaGUgbGF5ZXIgbG9hZGVyIGlzIG1peGVkIGluIGludG8gYSBtYXAgKG9yIEZvbGRlcikgc28gd2UgY2FuIGFkZCBsYXllcnMgdG8gdGhhdC5cbiAgICAgICAgICAgIGxheWVyLl9tYXAgPSB0aGlzO1xuXG4gICAgICAgICAgICBpZih0eXBlID09PSAgXCJTTUMubGF5ZXJzLmdlb21ldHJ5LlNvbHJHZW9tZXRyeUhpc3RvcnlMYXllclwiKXtcbiAgICAgICAgICAgICAgICBsYXllci5kb0ZlYXR1cmVzTG9hZGluZygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllci5hZGRUbyh0aGlzKTtcblxuICAgICAgICAgICAgLy8gVGhlIGxvYWRlciAodGhhdCBpcywgdGhlIG1hcCBvciBGb2xkZXIpIGlzIHRoZSBsYXllcidzIHBhcmVudFxuICAgICAgICAgICBcbiAgICAgICAgICAgIGxheWVyLnBhcmVudCA9IHRoaXM7XG4gIFxuICAgICAgICAgIFxuXG4gICAgICAgICAgICB2YXIgaWQ7XG4gICAgICAgICAgICBpZiAobGF5ZXJDb25maWcuaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IGxheWVyQ29uZmlnLmlkO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZCA9IFwibGF5ZXJcIiArIEwuc3RhbXAobGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvYWRlZExheWVyc1tpZF0gPSBsYXllcjtcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0TGFiZWw6IGZ1bmN0aW9uKGxhYmVsKXtcbiAgICAgICAgICAgIHZhciBleGlzdCA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIG5ld0xhYmVsID0gJyc7XG4gICAgICAgICAgICBmb3IodmFyIGwgaW4gdGhpcy5sYWJlbExheWVycyl7XG4gICAgICAgICAgICAgICAgaWYobCA9PSBsYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgIGV4aXN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKCFleGlzdCl7XG4gICAgICAgICAgICAgICAgdGhpcy5sYWJlbExheWVyc1tsYWJlbF0gPSBbXTtcbiAgICAgICAgICAgICAgICBuZXdMYWJlbCA9IGxhYmVsO1xuICAgICAgICAgICAgICAgIHRoaXMubGFiZWxMYXllcnNbbGFiZWxdLnB1c2gobmV3TGFiZWwpO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5sYWJlbExheWVyc1tsYWJlbF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgIG5ld0xhYmVsID0gbGFiZWwrXCIgXCIgK2kudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGlsZSh0aGlzLmxhYmVsTGF5ZXJzW25ld0xhYmVsXSl7XG4gICAgICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICAgICAgbmV3TGFiZWwgPSBsYWJlbCtcIiBcIiAraS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBmb3IodmFyIGxiIGluIHRoaXMubGFiZWxMYXllcnNbbGFiZWxdKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKHRoaXMubGFiZWxMYXllcnNbbGFiZWxdW2xiXSA9PSBuZXdMYWJlbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdMYWJlbCA9IGxhYmVsK1wiIFwiICtpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxhYmVsTGF5ZXJzW2xhYmVsXS5wdXNoKG5ld0xhYmVsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXdMYWJlbDtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4iLCJyZXF1aXJlKFwiLi9TTUMuanNcIik7XG5yZXF1aXJlKFwiLi9VdGlsLmpzXCIpO1xucmVxdWlyZShcIi4vTGF5ZXJMb2FkZXIuanNcIik7XG5cbi8qKlxuICogVGhlIG1hcCB2aWV3ZXIgY29tcG9uZW50IG9mIFNNQy5cbiAqIEV4dGVuZHMgW0xlYWZsZXQncyBtYXAgY29tcG9uZW50XXtAbGluayBodHRwOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNtYXAtY2xhc3N9XG4gKiB0byBpbmNsdWRlIG91ciBuZWVkZWQgZnVuY3Rpb25hbGl0eS5cbiAqXG4gKiBAY2xhc3MgVGhlIG1hcCB2aWV3ZXIgY29tcG9uZW50IG9mIFNNQy5cbiAqIEBleHRlbmRzIEwuTWFwXG4gKiBAbWl4ZXMgU01DLkxheWVyTG9hZGVyXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMuTWFwID0gTC5NYXAuZXh0ZW5kKFxuXHQvKiogQGxlbmRzIFNNQy5NYXAjICovXG5cdHtcblx0XG5cdFx0XG5cdH0sIFtTTUMuTGF5ZXJMb2FkZXJdKTtcblxuLyoqXG4gKiBBUEkgZmFjdG9yeSBtZXRob2QgZm9yIGNyZWF0aW5nIFNNQ1ZpZXdlcidzIE1hcHMuXG4gKiBAbWV0aG9kXG4gKiBAcGFyYW0geyhIVE1MRWxlbWVudHxTdHJpbmcpfSBlbGVtZW50IC0gVGhlIGlkIG9mIHRoZSBlbGVtZW50IHRoZSBtYXAgd2lsbCBiZSBjcmVhdGVkIGluXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIENvbmZpZ3VyYXRpb24gZm9yIHRoZSBtYXBcbiAqL1xuU01DLm1hcCA9IGZ1bmN0aW9uKGVsZW1lbnQsIG9wdGlvbnMpIHtcblx0cmV0dXJuIG5ldyBTTUMuTWFwKGVsZW1lbnQsIG9wdGlvbnMpO1xufTsiLCJyZXF1aXJlKFwiLi4vbGliL2xlYWZsZXQvbGVhZmxldC1zcmMuanNcIik7XG5yZXF1aXJlKFwiLi9VdGlsLmpzXCIpO1xuXG4vKipcbiAqIEdsb2JhbCBuYW1lc3BhY2UgZm9yIGNsYXNzZXMgbWFraW5nIHVwIHRoZSBTTUMncyBtYXAgdmlld2VyXG4gKiBAbmFtZXNwYWNlXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQyA9IHtcblx0LyoqXG4gICAgICogQmFzZSB1cmwgd2hlcmUgcmVzb3VyY2VzIGFyZVxuICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBCQVNFX1VSTCAtIFRoZSBkZWZhdWx0IHVybCB2YWx1ZS5cbiAgICAgKiBAZGVmYXVsdCAuLi9kaXN0L1xuICAgICAqL1xuXHRCQVNFX1VSTDogXCIuLi8uLi9kaXN0L1wiXG59O1xuIiwicmVxdWlyZShcIi4vU01DLmpzXCIpO1xuXG5cblNNQy5VdGlsID0ge1xuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBjbGFzcyBvYmplY3QgZnJvbSBpdHMgbmFtZSAoaW5jbHVkaW5nIHBhdGgpLlxuICAgICAqL1xuICAgIGdldENsYXNzOiBmdW5jdGlvbihjbGFzc05hbWUpIHtcbiAgICAgICAgdmFyIHR5cGVQYXRocyA9IGNsYXNzTmFtZS5zcGxpdChcIi5cIik7XG4gICAgICAgIHZhciBjbGFzc09iamVjdCA9IHdpbmRvdztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlUGF0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNsYXNzT2JqZWN0ID0gY2xhc3NPYmplY3RbdHlwZVBhdGhzW2ldXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghY2xhc3NPYmplY3QucHJvdG90eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTTUMubGF5ZXJzLkxheWVyTG9hZGVyOjpfbG9hZExheWVyQ29uZmlnOiBsYXllciBjb25maWcgaW4gcG9zaXRpb24gXCIgKyBpZHggKyBcIiBkZWZpbmVkIHR5cGUgJ1wiICsgdHlwZSArIFwiJyBpcyBub3QgYSB2YWxpZCBjbGFzc1wiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjbGFzc09iamVjdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhIGNvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgc3BlY2lmaWVkIGNsYXNzLlxuICAgICAqL1xuICAgIGdldENvbnN0cnVjdG9yOiBmdW5jdGlvbihjbGFzc09iamVjdCkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gRihhcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc09iamVjdC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2xhc3NPYmplY3QuYXBwbHkodGhpcywgYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBGLnByb3RvdHlwZSA9IGNsYXNzT2JqZWN0LnByb3RvdHlwZTtcblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEYoYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pKCk7XG4gICAgfVxufTsiLCJyZXF1aXJlKFwiLi9jb250cm9scy5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi9saWIvbGVhZmxldC5kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5qc1wiKTtcblxuU01DLmNvbnRyb2xzLklzb2Nocm9uZUNvbnRyb2wgPSBMLkNvbnRyb2wuRHJhdy5leHRlbmQoe1xuXHRvcHRpb25zOiB7XG5cdFx0IGRyYXc6IHtcbiAgICAgICAgICAgIHBvbHlsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgIHBvbHlnb246IGZhbHNlLFxuICAgICAgICAgICAgcmVjdGFuZ2xlOiBmYWxzZSxcbiAgICAgICAgICAgIGNpcmNsZTogZmFsc2UsXG4gICAgICAgICAgICBtYXJrZXI6ZmFsc2VcbiAgICAgICAgIH0sXG4gICAgIFxuXHR9LFxuXHRpbnB1dHM6e1xuICAgICAgICAgICAgd2Fsa1RpbWU6IFwibnVtXCIsXG4gICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICBcdHdhbGs6IHtcbiAgICAgICAgICAgIFx0XHRjb250ZW50OidXQUxLJyxcbiAgICAgICAgICAgIFx0XHRsYWJlbDonV2FsaydcbiAgICAgICAgICAgIFx0fSxcbiAgICAgICAgICAgIFx0dHJhbnNpdDoge1xuICAgICAgICAgICAgXHRcdGNvbnRlbnQ6ICdUUkFOU0lULFdBTEsnLFxuICAgICAgICAgICAgXHRcdGxhYmVsOiAnVHJhbnNpdCdcbiAgICAgICAgICAgIFx0fSxcbiAgICAgICAgICAgIFx0YnVzOiB7XG4gICAgICAgICAgICBcdFx0Y29udGVudDonQlVTSVNILFdBTEsnLFxuICAgICAgICAgICAgXHRcdGxhYmVsOiAnQnVzIG9ubHknXG4gICAgICAgICAgICBcdH0sXG4gICAgICAgICAgICBcdHRyYWluOiB7XG4gICAgICAgICAgICBcdFx0Y29udGVudDogJ1RSQUlOSVNILFdBTEsnLFxuICAgICAgICAgICAgXHRcdGxhYmVsOiAnVHJhaW4gb25seSdcbiAgICAgICAgICAgIFx0fSxcbiAgICAgICAgICAgIFx0YmljeWNsZToge1xuICAgICAgICAgICAgXHRcdGNvbnRlbnQ6J0JJQ1lDTEUnLFxuICAgICAgICAgICAgXHRcdGxhYmVsOiAnQmljeWNsZSBvbmx5J1xuICAgICAgICAgICAgXHR9LFxuICAgICAgICAgICAgXHRyZW50ZWRfYmljeWNsZToge1xuICAgICAgICAgICAgXHRcdGNvbnRlbnQ6J1dBTEssQklDWUNMRScsXG4gICAgICAgICAgICBcdFx0bGFiZWw6ICdSZW50ZWQgYmljeWNsZSdcbiAgICAgICAgICAgIFx0fSxcbiAgICAgICAgICAgIFx0dHJhbnNpdF9iaWN5Y2xlOiB7XG4gICAgICAgICAgICBcdFx0Y29udGVudDonVFJBTlNJVCxCSUNZQ0xFJyxcbiAgICAgICAgICAgIFx0XHRsYWJlbDogJ1RyYW5zaXQgJiBCaWN5Y2xlJ1xuICAgICAgICAgICAgXHR9LFxuICAgICAgICAgICAgXHR0cmFuc2l0X3JlbnRlZF9iaWN5Y2xlOiB7XG4gICAgICAgICAgICBcdFx0Y29udGVudDonVFJBTlNJVCxXQUxLLEJJQ1lDTEUnLFxuICAgICAgICAgICAgXHRcdGxhYmVsOiAnVHJhbnNpdCAmICBSZW50ZWQgQmljeWNsZSdcbiAgICAgICAgICAgIFx0fSxcbiAgICAgICAgICAgIFx0Y2FyOiB7XG4gICAgICAgICAgICBcdFx0Y29udGVudDogJ0NBUicsXG4gICAgICAgICAgICBcdFx0bGFiZWw6ICdDYXInXG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtYXhXYWxrRGlzdGFuY2U6IFwibnVtXCIsXG4gICAgICAgICAgICB0aW1lOiBcImRhdGVcIixcbiAgICAgICAgICAgIGFycml2ZUJ5OiB7XG4gICAgICAgICAgICBcdHllczp7XG5cdFx0XHRcdFx0IGNvbnRlbnQ6ICd5ZXMnLFxuXHRcdFx0XHRcdCBsYWJlbDogJ1llcydcblx0XHRcdFx0fSxcbiAgICAgICAgICAgIFx0bm86IHtcbiAgICAgICAgICAgIFx0XHRjb250ZW50OidubycsXG4gICAgICAgICAgICBcdFx0bGFiZWw6ICdObydcbiAgICAgICAgICAgIFx0fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdhbGtTcGVlZDogJ251bScsXG4gICAgICAgICAgICBiaWtlU3BlZWQ6ICdudW0nLCBcbiAgICAgICAgICAgIG91dHB1dDoge1xuICAgICAgICAgICAgXHRzaGVkOntcbiAgICAgICAgICAgIFx0IGNvbnRlbnQ6J1NIRUQnLFxuICAgICAgICAgICAgXHQgbGFiZWw6ICdQb2x5Z29uJ1xuICAgICAgICAgICAgXHR9LFxuICAgICAgICAgICAgXHRlZGdlczp7XG4gICAgICAgICAgICBcdFx0Y29udGVudDonRURHRVMnLFxuICAgICAgICAgICAgXHRcdGxhYmVsOiAnTGluZXMnXG4gICAgICAgICAgICBcdH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBsYWJlbDpcInRleHRcIlxuICAgICB9LFxuICAgICBwYXJhbXM6e1xuICAgICBcdGxhYmVsOiAnSXNvY3JvbmEnXG4gICAgIH0sXG5cblx0XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gKG1hcCkge1xuXHRcdGlmKG1hcC5pc28pe1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRMLkNvbnRyb2wuRHJhdy5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XG5cdFx0bWFwLmFkZENvbnRyb2wodGhpcyk7XG5cdFx0bWFwLmlzbyA9IHRydWU7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0bWFwLm9uKCdkcmF3OnN0YXJ0SXNvJywgZnVuY3Rpb24oZSl7XG5cdFx0XHRcdHNlbGYuc2V0Rm9ybShlLnRvb2xiYXIpO1x0XG5cdFx0fSk7XG5cblx0XHRtYXAub24oJ2RyYXc6Y3JlYXRlZCcsIGZ1bmN0aW9uIChlKSB7XG5cdFx0XHRcdHZhciBsYXQgPSBlLmxheWVyLl9sYXRsbmcubGF0O1xuXHRcdFx0XHR2YXIgbG5nID0gZS5sYXllci5fbGF0bG5nLmxuZztcblx0XHRcdFx0dmFyIHBhcmFtc1JlcXVlc3QgPSBzZWxmLnBhcmFtcztcblx0XHRcdFx0cGFyYW1zUmVxdWVzdC5mcm9tUGxhY2UgPSBsYXQgK1wiLFwiICsgbG5nO1xuXHQgICAgICAgICAgICBtYXAubG9hZExheWVycyhbe1xuXHRcdCAgICAgICAgICAgIHR5cGU6IFwiU01DLmxheWVycy5Jc29jaHJvbmVMYXllclwiLFxuXHRcdCAgICAgICAgICAgIHBhcmFtczpbcGFyYW1zUmVxdWVzdF1cblx0XHQgICAgICAgICB9LHtcblx0ICAgXHRcdFx0IHR5cGU6IFwiTC5NYXJrZXJcIixcblx0ICAgICAgICAgICAgIHBhcmFtczogW1xuXHQgICAgICAgICAgICAgICAgW2xhdCwgbG5nXSwge1xuXHQgICAgICAgICAgICAgICAgICAgIGxhYmVsOiBzZWxmLnBhcmFtcy5sYWJlbCArICcgTWFya2VyJ1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBdXG5cblx0XHRcdCAgICB9XSk7XG5cdFx0XHRcblx0ICAgIH0pO1xuXG4gICAgICAgXG5cdH0sXG5cblx0XG5cblx0c2V0Rm9ybTogZnVuY3Rpb24odG9vbGJhcil7XG5cdFx0dG9vbGJhci5fZGlzYWJsZWQoKTtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XG5cdFx0dmFyIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lcjtcblx0XHRjb250YWluZXIuc3R5bGUud2lkdGggPSAnMjZweCc7XG5cdFx0dmFyIHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGFibGUnKTtcblx0XHR0YWJsZS5pZCA9ICdmb3JtSXNvY2hyb25lJztcblx0XHR0YWJsZS5jbGFzc05hbWUgPSAnbGVhZmxldC1mb3JtJztcblx0XHR0YWJsZS5vbm1vdXNlZW50ZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuX21hcC5kcmFnZ2luZy5kaXNhYmxlKCk7XG5cdFx0XHRzZWxmLl9tYXAua2V5Ym9hcmQuZGlzYWJsZSgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHRhYmxlLm9ubW91c2VsZWF2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5fbWFwLmRyYWdnaW5nLmVuYWJsZSgpO1xuXHRcdFx0c2VsZi5fbWFwLmtleWJvYXJkLmVuYWJsZSgpO1xuXHRcdH1cblx0XHRmb3IodmFyIGkgaW4gdGhpcy5pbnB1dHMpe1xuXHRcdFx0dmFyIGUgPSB0aGlzLmlucHV0c1tpXTtcblx0XHRcdHZhciB0ciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RyJyk7XG5cdFx0XHR2YXIgdGQxID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcblx0XHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcblx0XHRcdGxhYmVsLmlubmVySFRNTCA9IGk7XG5cdFx0XHR0ZDEuYXBwZW5kQ2hpbGQobGFiZWwpO1xuXHRcdFx0dHIuYXBwZW5kQ2hpbGQodGQxKTtcblx0XHRcdHZhciB0ZDIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuXHRcdFx0dmFyIGlucHV0O1xuXHRcdFx0aWYoZSA9PSAnbnVtJyB8fCBlID09ICd0ZXh0Jyl7XG5cdFx0XHRcdGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblx0XHRcdFx0aW5wdXQudHlwZSA9ICd0ZXh0Jztcblx0XHRcdFx0bGFiZWwuYXBwZW5kQ2hpbGQoaW5wdXQpO1xuXHRcdFx0XHRpZihlID09ICdudW0nKXtcblx0XHRcdFx0XHRpbnB1dC5vbmtleXByZXNzID0gZnVuY3Rpb24oZXZlbnQpe1xuXHRcdFx0XHRcdFx0aWYgKChldmVudC5rZXlDb2RlIDwgNDgpIHx8IChldmVudC5rZXlDb2RlID4gNTcpKSBcbiAgXHRcdFx0XHRcdFx0XHRldmVudC5yZXR1cm5WYWx1ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYoZSA9PSAnZGF0ZScpe1xuXHRcdFx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRcdGlucHV0LnR5cGUgPSAnZGF0ZXRpbWUtbG9jYWwnO1xuXHRcdFx0XHRsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG5cdFx0XHR9XG5cdFx0XHRcblx0XHRcdGlmKGUgaW5zdGFuY2VvZiBPYmplY3Qpe1xuXHRcdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWxlY3QnKTtcblx0XHRcdFx0Zm9yKHZhciBvIGluIGUpe1xuXHRcdFx0XHRcdHZhciBvcHRpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdvcHRpb24nKTtcblx0XHRcdFx0XHRvcHRpb24udmFsdWUgPSBlW29dLmNvbnRlbnQ7XG5cdFx0XHRcdFx0b3B0aW9uLmlubmVySFRNTCA9IGVbb10ubGFiZWw7XG5cdFx0XHRcdFx0aW5wdXQuYXBwZW5kQ2hpbGQob3B0aW9uKTtcblx0XHRcdFx0XHRcblx0XHRcdFx0fVxuXHRcdFx0XG5cdFx0XHR9XG5cdFx0XHRpbnB1dC5pZCA9IGk7XG5cdFx0XHRpbnB1dC5zdHlsZS53aWR0aCA9ICcxMjBweCc7XG5cdFx0XHRpbnB1dC5zdHlsZS5mbG9hdCA9ICdyaWdodCc7XG5cdFx0XHRcblx0XHRcdHRkMi5hcHBlbmRDaGlsZChpbnB1dCk7XG5cdFx0XHR0ci5hcHBlbmRDaGlsZCh0ZDIpO1xuXHRcdFx0dGFibGUuYXBwZW5kQ2hpbGQodHIpO1xuXHRcdFx0XG5cdFx0fVxuXHRcdFxuXHRcdFxuXHRcdHZhciBidXR0b25zID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcblx0XHR2YXIgdGRzYXZlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcblx0XHR2YXIgc2F2ZSA9ICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuXHRcdHNhdmUudHlwZSA9ICdidXR0b24nO1xuXHRcdHNhdmUudmFsdWUgPSAnU2F2ZSc7XG5cdFx0dGRzYXZlLmFwcGVuZENoaWxkKHNhdmUpO1xuXHRcdHRkc2F2ZS5zdHlsZS50ZXh0QWxpZ24gPSAncmlnaHQnO1xuXHRcdGJ1dHRvbnMuYXBwZW5kQ2hpbGQodGRzYXZlKTtcblx0XHR2YXIgdGRjYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuXHRcdHZhciBjYW5jZWwgPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcblx0XHRjYW5jZWwudHlwZSA9ICdidXR0b24nO1xuXHRcdGNhbmNlbC52YWx1ZSA9ICdDYW5jZWwnO1xuXHRcdHRkY2FuY2VsLmFwcGVuZENoaWxkKGNhbmNlbCk7XG5cdFx0YnV0dG9ucy5hcHBlbmRDaGlsZCh0ZGNhbmNlbCk7XG5cdFx0dGFibGUuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG5cdFx0Y29udGFpbmVyLmFwcGVuZENoaWxkKHRhYmxlKTtcblx0XHRcblx0XHRjYW5jZWwub25jbGljayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRzZWxmLl9jYW5jZWwodG9vbGJhcik7XG5cdFx0fVxuXHRcdHNhdmUub25jbGljayA9IGZ1bmN0aW9uKCl7XG5cdFx0XHRzZWxmLl9zYXZlKHRvb2xiYXIsIHRhYmxlKTtcblx0XHR9XG5cblxuXHR9LFxuXG5cdF9jYW5jZWw6IGZ1bmN0aW9uKHRvb2xiYXIpe1xuXHRcdHRvb2xiYXIuX2VuYWJsZWQoKTtcblx0XHQkKCcjZm9ybUlzb2Nocm9uZScpLnJlbW92ZSgpO1xuXHRcdHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcblx0XHR0aGlzLl9tYXAua2V5Ym9hcmQuZW5hYmxlKCk7XG5cblx0fSxcblx0X3NhdmU6IGZ1bmN0aW9uKHRvb2xiYXIsIGZvcm0pe1xuXHRcdCQoJyNmb3JtSXNvY2hyb25lJykucmVtb3ZlKCk7XG5cdFx0dmFyIGZvcm0gPSBmb3JtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd0cicpO1xuXHRcdGZvcih2YXIgaT0gMDsgaSA8IGZvcm0ubGVuZ3RoIC0xOyBpKyspe1xuXHRcdFx0dmFyIG9wdGlvbiA9IGZvcm1baV0ubGFzdENoaWxkLmNoaWxkcmVuWzBdO1xuXHRcdFx0aWYob3B0aW9uLnZhbHVlICE9ICcnKXtcblx0XHRcdFx0dGhpcy5wYXJhbXNbb3B0aW9uLmlkXSA9IG9wdGlvbi52YWx1ZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0dG9vbGJhci5fZW5hYmxlZCgpO1xuXHRcdHRoaXMuX21hcC5kcmFnZ2luZy5lbmFibGUoKTtcblx0XHR0aGlzLl9tYXAua2V5Ym9hcmQuZW5hYmxlKCk7XG5cblxuXHR9XG5cblxuXG4gXG5cdFxufSk7XG5cblNNQy5pc29jaHJvbmVDb250cm9sID0gZnVuY3Rpb24obWFwKSB7XG4gICAgcmV0dXJuIG5ldyBTTUMuY29udHJvbHMuSXNvY2hyb25lQ29udHJvbChtYXApO1xufTsiLCJyZXF1aXJlKFwiLi4vU01DLmpzXCIpO1xuXG4vKipcbiAqIE5hbWVzcGFjZSBvZiBTTUMgbWFwIHZpZXdlciBjb250cm9scy5cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBTTUNcbiAqIEBhdXRob3IgTW9pc8OpcyBBcmNvcyAobWFyY29zQGVtZXJneWEuY29tKVxuICovXG5TTUMuY29udHJvbHMgPSB7fTtcbiIsInJlcXVpcmUoXCIuL2xheWVyVHJlZS5qc1wiKTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5ZXIgdHJlZSBjb250cm9scy5cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgTC5Db250cm9sXG4gKiBAcGFyYW0ge1NNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlQ29udHJvbH5vcHRpb25zfSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjbGFzc1xuICpcbiAqIEBhdXRob3IgTW9pc8OpcyBBcmNvcyAobWFyY29zQGVtZXJneWEuY29tKVxuICovXG5TTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZUNvbnRyb2wgPSBMLkNvbnRyb2wuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmNvbnRyb2xzLmxheWVyVHJlZS5MYXllclRyZWVDb250cm9sIyAqL1xuICAgIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlQ29udHJvbH5vcHRpb25zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7Ym9vbGVhbn0gY29sbGFwc2VkPXRydWUgLSBEZWZhdWx0IGNvbGxhcHNlZCB2YWx1ZVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcG9zaXRpb249J3RvcHJpZ2h0JyAtIERlZmF1bHQgcG9zaXRpb24gdmFsdWVcbiAgICAgICAgICogQHByb3BlcnR5IHtib29sZWFufSBhdXRvWkluZGV4PXRydWUgLSBEZWZhdWx0IGF1dG9aSW5kZXggdmFsdWVcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGNvbGxhcHNlZDogdHJ1ZSxcbiAgICAgICAgICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuICAgICAgICAgICAgYXV0b1pJbmRleDogdHJ1ZVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge1NNQy5sYXllcnN9IGJhc2VMYXllcnMgLSBMYXllcnMgYXMgYSBiYXNlIGxheWVyc1xuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9iamVjdCB3aXRoIGV4dHJhIGluZm9ybWF0aW9uXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihiYXNlTGF5ZXJzLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgdGhpcy5fYmFzZUxheWVycyA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fbGF5ZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLl9wYXJlbnRzID0ge307XG4gICAgICAgICAgICB0aGlzLl9sYXN0WkluZGV4ID0gMDtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX2dyb3VwTGlzdCA9IFtdO1xuICAgICAgICAgICAgdGhpcy5fZG9tR3JvdXBzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgaW4gYmFzZUxheWVycykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZExheWVyKGJhc2VMYXllcnNbaV0sIGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBnZXQgdGhlIG1hcFxuICAgICAgICAgKiBAcmV0dXJucyB7U01DLk1hcH0gbWFwIC0gTWFwIGxheWVyXG4gICAgICAgICAqL1xuICAgICAgICBnZXRNYXA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX21hcDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge1NNQy5NYXB9IG1hcCAtIE1hcCB0byBiZSBhZGRlZFxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUcmVlIGNvbnRyb2wgY29udGFpbmVyXG4gICAgICAgICAqL1xuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9pbml0TGF5b3V0KCk7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcblxuICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgLm9uKCdsYXllcmFkZCcsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpXG4gICAgICAgICAgICAgICAgLm9uKCdsYXllcnJlbW92ZScsIHRoaXMuX29uTGF5ZXJDaGFuZ2UsIHRoaXMpO1xuXG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb250YWluZXI7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBsb2FkIHRoZSBjb250cm9sIGluIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMuTWFwfSBtYXAgLSBNYXAgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgbWFwXG4gICAgICAgICAgICAgICAgLm9mZignbGF5ZXJhZGQnLCB0aGlzLl9vbkxheWVyQ2hhbmdlKVxuICAgICAgICAgICAgICAgIC5vZmYoJ2xheWVycmVtb3ZlJywgdGhpcy5fb25MYXllckNoYW5nZSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBhZGQgbGF5ZXIgYXMgYSBiYXNlIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSB7U01DLmxheWVyc30gbGF5ZXIgLSBMYXllciB0byBiZSBhZGRlZFxuICAgICAgICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIExheWVyIG5hbWVcbiAgICAgICAgICovXG4gICAgICAgIGFkZEJhc2VMYXllcjogZnVuY3Rpb24obGF5ZXIsIG5hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZExheWVyKGxheWVyLCBuYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBhZGQgbGF5ZXIgYXMgYW4gb3ZlcmxheSBsYXllclxuICAgICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAgICogQHBhcmFtIHtTTUMubGF5ZXJzfSBsYXllciAtIExheWVyIHRvIGJlIGFkZGVkXG4gICAgICAgICAqIHJldHVybnMge29iamVjdH0gVHJlZSBjb250cm9sXG4gICAgICAgICAqL1xuICAgICAgICBhZGRPdmVybGF5OiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgdGhpcy5fbWV0aG9kUmVjdXJzaXZlKGxheWVyKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZW1vdmUgYSBsYXllciBmcm9tIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMubGF5ZXJzfSBsYXllciAtIExheWVyIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICogcmV0dXJucyB7b2JqZWN0fSBUcmVlIGNvbnRyb2xcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUxheWVyOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgdmFyIGlkID0gTC5VdGlsLnN0YW1wKGxheWVyKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sYXllcnNbaWRdO1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICBfaW5pdExheW91dDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2xhc3NOYW1lID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMnLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSk7XG5cbiAgICAgICAgICAgIC8vTWFrZXMgdGhpcyB3b3JrIG9uIElFMTAgVG91Y2ggZGV2aWNlcyBieSBzdG9wcGluZyBpdCBmcm9tIGZpcmluZyBhIG1vdXNlb3V0IGV2ZW50IHdoZW4gdGhlIHRvdWNoIGlzIHJlbGVhc2VkXG4gICAgICAgICAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKCdhcmlhLWhhc3BvcHVwJywgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICghTC5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24oY29udGFpbmVyLCAnd2hlZWwnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24oY29udGFpbmVyLCAnY2xpY2snLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBmb3JtID0gdGhpcy5fZm9ybSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2Zvcm0nLCBjbGFzc05hbWUgKyAnLWxpc3QnKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUwuQnJvd3Nlci5hbmRyb2lkKSB7XG4gICAgICAgICAgICAgICAgICAgIEwuRG9tRXZlbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihjb250YWluZXIsICdtb3VzZW92ZXInLCB0aGlzLl9leHBhbmQsIHRoaXMpXG4gICAgICAgICAgICAgICAgICAgICAgICAub24oY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBsaW5rID0gdGhpcy5fbGF5ZXJzTGluayA9IEwuRG9tVXRpbC5jcmVhdGUoJ2EnLCBjbGFzc05hbWUgKyAnLXRvZ2dsZScsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICAgICAgbGluay5ocmVmID0gJyMnO1xuICAgICAgICAgICAgICAgIGxpbmsudGl0bGUgPSAnTGF5ZXJzJztcblxuICAgICAgICAgICAgICAgIGlmIChMLkJyb3dzZXIudG91Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgTC5Eb21FdmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLm9uKGxpbmssICdjbGljaycsIEwuRG9tRXZlbnQuc3RvcClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5vbihsaW5rLCAnY2xpY2snLCB0aGlzLl9leHBhbmQsIHRoaXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24obGluaywgJ2ZvY3VzJywgdGhpcy5fZXhwYW5kLCB0aGlzKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAub24oJ2NsaWNrJywgdGhpcy5fY29sbGFwc2UsIHRoaXMpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8ga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmQoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fYmFzZUxheWVyc0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWJhc2UnLCBmb3JtKTtcbiAgICAgICAgICAgIHRoaXMuX3NlcGFyYXRvciA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctc2VwYXJhdG9yJywgZm9ybSk7XG4gICAgICAgICAgICB0aGlzLl9vdmVybGF5c0xpc3QgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLW92ZXJsYXlzJywgZm9ybSk7XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyLCBuYW1lKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBMLlV0aWwuc3RhbXAobGF5ZXIpO1xuXG4gICAgICAgICAgICB0aGlzLl9sYXllcnNbaWRdID0ge1xuICAgICAgICAgICAgICAgIGxheWVyOiBsYXllcixcbiAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgIG92ZXJsYXk6IGZhbHNlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFpJbmRleCsrO1xuICAgICAgICAgICAgICAgIGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfdXBkYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9iYXNlTGF5ZXJzTGlzdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX292ZXJsYXlzTGlzdC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHRoaXMuX2RvbUdyb3Vwcy5sZW5ndGggPSAwO1xuXG4gICAgICAgICAgICB2YXIgYmFzZUxheWVyc1ByZXNlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBvdmVybGF5c1ByZXNlbnQgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBpLCBvYmo7XG5cbiAgICAgICAgICAgIGZvciAoaSBpbiB0aGlzLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICBvYmogPSB0aGlzLl9sYXllcnNbaV07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkSXRlbShvYmopO1xuICAgICAgICAgICAgICAgIG92ZXJsYXlzUHJlc2VudCA9IG92ZXJsYXlzUHJlc2VudCB8fCBvYmoub3ZlcmxheTtcbiAgICAgICAgICAgICAgICBiYXNlTGF5ZXJzUHJlc2VudCA9IGJhc2VMYXllcnNQcmVzZW50IHx8ICFvYmoub3ZlcmxheTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcblxuICAgICAgICAgICAgaWYgKG1hcCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogaW4gbWFwLl9sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gbWFwLl9sYXllcnNbal07XG4gICAgICAgICAgICAgICAgICAgIGlmIChvYmogaW5zdGFuY2VvZiBTTUMubGF5ZXJzLmFnZ3JlZ2F0aW9uLk11bHRpTW9kZUxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvYmouX2luaXRpYWxpemVUcmVlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc2VwYXJhdG9yLnN0eWxlLmRpc3BsYXkgPSBvdmVybGF5c1ByZXNlbnQgJiYgYmFzZUxheWVyc1ByZXNlbnQgPyAnJyA6ICdub25lJztcbiAgICAgICAgfSxcblxuICAgICAgICBfbWV0aG9kUmVjdXJzaXZlOiBmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgdmFyIGlkID0gTC5VdGlsLnN0YW1wKGxheWVyKTtcbiAgICAgICAgICAgIHZhciBuYW1lID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChsYXllci5jcmVhdGVOb2RlSFRNTCkge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBsYXllci5jcmVhdGVOb2RlSFRNTCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lID0gbGF5ZXIub3B0aW9ucy5sYWJlbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5fbGF5ZXJzW2lkXSkge1xuICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0ge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBsYXllcjogbGF5ZXIsXG4gICAgICAgICAgICAgICAgICAgIG92ZXJsYXk6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudDogbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLmxvYWRMYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcGFyZW50c1tpZF0gPSBlbGVtZW50O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xheWVyc1tpZF0gPSBlbGVtZW50O1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyLnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnBhcmVudCA9IEwuVXRpbC5zdGFtcChsYXllci5wYXJlbnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRob2RSZWN1cnNpdmUobGF5ZXIucGFyZW50KTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyLm9wdGlvbnMucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gbGF5ZXIub3B0aW9ucy5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21ldGhvZFJlY3Vyc2l2ZSh0aGlzLl9wYXJlbnRzW2VsZW1lbnQucGFyZW50XS5sYXllcik7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLmF1dG9aSW5kZXggJiYgbGF5ZXIuc2V0WkluZGV4KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbGFzdFpJbmRleCsrO1xuICAgICAgICAgICAgICAgIGxheWVyLnNldFpJbmRleCh0aGlzLl9sYXN0WkluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBfb25MYXllckNoYW5nZTogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUubGF5ZXIgaW5zdGFuY2VvZiBMLk1hcmtlcikge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gdHJpZ2dlciB0cmVlIHJlYnVpbGRpbmcgd2hlbiBhZGRpbmcgZWFjaCBtYXJrZXIgb2YgYSBsYXllci5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmxheWVyLl9zbGlkZXJtb3ZlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGUubGF5ZXIuX2dyb3VwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUubGF5ZXIuX2dyb3VwLl9zbGlkZXJtb3ZlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIG9iaiA9IHRoaXMuX2xheWVyc1tMLlV0aWwuc3RhbXAoZS5sYXllcildO1xuICAgICAgICAgICAgaWYgKGUubGF5ZXIuZGVsZXRlVHJlZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9sYXllcnNbTC5VdGlsLnN0YW1wKGUubGF5ZXIpXTtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlLmxheWVyLl9tYXApIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZS5sYXllci5vcHRpb25zICYmIGUubGF5ZXIub3B0aW9ucy5sYWJlbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWV0aG9kUmVjdXJzaXZlKGUubGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IG9iai5vdmVybGF5ID9cbiAgICAgICAgICAgICAgICAgICAgICAgIChlLnR5cGUgPT09ICdsYXllcmFkZCcgPyAnb3ZlcmxheWFkZCcgOiAnb3ZlcmxheXJlbW92ZScpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIChlLnR5cGUgPT09ICdsYXllcmFkZCcgPyAnYmFzZWxheWVyY2hhbmdlJyA6IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLmZpcmUodHlwZSwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxpbmdDbGljaykge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fbGF5ZXJzW0wuVXRpbC5zdGFtcChlLmxheWVyKV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICB9LFxuXG5cblxuICAgICAgICAvLyBJRTcgYnVncyBvdXQgaWYgeW91IGNyZWF0ZSBhIHJhZGlvIGR5bmFtaWNhbGx5LCBzbyB5b3UgaGF2ZSB0byBkbyBpdCB0aGlzIGhhY2t5IHdheSAoc2VlIGh0dHA6Ly9iaXQubHkvUHFZTEJlKVxuICAgICAgICBfY3JlYXRlUmFkaW9FbGVtZW50OiBmdW5jdGlvbihuYW1lLCBjaGVja2VkKSB7XG5cbiAgICAgICAgICAgIHZhciByYWRpb0h0bWwgPSAnPGlucHV0IHR5cGU9XCJyYWRpb1wiIGNsYXNzPVwibGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3RvclwiIG5hbWU9XCInICsgbmFtZSArICdcIic7XG4gICAgICAgICAgICBpZiAoY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHJhZGlvSHRtbCArPSAnIGNoZWNrZWQ9XCJjaGVja2VkXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmFkaW9IdG1sICs9ICcvPic7XG5cbiAgICAgICAgICAgIHZhciByYWRpb0ZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICByYWRpb0ZyYWdtZW50LmlubmVySFRNTCA9IHJhZGlvSHRtbDtcblxuICAgICAgICAgICAgcmV0dXJuIHJhZGlvRnJhZ21lbnQuZmlyc3RDaGlsZDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0TGFiZWw6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGFiZWwnKSxcbiAgICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgICBjaGVja2VkID0gdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllcik7XG5cbiAgICAgICAgICAgIGlmIChvYmoub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBpbnB1dC50eXBlID0gJ2NoZWNrYm94JztcbiAgICAgICAgICAgICAgICBpbnB1dC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1zZWxlY3Rvcic7XG4gICAgICAgICAgICAgICAgaW5wdXQuaWQgPSBvYmoubGF5ZXIuX2xlYWZsZXRfaWQ7XG4gICAgICAgICAgICAgICAgaW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgICAgIEwuRG9tRXZlbnQub24oaW5wdXQsICdjbGljaycsIHRoaXMuX29uSW5wdXRDbGljaywgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlucHV0ID0gdGhpcy5fY3JlYXRlUmFkaW9FbGVtZW50KCdsZWFmbGV0LWJhc2UtbGF5ZXJzJywgY2hlY2tlZCk7XG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5vbihpbnB1dCwgJ2NsaWNrJywgdGhpcy5fb25SYWRpb0NsaWNrLCB0aGlzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5wdXQubGF5ZXJJZCA9IEwuVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xuXG4gICAgICAgICAgICBpZiAob2JqLmxheWVyICYmIG9iai5sYXllci5jcmVhdGVOb2RlSFRNTCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlQ29udGVudCA9IG9iai5sYXllci5jcmVhdGVOb2RlSFRNTCgpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlQ29udGVudCkge1xuICAgICAgICAgICAgICAgICAgICBvYmoubmFtZSA9IG5vZGVDb250ZW50O1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIC8vbmFtZS5pbm5lckhUTUwgPSAnICcgKyBvYmoubmFtZTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqLm5hbWUgPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBuYW1lLmlubmVySFRNTCA9ICcgJyArIG9iai5uYW1lO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBuYW1lLmFwcGVuZENoaWxkKG9iai5uYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvYmoubGF5ZXIgaW5zdGFuY2VvZiBTTUMubGF5ZXJzLmdlb21ldHJ5LlNvbHJHZW9tZXRyeUhpc3RvcnlMYXllcikge1xuICAgICAgICAgICAgICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChuYW1lKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRHcm91cENvbnRhaW5lcjogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgZ3JvdXBDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGdyb3VwQ29udGFpbmVyLmNsYXNzTmFtZSA9ICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWdyb3VwJztcbiAgICAgICAgICAgIGdyb3VwQ29udGFpbmVyLmlkID0gJ2xlYWZsZXQtY29udHJvbC1sYXllcnMtZ3JvdXAtJyArIEwuVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xuICAgICAgICAgICAgLy8gQ3JlYXRlIHNwYW4gZm9sZGVyIHRpdGxlXG4gICAgICAgICAgICB2YXIgZ3JvdXBMYWJlbCA9IHRoaXMuX2dldEdyb3VwTGFiZWwob2JqKTtcbiAgICAgICAgICAgIC8vIEFkZCBmb2xkZXIgbGFiZWwgdG8gZ3JvdXAgY29udGFpbmVyXG4gICAgICAgICAgICBncm91cENvbnRhaW5lci5hcHBlbmRDaGlsZChncm91cExhYmVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRHcm91cExhYmVsOiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBncm91cExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgICAgICAgICAgZ3JvdXBMYWJlbC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1ncm91cC1uYW1lJztcbiAgICAgICAgICAgIGdyb3VwTGFiZWwuYXBwZW5kQ2hpbGQob2JqLm5hbWUpO1xuXG4gICAgICAgICAgICByZXR1cm4gZ3JvdXBMYWJlbDtcbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0R3JvdXBDb250ZW50OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIHZhciBncm91cENvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgIGdyb3VwQ29udGVudC5jbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWxheWVycy1ncm91cC1jb250ZW50JztcbiAgICAgICAgICAgIGlmIChvYmoubmFtZS5jbGFzc05hbWUuaW5kZXhPZihcIm9wZW5cIikgPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBncm91cENvbnRlbnQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGdyb3VwQ29udGVudDtcbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkSXRlbVJlY3Vyc2l2ZWx5OiBmdW5jdGlvbihvYmopIHtcbiAgICAgICAgICAgIGlmIChvYmoucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudHNbb2JqLnBhcmVudF07XG4gICAgICAgICAgICAgICAgdGhpcy5fYWRkSXRlbVJlY3Vyc2l2ZWx5KHBhcmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKG9iai5sYXllci5sb2FkZWRMYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZvbGRlcklkID0gTC5VdGlsLnN0YW1wKG9iai5sYXllcik7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fZG9tR3JvdXBzW2ZvbGRlcklkXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudERvbSA9IHRoaXMuX2dldFBhcmVudERvbShvYmoucGFyZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb250ZW50ID0gcGFyZW50RG9tLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWdyb3VwLWNvbnRlbnRcIilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRGb2xkZXJUb092ZXJsYXlzKG9iaiwgcGFyZW50Q29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGEgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYWRkTGF5ZXJUb092ZXJsYXlzKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqLmxheWVyLmxvYWRlZExheWVycykge1xuICAgICAgICAgICAgICAgICAgICAvLyBJdCdzIGEgZm9sZGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmb2xkZXJJZCA9IEwuVXRpbC5zdGFtcChvYmoubGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2RvbUdyb3Vwc1tmb2xkZXJJZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2FkZEZvbGRlclRvT3ZlcmxheXMob2JqKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEl0J3MgYSBsYXllclxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hZGRMYXllclRvT3ZlcmxheXMob2JqKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZEZvbGRlclRvT3ZlcmxheXM6IGZ1bmN0aW9uKG9iaiwgcGFyZW50KSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgZ3JvdXAgY29udGFpbmVyIGRpdlxuICAgICAgICAgICAgdmFyIGdyb3VwQ29udGFpbmVyID0gdGhpcy5fZ2V0R3JvdXBDb250YWluZXIob2JqKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBncm91cCBjb250ZW50IGRpdlxuICAgICAgICAgICAgZ3JvdXBDb250ZW50ID0gdGhpcy5fZ2V0R3JvdXBDb250ZW50KG9iaik7XG4gICAgICAgICAgICAvLyBBZGQgZ3JvdXAgY29udGVudCB0byBncm91cCBjb250YWluZXJcbiAgICAgICAgICAgIGdyb3VwQ29udGFpbmVyLmFwcGVuZENoaWxkKGdyb3VwQ29udGVudCk7XG4gICAgICAgICAgICAvLyBBZGQgZ3JvdXAgY29udGFpbmVyIHRvIGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChncm91cENvbnRhaW5lcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChncm91cENvbnRhaW5lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBZGQgZ3JvdXAgY29udGFpbmVyIHRvIGRvbUdyb3Vwc1xuICAgICAgICAgICAgdGhpcy5fZG9tR3JvdXBzW0wuVXRpbC5zdGFtcChvYmoubGF5ZXIpXSA9IGdyb3VwQ29udGFpbmVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRQYXJlbnREb206IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICB2YXIgcGFyZW50ID0gbnVsbDtcbiAgICAgICAgICAgIGZvciAoZWwgaW4gdGhpcy5fZG9tR3JvdXBzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGdyb3VwSWQgPSB0aGlzLl9kb21Hcm91cHNbZWxdLmlkLnNwbGl0KFwiLVwiKVs0XTtcbiAgICAgICAgICAgICAgICBpZiAoZ3JvdXBJZCA9PSBpZCkge1xuICAgICAgICAgICAgICAgICAgICBwYXJlbnQgPSB0aGlzLl9kb21Hcm91cHNbZWxdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZExheWVyVG9PdmVybGF5czogZnVuY3Rpb24ob2JqKSB7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLl9nZXRMYWJlbChvYmopO1xuICAgICAgICAgICAgaWYgKG9iai5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGFyZW50ID0gdGhpcy5fZ2V0UGFyZW50RG9tKG9iai5wYXJlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnRDb250ZW50ID0gcGFyZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoXCJsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWdyb3VwLWNvbnRlbnRcIilbMF07XG4gICAgICAgICAgICAgICAgcGFyZW50Q29udGVudC5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZEl0ZW06IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5fZ2V0TGFiZWwob2JqKTtcbiAgICAgICAgICAgIGlmIChvYmoub3ZlcmxheSkge1xuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IHRoaXMuX292ZXJsYXlzTGlzdDtcbiAgICAgICAgICAgICAgICB0aGlzLl9hZGRJdGVtUmVjdXJzaXZlbHkob2JqKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gdGhpcy5fYmFzZUxheWVyc0xpc3Q7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGxhYmVsO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbklucHV0Q2xpY2s6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGksIGlucHV0LCBvYmosXG4gICAgICAgICAgICAgICAgaW5wdXRzID0gJCgnaW5wdXRbdHlwZT1jaGVja2JveF0nLCB0aGlzLl9mcm9tKSxcbiAgICAgICAgICAgICAgICBpbnB1dHNMZW4gPSBpbnB1dHMubGVuZ3RoO1xuXG4gICAgICAgICAgICB0aGlzLl9oYW5kbGluZ0NsaWNrID0gdHJ1ZTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGlucHV0c0xlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaW5wdXQgPSBpbnB1dHNbaV07XG4gICAgICAgICAgICAgICAgb2JqID0gdGhpcy5fbGF5ZXJzW2lucHV0LmxheWVySWRdO1xuICAgICAgICAgICAgICAgIGlmIChvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoZWNrZWQgJiYgIXRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAuYWRkTGF5ZXIob2JqLmxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICghaW5wdXQuY2hlY2tlZCAmJiB0aGlzLl9tYXAuaGFzTGF5ZXIob2JqLmxheWVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKG9iai5sYXllcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGluZ0NsaWNrID0gZmFsc2U7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uUmFkaW9DbGljazogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgaSwgaW5wdXQsIG9iaixcbiAgICAgICAgICAgICAgICBpbnB1dHMgPSAkKCdpbnB1dFt0eXBlPXJhZGlvXScsIHRoaXMuX2Zyb20pLFxuICAgICAgICAgICAgICAgIGlucHV0c0xlbiA9IGlucHV0cy5sZW5ndGg7XG5cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSB0cnVlO1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5wdXRzTGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnB1dCA9IGlucHV0c1tpXTtcbiAgICAgICAgICAgICAgICBvYmogPSB0aGlzLl9sYXllcnNbaW5wdXQubGF5ZXJJZF07XG4gICAgICAgICAgICAgICAgaWYgKG9iaikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hlY2tlZCAmJiAhdGhpcy5fbWFwLmhhc0xheWVyKG9iai5sYXllcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21hcC5hZGRMYXllcihvYmoubGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCFpbnB1dC5jaGVja2VkICYmIHRoaXMuX21hcC5oYXNMYXllcihvYmoubGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlTGF5ZXIob2JqLmxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX2hhbmRsaW5nQ2xpY2sgPSBmYWxzZTtcbiAgICAgICAgfSxcblxuICAgICAgICBfZXhwYW5kOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NvbGxhcHNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5jbGFzc05hbWUgPSB0aGlzLl9jb250YWluZXIuY2xhc3NOYW1lLnJlcGxhY2UoJyBsZWFmbGV0LWNvbnRyb2wtbGF5ZXJzLWV4cGFuZGVkJyxcbiAgICAgICAgICAgICAgICAnJyk7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuLyoqXG4gKiBBUEkgZmFjdG9yeSBtZXRob2QgZm9yIGVhc2UgY3JlYXRpb24gb2YgTGF5ZXJUcmVlQ29udHJvbC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBiYXNlTGF5ZXIgLSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIGJhc2UgbGF5ZXIgbmFtZSBhbmQgaXRzIGxheWVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3ZlcmxheXMgLSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIG92ZXJhbHlzIGxheWVyIG5hbWUgYW5zIGl0cyBsYXllclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBKYXZhc2NyaXB0IG9iamVjdCB3aXRoIHRoZSBvcHRpb25zIHBhcmFtc1xuICovXG5TTUMubGF5ZXJUcmVlQ29udHJvbCA9IGZ1bmN0aW9uKGJhc2VMYXllcnMsIG92ZXJsYXlzLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZUNvbnRyb2woYmFzZUxheWVycywgb3ZlcmxheXMsIG9wdGlvbnMpO1xufTsiLCJyZXF1aXJlKFwiLi9MYXllclRyZWVOb2RlLmpzXCIpO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBtYWtlIGEgbGF5ZXIgdHJlZSBmb2xkZXIuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlTm9kZVxuICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBPYmplY3Qgd2l0aCBpbml0aWFsaXplZCBwYXJhbWV0ZXJzXG4gKiBAbWl4aW5cbiAqXG4gKiBAYXV0aG9yIE1vaXPDqXMgQXJjb3MgKG1hcmNvc0BlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmNvbnRyb2xzLmxheWVyVHJlZS5MYXllclRyZWVGb2xkZXIgPSBTTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZU5vZGUuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmNvbnRyb2xzLmxheWVyVHJlZS5MYXllclRyZWVGb2xkZXIjICovXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogT3B0aW9ucyBwcm9wZXJ0eVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gb3B0aW9ucy5sYWJlbCAtIGxhYmVsIGxheWVyIHRyZWVcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxhYmVsOiBudWxsXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHdpdGggbmVlZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYSBub2RlIGh0bWwgdGhhdCByZXByZXNlbnRzIHRoZSBsYXllciBsYWJlbFxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBTdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBsYWJlbCBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTm9kZUhUTUw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbDtcbiAgICAgICAgfVxuICAgIH1cbik7XG4iLCJyZXF1aXJlKCcuL2xheWVyVHJlZS5qcycpO1xucmVxdWlyZShcIi4vTGF5ZXJUcmVlTm9kZS5qc1wiKTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5ZXIgdHJlZSBjb250cm9scy5cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgU01DLmNvbnRyb2xzLmxheWVyVHJlZS5MYXllclRyZWVOb2RlXG4gKiBAcGFyYW0ge1NNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlTGVhZn5vcHRpb25zfSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjbGFzc1xuICpcbiAqIEBhdXRob3IgTW9pc8OpcyBBcmNvcyAobWFyY29zQGVtZXJneWEuY29tKVxuICovXG5TTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZUxlYWYgPSBTTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZU5vZGUuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmNvbnRyb2xzLmxheWVyVHJlZS5MYXllclRyZWVMZWFmIyAqL1xuICAgIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlTGVhZn5vcHRpb25zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBsYWJlbD1udWxsIC0gbGFiZWwgbGF5ZXIgdHJlZVxuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGJhc2VMYXllcj1mYWxzZSAtIGJhc2UgbGF5ZXJcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGxhYmVsOiBudWxsLFxuICAgICAgICAgICAgYmFzZUxheWVyOiBmYWxzZVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYW4gSFRNTCBub2RlIGZvciB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVubGVzcyBvdmVycmlkZW4gYnkgaW5oZXJpdGluZyBjbGFzc2VzLCBpdCByZXR1cm5zIHRoZSBsYXllcidzIGxhYmVsLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIVE1MIGNvZGUgcmVwcmVzZW50aW5nIHRoZSBjb2RlIHRvIGJlIGFkZGVkIHRvIHRoZSBsYXllcidzIGVudHJ5IGluIHRoZSBsYXllciB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTm9kZUhUTUw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5sYWJlbDtcbiAgICAgICAgfVxuICAgIH1cbik7XG4iLCJyZXF1aXJlKCcuL2xheWVyVHJlZS5qcycpO1xucmVxdWlyZShcIi4vTGF5ZXJUcmVlQ29udHJvbC5qc1wiKTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5ZXIgdHJlZSBjb250cm9scy5cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgTC5DbGFzc1xuICpcbiAqIEBhdXRob3IgTW9pc8OpcyBBcmNvcyAobWFyY29zQGVtZXJneWEuY29tKVxuICovXG5TTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZU5vZGUgPSBMLkNsYXNzLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlTm9kZSMgKi9cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExheWVyIHZpc2liaWxpdHkgcHJvcGVydHlcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHZpc2libGUgLSBsYXllciB2aXNpYmlsaXR5IHByb3BlcnR5XG4gICAgICAgICAqIEBkZWZhdWx0IHRydWVcbiAgICAgICAgICovXG4gICAgICAgIHZpc2libGU6IHRydWUsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbnMgb2YgTGF5ZXJUcmVlTm9kZSBtdXN0IGNvbnRhaW4gYW4gb3ZlcnJpZGUgb2YgdGhpcyBtZXRob2QsIHNvIEhUTUwgbm9kZXMgY2FuIGJlIGxvYWRlZCBmcm9tIHRoZWlyIHNvdXJjZS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVOb2RlSFRNTDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMYXllclRyZWVOb2RlOjpjcmVhdGVOb2RlSFRNTCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGRlcml2YXRlIGNsYXNzZXMuXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8ga25vdyBpZiBhIGxheWVyIGlzIHZpc2libGVcbiAgICAgICAgICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaXMgdGhlIGxheWVyIGlzIHZpc2libGVcbiAgICAgICAgICovXG4gICAgICAgIGlzVmlzaWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdmlzaWJsZTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHNldCB0aGUgdmlzaWJpbGl0eSBvZiBhIHRyZWUgbm9kZS5cbiAgICAgICAgICogQG1ldGhvZFxuICAgICAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IHZpc2libGUgLSBCb29sZWFuIHBhcmFtIHRvIHNldCB2aXNpYmlsdHkgdHJ1ZSBvciBmYWxzZS5cbiAgICAgICAgICovXG4gICAgICAgIHNldFZpc2libGU6IGZ1bmN0aW9uKHZpc2libGUpIHtcbiAgICAgICAgICAgIHZpc2libGUgPSB2aXNpYmxlO1xuICAgICAgICAgICAgLy8gVE9ETzogSGFuZGxlIHZpc2liaWxpdHkgY2hhbmdlLlxuICAgICAgICB9XG4gICAgfVxuKTtcbiIsInJlcXVpcmUoXCIuLi9jb250cm9scy5qc1wiKTtcblxuLyoqXG4gKiBOYW1lc3BhY2Ugb2YgTGF5ZXJUcmVlIGNvbnRyb2xzLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFNNQy5jb250cm9sc1xuICogQGF1dGhvciBNb2lzw6lzIEFyY29zIChtYXJjb3NAZW1lcmd5YS5jb20pXG4gKi9cblNNQy5jb250cm9scy5sYXllclRyZWUgPSB7fTtcbiIsInJlcXVpcmUoXCIuL1NpbmdsZUxheWVyLmpzXCIpO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgU01DIHZpZXdlciBsYXllciB3aGljaCBhcmUgYm90aCByZWxvYWRhYmxlIGFuZCBlZGl0YWJsZSBsYXllcnMuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXJcbiAqIEBhYnN0cmFjdFxuICpcbiAqIEBhdXRob3IgTW9pc8OpcyBBcmNvcyAobWFyY29zQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLkVkaXRhYmxlTGF5ZXIgPSBTTUMubGF5ZXJzLlNpbmdsZUxheWVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMuRWRpdGFibGVMYXllciMgKi9cbiAgICB7XG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVkaXRCdXR0b25MYWJlbDogXCJTdGFydCBFZGl0aW9uXCIsXG4gICAgICAgICAgICBjb25maXJtQnV0dG9uTGFiZWw6IFwiRmluaXNoIEVkaXRpb25cIlxuICAgICAgICB9LFxuXG4gICAgICAgIF9lZGl0aW5nOiBmYWxzZSxcbiAgICAgICAgX2J1dHRvbjogbnVsbCxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gYWRkIGVkaXQgY29udHJvbCB0byBtYXBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBFdmVudCB0byBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBfc3RhcnRFZGl0Q29udHJvbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgIFwiU01DLmxheWVycy5FZGl0YWJsZUxheWVyOjpfYWRkRWRpdENvbnRyb2w6IG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gZGVyaXZhdGUgY2xhc3Nlcy5cIik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gYWRkIGVkaXQgY29udHJvbCB0byBtYXBcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBFdmVudCB0byBoYW5kbGVyXG4gICAgICAgICAqL1xuICAgICAgICBfZmluaXNoRWRpdENvbnRyb2w6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgICBcIlNNQy5sYXllcnMuRWRpdGFibGVMYXllcjo6X2FkZEVkaXRDb250cm9sOiBtdXN0IGJlIGltcGxlbWVudGVkIGluIGRlcml2YXRlIGNsYXNzZXMuXCIpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGFkZCBlZGl0IGJ1dHRvbiB0byBsYXllciB0cmVlIHBhbmVsXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfYWRkRWRpdEJ1dHRvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICBub2RlLmlkID0gdGhpcy5vcHRpb25zLmxhYmVsO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJpbmhlcml0XCI7XG4gICAgICAgICAgICAvLyBDcmVhdGUgbGFiZWxcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xuICAgICAgICAgICAgbGFiZWwuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICBsYWJlbC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMubGFiZWw7XG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzcGFjZVxuICAgICAgICAgICAgdmFyIGJyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpO1xuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChicik7XG4gICAgICAgICAgICAvLyBDcmVhdGUgc3RhcnQgZWRpdGlvbiBidXR0b25cbiAgICAgICAgICAgIHZhciBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwidHlwZVwiLCBcImJ1dHRvblwiKTtcbiAgICAgICAgICAgIGJ1dHRvbi5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLCB0aGlzLm9wdGlvbnMuZWRpdEJ1dHRvbkxhYmVsKTtcbiAgICAgICAgICAgIGJ1dHRvbi5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICBidXR0b24ub25jbGljayA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLl9lZGl0aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9maW5pc2hFZGl0Q29udHJvbChldmVudCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3N0YXJ0RWRpdENvbnRyb2woZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5fZWRpdGluZyA9ICFfdGhpcy5fZWRpdGluZztcbiAgICAgICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2VkaXRpbmcgPyBfdGhpcy5vcHRpb25zLmNvbmZpcm1CdXR0b25MYWJlbCA6IF90aGlzLm9wdGlvbnMuZWRpdEJ1dHRvbkxhYmVsKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gU28gdGhlIGV2ZW50IGRvZXNudCBwcm9wYWdhdGUuXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbm9kZS5vbmNsaWNrID0gZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLl9idXR0b24gPSBidXR0b247XG5cbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2J1dHRvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2J1dHRvbi5zdHlsZS5kaXNwbGF5ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fYnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fYnV0dG9uLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gY3JlYXRlIGFuIEhUTUwgbm9kZSBmb3IgdGhlIG5hbWUgb2YgdGhlIGxheWVyLlxuICAgICAgICAgKiBAcmV0dXJucyB7U3RyaW5nfSBIVE1MIGNvZGUgcmVwcmVzZW50aW5nIHRoZSBjb2RlIHRvIGJlIGFkZGVkIHRvIHRoZSBsYXllcidzIGVudHJ5IGluIHRoZSBsYXllciB0cmVlLlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTm9kZUhUTUw6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9hZGRFZGl0QnV0dG9uKCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbik7XG4iLCJyZXF1aXJlKFwiLi9sYXllcnMuanNcIik7XG5yZXF1aXJlKFwiLi4vY29udHJvbHMvbGF5ZXJUcmVlL0xheWVyVHJlZUZvbGRlci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9MYXllckxvYWRlci5qc1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBmb2xkZXIuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEwuTGF5ZXJHcm91cFxuICogQG1peGVzIFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlRm9sZGVyXG4gKiBAbWl4ZXMgU01DLkxheWVyTG9hZGVyXG4gKiBcbiAqIEBhdXRob3IgTW9pc8OpcyBBcmNvcyAobWFyY29zQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLkZvbGRlciA9IEwuTGF5ZXJHcm91cC5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLkZvbGRlciMgKi9cbiAgICB7XG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBMLkxheWVyR3JvdXAucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlRm9sZGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF5ZXJzQ29uZmlnKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgdXNlIHRoZSBMYXllckxvYWRlciBmdW5jdGlvbmFsaXR5LlxuICAgICAgICAgICAgICAgIHRoaXMubG9hZExheWVycyh0aGlzLm9wdGlvbnMubGF5ZXJzQ29uZmlnKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLmxheWVycykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheWVyc1tpXS5hZGRUbyh0aGlzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmxheWVyc1tpXS5wYXJlbnQgPSB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLmxheWVycy5Gb2xkZXI6OmluaXRpYWxpemU6IEVpdGhlciBsYXllcnNDb25maWcgb3IgbGF5ZXJzIG11c3QgYmUgcGFzc2VkIGFzIGFuIGluaXRpYWxpemF0aW9uIG9wdGlvbiFcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYW4gSFRNTCBub2RlIGZvciB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgY29kZSByZXByZXNlbnRpbmcgdGhlIGNvZGUgdG8gYmUgYWRkZWQgdG8gdGhlIGxheWVyJ3MgZW50cnkgaW4gdGhlIGxheWVyIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVOb2RlSFRNTDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xuICAgICAgICAgICAgbm9kZS5jbGFzc05hbWUgPSAnZmEgZmEtZm9sZGVyLW9wZW4nO1xuICAgICAgICAgICAgbm9kZS5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcbiAgICAgICAgICAgIG5vZGUub25jbGljayA9IHRoaXMuX2NsaWNrT25Gb2xkZXI7XG4gICAgICAgICAgICBub2RlLmlubmVySFRNTCA9ICh0aGlzLm9wdGlvbnMubGFiZWwgfHwgdGhpcy5vcHRpb25zLnR5cGVOYW1lKTtcbiAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jbGlja09uRm9sZGVyOiBmdW5jdGlvbihldnQpe1xuICAgICAgICAgICAgaWYoZXZ0LnRhcmdldC5jbGFzc05hbWUuaW5kZXhPZihcIm9wZW5cIikgIT0gLTEpe1xuICAgICAgICAgICAgICAgIC8vIEZvbGRlciBvcGVuZWRcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxzID0gZXZ0LnRhcmdldC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImxlYWZsZXQtY29udHJvbC1sYXllcnMtZ3JvdXAtY29udGVudFwiKTtcbiAgICAgICAgICAgICAgICBsYWJlbHNbMF0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICBldnQudGFyZ2V0LnJlbW92ZUF0dHJpYnV0ZShcImNsYXNzXCIpO1xuICAgICAgICAgICAgICAgIGV2dC50YXJnZXQuY2xhc3NOYW1lID0gXCJmYSBmYS1mb2xkZXJcIjtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIC8vIEZvbGRlciBjbG9zZWRcbiAgICAgICAgICAgICAgICB2YXIgbGFiZWxzID0gZXZ0LnRhcmdldC5wYXJlbnRFbGVtZW50LnBhcmVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShcImxlYWZsZXQtY29udHJvbC1sYXllcnMtZ3JvdXAtY29udGVudFwiKTtcbiAgICAgICAgICAgICAgICBsYWJlbHNbMF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgZXZ0LnRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJjbGFzc1wiKTtcbiAgICAgICAgICAgICAgICBldnQudGFyZ2V0LmNsYXNzTmFtZSA9IFwiZmEgZmEtZm9sZGVyLW9wZW5cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sW1NNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlRm9sZGVyLCBTTUMuTGF5ZXJMb2FkZXJdKTtcbiIsInJlcXVpcmUoXCIuL2xheWVyc1wiKTtcbnJlcXVpcmUoXCIuL1NpbmdsZUxheWVyLmpzXCIpO1xuXG5cbi8qKlxuICogV3JhcHBlciBmb3IgW0xlYWZsZXQncyBXTVMgbGF5ZXJde0BsaW5rIGh0dHA6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI3RpbGVsYXllci13bXMgfSBzbyBpdHMgaW50ZWdyYXRlZCBpbiB0aGUgU01DJ3Mgdmlld2VyIGxheWVyIGFyY2hpdGVjdHVyZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEwuVGlsZUxheWVyLldNU1xuICogQG1peGVzIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXJcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMuSXNvY2hyb25lTGF5ZXIgPSBTTUMubGF5ZXJzLmdlb21ldHJ5LldGU0dlb21ldHJ5TGF5ZXIuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmxheWVycy5XTVNMYXllciMgKi9cbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTTUMubGF5ZXJzLklzb2Nocm9uZUxheWVyfm9wdGlvbnNcbiAgICAgICAgICogQHByb3BlcnR5IHtTTUMubGF5ZXJzLklzb2Nocm9uZUxheWVyfnJlcXVlc3RQYXJhbXN9IHJlcXVlc3RQYXJhbXMgLSBEZWZhdWx0IHdmcyByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlcnZlclVSTD1udWxsIC0gVGhlIHdmcyBzZXJ2ZXIgdXJsIHBhdGggcGFyYW1ldGVyXG4gICAgICAgICAqL1xuXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIC8qKiBAdHlwZWRlZiB7T2JqZWN0fSBTTUMubGF5ZXJzLklzb2Nocm9uZUxheWVyfnJlcXVlc3RQYXJhbXMgLSBEZWZhdWx0IHdmcyByZXF1ZXN0IHBhcmFtZXRlcnMgXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gYmF0Y2g9XCJ0cnVlXCIgLSBHb2FsIGRpcmVjdGlvbiBpcyB0dXJuZWQgb2ZmXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gd2FsVGltZT1udWxsIC0gRGVmYXVsdCB0cmF2ZWwgdGltZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHN0eWxlcz1cImNvbG9yMzBcIiAtIERlZmF1bHQgc3R5bGVzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gbW9kZT1cIldBTEtcIiAtIERlZmF1bHQgdHJhdmVsIG1vZGVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBtYXhXYWxrRGlzdGFuY2U9bnVsbCAtIERlZmF1bHQgbWF4aW11biB0cmF2ZWwgZGlzdGFuY2VcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0aW1lPW51bGwgLSBEZWZhdWx0IHRpbWVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBhcnJpdmVCeT1cImZhbHNlXCIgLSBCeSBkZWZhdWx0IHRyaXAgc2hvdWxkIGRlcGFydCBhdCB0aGUgc3BlY2lmaWVkIGRhdGUgYW5kIHRpbWVcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB3YWxrU3BlZWQ9bnVsbCAtIERlZmF1bHQgd2FsayBzcGVlZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJpa2VTcGVkZD1udWxsIC0gRGVmYXVsdCBiaWtlIHNwZWVkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gb3V0cHV0PVwiU0hFRFwiIC0gRGVmYXVsdCBvdXRwdXQgZ2VvbWV0cnlcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBvdXRwdXRGb3JtYXQ9XCJ0ZXh0L2phdmFzY3JpcHRcIiAtIERlZmF1bHQgd2ZzIG91dHB1dCBmb3JtYXQgcGFyYW1ldGVyXG4gICAgICAgICAgICAgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXM6IHtcbiAgICAgICAgICAgICAgICBiYXRjaDogXCJ0cnVlXCIsXG4gICAgICAgICAgICAgICAgd2Fsa1RpbWU6IFwiMTVcIixcbiAgICAgICAgICAgICAgICBzdHlsZXM6IFwiY29sb3IzMFwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IFwiV0FMS1wiLFxuICAgICAgICAgICAgICAgIG1heFdhbGtEaXN0YW5jZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0aW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIGZyb21QbGFjZTogbnVsbCxcbiAgICAgICAgICAgICAgICB0b1BsYWNlOiBcIm5vbmVcIixcbiAgICAgICAgICAgICAgICBhcnJpdmVCeTogXCJmYWxzZVwiLFxuICAgICAgICAgICAgICAgIHdhbGtTcGVlZDogbnVsbCxcbiAgICAgICAgICAgICAgICBiaWtlU3BlZWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgb3V0cHV0OiBcIlNIRURcIixcbiAgICAgICAgICAgICAgICBvdXRwdXRGb3JtYXQ6IFwidGV4dC9qYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2VydmVyVVJMOiAnaHR0cDovLzEwNy4xNzAuODguNjI6ODA4MC9vcGVudHJpcHBsYW5uZXItYXBpLXdlYmFwcC93cy9pc28nXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2dldERhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIHRvZGF5ID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIHZhciBkZCA9IHRvZGF5LmdldERhdGUoKTtcbiAgICAgICAgICAgIHZhciBtbSA9IHRvZGF5LmdldE1vbnRoKCkgKyAxO1xuICAgICAgICAgICAgdmFyIHl5eXkgPSB0b2RheS5nZXRGdWxsWWVhcigpO1xuICAgICAgICAgICAgdmFyIGhoID0gdG9kYXkuZ2V0SG91cnMoKTtcbiAgICAgICAgICAgIHZhciBtaSA9IHRvZGF5LmdldE1pbnV0ZXMoKTtcbiAgICAgICAgICAgIHZhciBzcyA9IHRvZGF5LmdldFNlY29uZHMoKTtcblxuICAgICAgICAgICAgaWYgKGRkIDwgMTApIHtcbiAgICAgICAgICAgICAgICBkZCA9ICcwJyArIGRkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1tIDwgMTApIHtcbiAgICAgICAgICAgICAgICBtbSA9ICcwJyArIG1tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGhoIDwgMTApIHtcbiAgICAgICAgICAgICAgICBoaCA9ICcwJyArIGhoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1pIDwgMTApIHtcbiAgICAgICAgICAgICAgICBtaSA9ICcwJyArIG1pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNzIDwgMTApIHtcbiAgICAgICAgICAgICAgICBzcyA9ICcwJyArIHNzO1xuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIHRvZGF5ID0geXl5eSArICctJyArIG1tICsgJy0nICsgZGQgKyAnVCcgKyBoaCArICc6JyArIG1pICsgJzonICsgc3M7XG4gICAgICAgICAgICB0aGlzLm9wdGlvbnMudGltZSA9IHRvZGF5O1xuICAgICAgICB9LFxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy50aW1lID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9nZXREYXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuc2VydmVyVVJMKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zZXJ2ZXJVUkwgPSB0aGlzLm9wdGlvbnMuc2VydmVyVVJMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZihvcHRpb25zLnNlcnZlclVSTCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTTUMubGF5ZXJzLklzb2Nocm9uZUxheWVyOjppbml0aWFsaXplOiBvcHRpb25zIG11c3QgY29udGFpbiBhbiB1cmwgYXR0cmlidXRlIG9mIHR5cGUgc3RyaW5nLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNNQy5sYXllcnMuZ2VvbWV0cnkuV0ZTR2VvbWV0cnlMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMuc2VydmVyVVJMLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge1NNQy5NYXB9IG1hcCAtIE1hcCB0byBiZSBhZGRlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgU01DLmxheWVycy5nZW9tZXRyeS5XRlNHZW9tZXRyeUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGdldCB0aGUgbWFwXG4gICAgICAgICAqIEByZXR1cm5zIHtTTUMuTWFwfSBtYXAgLSBNYXAgbGF5ZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmRvRmVhdHVyZXNMb2FkaW5nKCkudGhlbihmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIHJlc3BvbnNlLmNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0ge307XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUudHlwZSA9ICdGZWF0dXJlJztcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5nZW9tZXRyeSA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPSByZXNwb25zZS50eXBlO1xuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gcmVzcG9uc2UuY29vcmRpbmF0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dC5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNlbGYub25GZWF0dXJlc0xvYWRlZChvdXRwdXQpO1xuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIGRvRmVhdHVyZXNMb2FkaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciBqc29ucFJhbmRvbSA9IHRoaXMuX21ha2VpZCgpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvcm1hdF9vcHRpb25zID0gXCJjYWxsYmFjazpcIiArIGpzb25wUmFuZG9tO1xuICAgICAgICAgICAgdmFyIHN0eWxlc2hlZXQgPSAnKntmaWxsQ29sb3I6IFwicmdiYSg0MywxNDAsMTkwLDAuNSlcIjsgY29sb3I6IFwicmdiYSg0MywxNDAsMTkwLDAuNSlcIjt9JztcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuc3R5bGVzaGVldCA9IHN0eWxlc2hlZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnR0VUJyxcbiAgICAgICAgICAgICAgICB1cmw6IHNlbGYub3B0aW9ucy5zZXJ2ZXJVUkwsXG4gICAgICAgICAgICAgICAgZGF0YTogc2VsZi5nZXRQYXJhbXNGcm9tT3B0aW9ucygpLFxuICAgICAgICAgICAgICAgIGpzb25wQ2FsbGJhY2s6IGpzb25wUmFuZG9tLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCIsXG4gICAgICAgICAgICAgICAgYXN5bmM6IGZhbHNlXG4gICAgICAgICAgICB9KTtcblxuXG4gICAgICAgIH0sXG5cblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gdW5sb2FkIHRoZSBsYXllci5cbiAgICAgICAgICovXG4gICAgICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9uZWVkc2xvYWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fcmVzZXQoKTtcbiAgICAgICAgfVxuXG5cbiAgICB9LCBbU01DLmxheWVycy5TaW5nbGVMYXllcl0pO1xuXG4vKipcbiAqIEFQSSBmYWN0b3J5IG1ldGhvZCBmb3IgZWFzZSBjcmVhdGlvbiBvZiBXTVMgbGF5ZXJzLlxuICogQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLiBNdXN0IGNvbnRhaW4gYSBmaWVsZCB1cmwgb2YgdHlwZSBzdHJpbmcuXG4gKi9cblNNQy5pc29jaHJvbmVMYXllciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNNQy5sYXllcnMuSXNvY2hyb25lTGF5ZXIob3B0aW9ucyk7XG59OyIsInJlcXVpcmUoXCIuL2xheWVycy5qc1wiKTtcbnJlcXVpcmUoXCIuLi9jb250cm9scy9sYXllclRyZWUvTGF5ZXJUcmVlTGVhZi5qc1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBhbGwgbGF5ZXIgdHlwZXMgc3VwcG9ydGluZyBkYXRhIHByb3ZpZGVycy5cbiAqIEBjbGFzc1xuICogQGFic3RyYWN0XG4gKiBAZXh0ZW5kcyBMLkNsYXNzXG4gKiBAbWl4ZXMgU01DLmNvbnRyb2xzLmxheWVyVHJlZS5MYXllclRyZWVMZWFmXG4gKi9cblNNQy5sYXllcnMuTGF5ZXIgPSBMLkNsYXNzLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMuTGF5ZXIjICovXG4gICAge1xuICAgICAgICB2aXNpYmxlOiB0cnVlLFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIGNsYXNzIHdpdGggb3B0aW9ucyBwYXJhbWV0ZXJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5jb250cm9scy5sYXllclRyZWUuTGF5ZXJUcmVlTGVhZi5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbnMgb2YgRmVhdHVyZVByb3ZpZGVyIG11c3QgY29udGFpbiBhbiBvdmVycmlkZSBvZiB0aGlzIG1ldGhvZCwgc28gZmVhdHVyZXMgY2FuIGJlIGxvYWRlZCBmcm9tIHRoZWlyIHNvdXJjZS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBvbkFkZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlc1Byb3ZpZGVyOjpkb0ZlYXR1cmVzTG9hZGluZyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGRlcml2YXRlIGNsYXNzZXMuXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gc2V0IHRoZSB2aXNpYmlsaXR5IG9mIGEgdHJlZSBsYXllci5cbiAgICAgICAgICogQHBhcmFtIHtCb29sZWFufSB2aXNpYmxlIC0gQm9vbGVhbiBwYXJhbSB0byBzZXQgdmlzaWJpbHR5IHRydWUgb3IgZmFsc2UuXG4gICAgICAgICAqL1xuICAgICAgICBzZXRWaXNpYmxlOiBmdW5jdGlvbih2aXNpYmxlKSB7XG4gICAgICAgICAgICAgdGhpcy52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgfVxuICAgIH0sIFtTTUMuY29udHJvbHMubGF5ZXJUcmVlLkxheWVyVHJlZUxlYWZdKTtcbiIsInJlcXVpcmUoXCIuL2xheWVyc1wiKTtcbnJlcXVpcmUoXCIuL0xheWVyLmpzXCIpO1xucmVxdWlyZShcIi4vcmVsb2FkZXJzL0xheWVyUmVsb2FkZXIuanNcIik7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgYWxsIFNNQyB2aWV3ZXIgbGF5ZXIgd2hpY2ggYXJlIGJvdGggcmVsb2FkYWJsZSBhbmQgYWdncmVnYWJsZSBpbiBncm91cGluZyBsYXllcnMuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMuTGF5ZXJcbiAqIEBhYnN0cmFjdFxuICogQG1peGVzIFNNQy5sYXllcnMucmVsb2FkZXJzLkxheWVyUmVsb2FkZXJcbiAqIEBtaXhpbiBTTUMubGF5ZXJzLlNpbmdsZUxheWVyXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLlNpbmdsZUxheWVyID0gU01DLmxheWVycy5MYXllci5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLlNpbmdsZUxheWVyIyAqL1xuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLkxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLnJlbG9hZGVycy5MYXllclJlbG9hZGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgY29udHJvbCBpbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIGFkZGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICB0aGlzLm1hcCA9IG1hcDtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZ2V0IHRoZSBtYXBcbiAgICAgICAgICogQHJldHVybnMge1NNQy5NYXB9IG1hcCAtIE1hcCBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgcmV0dXJuIHRoaXMubWFwO1xuICAgICAgICB9XG5cbiAgICB9LCBbU01DLmxheWVycy5yZWxvYWRlcnMuTGF5ZXJSZWxvYWRlcl0pOyIsInJlcXVpcmUoXCIuL2xheWVyc1wiKTtcbnJlcXVpcmUoXCIuL1NpbmdsZUxheWVyLmpzXCIpO1xuXG4vKipcbiAqIFdyYXBwZXIgZm9yIFtMZWFmbGV0J3MgV01TIGxheWVyXXtAbGluayBodHRwOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCN0aWxlbGF5ZXJ9XG4gKiBzbyBpdHMgaW50ZWdyYXRlZCBpbiB0aGUgU01DJ3Mgdmlld2VyIGxheWVyIGFyY2hpdGVjdHVyZS5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEwuVGlsZUxheWVyXG4gKiBAbWl4ZXMgU01DLmxheWVycy5TaW5nbGVMYXllclxuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5UaWxlTGF5ZXIgPSBMLlRpbGVMYXllci5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLlRpbGVMYXllciMgKi9cbiAgICB7XG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHdpdGggbmVlZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMudXJsIHx8IHR5cGVvZihvcHRpb25zLnVybCkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTTUMubGF5ZXJzLlRpbGVMYXllcjo6aW5pdGlhbGl6ZTogb3B0aW9ucyBtdXN0IGNvbnRhaW4gYW4gdXJsIGF0dHJpYnV0ZSBvZiB0eXBlIHN0cmluZy5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMLlRpbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMudXJsLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge1NNQy5NYXB9IG1hcCAtIE1hcCB0byBiZSBhZGRlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgTC5UaWxlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZmVhdHVyZXMgZnJvbSBpdHMgc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbmVlZHNsb2FkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbmVlZHNsb2FkID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gdW5sb2FkIHRoZSBsYXllci5cbiAgICAgICAgICovXG4gICAgICAgIHVubG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICAgICAgdGhpcy5fbmVlZHNsb2FkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH0sIFtTTUMubGF5ZXJzLlNpbmdsZUxheWVyXSk7XG5cbi8qKlxuICogQVBJIGZhY3RvcnkgbWV0aG9kIGZvciBlYXNlIGNyZWF0aW9uIG9mIHRpbGUgbGF5ZXJzLlxuICogQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxuICovXG5TTUMudGlsZUxheWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLmxheWVycy5UaWxlTGF5ZXIob3B0aW9ucyk7XG59O1xuIiwicmVxdWlyZShcIi4vbGF5ZXJzXCIpO1xucmVxdWlyZShcIi4vU2luZ2xlTGF5ZXIuanNcIik7XG5cblxuLyoqXG4gKiBXcmFwcGVyIGZvciBbTGVhZmxldCdzIFdNUyBsYXllcl17QGxpbmsgaHR0cDovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjdGlsZWxheWVyLXdtcyB9IHNvIGl0cyBpbnRlZ3JhdGVkIGluIHRoZSBTTUMncyB2aWV3ZXIgbGF5ZXIgYXJjaGl0ZWN0dXJlLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgTC5UaWxlTGF5ZXIuV01TXG4gKiBAbWl4ZXMgU01DLmxheWVycy5TaW5nbGVMYXllclxuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5XTVNMYXllciA9IEwuVGlsZUxheWVyLldNUy5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLldNU0xheWVyIyAqL1xuICAgIHtcblxuICAgICAgIGRlZmF1bHRXbXNQYXJhbXM6IHtcbiAgICAgICAgICAgIHNlcnZpY2U6ICdXTVMnLFxuICAgICAgICAgICAgcmVxdWVzdDogJ0dldE1hcCcsXG4gICAgICAgICAgICB2ZXJzaW9uOiAnMS4xLjEnLFxuICAgICAgICAgICAgbGF5ZXJzOiAnJyxcbiAgICAgICAgICAgIHN0eWxlczogJycsXG4gICAgICAgICAgICBmb3JtYXQ6ICdpbWFnZS9wbmcnLFxuICAgICAgICAgICAgdHJhbnNwYXJlbnQ6IHRydWVcbiAgICAgICAgfSxcblxuICAgICAgXG4gICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICBcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy51cmwgfHwgdHlwZW9mKG9wdGlvbnMudXJsKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMuV01TTGF5ZXI6OmluaXRpYWxpemU6IG9wdGlvbnMgbXVzdCBjb250YWluIGFuIHVybCBhdHRyaWJ1dGUgb2YgdHlwZSBzdHJpbmcuXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTC5UaWxlTGF5ZXIuV01TLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucy51cmwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgU01DLmxheWVycy5TaW5nbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgY29udHJvbCBpbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIGFkZGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBMLlRpbGVMYXllci5XTVMucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBmZWF0dXJlcyBmcm9tIGl0cyBzb3VyY2UuXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZWVkc2xvYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGUoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9uZWVkc2xvYWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byB1bmxvYWQgdGhlIGxheWVyLlxuICAgICAgICAgKi9cbiAgICAgICAgdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX25lZWRzbG9hZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9yZXNldCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIGdldFRpbGVVcmw6IGZ1bmN0aW9uKHRpbGVQb2ludCkge1xuICAgICAgICAgICAgdmFyIHVybCA9IEwuVGlsZUxheWVyLldNUy5wcm90b3R5cGUuZ2V0VGlsZVVybC5hcHBseSh0aGlzLCBbdGlsZVBvaW50XSk7XG4gICAgICAgICAgICBpZih0aGlzLl9uZWVkc2xvYWQpIHtcbiAgICAgICAgICAgICAgIHVybCs9XCImX2RjPVwiK01hdGgucmFuZG9tKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB1cmw7XG4gICAgICAgIH0sXG5cblxuICAgIH0sIFtTTUMubGF5ZXJzLlNpbmdsZUxheWVyXSk7XG5cbi8qKlxuICogQVBJIGZhY3RvcnkgbWV0aG9kIGZvciBlYXNlIGNyZWF0aW9uIG9mIFdNUyBsYXllcnMuXG4gKiBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuIE11c3QgY29udGFpbiBhIGZpZWxkIHVybCBvZiB0eXBlIHN0cmluZy5cbiAqL1xuU01DLndtc0xheWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLmxheWVycy5XTVNMYXllcihvcHRpb25zKTtcbn07XG4iLCJyZXF1aXJlKFwiLi9hZ2dyZWdhdGlvbi5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi9jb250cm9scy9sYXllclRyZWUvTGF5ZXJUcmVlRm9sZGVyLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL0xheWVyTG9hZGVyLmpzXCIpO1xuXG4vKipcbiAqIENsYXNzIGZvcm1lZCBieSB0aGUgYWdncmVnYXRpb24gb2Ygc2V2ZXJhbCBsYXllcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTTUMubGF5ZXJzLkxheWVyXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLmFnZ3JlZ2F0aW9uLkFnZ3JlZ2F0aW5nTGF5ZXIgPSBMLkxheWVyR3JvdXAuZXh0ZW5kKFxuXHQvKiogQGxlbmRzIFNNQy5sYXllcnMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllciMgKi9cblx0e1xuXG5cdFx0X2FnZ3JlZ2F0aW5nTGF5ZXJzOiB7fSxcblx0XHRcblxuXHRcdC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHdpdGggZXh0cmEgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0TC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0XHR0aGlzLl9hZ2dyZWdhdGluZ0xheWVycyA9IHt9O1xuXG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEFkZHMgYSBzdWJsYXllciB0byB0aGUgbGF5ZXIuXG5cdFx0ICogQHBhcmFtIHtzdHJpbmd9IGxheWVySWQgLSBMYXllciBJZGVudGlmaWVyXG5cdFx0ICogQHBhcmFtIHtTTUMubGF5ZXJzfSBsYXllciAtIExheWVyIG9iamVjdFxuXHRcdCAqL1xuXHRcdGFkZExheWVyOiBmdW5jdGlvbihsYXllcklkLCBsYXllcikge1xuXG5cdFx0XHRpZiAobGF5ZXJJZC5sYXllcnNDb25maWcpIHtcblx0XHRcdFx0Ly8gV2UgdXNlIHRoZSBMYXllckxvYWRlciBmdW5jdGlvbmFsaXR5LlxuXHRcdFx0XHR0aGlzLmxvYWRMYXllcnMobGF5ZXJJZC5sYXllcnNDb25maWcpO1xuXG5cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGxheWVySWQgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdFx0Y29uc29sZS5sb2cobGF5ZXJJZC5vcHRpb25zLnR5cGVOYW1lIHx8IGxheWVySWQub3B0aW9ucy5sYWJlbCk7XG5cdFx0XHRcdHRoaXMuX2FnZ3JlZ2F0aW5nTGF5ZXJzW0wuc3RhbXAobGF5ZXJJZCldID0gbGF5ZXJJZDtcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdCAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGdldCB0aGUgbWFwXG4gICAgICAgICAqIEByZXR1cm5zIHtTTUMuTWFwfSBtYXAgLSBNYXAgbGF5ZXJcbiAgICAgICAgICovXG5cdFx0Z2V0TWFwOiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICh0aGlzLnBhcmVudCkge1xuXHRcdFx0XHRpZiAodGhpcy5wYXJlbnQubWFwKSB7XG5cdFx0XHRcdFx0bWFwID0gdGhpcy5wYXJlbnQubWFwO1xuXHRcdFx0XHR9ZWxzZSBpZih0aGlzLnBhcmVudC5fbWFwKXtcblx0XHRcdFx0XHRtYXAgPSB0aGlzLnBhcmVudC5fbWFwO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRoaXMucGFyZW50LnBhcmVudCkge1xuXHRcdFx0XHRcdGlmICh0aGlzLnBhcmVudC5wYXJlbnQubWFwKVxuXHRcdFx0XHRcdFx0bWFwID0gdGhpcy5wYXJlbnQucGFyZW50Lm1hcDtcblx0XHRcdFx0XHRlbHNlIGlmICh0aGlzLnBhcmVudC5wYXJlbnQuX21hcClcblx0XHRcdFx0XHRcdG1hcCA9IHRoaXMucGFyZW50LnBhcmVudC5fbWFwO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblx0XHRcdGVsc2UgaWYodGhpcy5fbWFwKXtcblx0XHRcdFx0bWFwID0gdGhpcy5fbWFwO1xuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcblx0XHQvLyBcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXG5cdFx0Ly8gfSxcblxuXHRcdC8vIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApe1xuXHRcdC8vIFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0Ly8gfSxcblxuXHRcdC8vIGFkZFRvOiBmdW5jdGlvbihtYXApe1xuXHRcdC8vIFx0TC5MYXllckdyb3VwLnByb3RvdHlwZS5hZGRUby5jYWxsKHRoaXMsIG1hcCk7XG5cdFx0Ly8gfVxuXG5cblxuXHR9LCBbU01DLkxheWVyTG9hZGVyXSk7IiwicmVxdWlyZShcIi4uL2xheWVycy5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi9MYXllckxvYWRlci5qc1wiKTtcbnJlcXVpcmUoXCIuL0FnZ3JlZ2F0aW5nTGF5ZXIuanNcIik7XG5cblxuXG4vKipcbiAqIENsYXNzIGZvcm1lZCBieSB0aGUgYWdncmVnYXRpb24gb2Ygc2V2ZXJhbCBsYXllcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTTUMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllclxuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5hZ2dyZWdhdGlvbi5NdWx0aU1vZGVMYXllciA9IFNNQy5sYXllcnMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllci5leHRlbmQoXG5cdC8qKiBAbGVuZHMgU01DLmxheWVycy5oaXN0b3J5LkFnZ3JlZ2F0aW5nSGlzdG9yeUxheWVyIyAqL1xuXHR7XG5cdFx0bm9kZTogbnVsbCxcblxuXHRcdC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT2JqZWN0IHdpdGggZXh0cmEgaW5mb3JtYXRpb25cbiAgICAgICAgICovXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0TC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0XHRTTUMubGF5ZXJzLmFnZ3JlZ2F0aW9uLkFnZ3JlZ2F0aW5nTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLmNoZWNrZWQgPSB0cnVlO1xuXHRcdH0sXG5cblx0XHQgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYW4gSFRNTCBub2RlIGZvciB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgY29kZSByZXByZXNlbnRpbmcgdGhlIGNvZGUgdG8gYmUgYWRkZWQgdG8gdGhlIGxheWVyJ3MgZW50cnkgaW4gdGhlIGxheWVyIHRyZWUuXG4gICAgICAgICAqL1xuXHRcdGNyZWF0ZU5vZGVIVE1MOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0dmFyIG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXHRcdFx0bm9kZS5pZCA9IHRoaXMuX2xlYWZsZXRfaWQ7XG5cblx0XHRcdHZhciBsYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xhYmVsJyk7XG5cdFx0XHR2YXIgY2hlY2tlZCA9IHRoaXMuZ2V0TWFwKCkuaGFzTGF5ZXIodGhpcyk7XG5cblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG5cdFx0XHRpbnB1dC50eXBlID0gJ2NoZWNrYm94Jztcblx0XHRcdGlucHV0LmRlZmF1bHRDaGVja2VkID0gY2hlY2tlZDtcblx0XHRcdHZhciBuYW1lID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuXHRcdFx0bmFtZS5pbm5lckhUTUwgPSAnICcgKyB0aGlzLm9wdGlvbnMubGFiZWw7XG5cblx0XHRcdGxhYmVsLmFwcGVuZENoaWxkKGlucHV0KTtcblx0XHRcdGxhYmVsLmFwcGVuZENoaWxkKG5hbWUpO1xuXG5cdFx0XHRsYWJlbC5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblxuXG5cdFx0XHRpbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRcdHNlbGYuX2NsaWNrT25NdWx0aUxheWVyKG5vZGUpO1xuXHRcdFx0fTtcblxuXG5cdFx0XHRub2RlLmFwcGVuZENoaWxkKGxhYmVsKTtcblxuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMuX2FnZ3JlZ2F0aW5nTGF5ZXJzO1xuXG5cdFx0XHQvL2NyZWF0ZSBidXR0b25zIGNvbnRhaW5lclxuXHRcdFx0dmFyIG1vZGVzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuXHRcdFx0Zm9yICh2YXIgbCBpbiBsYXllcnMpIHtcblx0XHRcdFx0Ly9jcmVhdGUgYnV0dG9uc1xuXHRcdFx0XHR2YXIgYnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0XHRidXR0b24uc2V0QXR0cmlidXRlKCd0eXBlJywgJ2J1dHRvbicpO1xuXHRcdFx0XHRidXR0b24uc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG5cdFx0XHRcdGJ1dHRvbi52YWx1ZSA9IGxheWVyc1tsXS5vcHRpb25zLmxhYmVsO1xuXG5cdFx0XHRcdG1vZGVzLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cdFx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdFx0YnV0dG9uLm9uY2xpY2sgPSBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdHNlbGYuX29uQWN0aXZlKGV2ZW50LCBtb2Rlcyk7XG5cdFx0XHRcdH07XG5cblx0XHRcdH07XG5cblxuXHRcdFx0bm9kZS5hcHBlbmRDaGlsZChtb2Rlcyk7XG5cdFx0XHRpZiAodGhpcy5ub2RlID09IG51bGwpIHtcblx0XHRcdFx0dGhpcy5ub2RlID0gbm9kZTtcblx0XHRcdFx0dGhpcy5faW5pdGlhbGl6ZUJ1dHRvbnMobW9kZXMpO1xuXHRcdFx0XHR2YXIgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlTGF5ZXIoKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbm9kZTtcblx0XHR9LFxuXG5cdFx0X2luaXRpYWxpemVCdXR0b25zOiBmdW5jdGlvbihtb2Rlcykge1xuXHRcdFx0dmFyIGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUxheWVyKCk7XG5cdFx0XHR2YXIgYnV0dG9ucyA9IG1vZGVzLmNoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidXR0b25zLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChidXR0b25zW2ldLnZhbHVlID09IGFjdGl2ZS5vcHRpb25zLmxhYmVsKSB7XG5cdFx0XHRcdFx0YnV0dG9uc1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2RkZCc7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdGJ1dHRvbnNbaV0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgbXVsdGlMYXllcnMgPSB0aGlzLl9hZ2dyZWdhdGluZ0xheWVycztcblxuXHRcdFx0Zm9yICh2YXIgbCBpbiBtdWx0aUxheWVycykge1xuXHRcdFx0XHRtdWx0aUxheWVyc1tsXS5hZGRUbyh0aGlzLmdldE1hcCgpKTtcblx0XHRcdFx0aWYgKCFtdWx0aUxheWVyc1tsXS5hY3RpdmUpIHtcblx0XHRcdFx0XHRMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuXHRcdFx0XHRcdG11bHRpTGF5ZXJzW2xdLm9uUmVtb3ZlKG1hcCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0LyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZmVhdHVyZXMgZnJvbSBpdHMgc291cmNlLlxuICAgICAgICAgKi9cblx0XHRsb2FkOiBmdW5jdGlvbigpIHtcblxuXHRcdH0sXG5cblx0XHRfaW5pdGlhbGl6ZVRyZWU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHR2YXIgbXVsdGlMYXllcnMgPSB0aGlzLl9hZ2dyZWdhdGluZ0xheWVycztcblx0XHRcdGZvciAodmFyIGwgaW4gbXVsdGlMYXllcnMpIHtcblx0XHRcdFx0aWYgKG11bHRpTGF5ZXJzW2xdLmFjdGl2ZSkge1xuXHRcdFx0XHRcdGlmKG11bHRpTGF5ZXJzW2xdIGluc3RhbmNlb2YgU01DLmxheWVycy5tYXJrZXJzLldGU1RNYXJrZXJMYXllcil7XG5cdFx0XHRcdFx0XHRtdWx0aUxheWVyc1tsXS5fc2V0QnV0dG9uVGV4dCgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQvL2FkZCBub2RlIG9mIGFjdGl2ZSBsYXllclxuXHRcdFx0XHRcdGlmICgobXVsdGlMYXllcnNbbF0gaW5zdGFuY2VvZiBTTUMubGF5ZXJzLmFnZ3JlZ2F0aW9uLkFnZ3JlZ2F0aW5nTGF5ZXIgfHwgbXVsdGlMYXllcnNbbF0gaW5zdGFuY2VvZiBTTUMubGF5ZXJzLm1hcmtlcnMuV0ZTVE1hcmtlckxheWVyKSAmJiB0aGlzLmNoZWNrZWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuX2FkZE5vZGUobXVsdGlMYXllcnNbbF0ub3B0aW9ucy5sYWJlbCk7XG5cdFx0XHRcdFx0fSBlbHNlXG5cdFx0XHRcdFx0XHR0aGlzLl9hZGROb2RlKCdub25lJyk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cblxuXHRcdF9nZXRBY3RpdmVMYXllcjogZnVuY3Rpb24obXVsdGlMYXllcnMpIHtcblx0XHRcdHZhciBpID0gMDtcblx0XHRcdHZhciBtdWx0aUxheWVycyA9IHRoaXMuX2FnZ3JlZ2F0aW5nTGF5ZXJzO1xuXHRcdFx0dmFyIGFjdGl2ZTtcblx0XHRcdHZhciBkZWZhdWx0QWN0aXZlO1xuXHRcdFx0Zm9yICh2YXIgbCBpbiBtdWx0aUxheWVycykge1xuXHRcdFx0XHRpZiAoaSA9PSAwKSB7XG5cdFx0XHRcdFx0ZGVmYXVsdEFjdGl2ZSA9IG11bHRpTGF5ZXJzW2xdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChtdWx0aUxheWVyc1tsXS5vcHRpb25zLmFjdGl2ZSB8fCBtdWx0aUxheWVyc1tsXS5hY3RpdmUpIHtcblx0XHRcdFx0XHRtdWx0aUxheWVyc1tsXS5hY3RpdmUgPSB0cnVlO1xuXHRcdFx0XHRcdGFjdGl2ZSA9IG11bHRpTGF5ZXJzW2xdO1xuXHRcdFx0XHRcdG11bHRpTGF5ZXJzW2xdLnNldFZpc2libGUodHJ1ZSk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRtdWx0aUxheWVyc1tsXS5hY3RpdmUgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cdFx0XHRcdGkrKztcblxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIWFjdGl2ZSkge1xuXHRcdFx0XHRkZWZhdWx0QWN0aXZlLmFjdGl2ZSA9IHRydWU7XG5cdFx0XHRcdGFjdGl2ZSA9IGRlZmF1bHRBY3RpdmU7XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGFjdGl2ZTtcblxuXG5cdFx0fSxcblxuXHRcdF9vbkFjdGl2ZTogZnVuY3Rpb24oZXZlbnQsIG1vZGVzKSB7XG5cdFx0XHQvL2FjdGl2ZS9kZXNhY3RpdmUgbGF5ZXJzXG5cdFx0XHR2YXIgbXVsdGlMYXllcnMgPSB0aGlzLl9hZ2dyZWdhdGluZ0xheWVycztcblx0XHRcdHZhciBidXR0b25zID0gbW9kZXMuY2hpbGRyZW47XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGJ1dHRvbnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0aWYgKGJ1dHRvbnNbaV0gPT0gZXZlbnQudGFyZ2V0KSB7XG5cdFx0XHRcdFx0YnV0dG9uc1tpXS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2RkZCc7XG5cdFx0XHRcdH0gZWxzZVxuXHRcdFx0XHRcdGJ1dHRvbnNbaV0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyNmZmYnO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IgKHZhciBsIGluIG11bHRpTGF5ZXJzKSB7XG5cdFx0XHRcdHZhciBsYXllcjtcblx0XHRcdFx0aWYgKG11bHRpTGF5ZXJzW2xdLm9wdGlvbnMubGFiZWwgIT0gZXZlbnQudGFyZ2V0LnZhbHVlKSB7XG5cblx0XHRcdFx0XHRpZiAobXVsdGlMYXllcnNbbF0uYWN0aXZlKSB7XG5cdFx0XHRcdFx0XHR2YXIgcGF1c2UgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdmYSBmYS1wYXVzZScpO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwYXVzZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdFx0XHRwYXVzZVtpXS5jbGFzc05hbWUgPSAnZmEgZmEtcGxheSc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRjbGVhckludGVydmFsKG11bHRpTGF5ZXJzW2xdLl90aW1lcik7XG5cblx0XHRcdFx0XHRcdGlmIChtdWx0aUxheWVyc1tsXS5fZmluaXNoRWRpdENvbnRyb2wpIHtcblx0XHRcdFx0XHRcdFx0bXVsdGlMYXllcnNbbF0uX2ZpbmlzaEVkaXRDb250cm9sKCk7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdG11bHRpTGF5ZXJzW2xdLm9uUmVtb3ZlKG1hcCk7XG5cdFx0XHRcdFx0XHRtdWx0aUxheWVyc1tsXS5hY3RpdmUgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cblxuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKCFtdWx0aUxheWVyc1tsXS5hY3RpdmUpIHtcblxuXHRcdFx0XHRcdFx0bXVsdGlMYXllcnNbbF0ub25BZGQobWFwKTtcblx0XHRcdFx0XHRcdG11bHRpTGF5ZXJzW2xdLmFjdGl2ZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9pbml0aWFsaXplVHJlZSgpO1xuXG5cdFx0XHRcblxuXHRcdH0sXG5cblx0XHRfYWRkTm9kZTogZnVuY3Rpb24obGFiZWwpIHtcblx0XHRcdHZhciBpZCA9IHRoaXMuX2xlYWZsZXRfaWQ7XG5cdFx0XHR2YXIgdHJlZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblx0XHRcdGlmICghdHJlZSkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgdHJlZU5vZGVzID0gdHJlZS5wYXJlbnROb2RlLm5leHRFbGVtZW50U2libGluZztcblx0XHRcdHZhciB0cmVlID0gdHJlZU5vZGVzLmNoaWxkcmVuO1xuXHRcdFx0XG5cdFx0XHR0cmVlTm9kZXMuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHRyZWUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XG5cdFx0XHRcdFx0dHJlZVtpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHRcdHNlYXJjaCh0cmVlW2ldKTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvL3NlYXJjaCBub2RlIGFjdGl2ZSBsYXllclxuXHRcdFx0ZnVuY3Rpb24gc2VhcmNoKHRyZWUpIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0cmVlLmNoaWxkcmVuO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRpZiAobm9kZVtpXS5pbm5lckhUTUwudHJpbSgpICE9IGxhYmVsKSB7XG5cdFx0XHRcdFx0XHRcdGlmKG5vZGVbaV0udHlwZSA9PSAnY2hlY2tib3gnIHx8IG5vZGVbaV0ubm9kZU5hbWUgPT0gJ0JSJyl7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZVtpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1x0XG5cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0XHRpZiAobm9kZVtpXS5jaGlsZHJlbi5sZW5ndGggIT0gMClcblx0XHRcdFx0XHRcdFx0c2VhcmNoKG5vZGVbaV0pO1xuXG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZVtpXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXHRcdFx0XHRcdFx0bm9kZVtpXS5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHRcdFx0bm9kZVtpXS5wYXJlbnROb2RlLnBhcmVudE5vZGUuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdFx0XHRub2RlW2ldLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHRcdFx0bm9kZVtpXS5wYXJlbnROb2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHRcdFx0XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cblxuXHRcdH0sXG5cblx0XHRfY2xpY2tPbk11bHRpTGF5ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdC8vYWN0aXZlL2Rlc2FjdGl2ZSBtdWx0aW1vZGUgbGF5ZXJcblxuXHRcdFx0dmFyIGlkID0gdGhpcy5fbGVhZmxldF9pZDtcblx0XHRcdHZhciB0cmVlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHRcdFx0aWYgKCF0cmVlKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHZhciB0cmVlTm9kZXMgPSB0cmVlLnBhcmVudE5vZGUubmV4dEVsZW1lbnRTaWJsaW5nO1xuXHRcdFx0dmFyIHBhdXNlID0gdHJlZU5vZGVzLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ZhIGZhLXBhdXNlJyk7XG5cdFx0XHR2YXIgbXVsdGlMYXllcnMgPSB0aGlzLl9hZ2dyZWdhdGluZ0xheWVycztcblxuXHRcdFx0aWYgKG5vZGUuY2hpbGRyZW5bMV0uc3R5bGUuZGlzcGxheSAhPSAnbm9uZScpIHtcblx0XHRcdFx0dGhpcy5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHRcdG5vZGUuY2hpbGRyZW5bMV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0dHJlZU5vZGVzLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cdFx0XHRcdG5vZGUuY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hlY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRmb3IgKHZhciBkIGluIG11bHRpTGF5ZXJzKSB7XG5cdFx0XHRcdFx0aWYgKG11bHRpTGF5ZXJzW2RdLmFjdGl2ZSkge1xuXHRcdFx0XHRcdFx0aWYgKG11bHRpTGF5ZXJzW2RdIGluc3RhbmNlb2YgU01DLmxheWVycy5oaXN0b3J5LkFnZ3JlZ2F0aW5nSGlzdG9yeUxheWVyKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcGF1c2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHRjbGVhckludGVydmFsKG11bHRpTGF5ZXJzW2RdLl90aW1lcik7XG5cdFx0XHRcdFx0XHRcdFx0cGF1c2VbaV0uY2xhc3NOYW1lID0gJ2ZhIGZhLXBsYXknO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRpZiAobXVsdGlMYXllcnNbZF0gaW5zdGFuY2VvZiBTTUMubGF5ZXJzLm1hcmtlcnMuV0ZTVE1hcmtlckxheWVyKSB7XG5cdFx0XHRcdFx0XHRcdG11bHRpTGF5ZXJzW2RdLl9maW5pc2hFZGl0Q29udHJvbCgpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0bXVsdGlMYXllcnNbZF0ub25SZW1vdmUobWFwKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuY2hlY2tlZCA9IHRydWU7XG5cdFx0XHRcdG5vZGUuY2hpbGRyZW5bMV0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cdFx0XHRcdHRyZWVOb2Rlcy5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcblx0XHRcdFx0bm9kZS5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGVja2VkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICh2YXIgbCBpbiBtdWx0aUxheWVycykge1xuXHRcdFx0XHRcdGlmIChtdWx0aUxheWVyc1tsXS5hY3RpdmUpIHtcblx0XHRcdFx0XHRcdG11bHRpTGF5ZXJzW2xdLm9uQWRkKG1hcCk7XG5cdFx0XHRcdFx0XHRpZiAoKG11bHRpTGF5ZXJzW2xdIGluc3RhbmNlb2YgU01DLmxheWVycy5hZ2dyZWdhdGlvbi5BZ2dyZWdhdGluZ0xheWVyIHx8IG11bHRpTGF5ZXJzW2xdIGluc3RhbmNlb2YgU01DLmxheWVycy5tYXJrZXJzLldGU1RNYXJrZXJMYXllcikgJiYgdGhpcy5jaGVja2VkKSB7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX2FkZE5vZGUobXVsdGlMYXllcnNbbF0ub3B0aW9ucy5sYWJlbCk7XG5cdFx0XHRcdFx0XHR9IGVsc2Vcblx0XHRcdFx0XHRcdFx0dGhpcy5fYWRkTm9kZSgnbm9uZScpO1xuXHRcdFx0XHRcdFx0XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG5cblx0fSwgW1NNQy5sYXllcnMuU2luZ2xlTGF5ZXJdKTsiLCIvKipcbiAqIE5hbWVzcGFjZSBmb3IgYWdyZWdnYXRpbmcgbGF5ZXJzLCBlLmcuLCBsYXllcnMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZiB0aGUgY29tcG9zaXRpb25cbiAqIG9mIHNldmVyYWwgb3RoZXIgbGF5ZXJzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBTTUMubGF5ZXJzXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMuYWdncmVnYXRpb24gPSB7fTsiLCJyZXF1aXJlKFwiLi4vc3R5bGVycy9NYXBDc3NTdHlsZXIuanNcIik7XG4vKipcbiAqIEdsb2JhbCB2YXJpYWJsZSB0aGF0IHJlcHJlc2VudHMgcGFwZXIgbGlicmFyeSBmdW5jdGlvbmFsaXR5XG4gKiBAcHJvcGVydHkge3BhcGVyfSAtIHBhcGVyIHZhcmlhYmxlXG4gKi9cbnZhciBwYXBlciA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvcGFwZXIvZGlzdC9wYXBlci1mdWxsLmpzXCIpLmV4cG9ydHM7XG52YXIgcmJ1c2ggPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL3JidXNoLmpzXCIpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxheWVycyB1c2luZyBjbGllbnQgc2lkZSByZW5kZXJpbmcgb2YgY2FudmFzIHJlbmRlcmVyLlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIEwuQ2xhc3NcbiAqIEBtaXhlcyBTTUMubGF5ZXJzLnN0eWxlcnMuTWFwQ3NzU3R5bGVyXG4gKiBAcGFyYW0ge1NNQy5sYXllcnMuZ2VvbWV0cnkuQ2FudmFzUmVuZGVyZXJ+b3B0aW9uc30gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2xhc3NcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMuZ2VvbWV0cnkuQ2FudmFzUmVuZGVyZXIgPSBMLkNsYXNzLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMuZ2VvbWV0cnkuQ2FudmFzUmVuZGVyZXIjICovXG4gICAge1xuXG4gICAgICAgIGNhbnZhc1RyZWU6IG51bGwsXG5cbiAgICAgICAgLy8gVGhpcyBtYXAgd2lsbCBiZSB1c2VkIHRvIHN0b3JlIGN0eCByZWxhdGVkIGV2ZW50cywgb2Ygd2hpY2ggZXhpc3Qgb25lIHBlciBjYW52YXMsXG4gICAgICAgIC8vIHNvIHdlIGFyZSBhYmxlIG9mIHJlbW92aW5nIHRoZW0gdG8gYXZvaWQgcGVyZm9ybWFuY2UgcmVncmVzc2lvbnMuXG4gICAgICAgIF9jdHhFdmVudHM6IG51bGwsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5sYXllcnMuZ2VvbWV0cnkuQ2FudmFzUmVuZGVyZXJ+b3B0aW9uc1xuICAgICAgICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGRyYWdnaW5nVXBkYXRlcz10cnVlIC0gRGVmYXVsdCBkcmFnZ2luZyB1cGRhdGVzIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBkcmFnZ2luZ1VwZGF0ZXM6IHRydWUsXG4gICAgICAgICAgICBtb3VzZU92ZXI6IGZhbHNlLFxuICAgICAgICAgICAgZGVidWc6IGZhbHNlXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3Zpc2libGU6IGZhbHNlLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHdpdGggbmVlZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLnN0eWxlcnMuTWFwQ3NzU3R5bGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ2xheWVyTG9hZCcsIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlczogdGhpcy5mZWF0dXJlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uTWFwQ2xpY2tlZDogZnVuY3Rpb24oZXZlbnQpIHtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzVHJlZSkge1xuXG4gICAgICAgICAgICAgICAgdmFyIGNhbnZhc0Jib3ggPSB0aGlzLl9zZWFyY2hDYW52YXMoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2FudmFzQmJveC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzQmJveFtpXS5jdHg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX29uTW91c2VDbGljayhjdHgsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uTWFwTW92ZUVuZGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhc1RyZWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1RyZWUuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2V0TWFwKCkuZmlyZUV2ZW50KFwiZHJhZ2VuZFwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25NYXBEcmFnU3RhcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhbnZhc1RyZWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1RyZWUuY2xlYXIoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIm1vdmluZyBkaXNhYmxlZCFcIik7XG4gICAgICAgICAgICB0aGlzLmdldE1hcCgpLm9mZihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1hcE1vdXNlTW92ZWQsIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbk1hcE1vdXNlTW92ZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXNUcmVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmVBdXgoZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9vbk1vdXNlTW92ZUF1eDogZnVuY3Rpb24oZXZlbnQpIHtcblxuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmRyYWdnaW5nIHx8ICF0aGlzLm9wdGlvbnMubW91c2VPdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FudmFzQmJveCA9IHRoaXMuX3NlYXJjaENhbnZhcyhldmVudCk7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiTW91c2UgbW92ZSBjYW52YXNlcyBzZWFyY2hlZDogXCIgKyBjYW52YXNCYm94Lmxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNhbnZhc0Jib3gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgY3R4ID0gY2FudmFzQmJveFtpXS5jdHg7XG4gICAgICAgICAgICAgICAgdGhpcy5fb25Nb3VzZU1vdmUoY3R4LCBldmVudCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVuZGVyIGEgbGF5ZXIgd2l0aCBjYW52YXMgY29tcG9uZW50XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjdHggLSBjYW52YXMgY29udGV4dFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZXMgLSBvYmplY3QgdGhhdCByZXByZXNlbnRzIGEgZmVhdHVyZXMgc2V0XG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gbWFwIHdoZXJlIGxvYWQgdGhlIGZlYXR1cmVzXG4gICAgICAgICAqIEByZXR1cm5zIHtTTUMubGF5ZXJzLkxheWVyfSBsYXllciB0byBzaG93IG9uIHRoZSBtYXBcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlckNhbnZhczogZnVuY3Rpb24oY3R4LCBmZWF0dXJlcywgbWFwKSB7XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5fdmlzaWJsZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5faW5pdEN0eChjdHgsIG1hcCk7XG4gICAgICAgICAgICB2YXIgekJ1ZmZlciA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5kcmFnZ2luZ1VwZGF0ZXMgJiYgdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGRyYXcgd2hpbGUgZHJhZ2dpbmcsIGFzIGl0IGVhdHMgQSBMT1Qgb2YgQ1BVLlxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY3R4LmZlYXR1cmVzID0gZmVhdHVyZXM7XG5cbiAgICAgICAgICAgIHRoaXMubGFiZWxzID0gW107XG4gICAgICAgICAgICB2YXIgY2FudmFzID0gY3R4LmNhbnZhcztcblxuICAgICAgICAgICAgdmFyIG15cGFwZXI7XG4gICAgICAgICAgICBpZiAoIWNhbnZhcy5fcGFwZXIpIHtcbiAgICAgICAgICAgICAgICBteXBhcGVyID0gbmV3IHBhcGVyLlBhcGVyU2NvcGUoKTtcbiAgICAgICAgICAgICAgICBteXBhcGVyLnNldHVwKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgY2FudmFzLl9wYXBlciA9IG15cGFwZXI7XG4gICAgICAgICAgICAgICAgY2FudmFzLl9tYXAgPSBtYXA7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlwYXBlciA9IGNhbnZhcy5fcGFwZXI7XG5cbiAgICAgICAgICAgIGlmIChjYW52YXMuX2luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICAgICAgbXlwYXBlci5hY3RpdmF0ZSgpO1xuICAgICAgICAgICAgICAgIG15cGFwZXIucHJvamVjdC5hY3RpdmVMYXllci5yZW1vdmVDaGlsZHJlbigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY2FudmFzTGFiZWw7XG4gICAgICAgICAgICBpZiAoY3R4LnRpbGUpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNMYWJlbCA9IFwiKFwiICsgY3R4LnRpbGUueCArIFwiICwgXCIgKyBjdHgudGlsZS55ICsgXCIpXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhc0xhYmVsID0gbXlwYXBlci5faWQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUudGltZShcInJlbmRlciBcIiArIGNhbnZhc0xhYmVsKTtcblxuXG5cbiAgICAgICAgICAgIGlmIChjdHgudGlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5jYW52YXMuX3MgPSBjdHgudGlsZS5tdWx0aXBseUJ5KGN0eC5jYW52YXMud2lkdGgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdHguY2FudmFzLl9zID0gY3R4LmNhbnZhcy5fbWFwLmdldFBpeGVsQm91bmRzKCkubWluO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zb2xlLnRpbWUoXCJhcHBseVN0eWxlcyBcIiArIGNhbnZhc0xhYmVsKTtcblxuICAgICAgICAgICAgdmFyIGxheWVyID0gbmV3IG15cGFwZXIuR3JvdXAoKTtcbiAgICAgICAgICAgIGxheWVyLmFwcGx5TWF0cml4ID0gZmFsc2U7XG4gICAgICAgICAgICBsYXllci50cmFuc2xhdGUobmV3IHBhcGVyLlBvaW50KC1jdHguY2FudmFzLl9zLngsIC1jdHguY2FudmFzLl9zLnkpKTtcblxuICAgICAgICAgICAgdmFyIHo7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlc1tpXTtcblxuICAgICAgICAgICAgICAgIHZhciBzdHlsZXM7XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuX2NsZWFuICYmICFjdHguZm9yY2VTdHlsZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVzID0gZmVhdHVyZS5fc3R5bGVzO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyA9IGZlYXR1cmUuX3N0eWxlcyA9IHRoaXMuX2FwcGx5U3R5bGVzKGZlYXR1cmUsIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgeiA9IHtcbiAgICAgICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlcyxcbiAgICAgICAgICAgICAgICAgICAgekluZGV4OiBzdHlsZXMuekluZGV4LFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIHpCdWZmZXIucHVzaCh6KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgekJ1ZmZlci5zb3J0KGZ1bmN0aW9uKGYxLCBmMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmMS56SW5kZXggLSBmMi56SW5kZXg7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGl0ZW1zID0gW107XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCB6QnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgeiA9IHpCdWZmZXJbaV07XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9hZGRGZWF0dXJlKGN0eCwgeik7XG4gICAgICAgICAgICAgICAgaXRlbXMucHVzaChpdGVtKTtcblxuICAgICAgICAgICAgICAgIGlmICh6LmZlYXR1cmUuc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBsYXllci5hZGRDaGlsZHJlbihpdGVtcyk7XG5cbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZChcImFwcGx5U3R5bGVzIFwiICsgY2FudmFzTGFiZWwpO1xuXG4gICAgICAgICAgICBjb25zb2xlLnRpbWUoXCJkcmF3IFwiICsgY2FudmFzTGFiZWwpO1xuXG4gICAgICAgICAgICAvLyBWaXN1YWwgZGVidWcgaW5mbzpcblxuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kZWJ1Zykge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0gbmV3IG15cGFwZXIuUG9pbnRUZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IFs1LCAxMF0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNhbnZhc0xhYmVsLFxuICAgICAgICAgICAgICAgICAgICBmaWxsQ29sb3I6ICdyZWQnLFxuICAgICAgICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQ291cmllciBOZXcnLFxuICAgICAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXG4gICAgICAgICAgICAgICAgICAgIGZvbnRTaXplOiAxMFxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgdmFyIGJvcmRlciA9IG5ldyBteXBhcGVyLlBhdGguUmVjdGFuZ2xlKDAsIDAsIGNhbnZhcy5jbGllbnRXaWR0aCwgY2FudmFzLmNsaWVudEhlaWdodCk7XG4gICAgICAgICAgICAgICAgYm9yZGVyLnN0eWxlLnN0cm9rZUNvbG9yID0gXCJncmF5XCI7XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbXlwYXBlci52aWV3LmRyYXcoKTtcblxuICAgICAgICAgICAgY29uc29sZS50aW1lRW5kKFwiZHJhdyBcIiArIGNhbnZhc0xhYmVsKTtcbiAgICAgICAgICAgIGNvbnNvbGUudGltZUVuZChcInJlbmRlciBcIiArIGNhbnZhc0xhYmVsKTtcblxuICAgICAgICAgICAgcmV0dXJuIGxheWVyO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9pbml0Q3R4OiBmdW5jdGlvbihjdHgsIG1hcCkge1xuXG4gICAgICAgICAgICBpZiAoY3R4LmNhbnZhcy5faW5pdGlhbGl6ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN0eC5jYW52YXMuX2luaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgICAgICAgICAgaWYgKCFtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHpvb20gPSBtYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FudmFzVHJlZSA9PT0gbnVsbCB8fCB0aGlzLmxhc3Rab29tICE9IHpvb20pIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhbnZhc1RyZWUgPSByYnVzaCg5LCBbJy5taW54JywgJy5taW55JywgJy5tYXh4JywgJy5tYXh5J10pO1xuICAgICAgICAgICAgICAgIHRoaXMubGFzdFpvb20gPSB6b29tO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdHJlZU5vZGUgPSB0aGlzLl9jcmVhdGVUcmVlTm9kZShjdHgpO1xuICAgICAgICAgICAgdGhpcy5jYW52YXNUcmVlLmluc2VydCh0cmVlTm9kZSk7XG5cbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ3R4RXZlbnQoXCJ6b29tZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX29uVmlld0NoYW5nZWQoY3R4KTtcbiAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIHRoaXMuX3JlZ2lzdGVyQ3R4RXZlbnQoXCJkcmFnZW5kXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoXCJtb3ZpbmcgcmVuYWJsZWQhXCIpO1xuICAgICAgICAgICAgICAgIG1hcC5vbihcIm1vdXNlbW92ZVwiLCB0aGlzLl9vbk1vdXNlTW92ZUF1eCwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICB2YXIgdHJlZU5vZGUgPSB0aGlzLl9jcmVhdGVUcmVlTm9kZShjdHgpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzVHJlZS5pbnNlcnQodHJlZU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZHJhZ2dpbmdVcGRhdGVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGN0eCwgY3R4LmZlYXR1cmVzLCBjdHguY2FudmFzLl9tYXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9yZWdpc3RlckN0eEV2ZW50OiBmdW5jdGlvbihldmVudE5hbWUsIGZuKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N0eEV2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2N0eEV2ZW50cyA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2N0eEV2ZW50c1tldmVudE5hbWVdKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY3R4RXZlbnRzW2V2ZW50TmFtZV0gPSBbXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3R4RXZlbnRzW2V2ZW50TmFtZV0ucHVzaChmbik7XG5cbiAgICAgICAgICAgIHZhciBtYXAgPSB0aGlzLmdldE1hcCgpO1xuICAgICAgICAgICAgaWYgKCFtYXAgJiYgdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQuX21hcCkge1xuICAgICAgICAgICAgICAgICAgICBtYXAgPSB0aGlzLnBhcmVudC5fbWFwO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQucGFyZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcCA9IHRoaXMucGFyZW50LnBhcmVudC5fbWFwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbWFwLm9uKGV2ZW50TmFtZSwgZm4sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVUcmVlTm9kZTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gY3R4LmNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHZhciBiYm94ID0gTC5ib3VuZHMoW3BvaW50cy50b3AsIHBvaW50cy5sZWZ0XSwgW3BvaW50cy5ib3R0b20sIHBvaW50cy5yaWdodF0pO1xuXG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY3R4OiBjdHgsXG4gICAgICAgICAgICAgICAgbWlueDogYmJveC5taW4ueCxcbiAgICAgICAgICAgICAgICBtYXh4OiBiYm94Lm1heC54LFxuICAgICAgICAgICAgICAgIG1pbnk6IGJib3gubWluLnksXG4gICAgICAgICAgICAgICAgbWF4eTogYmJveC5tYXgueSxcbiAgICAgICAgICAgICAgICB0aWxlUG9pbnQ6IGN0eC50aWxlXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NlYXJjaENhbnZhczogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBiYm94ID0gTC5ib3VuZHMoW2V2ZW50LmNvbnRhaW5lclBvaW50LnksIGV2ZW50LmNvbnRhaW5lclBvaW50LnhdLCBbZXZlbnQuY29udGFpbmVyUG9pbnQueSxcbiAgICAgICAgICAgICAgICBldmVudC5jb250YWluZXJQb2ludC54XG4gICAgICAgICAgICBdKTtcblxuXG4gICAgICAgICAgICB2YXIgY2FudmFzID0gW107XG4gICAgICAgICAgICBpZiAodGhpcy5jYW52YXNUcmVlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzID0gdGhpcy5jYW52YXNUcmVlLnNlYXJjaChbYmJveC5taW4ueCwgYmJveC5taW4ueSwgYmJveC5tYXgueCwgYmJveC5tYXgueV0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgX2FkZEZlYXR1cmU6IGZ1bmN0aW9uKGN0eCwgZWxlbSkge1xuICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBlbGVtLmZlYXR1cmU7XG5cbiAgICAgICAgICAgIGlmIChmZWF0dXJlLl9jbGVhbikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmZWF0dXJlLl9pdGVtO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc3R5bGVzID0gZWxlbS5zdHlsZTtcblxuICAgICAgICAgICAgdmFyIGdlb20gPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgaWYgKGdlb21bMF0pIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoTC5VdGlsLmlzQXJyYXkoZ2VvbVswXVswXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbSA9IGdlb21bMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbGFiZWxzID0gdGhpcy5fYWRkTGFiZWxzKGZlYXR1cmUsIGN0eCk7XG4gICAgICAgICAgICB2YXIgc3R5bGVQb3B1cCA9IHRoaXMuX2FkZFBvcFVwKGZlYXR1cmUsIGN0eCk7XG5cblxuICAgICAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG5cbiAgICAgICAgICAgIHZhciBpdGVtLCBwYXRoO1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnUG9pbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludCA9IHRoaXMuX2NhbnZhc1BvaW50KGdlb20sIGN0eCwgZmVhdHVyZS5fY2xlYW4pO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMucGF0aC5wb3NpdGlvbiA9IHBvaW50O1xuICAgICAgICAgICAgICAgICAgICBwYXRoID0gc3R5bGVzLnBhdGg7XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSB0aGlzLl9jcmVhdGVHZW9tZXRyeShjdHgsIGdlb20sIGZlYXR1cmUsIHN0eWxlcy5vZmZzZXQsIGZlYXR1cmUuX2NsZWFuKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuXG4gICAgICAgICAgICAgICAgICAgIHBhdGggPSB0aGlzLl9jcmVhdGVHZW9tZXRyeShjdHgsIGdlb20sIGZlYXR1cmUsIG51bGwsIGZlYXR1cmUuX2NsZWFuKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5jbG9zZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgZmVhdHVyZS5fY2xlYW4gPSB0cnVlO1xuICAgICAgICAgICAgcGF0aC5fZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgICBpdGVtID0gdGhpcy5fY3JlYXRlSXRlbShwYXRoLCBzdHlsZXMsIGxhYmVscywgc3R5bGVQb3B1cCwgY3R4KTtcbiAgICAgICAgICAgIGZlYXR1cmUuX2l0ZW0gPSBpdGVtO1xuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Q3R4SWQ6IGZ1bmN0aW9uKGN0eCkge1xuXG4gICAgICAgICAgICBpZiAoY3R4LmlkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN0eC5pZDtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIGlmIChjdHgudGlsZSkge1xuICAgICAgICAgICAgICAgIGN0eC5pZCA9IGN0eC50aWxlLnggKyBcIjpcIiArIGN0eC50aWxlLnk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN0eC5pZCA9IFwiY3R4XCI7IC8vIEp1c3Qgb25lIGN0eCBhbnl3YXkgc28gYW55IGlkIHNob3VsZCB3b3JrLlxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gY3R4LmlkO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jYW52YXNQb2ludDogZnVuY3Rpb24oY29vcmRzLCBjdHgsIGNsZWFuKSB7XG5cbiAgICAgICAgICAgIC8vIGFjdHVhbCBjb29yZHMgdG8gdGlsZSAnc3BhY2UnXG4gICAgICAgICAgICB2YXIgcDtcbiAgICAgICAgICAgIHZhciB6b29tID0gY3R4Lnpvb207XG4gICAgICAgICAgICBpZiAoY29vcmRzLl9wcm9qQ29vcmRzICYmIGNsZWFuKSB7XG4gICAgICAgICAgICAgICAgcCA9IGNvb3Jkcy5fcHJvakNvb3JkcztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcCA9IGNvb3Jkcy5fcHJvakNvb3JkcyA9IGN0eC5jYW52YXMuX21hcC5wcm9qZWN0KG5ldyBMLkxhdExuZyhjb29yZHNbMV0sIGNvb3Jkc1swXSksIHpvb20pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHAueCxcbiAgICAgICAgICAgICAgICB5OiBwLnlcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG5cblxuXG4gICAgICAgIF9jcmVhdGVHZW9tZXRyeTogZnVuY3Rpb24oY3R4LCBnZW9tLCBmZWF0dXJlLCBvZmZzZXQsIGNsZWFuKSB7XG4gICAgICAgICAgICB2YXIgcGF0aDsgLy8gPSBuZXcgY3R4LnBhcGVyLlBhdGgoKTtcblxuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBnZW9tLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzW2ldID0gdGhpcy5fY2FudmFzUG9pbnQoZ2VvbVtpXSwgY3R4LCBjbGVhbik7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBvaW50cyA9IEwuTGluZVV0aWwuc2ltcGxpZnkocG9pbnRzLCAxKTtcblxuICAgICAgICAgICAgaWYgKG9mZnNldCAmJiBvZmZzZXQgIT09IDApIHtcbiAgICAgICAgICAgICAgICBwb2ludHMgPSB0aGlzLl9hZGRPZmZzZXQocG9pbnRzLCBvZmZzZXQsIGN0eCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHBhdGggPSBuZXcgY3R4LmNhbnZhcy5fcGFwZXIuUGF0aCh7XG4gICAgICAgICAgICAgICAgc2VnbWVudHM6IHBvaW50c1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJldHVybiBwYXRoO1xuXG4gICAgICAgIH0sXG5cblxuICAgICAgICBfYXBwbHlTdHlsZXM6IGZ1bmN0aW9uKGZlYXR1cmUsIGN0eCkge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBjdHguY2FudmFzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gdGhpcy5hcHBseVN0eWxlKGZlYXR1cmUsIGN0eCwgem9vbSk7XG4gICAgICAgICAgICByZXR1cm4gc3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZExhYmVsczogZnVuY3Rpb24oZmVhdHVyZSwgY3R4KSB7XG4gICAgICAgICAgICB2YXIgem9vbSA9IGN0eC5jYW52YXMuX21hcC5nZXRab29tKCk7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSB0aGlzLmFkZExhYmVsU3R5bGUoZmVhdHVyZSwgem9vbSk7XG4gICAgICAgICAgICByZXR1cm4gbGFiZWw7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkUG9wVXA6IGZ1bmN0aW9uKGZlYXR1cmUsIGN0eCkge1xuICAgICAgICAgICAgdmFyIHpvb20gPSBjdHguY2FudmFzLl9tYXAuZ2V0Wm9vbSgpO1xuICAgICAgICAgICAgdmFyIHBvcFVwU3R5bGUgPSB0aGlzLmFkZFBvcFVwKGZlYXR1cmUsIHpvb20pO1xuICAgICAgICAgICAgcmV0dXJuIHBvcFVwU3R5bGU7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZUl0ZW06IGZ1bmN0aW9uKHBhdGgsIHN0eWxlcywgbGFiZWxzLCBzdHlsZVBvcHVwLCBjdHgpIHtcblxuICAgICAgICAgICAgcGF0aC5zdHlsZSA9IHN0eWxlcy5wYXRoU3R5bGU7XG4gICAgICAgICAgICBwYXRoLm9wYWNpdHkgPSBzdHlsZXMub3BhY2l0eTtcbiAgICAgICAgICAgIHBhdGgudmlzaWJsZSA9IHN0eWxlcy52aXNpYmxlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdHlsZXMudmlzaWJsZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHBhdGgudmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXRoLl9mZWF0dXJlLnN0eWxlUG9wdXAgPSBzdHlsZVBvcHVwO1xuXG5cbiAgICAgICAgICAgIHZhciBpdGVtID0gbmV3IGN0eC5jYW52YXMuX3BhcGVyLkdyb3VwKCk7XG4gICAgICAgICAgICBpdGVtLmFkZENoaWxkKHBhdGgpO1xuICAgICAgICAgICAgaXRlbS56SW5kZXggPSBzdHlsZXMuekluZGV4O1xuXG4gICAgICAgICAgICBpZiAobGFiZWxzLmNvbnRlbnQgJiYgcGF0aC52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBvaW50VGV4dCA9IG5ldyBjdHguY2FudmFzLl9wYXBlci5Qb2ludFRleHQocGF0aC5pbnRlcmlvclBvaW50KTtcbiAgICAgICAgICAgICAgICBwb2ludFRleHQuY29udGVudCA9IGxhYmVscy5jb250ZW50O1xuICAgICAgICAgICAgICAgIHBvaW50VGV4dC5zdHlsZSA9IGxhYmVscy5zdHlsZTtcbiAgICAgICAgICAgICAgICBpdGVtLmFkZENoaWxkKHBvaW50VGV4dCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBpdGVtO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbk1vdXNlQ2xpY2s6IGZ1bmN0aW9uKGN0eCwgZXZlbnQpIHtcblxuICAgICAgICAgICAgdmFyIHBvcHVwO1xuICAgICAgICAgICAgdmFyIGhpdFJlc3VsdCA9IHRoaXMuX2hpdFRlc3QoY3R4LCBldmVudCk7XG5cbiAgICAgICAgICAgIGlmIChoaXRSZXN1bHQgJiYgaGl0UmVzdWx0Lml0ZW0uX2NsYXNzID09ICdQYXRoJykge1xuICAgICAgICAgICAgICAgIGV2ZW50Ll9oaXQgPSBoaXRSZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVFdmVudChcImZlYXR1cmVDbGlja1wiLCB7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmU6IGhpdFJlc3VsdC5pdGVtLl9mZWF0dXJlLFxuICAgICAgICAgICAgICAgICAgICBldmVudDogZXZlbnQsXG5cbiAgICAgICAgICAgICAgICB9KTtcblxuXG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVGZWF0dXJlKGhpdFJlc3VsdC5pdGVtLl9mZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGVQb3B1cCA9IHRoaXMuX2FkZFBvcFVwKGhpdFJlc3VsdC5pdGVtLl9mZWF0dXJlLCBjdHgpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHN0eWxlUG9wdXAuY29udGVudCAhPSBudWxsKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcG9wdXAgPSBMLnBvcHVwKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHN0eWxlUG9wdXAub2Zmc2V0XG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLnNldExhdExuZyhldmVudC5sYXRsbmcpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc2V0Q29udGVudChzdHlsZVBvcHVwLmNvbnRlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAub3Blbk9uKGN0eC5jYW52YXMuX21hcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uTW91c2VNb3ZlOiBmdW5jdGlvbihjdHgsIGV2ZW50KSB7XG5cbiAgICAgICAgICAgIHZhciBoaXRSZXN1bHQgPSB0aGlzLl9oaXRUZXN0KGN0eCwgZXZlbnQpO1xuXG4gICAgICAgICAgICBpZiAoaGl0UmVzdWx0ICYmIGhpdFJlc3VsdC5pdGVtLl9jbGFzcyA9PSAnUGF0aCcpIHtcbiAgICAgICAgICAgICAgICBldmVudC5faGl0ID0gaGl0UmVzdWx0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdHguY2FudmFzLl9tYXAuZ2V0Q29udGFpbmVyKCkuc3R5bGUuY3Vyc29yID0gZXZlbnQuX2hpdCA/ICdwb2ludGVyICcgOiAnJztcbiAgICAgICAgfSxcblxuXG4gICAgICAgIF9oaXRUZXN0OiBmdW5jdGlvbihjdHgsIGV2ZW50KSB7XG5cbiAgICAgICAgICAgIC8vY29uc29sZS50aW1lKFwiaGl0VGVzdFwiKTtcbiAgICAgICAgICAgIHZhciBjUG9pbnQgPSB0aGlzLl9jYW52YXNQb2ludChbZXZlbnQubGF0bG5nLmxuZywgZXZlbnQubGF0bG5nLmxhdF0sIGN0eCk7XG5cbiAgICAgICAgICAgIHZhciBzID0gY3R4LmNhbnZhcy5fbWFwLmdldFBpeGVsQm91bmRzKCkubWluO1xuXG5cbiAgICAgICAgICAgIGNQb2ludC54IC09IGN0eC5jYW52YXMuX3MueDtcbiAgICAgICAgICAgIGNQb2ludC55IC09IGN0eC5jYW52YXMuX3MueTtcbiAgICAgICAgICAgIHZhciBmaWxsID0gdHJ1ZTtcblxuICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdG9sZXJhbmNlOiAxMCxcbiAgICAgICAgICAgICAgICBmaWxsOiB0cnVlLFxuICAgICAgICAgICAgICAgIHN0cm9rZTogdHJ1ZVxuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICB2YXIgaGl0UmVzdWx0ID0gY3R4LmNhbnZhcy5fcGFwZXIucHJvamVjdC5oaXRUZXN0KGNQb2ludCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAvL2NvbnNvbGUudGltZUVuZChcImhpdFRlc3RcIik7XG5cbiAgICAgICAgICAgIHJldHVybiBoaXRSZXN1bHQ7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uVmlld0NoYW5nZWQ6IGZ1bmN0aW9uKGN0eCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGYgPSB0aGlzLmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgICAgIGYuX2NsZWFuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNUcmVlLmNsZWFyKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfYWRkT2Zmc2V0OiBmdW5jdGlvbihwcm9qLCBvZmZzZXQsIGN0eCkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBwcm9qLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSBwcm9qW2pdO1xuXG4gICAgICAgICAgICAgICAgcC5sYXQgPSBwLng7XG4gICAgICAgICAgICAgICAgcC5sbmcgPSBwLnk7XG5cbiAgICAgICAgICAgICAgICBpZiAoaiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBuZXh0UG9pbnQgPSBwcm9qW2ogKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgbm9ybWFsID0gdGhpcy5fY2FsY3VsYXRlTm9ybWFsKHAsIG5leHRQb2ludCk7XG4gICAgICAgICAgICAgICAgICAgIHAueCA9IHAueCArIG9mZnNldCAqIG5vcm1hbC54O1xuICAgICAgICAgICAgICAgICAgICBwLnkgPSBwLnkgKyBvZmZzZXQgKiBub3JtYWwueTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGogPT0gcHJvai5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHByZXZQb2ludCA9IHByb2pbaiAtIDFdO1xuICAgICAgICAgICAgICAgICAgICBub3JtYWwgPSB0aGlzLl9jYWxjdWxhdGVOb3JtYWwocHJldlBvaW50LCBwKTtcbiAgICAgICAgICAgICAgICAgICAgcC54ID0gcC54ICsgb2Zmc2V0ICogbm9ybWFsLng7XG4gICAgICAgICAgICAgICAgICAgIHAueSA9IHAueSArIG9mZnNldCAqIG5vcm1hbC55O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAgICAgcHJldlBvaW50ID0gcHJvaltqIC0gMV07XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbDAgPSB0aGlzLl9jYWxjdWxhdGVOb3JtYWwocHJldlBvaW50LCBwKTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgeDEgPSBwcmV2UG9pbnQueCArIG9mZnNldCAqIG5vcm1hbDAueDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHkxID0gcHJldlBvaW50LnkgKyBvZmZzZXQgKiBub3JtYWwwLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHgyID0gcC54ICsgb2Zmc2V0ICogbm9ybWFsMC54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTIgPSBwLnkgKyBvZmZzZXQgKiBub3JtYWwwLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgbmV4dFBvaW50ID0gbmV4dFBvaW50ID0gcHJvaltqICsgMV07XG4gICAgICAgICAgICAgICAgICAgIG5vcm1hbDEgPSB0aGlzLl9jYWxjdWxhdGVOb3JtYWwocCwgbmV4dFBvaW50KTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHgzID0gcC54ICsgb2Zmc2V0ICogbm9ybWFsMS54O1xuICAgICAgICAgICAgICAgICAgICB2YXIgeTMgPSBwLnkgKyBvZmZzZXQgKiBub3JtYWwxLnk7XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIHg0ID0gbmV4dFBvaW50LnggKyBvZmZzZXQgKiBub3JtYWwxLng7XG4gICAgICAgICAgICAgICAgICAgIHZhciB5NCA9IG5leHRQb2ludC55ICsgb2Zmc2V0ICogbm9ybWFsMS55O1xuXG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGQgPSAoeDEgLSB4MikgKiAoeTMgLSB5NCkgLSAoeTEgLSB5MikgKiAoeDMgLSB4NCk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCAwLjAwMDAwMDAwMDAwMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVmVyeSBzbWFsbCBkZW5vbWluYXRvcnMgbWFrZSB0aGUgY2FsY3VsYXRpb24gZ28gY3JhenkuXG4gICAgICAgICAgICAgICAgICAgICAgICBwLnggPSBwLnggKyBvZmZzZXQgKiBub3JtYWwueDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueSA9IHAueSArIG9mZnNldCAqIG5vcm1hbC55O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbjEgPSAoeDEgKiB5MiAtIHkxICogeDIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG4yID0gKHgzICogeTQgLSB5MyAqIHg0KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgcC54ID0gKG4xICogKHgzIC0geDQpIC0gKHgxIC0geDIpICogbjIpIC8gZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAueSA9IChuMSAqICh5MyAtIHk0KSAtICh5MSAtIHkyKSAqIG4yKSAvIGQ7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwcm9qW2pdID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiBwLmxhdCxcbiAgICAgICAgICAgICAgICAgICAgeTogcC5sbmdcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvaW50c1tqXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgeDogcC54LFxuICAgICAgICAgICAgICAgICAgICB5OiBwLnlcbiAgICAgICAgICAgICAgICB9O1xuXG5cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICByZXR1cm4gcG9pbnRzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jYWxjdWxhdGVOb3JtYWw6IGZ1bmN0aW9uKHAwLCBwMSkge1xuXG4gICAgICAgICAgICB2YXIgcnkgPSBwMS55IC0gcDAueTtcbiAgICAgICAgICAgIHZhciByeCA9IHAxLnggLSBwMC54O1xuXG4gICAgICAgICAgICB2YXIgZCA9IE1hdGguc3FydChyeCAqIHJ4ICsgcnkgKiByeSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogLXJ5IC8gZCxcbiAgICAgICAgICAgICAgICB5OiByeCAvIGRcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGFkZCBhIGxheWVyIGZyb20gdGhlIG1hcFxuICAgICAgICAgKi9cbiAgICAgICAgb25BZGQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5fY3R4RXZlbnRzID0ge307XG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcbiAgICAgICAgICAgIG1hcC5vbihcImRyYWdzdGFydFwiLCB0aGlzLl9vbk1hcERyYWdTdGFydGVkLCB0aGlzKTtcblxuICAgICAgICAgICAgbWFwLm9uKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTWFwTW91c2VNb3ZlZCwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub24oXCJtb3ZlZW5kXCIsIHRoaXMuX29uTWFwTW92ZUVuZGVkLCB0aGlzKTtcbiAgICAgICAgICAgIG1hcC5vbihcImNsaWNrXCIsIHRoaXMuX29uTWFwQ2xpY2tlZCwgdGhpcyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3Zpc2libGUgPSB0cnVlO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVtb3ZlIGEgbGF5ZXIgZnJvbSB0aGUgbWFwXG4gICAgICAgICAqL1xuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIHJlbW92ZSBhbGwgZXZlbnRzIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGF5ZXIsIG9yIHBlcmZvcm1hbmNlIHdpbGwgYmUgc29yZWx5IGFmZmVjdGVkLlxuXG4gICAgICAgICAgICB2YXIgbWFwID0gdGhpcy5nZXRNYXAoKTtcblxuICAgICAgICAgICAgbWFwLm9mZihcImNsaWNrXCIsIHRoaXMuX29uTWFwQ2xpY2tlZCwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKFwibW91c2Vtb3ZlXCIsIHRoaXMuX29uTWFwTW91c2VNb3ZlZCwgdGhpcyk7XG4gICAgICAgICAgICBtYXAub2ZmKFwiZHJhZ3N0YXJ0XCIsIHRoaXMuX29uTWFwRHJhZ1N0YXJ0ZWQsIHRoaXMpO1xuICAgICAgICAgICAgbWFwLm9mZihcIm1vdmVlbmRcIiwgdGhpcy5fb25NYXBNb3ZlRW5kZWQsIHRoaXMpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBldmVudE5hbWUgaW4gdGhpcy5fY3R4RXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGV2ZW50SGFuZGxlcnMgPSB0aGlzLl9jdHhFdmVudHNbZXZlbnROYW1lXTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50SGFuZGxlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwLm9mZihldmVudE5hbWUsIGV2ZW50SGFuZGxlcnNbaV0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fdmlzaWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICB9LCBbU01DLmxheWVycy5zdHlsZXJzLk1hcENzc1N0eWxlcl0pOyIsInJlcXVpcmUoXCIuL2dlb21ldHJ5LmpzXCIpO1xucmVxdWlyZShcIi4uL1NpbmdsZUxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4vQ2FudmFzUmVuZGVyZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3R5bGVycy9NYXBDc3NTdHlsZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vLi4vLi4vbGliL2NhbnZhc0xheWVyL2xlYWZsZXRfY2FudmFzX2xheWVyLmpzXCIpO1xuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXllcnMgdXNpbmcgY2xpZW50IHNpZGUgcmVuZGVyaW5nIG9mIGdlb2dyYXBoaWNhbCBmZWF0dXJlcyBpbiB0aGUgU0NNIG1hcCB2aWV3ZXIgY29tcG9uZW50LlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIEwuQ2FudmFzTGF5ZXJcbiAqIEBtaXhlcyBTTUMubGF5ZXJzLlNpbmdsZUxheWVyXG4gKiBAbWl4ZXMgU01DLmxheWVycy5nZW9tZXRyeS5DYW52YXNSZW5kZXJlclxuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5nZW9tZXRyeS5HZW9tZXRyeUxheWVyID0gTC5DYW52YXNMYXllci5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLmdlb21ldHJ5Lkdlb21ldHJ5TGF5ZXIjICovXG4gICAge1xuXG5cdFx0ZmVhdHVyZXM6IFtdLFxuXHRcdC8qKlxuXHRcdCAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcblx0XHQgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuXHRcdCAqL1xuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdEwuQ2FudmFzTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFNNQy5sYXllcnMuc3R5bGVycy5NYXBDc3NTdHlsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXHRcdH0sXG5cdFx0LyoqXG5cdFx0ICogTWV0aG9kIHRvIGxvYWQgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuXHRcdCAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIGFkZGVkXG5cdFx0ICovXG5cdFx0b25BZGQ6IGZ1bmN0aW9uKG1hcCkge1xuXHRcdFx0TC5DYW52YXNMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdFx0U01DLmxheWVycy5nZW9tZXRyeS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdFx0U01DLmxheWVycy5TaW5nbGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuXHRcdCAgIFxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0XG5cdFx0XHRtYXAub24oXCJwb3B1cG9wZW5cIiwgZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdFx0aWYgKG1hcC5fYXV0b3Bhbikge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc2l6ZUFsbENhbnZhcygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRtYXAuX2F1dG9wYW4gPSBmYWxzZTtcblxuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdG1hcC5vbihcImF1dG9wYW5zdGFydFwiLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0bWFwLl9hdXRvcGFuID0gdHJ1ZTtcblx0XHRcdH0sIHRoaXMpO1xuXG5cblx0XHRcdG1hcC5vbihcInJlc2l6ZVwiLCBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0XHRcdHRoaXMuX3Jlc2l6ZUFsbENhbnZhcygpO1xuXHRcdFx0fSwgdGhpcyk7XG5cblx0XHRcdG1hcC5vbihcImRyYWdlbmRcIiwgZnVuY3Rpb24oKXtcbiAgICAgICAgICB0aGlzLl9yZXNpemVBbGxDYW52YXMoKTtcbiAgICAgIH0sIHRoaXMpO1xuXG5cdFx0XHRtYXAub24oJ3pvb21lbmQnLCBmdW5jdGlvbigpe1xuXHRcdFx0XHRzZWxmLl9vblZpZXdDaGFuZ2VkKCk7XG5cdFx0XHR9KVxuXG5cblx0XHR9LFxuXG4gICAgICAgIF9yZXNpemVDYW52YXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0TWFwKCkuX21hcFBhbmUuX2xlYWZsZXRfcG9zO1xuICAgICAgICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgIEwuRG9tVXRpbC5zZXRQb3NpdGlvbih0aGlzLl9jYW52YXMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDogLXAueCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTogLXAueVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIF9yZXNpemVBbGxDYW52YXM6IGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICB2YXIgbGF5ZXJzID0gdGhpcy5nZXRNYXAoKS5fbGF5ZXJzO1xuICAgICAgICAgICAgZm9yICh2YXIgbCBpbiBsYXllcnMpe1xuICAgICAgICAgICAgICAgICAgICBpZihsYXllcnNbbF0gaW5zdGFuY2VvZiBTTUMubGF5ZXJzLmdlb21ldHJ5Lkdlb21ldHJ5TGF5ZXIpe1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJzW2xdLl9yZXNpemVDYW52YXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuXHQgICAgbG9hZDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHRoaXMuYWRkR2VvbWV0cnlGcm9tRmVhdHVyZXModGhpcy5mZWF0dXJlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBsb2FkIHRoZSBjb250cm9sIGluIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMuTWFwfSBtYXAgLSBNYXAgdG8gYmUgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgIG9uUmVtb3ZlOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuZ2VvbWV0cnkuQ2FudmFzUmVuZGVyZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBMLkNhbnZhc0xheWVyLnByb3RvdHlwZS5vblJlbW92ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZ2V0IHRoZSBtYXBcbiAgICAgICAgICogQHJldHVybnMge1NNQy5NYXB9IG1hcCAtIE1hcCBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0TWFwOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9tYXA7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZW5kZXIgYSBsYXllciBvbiB0aGUgbWFwXG4gICAgICAgICAqL1xuICAgICAgICByZW5kZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLl9yZW5kZXJUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3JlbmRlclRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgdGhpc18gPSB0aGlzO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNfLmZlYXR1cmVzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzXy5yZW5kZXJDYW52YXMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzOiBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgfSwgdGhpc18uZmVhdHVyZXMsIHRoaXNfLmdldE1hcCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgIH0sIDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gYWRkIGdlb21ldHJpZXMgZnJvbSBmZWF0dXJlc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZXMgLSBGZWF0dXJlcyB0byBnZXQgaXRzIGdlb21ldHJpZXNcbiAgICAgICAgICovXG4gICAgICAgIGFkZEdlb21ldHJ5RnJvbUZlYXR1cmVzOiBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICAgICAgaWYgKEwuVXRpbC5pc0FycmF5KGZlYXR1cmVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmVhdHVyZXMgPSBmZWF0dXJlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gW2ZlYXR1cmVzXTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydGllcyh0aGlzLmZlYXR1cmVzW2ldKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgU01DLmxheWVycy5nZW9tZXRyeS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLnJlbmRlcigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbihmZWF0dXJlKSB7XG4gICAgICAgICAgICB2YXIgaWQgPSB0aGlzLm9wdGlvbnMuaWRGaWVsZDtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLmhhc093blByb3BlcnR5KGlkKSlcbiAgICAgICAgICAgICAgICBmZWF0dXJlLmlkID0gZmVhdHVyZVtpZF07XG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZVtwcm9wS2V5XS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBmZWF0dXJlW3Byb3BLZXldW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gdXBkYXRlIHRoZSBzdHlsZSBvZiBhIGZlYXR1cmVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBmZWF0dXJlIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmVzW2ldLmlkID09IGZlYXR1cmUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5fY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlc1tpXSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZW5kZXIoKTtcblxuICAgICAgICB9XG5cblxuICAgIH0sIFtTTUMubGF5ZXJzLlNpbmdsZUxheWVyLCBTTUMubGF5ZXJzLmdlb21ldHJ5LkNhbnZhc1JlbmRlcmVyXSk7XG4iLCJyZXF1aXJlKFwiLi9HZW9tZXRyeUxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL3Byb3ZpZGVycy9Tb2xySGlzdG9yeVByb3ZpZGVyLmpzXCIpO1xuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5ZXJzIHVzaW5nIGEgU29sciBwcm92aWRlciB0byBnZXQgdGhlIGZlYXR1cmVzXG4gKlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMuZ2VvbWV0cnkuR2VvbWV0cnlMYXllclxuICogQG1peGVzIFNNQy5wcm92aWRlcnMuU29sckhpc3RvcnlQcm92aWRlclxuICpcbiAqL1xuU01DLmxheWVycy5nZW9tZXRyeS5Tb2xyR2VvbWV0cnlIaXN0b3J5TGF5ZXIgPSBTTUMubGF5ZXJzLmdlb21ldHJ5Lkdlb21ldHJ5TGF5ZXIuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmxheWVycy5nZW9tZXRyeS5Tb2xyR2VvbWV0cnlIaXN0b3J5TGF5ZXIjICovXG4gICAge1xuICAgICAgICBfaGlzdG9yeUxheWVyczoge30sXG4gICAgICAgIF90aW1lcjogbnVsbCxcbiAgICAgICAgX25vZGU6IG51bGwsXG5cbiAgICAgICAgY3VycmVudFRpbWU6IDAsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvYmplY3Qgd2l0aCBuZWVkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuZ2VvbWV0cnkuR2VvbWV0cnlMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgU01DLnByb3ZpZGVycy5Tb2xySGlzdG9yeVByb3ZpZGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KDEwMDApO1xuICAgICAgICB9LFxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGZlYXR1cmVzXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYW4gSFRNTCBub2RlIGZvciB0aGUgbGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgY29kZSByZXByZXNlbnRpbmcgdGhlIGNvZGUgdG8gYmUgYWRkZWQgdG8gdGhlIGxheWVyJ3MgZW50cnkgaW4gdGhlIGxheWVyIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVOb2RlSFRNTDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIG5vZGUuaWQgPSBcIm5vZGVfXCIgKyB0aGlzLl9sZWFmbGV0X2lkO1xuXG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IHRoaXMuZ2V0TWFwKCkuaGFzTGF5ZXIodGhpcyk7XG5cbiAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgaW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgaW5wdXQuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIG5hbWUuaW5uZXJIVE1MID0gJyAnICsgKHRoaXMub3B0aW9ucy5sYWJlbCB8fCB0aGlzLm9wdGlvbnMudHlwZU5hbWUpO1xuXG4gICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChuYW1lKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgICAgICAgICAgaWYgKCQuaXNFbXB0eU9iamVjdCh0aGlzLl9mZWF0dXJlc0ZvckxheWVyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2xpZGVyQ29udHJvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2wuc3R5bGUubWFyZ2luTGVmdCA9ICcxMHB4JztcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2wuc3R5bGUubWFyZ2luVG9wID0gJzVweCc7XG4gICAgICAgICAgICBzbGlkZXJDb250cm9sLmNsYXNzTmFtZSA9ICdsZWFmbGV0LWJhciBsZWFmbGV0LXVwZGF0ZS1pbnRlcnZhbCAnO1xuXG4gICAgICAgICAgICB2YXIgc2xpZGVyQ29udHJvbExhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICAgICAgICB0aGlzLnNsaWRlckNvbnRyb2xMYWJlbCA9IHNsaWRlckNvbnRyb2xMYWJlbDtcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2xMYWJlbC5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2wuc3R5bGUuZm9udCA9ICcxMnB4LzEuNSBcIkhlbHZldGljYSBOZXVlXCIsIEFyaWFsLCBIZWx2ZXRpY2EsIHNhbnMtc2VyaWYnO1xuXG4gICAgICAgICAgICB2YXIgaW5wdXRJbnRlcnZhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLnR5cGUgPSAncmFuZ2UnO1xuICAgICAgICAgICAgaW5wdXRJbnRlcnZhbC5pZCA9IFwiaW50ZXJ2YWxfXCIgKyB0aGlzLl9sZWFmbGV0X2lkO1xuICAgICAgICAgICAgaW5wdXRJbnRlcnZhbC5uYW1lID0gXCJpbnRlcnZhbF9cIiArIHRoaXMuX2xlYWZsZXRfaWQ7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLm1pbiA9IDA7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLm1heCA9IE9iamVjdC5rZXlzKHRoaXMuX2ZlYXR1cmVzRm9yTGF5ZXIpLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLnN0ZXAgPSAxO1xuICAgICAgICAgICAgaW5wdXRJbnRlcnZhbC52YWx1ZSA9IHRoaXMuY3VycmVudFRpbWU7XG5cbiAgICAgICAgICAgIHZhciB0aW1lID0gaW5wdXRJbnRlcnZhbC52YWx1ZTtcblxuICAgICAgICAgICAgdmFyIHBsYXlfcGF1c2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgICAgICAgICAgIHBsYXlfcGF1c2UuY2xhc3NOYW1lID0gJ2ZhIGZhLXBsYXknO1xuICAgICAgICAgICAgcGxheV9wYXVzZS5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblxuICAgICAgICAgICAgdGhpcy5zaG93VGltZURhdGEodGhpcy5jdXJyZW50VGltZSk7XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXRJbnRlcnZhbCwgJ21vdXNlZG93bicsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXRJbnRlcnZhbCwgJ21vdXNldXAnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IGlucHV0SW50ZXJ2YWwudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VGltZURhdGEodGltZSk7XG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24oZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXRJbnRlcnZhbCwgJ3RvdWNoc3RhcnQnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGlucHV0SW50ZXJ2YWwsICd0b3VjaGVuZCcsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcblxuICAgICAgICAgICAgdmFyIHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgICAgIHZhciB0ZDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgdmFyIHRkMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICB2YXIgdGQzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIHRkMS5hcHBlbmRDaGlsZChzbGlkZXJDb250cm9sTGFiZWwpO1xuICAgICAgICAgICAgdGQyLmFwcGVuZENoaWxkKHBsYXlfcGF1c2UpO1xuICAgICAgICAgICAgdGQzLmFwcGVuZENoaWxkKGlucHV0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQxKTtcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMik7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDMpO1xuXG4gICAgICAgICAgICBzbGlkZXJDb250cm9sLmFwcGVuZENoaWxkKHRyKTtcblxuXG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKHNsaWRlckNvbnRyb2wpO1xuXG4gICAgICAgICAgICBwbGF5X3BhdXNlLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9vblBsYXlQYXVzZShub2RlLCB0aW1lKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBsYWJlbC5vbmNoYW5nZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fY2xpY2tPbkxheWVyKG5vZGUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX25vZGUgPSBub2RlO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGdldCB0aGUgbWFwXG4gICAgICAgICAqIEByZXR1cm5zIHtTTUMuTWFwfSBtYXAgLSBNYXAgbGF5ZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQubWFwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hcCA9IHRoaXMucGFyZW50Lm1hcDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50Ll9tYXApIHtcbiAgICAgICAgICAgICAgICAgICAgbWFwID0gdGhpcy5wYXJlbnQuX21hcDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMucGFyZW50LnBhcmVudCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wYXJlbnQucGFyZW50Lm1hcClcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcCA9IHRoaXMucGFyZW50LnBhcmVudC5tYXA7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMucGFyZW50LnBhcmVudC5fbWFwKVxuICAgICAgICAgICAgICAgICAgICAgICAgbWFwID0gdGhpcy5wYXJlbnQucGFyZW50Ll9tYXA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG1hcDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fbWFwKSB7XG4gICAgICAgICAgICAgICAgbWFwID0gdGhpcy5fbWFwO1xuICAgICAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gY2hhbmdlIHRoZSBzZXQgb2YgZmVhdHVyZXMgZm9yIHRoZSBsYXllclxuICAgICAgICAgKi9cbiAgICAgICAgc2hvd1RpbWVEYXRhOiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZlYXR1cmVzRm9yTGF5ZXI7XG4gICAgICAgICAgICBpZiAodGltZSAlIDEgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aW1lID0gdGltZSAtICh0aW1lICUgMSk7XG4gICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICB0aGlzLmN1cnJlbnRUaW1lID0gdGltZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgZCBpbiBkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGFbZF0uYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbZF0uYWN0dWFsID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09IHRpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhW2RdLmFjdHVhbCkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhW2RdLmFjdHVhbCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtkXS5sYXN0Wm9vbSAmJiAoZGF0YVtkXS5sYXN0Wm9vbSAhPSB0aGlzLmdldE1hcCgpLmdldFpvb20oKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBmIGluIGRhdGFbZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkXVtmXS5fY2xlYW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFkZEdlb21ldHJ5RnJvbUZlYXR1cmVzKGRhdGFbZF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkXS5sYXN0Wm9vbSA9IHRoaXMuZ2V0TWFwKCkuZ2V0Wm9vbSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgbGF5ZXIgbGFiZWxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2xpZGVyQ29udHJvbExhYmVsLmlubmVySFRNTCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpKys7XG5cbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICBfY2xpY2tPbkxheWVyOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICB2YXIgcGF1c2UgPSBub2RlLmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2ZhIGZhLXBhdXNlJylbMF07XG4gICAgICAgICAgICBpZiAocGF1c2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9vblBsYXlQYXVzZShub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZmVhdHVyZXNGb3JMYXllcjtcbiAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuWzFdLnN0eWxlLmRpc3BsYXkgIT0gJ25vbmUnKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlblsxXS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW5bMF0uY2hlY2tlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGQgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YVtkXS5hY3R1YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25SZW1vdmUodGhpcy5nZXRNYXAoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW5bMV0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlblswXS5jaGVja2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBkIGluIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGFbZF0uYWN0dWFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQWRkKHRoaXMuZ2V0TWFwKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRHZW9tZXRyeUZyb21GZWF0dXJlcyhkYXRhW2RdKTtcblxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uUGxheVBhdXNlOiBmdW5jdGlvbihub2RlLCB0aW1lKSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2ZlYXR1cmVzRm9yTGF5ZXI7XG4gICAgICAgICAgICB2YXIgc2xpZGVyID0gbm9kZS5jaGlsZHJlblsxXS5jaGlsZHJlblswXS5jaGlsZHJlblsyXS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHZhciBtYXhWYWx1ZSA9IHNsaWRlci5tYXg7XG4gICAgICAgICAgICB2YXIgc2xpZGVyQ29udHJvbExhYmVsID0gbm9kZS5jaGlsZHJlblsxXS5jaGlsZHJlblswXS5jaGlsZHJlblswXS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgIHZhciBwbGF5ID0gbm9kZS5jaGlsZHJlblsxXS5jaGlsZHJlblswXS5jaGlsZHJlblsxXS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgaWYgKHBsYXkuY2xhc3NOYW1lID09ICdmYSBmYS1wbGF5Jykge1xuICAgICAgICAgICAgICAgIHBsYXkuY2xhc3NOYW1lID0gJ2ZhIGZhLXBhdXNlJztcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVyLnZhbHVlID09IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHNsaWRlci52YWx1ZSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB2YXIgaSA9IHBhcnNlRmxvYXQoc2xpZGVyLnZhbHVlKTtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLnNob3dUaW1lRGF0YShpKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPCBtYXhWYWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLnZhbHVlID0gaTtcblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChzZWxmLl90aW1lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGF5LmNsYXNzTmFtZSA9ICdmYSBmYS1wbGF5JztcbiAgICAgICAgICAgICAgICAgICAgICAgIHNsaWRlci52YWx1ZSA9IG1heFZhbHVlO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaSArPSBwYXJzZUZsb2F0KHNsaWRlci5zdGVwKTtcblxuICAgICAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy50aW1lKTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIHBsYXkuY2xhc3NOYW1lID0gJ2ZhIGZhLXBsYXknO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fdGltZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG5cblxuICAgIH0sIFtTTUMucHJvdmlkZXJzLlNvbHJIaXN0b3J5UHJvdmlkZXJdKTtcblxuLyoqXG4gKiBBUEkgZmFjdG9yeSBtZXRob2QgZm9yIGVhc3kgY3JlYXRpb24gb2YgU29sciBnZW9tZXRyeSBoaXN0b3J5IGxheWVyLlxuICogQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBTb2xyIHJlcXVlc3RcbiAqL1xuU01DLnNvbHJHZW9tZXRyeUhpc3RvcnlMYXllciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNNQy5sYXllcnMuZ2VvbWV0cnkuU29sckdlb21ldHJ5SGlzdG9yeUxheWVyKG9wdGlvbnMpO1xufTtcbiIsInJlcXVpcmUoXCIuL2dlb21ldHJ5LmpzXCIpO1xucmVxdWlyZShcIi4uL2xheWVycy5qc1wiKTtcbnJlcXVpcmUoXCIuLi9TaW5nbGVMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuL0NhbnZhc1JlbmRlcmVyLmpzXCIpO1xucmVxdWlyZShcIi4uL3N0eWxlcnMvTWFwQ3NzU3R5bGVyLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uLy4uL2xpYi9jYW52YXNMYXllci9sZWFmbGV0X2NhbnZhc19sYXllci5qc1wiKTtcbi8vIFJCdXNoIGluc2VydHMgaXRzZWxmIGFzIE5vZGVKcyBtb2R1bGUgc28gd2UgbXVzdCByZXRyaWV2ZSBpdCB0aGlzIHdheS5cbi8qKlxuICogR2xvYmFsIHZhcmlhYmxlIHRoYXQgcmVwcmVzZW50cyBSQnVzaCBsaWJyYXJ5IGZ1bmN0aW9uYWxpdHlcbiAqIEBwcm9wZXJ0eSB7cmJ1c2h9IC0gcmJ1c2ggdmFyaWFibGVcbiAqL1xudmFyIHJidXNoID0gcmVxdWlyZShcIi4uLy4uLy4uL2xpYi9yYnVzaC5qc1wiKTtcbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5ZXJzIHVzaW5nIGNsaWVudCBzaWRlIHJlbmRlcmluZyBvZiB0aWxlcyBjb250YWluaW5nIGdlb2dyYXBoaWNhbCBmZWF0dXJlcyBpbiB0aGUgU01DIG1hcCB2aWV3ZXIgY29tcG9uZW50LlxuICpcbiAqIFRoZSB0aWxlcyBjb250ZW50cyB3aWxsIGJlIHJldHJpZXZlZCB1c2luZyBhIGRhdGEgcHJvdmlkZWQgc3VwcG9ydGluZyB0aWxpbmcgYXMgbmVlZGVkIHRvIGNvdmVyIHRoZSB2aWV3aW5nIGFyZWEuXG4gKlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIEwuVGlsZUxheWVyLkNhbnZhc1xuICogQG1peGVzIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXJcbiAqIEBtaXhlcyBTTUMubGF5ZXJzLmdlb21ldHJ5LkNhbnZhc1JlbmRlcmVyXG4gKiBAcGFyYW0ge1NNQy5sYXllcnMuZ2VvbWV0cnkuVGlsZWRHZW9tZXRyeUxheWVyfm9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNsYXNzXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLmdlb21ldHJ5LlRpbGVkR2VvbWV0cnlMYXllciA9IEwuVGlsZUxheWVyLkNhbnZhcy5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLmdlb21ldHJ5LlRpbGVkR2VvbWV0cnlMYXllciMgKi9cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5sYXllcnMuZ2VvbWV0cnkuVGlsZWRHZW9tZXRyeUxheWVyfm9wdGlvbnNcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbGVTaXplPTI1NiAtIERlZmF1bHQgdGlsZSBzaXplIHZhbHVlXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB0aWxlU2l6ZTogMjU2LCBcbiAgICAgICAgICAgIGZpZWxkR2VvbTogJ3RoZV9nZW9tJyAgIFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogR2xvYmFsIHRyZWVcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGdsb2JhbFRyZWUgLSBEZWZhdWx0IGdsb2JhbCB0cmVlXG4gICAgICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgICAgICovXG4gICAgICAgIGdsb2JhbFRyZWU6IG51bGwsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGZWF0dXJlcyBhcnJheVxuICAgICAgICAgKiBAcHJvcGVydHkge29iamVjdFtdfSBmZWF0dXJlcyAtIERlZmF1bHQgZmVhdHVyZXMgYXJyYXlcbiAgICAgICAgICogQGRlZmF1bHQgW11cbiAgICAgICAgICovXG4gICAgICAgIGZlYXR1cmVzOiBbXSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFRpbGVzIGxvYWQgdmFyaWFibGVcbiAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHRpbGVzTG9hZCAtIERlZmF1bHQgdGlsZXMgbG9hZCB2YXJpYWJsZVxuICAgICAgICAgKiBAZGVmYXVsdCAwXG4gICAgICAgICAqL1xuICAgICAgICB0aWxlc0xvYWQ6IDAsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaWxlcyB0byBsb2FkXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSB0aWxlc1RvTG9hZCAtIERlZmF1bHQgdGlsZXMgdG8gbG9hZFxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICB0aWxlc1RvTG9hZDogbnVsbCxcbiAgICAgICAgXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvYmplY3Qgd2l0aCBuZWVkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgTC5UaWxlTGF5ZXIuQ2FudmFzLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLmdlb21ldHJ5LkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLnN0eWxlcnMuTWFwQ3NzU3R5bGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgICAgIHRoaXMuX3NldEZpZWxkR2VvbSgpO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZHJhd1RpbGUgPSBmdW5jdGlvbihjYW52YXMsIHRpbGVQb2ludCwgem9vbSkge1xuICAgICAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhczogY2FudmFzLFxuICAgICAgICAgICAgICAgICAgICB0aWxlOiB0aWxlUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgIHpvb206IHRoaXMuX2dldFpvb21Gb3JVcmwoKVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nbG9iYWxUcmVlID09PSBudWxsIHx8IHRoaXMubGFzdFpvb20gIT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsb2JhbFRyZWUgPSByYnVzaCg5LCBbJy5taW54JywgJy5taW55JywgJy5tYXh4JywgJy5tYXh5J10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3Rab29tID0gem9vbTtcblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGN0eC5jYW52YXMudHJlZSA9IG51bGw7XG5cbiAgICAgICAgICAgICAgICBpZiAoY3R4LmNhbnZhcy50cmVlID09PSBudWxsIHx8IHRoaXMubGFzdFpvb20gIT0gem9vbSkge1xuICAgICAgICAgICAgICAgICAgICBjdHguY2FudmFzLnRyZWUgPSByYnVzaCg5LCBbJy5taW54JywgJy5taW55JywgJy5tYXh4JywgJy5tYXh5J10pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3Rab29tID0gem9vbTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3KGN0eCk7XG4gICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgICAgIGlmICghdGhpcy50aWxlc1RvTG9hZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRpbGVzVG9Mb2FkID0gdGhpcy5fdGlsZXNUb0xvYWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiBcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9zZXRGaWVsZEdlb206IGZ1bmN0aW9uKCl7XG5cbiAgICAgICAgICAgIHZhciBqc29ucFJhbmRvbSA9IHRoaXMuX21ha2VpZCgpO1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmZvcm1hdF9vcHRpb25zID0gXCJjYWxsYmFjazpcIiArIGpzb25wUmFuZG9tO1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy5zZXJ2ZXJVUkwgKyBcIj9yZXF1ZXN0PURlc2NyaWJlRmVhdHVyZVR5cGUmdmVyc2lvbj0xLjEuMCZ0eXBlbmFtZT1cIiArXG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy50eXBlTmFtZSArICcmb3V0cHV0Rm9ybWF0PXRleHQvamF2YXNjcmlwdCcgKycmZm9ybWF0X29wdGlvbnM9JyArdGhpcy5vcHRpb25zLmZvcm1hdF9vcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwianNvbnBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25wOmZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAganNvbnBDYWxsYmFjazoganNvbnBSYW5kb20sXG4gICAgICAgICAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gcmVzcG9uc2UuZmVhdHVyZVR5cGVzWzBdLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzW2ldLnR5cGUuc3Vic3RyaW5nKDAsMykgPT0gXCJnbWxcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLmZpZWxkR2VvbSA9IGF0dHJpYnV0ZXNbaV0ubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBsb2FkIHRoZSBsYXllciBvbiB0aGUgbWFwXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCBhIHRpbGUgb24gdGhlIG1hcFxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIGxvYWRUaWxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRpbGVkR2VvbWV0cnlsYXllcjo6bG9hZFRpbGUgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmF0ZSBjbGFzc2VzLlwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge1NNQy5NYXB9IG1hcCAtIE1hcCB0byBiZSBhZGRlZFxuICAgICAgICAgKiBAZmlyZXMgU01DLmxheWVycy5nZW9tZXRyeS5UaWxlZEdlb21ldHJ5TGF5ZXIjbGF5ZXJhZGRcbiAgICAgICAgICovXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcbiAgICAgICAgICAgIEwuVGlsZUxheWVyLkNhbnZhcy5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgU01DLmxheWVycy5nZW9tZXRyeS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUub25BZGQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBMYXllciBhZGQgZXZlbnQuXG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAZXZlbnQgU01DLmxheWVycy5nZW9tZXRyeS5UaWxlZEdlb21ldHJ5TGF5ZXIjbGF5ZXJhZGRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBsYXllciAtIExheWVyIHRvIGJlIGFkZGVkLlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFwLmZpcmUoJ2xheWVyYWRkJyx7XG4gICAgICAgICAgICAgICAgbGF5ZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVtb3ZlIHRoZSBjb250cm9sIGluIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMuTWFwfSBtYXAgLSBNYXAgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgU01DLmxheWVycy5nZW9tZXRyeS5DYW52YXNSZW5kZXJlci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIEwuVGlsZUxheWVyLkNhbnZhcy5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgLy9TTUMubGF5ZXJzLlNpbmdsZUxheWVyLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGdldCB0aGUgbWFwXG4gICAgICAgICAqIEByZXR1cm5zIHtTTUMuTWFwfSBtYXAgLSBNYXAgbGF5ZXJcbiAgICAgICAgICovXG4gICAgICAgIGdldE1hcDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbWFwO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblxuICAgICAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuX3RpbGVCb3VuZHMoY3R4KTtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICAgICAgdGhpcy5sb2FkVGlsZShib3VuZHMpLnRoZW4oZnVuY3Rpb24oZmVhdHVyZXNDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coZmVhdHVyZXNDb2xsZWN0aW9uLmZlYXR1cmVzKTtcbiAgICAgICAgICAgICAgICBzZWxmLmFkZFRpbGVkR2VvbWV0cnlGcm9tRmVhdHVyZXMoZmVhdHVyZXNDb2xsZWN0aW9uLmZlYXR1cmVzLCBjdHgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcblxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gYWRkIGEgdGlsZWQgZ2VvbWV0cnkgZnJvbSBhIGZlYXR1cmVzIHNldFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZXMgLSBmZWF0dXJlcyBzZXQgdG8gZ2V0IGl0cyBnZW9tZXRyaWVzXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjdHggLSBmdW5jdGlvbiBjb250ZXh0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBza2lwVHJlZSAtIHZhcmlhYmxlIHRvIHNraXAgdHJlZVxuICAgICAgICAgKi9cbiAgICAgICAgYWRkVGlsZWRHZW9tZXRyeUZyb21GZWF0dXJlczogZnVuY3Rpb24oZmVhdHVyZXMsIGN0eCwgc2tpcFRyZWUpIHtcbiAgICAgICAgICAgIHZhciBmO1xuICAgICAgICAgICAgaWYgKEwuVXRpbC5pc0FycmF5KGZlYXR1cmVzKSkge1xuICAgICAgICAgICAgICAgIGYgPSBmZWF0dXJlcztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBmID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmID0gW2ZlYXR1cmVzXTtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmUgPSBmW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldFByb3BlcnRpZXMoZmVhdHVyZSk7XG5cblxuICAgICAgICAgICAgICAgIGlmKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoID4gMCl7XG4gICAgICAgICAgICAgICAgICAgIC8vV2Ugc3RvcmUgdGhlIHJldHJpZXZlZCBmZWF0dXJlcyBpbiBhIHNlYXJjaCB0cmVlLlxuICAgICAgICAgICAgICAgICAgICBpZiAoIXNraXBUcmVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdHJlZU5vZGUgPSB0aGlzLl9jcmVhdGVUcmVlRGF0YShmZWF0dXJlLCBjdHgudGlsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdHguY2FudmFzLnRyZWUuaW5zZXJ0KHRyZWVOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2xvYmFsVHJlZS5pbnNlcnQodHJlZU5vZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgaWYgKGYubGVuZ3RoICE9PSAwKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLnJlbmRlckNhbnZhcyhjdHgsIGYsIHRoaXMuX21hcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnRpbGVzTG9hZCsrO1xuICAgICAgICAgICAgaWYgKHRoaXMudGlsZXNMb2FkID09IHRoaXMudGlsZXNUb0xvYWQpIHtcbiAgICAgICAgICAgICAgICBTTUMubGF5ZXJzLmdlb21ldHJ5LkNhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldFByb3BlcnRpZXM6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5pZEZpZWxkO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICAgICAgZmVhdHVyZS5pZCA9IGZlYXR1cmVbaWRdO1xuICAgICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZVtwcm9wS2V5XS5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBmZWF0dXJlW3Byb3BLZXldW2lkXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIGlmICh0aGlzLmZlYXR1cmVzLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBzYW1lRmVhdHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5mZWF0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5pZCA9PSB0aGlzLmZlYXR1cmVzW2pdLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmlkID0gdGhpcy5mZWF0dXJlc1tqXS5pZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuc2VsZWN0ZWQgPSB0aGlzLmZlYXR1cmVzW2pdLnNlbGVjdGVkO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzID0gdGhpcy5mZWF0dXJlc1tqXS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2FtZUZlYXR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICghc2FtZUZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mZWF0dXJlcy5wdXNoKGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgIH0sXG5cblxuXG4gICAgICAgIF9jcmVhdGVUcmVlRGF0YTogZnVuY3Rpb24oZmVhdHVyZSwgdGlsZVBvaW50KSB7XG5cbiAgICAgICAgICAgIHZhciBiYm94ID0gdGhpcy5fZmVhdHVyZUJCb3goZmVhdHVyZSk7XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWQ6IGZlYXR1cmUucHJvcGVydGllcy5pZCxcbiAgICAgICAgICAgICAgICBmZWF0dXJlOiBmZWF0dXJlLFxuICAgICAgICAgICAgICAgIG1pbng6IGJib3gubWluLngsXG4gICAgICAgICAgICAgICAgbWF4eDogYmJveC5tYXgueCxcbiAgICAgICAgICAgICAgICBtaW55OiBiYm94Lm1pbi55LFxuICAgICAgICAgICAgICAgIG1heHk6IGJib3gubWF4LnksXG4gICAgICAgICAgICAgICAgdGlsZVBvaW50OiB0aWxlUG9pbnRcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9mZWF0dXJlQkJveDogZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IFtdO1xuXG4gICAgICAgICAgICB2YXIgZ2VvbSA9IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IGZlYXR1cmUuZ2VvbWV0cnkudHlwZTtcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gW2dlb21dO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGdlb21bal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKEwuVXRpbC5pc0FycmF5KGdlb21bMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tID0gZ2VvbVswXTtcblxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnZW9tLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSBwb2ludHMuY29uY2F0KGdlb21bal0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VubWFuYWdlZCB0eXBlOiAnICsgdHlwZSk7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmV0dXJuIEwuYm91bmRzKHBvaW50cyk7XG4gICAgICAgIH0sXG5cblxuXG4gICAgICAgIF90aWxlQm91bmRzOiBmdW5jdGlvbihjdHgpIHtcbiAgICAgICAgICAgIHZhciBud1BvaW50ID0gY3R4LnRpbGUubXVsdGlwbHlCeSh0aGlzLm9wdGlvbnMudGlsZVNpemUpO1xuICAgICAgICAgICAgdmFyIHNlUG9pbnQgPSBud1BvaW50LmFkZChuZXcgTC5Qb2ludCh0aGlzLm9wdGlvbnMudGlsZVNpemUsIHRoaXMub3B0aW9ucy50aWxlU2l6ZSkpO1xuXG4gICAgICAgICAgICAvLyBvcHRpb25hbGx5LCBlbmxhcmdlIHJlcXVlc3QgYXJlYS5cbiAgICAgICAgICAgIC8vIHdpdGggdGhpcyBJIGNhbiBkcmF3IHBvaW50cyB3aXRoIGNvb3JkcyBvdXRzaWRlIHRoaXMgdGlsZSBhcmVhLFxuICAgICAgICAgICAgLy8gYnV0IHdpdGggcGFydCBvZiB0aGUgZ3JhcGhpY3MgYWN0dWFsbHkgaW5zaWRlIHRoaXMgdGlsZS5cbiAgICAgICAgICAgIC8vIE5PVEU6IHRoYXQgeW91IHNob3VsZCB1c2UgdGhpcyBvcHRpb24gb25seSBpZiB5b3UncmUgYWN0dWFsbHkgZHJhd2luZyBwb2ludHMhXG4gICAgICAgICAgICB2YXIgYnVmID0gdGhpcy5vcHRpb25zLmJ1ZmZlcjtcbiAgICAgICAgICAgIGlmIChidWYgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpZmYgPSBuZXcgTC5Qb2ludChidWYsIGJ1Zik7XG4gICAgICAgICAgICAgICAgbndQb2ludCA9IG53UG9pbnQuc3VidHJhY3QoZGlmZik7XG4gICAgICAgICAgICAgICAgc2VQb2ludCA9IHNlUG9pbnQuYWRkKGRpZmYpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbndDb29yZCA9IHRoaXMuX21hcC51bnByb2plY3QobndQb2ludCwgY3R4Lnpvb20sIHRydWUpO1xuICAgICAgICAgICAgdmFyIHNlQ29vcmQgPSB0aGlzLl9tYXAudW5wcm9qZWN0KHNlUG9pbnQsIGN0eC56b29tLCB0cnVlKTtcbiAgICAgICAgICAgIHJldHVybiBbbndDb29yZC5sbmcsIHNlQ29vcmQubGF0LCBzZUNvb3JkLmxuZywgbndDb29yZC5sYXRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gdXBkYXRlIHRoZSBzdHlsZSBvZiBhIGZlYXR1cmVcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBmZWF0dXJlIHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIHVwZGF0ZUZlYXR1cmU6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcblxuICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCB0aGlzLmZlYXR1cmVzLmxlbmd0aDsgaysrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZlYXR1cmUuaWQgPT0gdGhpcy5mZWF0dXJlc1trXS5pZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zZWxlY3RlZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzW2tdLnNlbGVjdGVkID0gZmVhdHVyZS5zZWxlY3RlZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZlYXR1cmVzW2tdLnByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGJib3ggPSB0aGlzLl9mZWF0dXJlQkJveChmZWF0dXJlKTtcblxuICAgICAgICAgICAgdmFyIGludGVyc2VjdGluZ0ZlYXR1cmVOb2RlcyA9IHRoaXMuZ2xvYmFsVHJlZS5zZWFyY2goW2Jib3gubWluLngsIGJib3gubWluLnksIGJib3gubWF4LngsIGJib3gubWF4LnldKTtcblxuXG4gICAgICAgICAgICAvLyB3ZSBkZXRlcm1pbmUgdGhlIHRpbGVzIHRvIGJlIHJlZHJhd24gZnJvbSB0aGUgZmVhdHVyZXMuXG4gICAgICAgICAgICB2YXIgcmVhZGRlZFRpbGVLZXlzID0gW107XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50ZXJzZWN0aW5nRmVhdHVyZU5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZlYXR1cmVUaWxlUG9pbnQgPSBpbnRlcnNlY3RpbmdGZWF0dXJlTm9kZXNbaV0udGlsZVBvaW50O1xuXG5cbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gZmVhdHVyZVRpbGVQb2ludC54ICsgXCI6XCIgKyBmZWF0dXJlVGlsZVBvaW50Lnk7XG5cbiAgICAgICAgICAgICAgICBpZiAocmVhZGRlZFRpbGVLZXlzLmluZGV4T2Yoa2V5KSA8IDApIHtcblxuICAgICAgICAgICAgICAgICAgICByZWFkZGVkVGlsZUtleXMucHVzaChrZXkpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGlsZSA9IHRoaXMuX3RpbGVzW2tleV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9tYXApIHsgLy8gSWYgd2UgcmVtb3ZlZCB0aGUgbGF5ZXIgd2UgZG9uJ3Qgd2FudCB1cGRhdGVzLlxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjdHggPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzOiB0aWxlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbGU6IGZlYXR1cmVUaWxlUG9pbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgem9vbTogdGhpcy5fbWFwLmdldFpvb20oKSAvLyBmaXggZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9DbG91ZE1hZGUvTGVhZmxldC9wdWxsLzk5M1xuICAgICAgICAgICAgICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdGlsZUZlYXR1cmVzID0gY3R4LmNhbnZhcy50cmVlLnNlYXJjaCh0aGlzLl90aWxlQm91bmRzKGN0eCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdXBkYXRlZEZlYXR1cmVzID0gW107XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGlsZUZlYXR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4aXN0aW5nRmVhdHVyZSA9IHRpbGVGZWF0dXJlc1tqXS5mZWF0dXJlO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdGZWF0dXJlLmlkID09IGZlYXR1cmUuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2UgdXBkYXRlIHRoZSBkYXRhISEhIVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRmVhdHVyZS5wcm9wZXJ0aWVzID0gZmVhdHVyZS5wcm9wZXJ0aWVzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS5zZWxlY3RlZCAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nRmVhdHVyZS5zZWxlY3RlZCA9IGZlYXR1cmUuc2VsZWN0ZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdGZWF0dXJlLl9jbGVhbiA9IGZhbHNlO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cblxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlZEZlYXR1cmVzLnB1c2goZXhpc3RpbmdGZWF0dXJlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyQ2FudmFzKGN0eCwgdXBkYXRlZEZlYXR1cmVzLCB0aGlzLl9tYXApO1xuXG5cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGNyZWF0ZSBhIHJlcXVlc3QgdG8gZ2V0IGZlYXR1cmVzXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBib3VuZHMgLSBib3VuZCBsaW1pdCB0byByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjdHggLSBmdW5jdGlvbiBjb250ZXh0XG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVSZXF1ZXN0OiBmdW5jdGlvbihib3VuZHMsIGN0eCkge1xuICAgICAgICAgICAgLy8gb3ZlcnJpZGUgd2l0aCB5b3VyIGNvZGVcbiAgICAgICAgfVxuXG4gICAgfSwgW1NNQy5sYXllcnMuU2luZ2xlTGF5ZXIsIFNNQy5sYXllcnMuZ2VvbWV0cnkuQ2FudmFzUmVuZGVyZXJdKTsiLCJyZXF1aXJlKFwiLi9HZW9tZXRyeUxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL3Byb3ZpZGVycy9XRlNQcm92aWRlci5qc1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXllcnMgdXNpbmcgYSBXRlMgcHJvdmlkZXIgdG8gZ2V0IHRoZSBmZWF0dXJlc1xuICpcbiAqIEBjbGFzc1xuICogQGFic3RyYWN0XG4gKiBAZXh0ZW5kcyBTTUMubGF5ZXJzLmdlb21ldHJ5Lkdlb21ldHJ5TGF5ZXJcbiAqIEBtaXhlcyBTTUMucHJvdmlkZXJzLldGU1Byb3ZpZGVyXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLmdlb21ldHJ5LldGU0dlb21ldHJ5TGF5ZXIgPSBTTUMubGF5ZXJzLmdlb21ldHJ5Lkdlb21ldHJ5TGF5ZXIuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmxheWVycy5nZW9tZXRyeS5XRlNHZW9tZXRyeUxheWVyIyAqL1xuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgU01DLmxheWVycy5nZW9tZXRyeS5HZW9tZXRyeUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMucHJvdmlkZXJzLldGU1Byb3ZpZGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KDEwMDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgZmVhdHVyZXMgb24gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZmVhdHVyZXMgLSBGZWF0dXJlcyB0byBiZSBsb2FkZWRcbiAgICAgICAgICovXG4gICAgICAgIG9uRmVhdHVyZXNMb2FkZWQ6IGZ1bmN0aW9uKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLmFkZEdlb21ldHJ5RnJvbUZlYXR1cmVzKGZlYXR1cmVzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGZlYXR1cmVzXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMubG9hZEZlYXR1cmVzKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYW4gSFRNTCBub2RlIGZvciB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgY29kZSByZXByZXNlbnRpbmcgdGhlIGNvZGUgdG8gYmUgYWRkZWQgdG8gdGhlIGxheWVyJ3MgZW50cnkgaW4gdGhlIGxheWVyIHRyZWUuXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVOb2RlSFRNTDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zLmxhYmVsIHx8IHRoaXMub3B0aW9ucy50eXBlTmFtZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICB9LCBbU01DLnByb3ZpZGVycy5XRlNQcm92aWRlcl0pO1xuXG4vKipcbiAqIEFQSSBmYWN0b3J5IG1ldGhvZCBmb3IgZWFzeSBjcmVhdGlvbiBvZiB3ZnMgZ2VvbWV0cnkgbGF5ZXIuXG4gKiBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIGluaXRpYWxpemUgdGhlIFdGUyBcbiAqL1xuU01DLndmc0dlb21ldHJ5TGF5ZXIgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBTTUMubGF5ZXJzLmdlb21ldHJ5LldGU0dlb21ldHJ5TGF5ZXIob3B0aW9ucyk7XG59OyIsInJlcXVpcmUoXCIuL1RpbGVkR2VvbWV0cnlMYXllci5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi9wcm92aWRlcnMvV0ZTUHJvdmlkZXIuanNcIik7XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxheWVycyB1c2luZyBhIFdGUyBwcm92aWRlciB0byBnZXQgdGhlIGZlYXR1cmVzXG4gKlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMuZ2VvbWV0cnkuVGlsZWRHZW9tZXRyeUxheWVyXG4gKiBAbWl4ZXMgU01DLnByb3ZpZGVycy5XRlNQcm92aWRlclxuICogQHBhcmFtIHtTTUMubGF5ZXJzLmdlb21ldHJ5LlRpbGVkR2VvbWV0cnlMYXllcn5vcHRpb25zfSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjbGFzc1xuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5nZW9tZXRyeS5XRlNUaWxlZEdlb21ldHJ5TGF5ZXIgPSBTTUMubGF5ZXJzLmdlb21ldHJ5LlRpbGVkR2VvbWV0cnlMYXllci5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLmdlb21ldHJ5LldGU1RpbGVkR2VvbWV0cnlMYXllciMgKi9cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvYmplY3Qgd2l0aCBuZWVkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuZ2VvbWV0cnkuVGlsZWRHZW9tZXRyeUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMucHJvdmlkZXJzLldGU1Byb3ZpZGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2V0WkluZGV4KDEwMDApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCBhIHRpbGUgb24gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gYmJveCAtIGJvdW5kaW5nIGJveCBvZiB0aGUgdGlsZSB0byBsb2FkXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkVGlsZTogZnVuY3Rpb24oYmJveCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kb0ZlYXR1cmVzTG9hZGluZyhiYm94KTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGNyZWF0ZSBhbiBIVE1MIG5vZGUgZm9yIHRoZSBuYW1lIG9mIHRoZSBsYXllci5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gSFRNTCBjb2RlIHJlcHJlc2VudGluZyB0aGUgY29kZSB0byBiZSBhZGRlZCB0byB0aGUgbGF5ZXIncyBlbnRyeSBpbiB0aGUgbGF5ZXIgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZU5vZGVIVE1MOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWwgfHwgdGhpcy5vcHRpb25zLnR5cGVOYW1lO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0sIFtTTUMucHJvdmlkZXJzLldGU1Byb3ZpZGVyXSk7XG5cbi8qKlxuICogQVBJIGZhY3RvcnkgbWV0aG9kIGZvciBlYXN5IGNyZWF0aW9uIG9mIHdmcyB0aWxlZCBnZW9tZXRyeSBsYXllci5cbiAqIEBwYXJhbXMge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgV0ZTIHRpbGVkIFxuICovXG5TTUMud2ZzVGlsZWRHZW9tZXRyeUxheWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLmxheWVycy5nZW9tZXRyeS5XRlNUaWxlZEdlb21ldHJ5TGF5ZXIob3B0aW9ucyk7XG59OyIsInJlcXVpcmUoXCIuLi9sYXllcnMuanNcIik7XG4vKipcbiAqIE5hbWVzcGFjZSBvZiBTTUMuVmlld2VyJ3MgbGF5ZXJzIGRpc3BsYXllZCB1c2luZyBjbGllbnQgc2lkZSBnZW9tZXRyeSByZW5kZXJpbmcgLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFNNQy5sYXllcnNcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5nZW9tZXRyeSA9IHt9OyIsInJlcXVpcmUoXCIuL2hpc3RvcnkuanNcIik7XG5yZXF1aXJlKFwiLi9EYXRhSGlzdG9yeUxheWVyLmpzXCIpO1xuLyoqXG4gKiBDbGFzcyBmb3JtZWQgYnkgdGhlIGFnZ3JlZ2F0aW9uIG9mIHNldmVyYWwgaGlzdG9yeSBsYXllcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTTUMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllclxuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5oaXN0b3J5LkFnZ3JlZ2F0aW5nSGlzdG9yeUxheWVyID0gU01DLmxheWVycy5hZ2dyZWdhdGlvbi5BZ2dyZWdhdGluZ0xheWVyLmV4dGVuZChcblx0LyoqIEBsZW5kcyBTTUMubGF5ZXJzLmhpc3RvcnkuQWdncmVnYXRpbmdIaXN0b3J5TGF5ZXIjICovXG5cdHtcblxuXHRcdG9wdGlvbnM6e1xuXHRcdFx0dGltZTogMTAwMFxuXHRcdH0sXG5cblx0XHQgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvYmplY3Qgd2l0aCBuZWVkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0U01DLmxheWVycy5hZ2dyZWdhdGlvbi5BZ2dyZWdhdGluZ0xheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRTTUMubGF5ZXJzLmhpc3RvcnkuRGF0YUhpc3RvcnlMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogQWRkcyBhIHN1YmxheWVyIHRvIHRoZSBsYXllci5cblx0XHQgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJJZCAtIExheWVyIElkZW50aWZpZXJcblx0XHQgKiBAcGFyYW0ge1NNQy5sYXllcnN9IGxheWVyIC0gTGF5ZXIgb2JqZWN0XG5cdFx0ICogQGFic3RyYWN0XG5cdFx0ICovXG5cdFx0YWRkVGltZURhdGE6IGZ1bmN0aW9uKHRpbWUsIGRhdGEpe1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5pbXBsZW1lbnRlZCBtZXRob2QhXCIpO1xuXHRcdFx0XG5cdFx0fSxcblxuXHRcdC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgbGF5ZXIgb24gdGhlIG1hcFxuICAgICAgICAgKi9cblx0XHRsb2FkOiBmdW5jdGlvbigpe1xuXHRcdFx0XG5cdFx0fSxcblxuXHRcdCAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge1NNQy5NYXB9IG1hcCAtIE1hcCB0byBiZSBhZGRlZFxuICAgICAgICAgKi9cblx0XHRvbkFkZDogZnVuY3Rpb24obWFwKSB7XHRcblx0XHRcdFNNQy5sYXllcnMuaGlzdG9yeS5EYXRhSGlzdG9yeUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLmFnZ3JlZ2F0aW9uLkFnZ3JlZ2F0aW5nTGF5ZXIucHJvdG90eXBlLm9uQWRkLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gXHRcdC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVtb3ZlIHRoZSBjb250cm9sIGluIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMuTWFwfSBtYXAgLSBNYXAgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCl7XG4gICAgICAgIFx0U01DLmxheWVycy5oaXN0b3J5LkRhdGFIaXN0b3J5TGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgXHRTTUMubGF5ZXJzLmFnZ3JlZ2F0aW9uLkFnZ3JlZ2F0aW5nTGF5ZXIucHJvdG90eXBlLm9uUmVtb3ZlLmNhbGwodGhpcywgbWFwKTtcbiAgICAgICAgfVxuXG5cdH0sIFtTTUMubGF5ZXJzLmhpc3RvcnkuRGF0YUhpc3RvcnlMYXllcl0pOyIsInJlcXVpcmUoXCIuL0FnZ3JlZ2F0aW5nSGlzdG9yeUxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uL2xheWVycy5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi9MYXllckxvYWRlci5qc1wiKTtcblxuLyoqXG4gKiBDbGFzcyBmb3JtZWQgYnkgdGhlIGFnZ3JlZ2F0aW9uIG9mIHNldmVyYWwgaGlzdG9yeSBsYXllcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTTUMubGF5ZXJzLlNpbmdsZUxheWVyXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLmhpc3RvcnkuRGF0YUhpc3RvcnlMYXllciA9IFNNQy5sYXllcnMuU2luZ2xlTGF5ZXIuZXh0ZW5kKFxuXHQvKiogQGxlbmRzIFNNQy5sYXllcnMuaGlzdG9yeS5EYXRhSGlzdG9yeUxheWVyIyAqL1xuXHR7XG5cdFx0X2hpc3RvcnlMYXllcnM6IHt9LFxuXHRcdF90aW1lcjogbnVsbCxcblx0XHRfbm9kZTogbnVsbCxcblxuXHRcdCAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIG9iamVjdCB3aXRoIG5lZWQgcGFyYW1ldGVyc1xuICAgICAgICAgKi9cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcblx0XHRcdEwuTGF5ZXJHcm91cC5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXHRcdFx0Ly9TTUMubGF5ZXJzLlNpbmdsZUxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIG9wdGlvbnMpO1xuXG5cblx0XHR9LFxuXG5cdFx0LyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYW4gSFRNTCBub2RlIGZvciB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIuXG4gICAgICAgICAqIEByZXR1cm5zIHtTdHJpbmd9IEhUTUwgY29kZSByZXByZXNlbnRpbmcgdGhlIGNvZGUgdG8gYmUgYWRkZWQgdG8gdGhlIGxheWVyJ3MgZW50cnkgaW4gdGhlIGxheWVyIHRyZWUuXG4gICAgICAgICAqL1xuXHRcdGNyZWF0ZU5vZGVIVE1MOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2hpc3RvcnlMYXllcnMgPSB0aGlzLl9vcmRlckxheWVycygpO1xuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMuX2hpc3RvcnlMYXllcnM7XG5cblx0XHRcdCB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgICAgICAgICB2YXIgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyksXG4gICAgICAgICAgICAgICAgaW5wdXQsXG4gICAgICAgICAgICAgICAgY2hlY2tlZCA9IHRoaXMuZ2V0TWFwKCkuaGFzTGF5ZXIodGhpcyk7XG5cbiAgICAgICAgICAgIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgIGlucHV0LnR5cGUgPSAnY2hlY2tib3gnO1xuICAgICAgICAgICAgaW5wdXQuZGVmYXVsdENoZWNrZWQgPSBjaGVja2VkO1xuICAgICAgICAgICAgaW5wdXQuc3R5bGUuY3Vyc29yID0gXCJwb2ludGVyXCI7XG4gICAgICAgICAgICB2YXIgbmFtZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIG5hbWUuaW5uZXJIVE1MID0gJyAnICsgKHRoaXMub3B0aW9ucy5sYWJlbCB8fCB0aGlzLm9wdGlvbnMudHlwZU5hbWUpO1xuXG4gICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChpbnB1dCk7XG4gICAgICAgICAgICBsYWJlbC5hcHBlbmRDaGlsZChuYW1lKTtcblxuXG4gICAgICAgICAgICB2YXIgc2xpZGVyQ29udHJvbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ0YWJsZVwiKTtcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2wuc3R5bGUubWFyZ2luTGVmdCA9ICcxMHB4JztcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2wuc3R5bGUubWFyZ2luVG9wID0gJzVweCc7XG4gICAgICAgICAgICBzbGlkZXJDb250cm9sLmNsYXNzTmFtZSA9ICdsZWFmbGV0LWJhciBsZWFmbGV0LXVwZGF0ZS1pbnRlcnZhbCAnO1xuICAgICAgICAgICAgc2xpZGVyQ29udHJvbC5zdHlsZS5mb250ID0gJzEycHgvMS41IFwiSGVsdmV0aWNhIE5ldWVcIiwgQXJpYWwsIEhlbHZldGljYSwgc2Fucy1zZXJpZic7XG5cbiAgICAgICAgICAgIHZhciBzbGlkZXJDb250cm9sTGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICAgIHNsaWRlckNvbnRyb2xMYWJlbC5zdHlsZS5mbG9hdCA9ICdsZWZ0JztcbiAgICAgICAgICAgIFxuXG4gICAgICAgICAgICB2YXIgaW5wdXRJbnRlcnZhbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lucHV0Jyk7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLnR5cGUgPSAncmFuZ2UnO1xuICAgICAgICAgICAgaW5wdXRJbnRlcnZhbC5pZCA9IFwiaW50ZXJ2YWxfXCIgKyB0aGlzLl9sZWFmbGV0X2lkO1xuICAgICAgICAgICAgaW5wdXRJbnRlcnZhbC5uYW1lID0gXCJpbnRlcnZhbF9cIiArIHRoaXMuX2xlYWZsZXRfaWQ7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLm1pbiA9IDA7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLm1heCA9IE9iamVjdC5rZXlzKGxheWVycykubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgIGlucHV0SW50ZXJ2YWwuc3RlcCA9IDE7XG4gICAgICAgICAgICBpbnB1dEludGVydmFsLnZhbHVlID0gMDtcbiAgICAgICAgICAgIC8vc2xpZGVyQ29udHJvbC5pbm5lckhUTUwgKz0gJzxpbnB1dCBpZD1cImludGVydmFsXycgKyB0aGlzLl9sZWFmbGV0X2lkICsgJ1wiIG5hbWU9XCJpbnRlcnZhbF8nICsgdGhpcy5fbGVhZmxldF9pZCArICdcIiBtaW49XCIwXCIgbWF4PVwiJyArIChPYmplY3Qua2V5cyh0aGlzLl9mZWF0dXJlc0ZvckxheWVyKS5sZW5ndGggLSAxKSArICdcIiB0eXBlPVwicmFuZ2VcIiBzdGVwPVwiMVwiIHZhbHVlPVwiMFwiLz4nO1xuICAgICAgICAgICBcblxuICAgICAgICAgICAgdmFyIHRpbWUgPSBpbnB1dEludGVydmFsLnZhbHVlO1xuXG4gICAgICAgICAgICB2YXIgcGxheV9wYXVzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpOyBcbiAgICAgICAgICAgIHBsYXlfcGF1c2UuY2xhc3NOYW1lID0gJ2ZhIGZhLXBsYXknO1xuICAgICAgICAgICAgcGxheV9wYXVzZS5zdHlsZS5jdXJzb3IgPSBcInBvaW50ZXJcIjtcblxuICAgICAgICAgICAgdGhpcy5fYWRkVGltZURhdGEodGltZSk7XG4gICAgICAgICAgICB0aGlzLl9zaG93TGFiZWwoc2xpZGVyQ29udHJvbExhYmVsKTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dEludGVydmFsLCAnbW91c2Vkb3duJywgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb24pO1xuICAgICAgICAgICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dEludGVydmFsLCAnY2hhbmdlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGltZSA9IGlucHV0SW50ZXJ2YWwudmFsdWU7XG4gICAgICAgICAgICAgICAgc2VsZi5zaG93VGltZURhdGEodGltZSk7XG4gICAgICAgICAgICAgICAgc2VsZi5fc2hvd0xhYmVsKHNsaWRlckNvbnRyb2xMYWJlbCk7XG4gICAgICAgICAgICAgICAgTC5Eb21FdmVudC5zdG9wUHJvcGFnYXRpb247XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXRJbnRlcnZhbCwgJ3RvdWNoc3RhcnQnLCBMLkRvbUV2ZW50LnN0b3BQcm9wYWdhdGlvbik7XG4gICAgICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGlucHV0SW50ZXJ2YWwsICd0b3VjaGVuZCcsIEwuRG9tRXZlbnQuc3RvcFByb3BhZ2F0aW9uKTtcblxuICAgICAgICAgICAgdmFyIHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgICAgIHZhciB0ZDEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZCcpO1xuICAgICAgICAgICAgdmFyIHRkMiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RkJyk7XG4gICAgICAgICAgICB2YXIgdGQzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGQnKTtcbiAgICAgICAgICAgIHRkMS5hcHBlbmRDaGlsZChzbGlkZXJDb250cm9sTGFiZWwpO1xuICAgICAgICAgICAgdGQyLmFwcGVuZENoaWxkKHBsYXlfcGF1c2UpO1xuICAgICAgICAgICAgdGQzLmFwcGVuZENoaWxkKGlucHV0SW50ZXJ2YWwpO1xuICAgICAgICAgICAgdHIuYXBwZW5kQ2hpbGQodGQxKTtcbiAgICAgICAgICAgIHRyLmFwcGVuZENoaWxkKHRkMik7XG4gICAgICAgICAgICB0ci5hcHBlbmRDaGlsZCh0ZDMpO1xuXG4gICAgICAgICAgICBzbGlkZXJDb250cm9sLmFwcGVuZENoaWxkKHRyKTtcbiAgICAgICAgICAgXG4gICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGxhYmVsKTtcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoc2xpZGVyQ29udHJvbCk7XG5cbiAgICAgICAgICAgIHBsYXlfcGF1c2Uub25jbGljayA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuX29uUGxheVBhdXNlKG5vZGUsIHRpbWUpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxhYmVsLm9uY2hhbmdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9jbGlja09uTGF5ZXIobm9kZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5fbm9kZSA9IG5vZGU7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcblx0XHR9LFxuXG5cdFx0X29yZGVyTGF5ZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBsYXllcnM7XG5cdFx0XHR2YXIgZXhpc3RzID0gdHJ1ZTtcblx0XHRcdGZvciAodmFyIGQgaW4gdGhpcy5fYWdncmVnYXRpbmdMYXllcnMpIHtcblx0XHRcdFx0dmFyIGRhdGUgPSB0aGlzLl9hZ2dyZWdhdGluZ0xheWVyc1tkXS5vcHRpb25zLmRhdGU7XG5cdFx0XHRcdGlmICghZGF0ZSkge1xuXHRcdFx0XHRcdGV4aXN0cyA9IGZhbHNlO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZXhpc3RzKSB7XG5cdFx0XHRcdGxheWVycyA9IHRoaXMuX2FnZ3JlZ2F0aW5nTGF5ZXJzO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHZhciBsYXllcnNPYmogPSB7fTtcblx0XHRcdFx0dmFyIGxheWVyc0FycmF5ID0gW107XG5cdFx0XHRcdGZvciAodmFyIGwgaW4gdGhpcy5fYWdncmVnYXRpbmdMYXllcnMpIHtcblx0XHRcdFx0XHRsYXllcnNBcnJheS5wdXNoKHRoaXMuX2FnZ3JlZ2F0aW5nTGF5ZXJzW2xdKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxheWVyc0FycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0XHRcdHJldHVybiAoYS5vcHRpb25zLmRhdGUgLSBiLm9wdGlvbnMuZGF0ZSlcblx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnNBcnJheS5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGlmICghbGF5ZXJzT2JqW2xheWVyc0FycmF5W2ldLm9wdGlvbnMuZGF0ZV0pIHtcblx0XHRcdFx0XHRcdGxheWVyc09ialtsYXllcnNBcnJheVtpXS5vcHRpb25zLmRhdGVdID0gbGF5ZXJzQXJyYXlbaV07XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGxheWVyc09ialtsYXllcnNBcnJheVtpXS5vcHRpb25zLmxhYmVsXSA9IGxheWVyc0FycmF5W2ldO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRsYXllcnMgPSBsYXllcnNPYmo7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbGF5ZXJzO1xuXG5cdFx0fSxcblxuXG5cdFx0IC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgY29udHJvbCBpbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIGFkZGVkXG4gICAgICAgICAqL1xuXHRcdGFkZFRvOiBmdW5jdGlvbihtYXApIHtcblx0XHRcdFNNQy5sYXllcnMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllci5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xuXHRcdH0sXG5cblx0XHQvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGdldCB0aGUgbWFwXG4gICAgICAgICAqIEByZXR1cm5zIHtTTUMuTWFwfSBtYXAgLSBNYXAgbGF5ZXJcbiAgICAgICAgICovXG5cdFx0Z2V0TWFwOiBmdW5jdGlvbigpIHtcblx0XHRcdFNNQy5sYXllcnMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllci5wcm90b3R5cGUuZ2V0TWFwLmNhbGwodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBtYXA7XG5cdFx0fSxcblxuXHRcdC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gc2hvdyB0aGUgY29ycmVjdCBoaXN0b3J5IGxheWVyXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0aW1lIC0gVmFsdWUgb2YgdGhlIHNsaWRlciBjb250cm9sXG4gICAgICAgICAqL1xuXHRcdHNob3dUaW1lRGF0YTogZnVuY3Rpb24odGltZSkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLl9oaXN0b3J5TGF5ZXJzO1xuXHRcdFx0aWYgKHRpbWUgJSAxICE9PSAwKSB7XG5cdFx0XHRcdHRpbWUgPSB0aW1lIC0gKHRpbWUgJSAxKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGQgaW4gZGF0YSkge1xuXHRcdFx0XHQvLyBpZiAoaSA9PSB0aW1lICYmIGRhdGFbZF0uYWN0dWFsKSB7XG5cdFx0XHRcdC8vIFx0YnJlYWs7XG5cdFx0XHRcdC8vIH1cblx0XHRcdFx0ZGF0YVtkXS5fc2xpZGVybW92ZSA9IHRydWU7XG5cdFx0XHRcdGlmIChkYXRhW2RdLmFjdHVhbCkge1xuXHRcdFx0XHRcdHZhciBpZCA9IEwuc3RhbXAoZGF0YVtkXSk7XG5cdFx0XHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpO1xuXHRcdFx0XHRcdGlmKGlucHV0KVxuXHRcdFx0XHRcdFx0aW5wdXQuY2hlY2tlZCA9IGZhbHNlO1xuXHRcdFx0XHRcdHRoaXMuZ2V0TWFwKCkucmVtb3ZlTGF5ZXIoZGF0YVtkXSk7XG5cdFx0XHRcdFx0ZGF0YVtkXS5hY3R1YWwgPSBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGkgPT0gdGltZSkge1xuXHRcdFx0XHRcdGlmICghZGF0YVtkXS5hY3R1YWwpIHtcblx0XHRcdFx0XHRcdFxuXHRcdFx0XHRcdFx0ZGF0YVtkXS5hY3R1YWwgPSB0cnVlO1xuXHRcdFx0XHRcdFx0aWYoZGF0YVtkXS5sYXN0Wm9vbSAmJiAoZGF0YVtkXS5sYXN0Wm9vbSAhPSB0aGlzLmdldE1hcCgpLmdldFpvb20oKSkpe1xuXHRcdFx0XHRcdFx0XHQgZm9yKHZhciBmIGluIGRhdGFbZF0uZmVhdHVyZXMpe1xuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtkXS5mZWF0dXJlc1tmXS5fY2xlYW4gPSBmYWxzZTtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgICAgIH1cblxuXHRcdFx0XHRcdFx0ZGF0YVtkXS5hZGRUbyh0aGlzLmdldE1hcCgpKTtcblx0XHRcdFx0XHRcdGRhdGFbZF0ubGFzdFpvb20gPSB0aGlzLmdldE1hcCgpLmdldFpvb20oKTtcblx0XHRcdFx0XHRcdC8vcmVjYWxjdWxhdGUgY2FudmFzIHBvc2l0aW9uIGZvciBnZW9tZXRyeSBsYXllcnMgKGltcG9ydGFudClcblx0XHRcdFx0XHRcdGlmKGRhdGFbZF0gaW5zdGFuY2VvZiBTTUMubGF5ZXJzLmdlb21ldHJ5Lkdlb21ldHJ5TGF5ZXIpe1xuXHRcdFx0XHRcdFx0XHRkYXRhW2RdLl9yZXNpemVDYW52YXMoKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpKys7XG5cblx0XHRcdH1cblx0XHRcdFxuXG5cdFx0fSxcblxuXHRcdF9hZGRUaW1lRGF0YTogZnVuY3Rpb24odGltZSkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLl9oaXN0b3J5TGF5ZXJzO1xuXHRcdFx0Zm9yICh2YXIgZCBpbiBkYXRhKSB7XG5cblx0XHRcdFx0aWYgKGkgPT0gdGltZSkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0TWFwKCkuYWRkTGF5ZXIoZGF0YVtkXSk7XG5cdFx0XHRcdFx0dGhpcy5faGlzdG9yeUxheWVyc1tkXS5hY3R1YWwgPSB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGkrKztcblxuXHRcdFx0fVxuXG5cdFx0fSxcblxuXHRcdF9zaG93TGFiZWw6IGZ1bmN0aW9uKHNsaWRlckNvbnRyb2xMYWJlbCkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLl9oaXN0b3J5TGF5ZXJzO1xuXHRcdFx0Zm9yICh2YXIgZCBpbiBkYXRhKSB7XG5cdFx0XHRcdGlmIChkYXRhW2RdLmFjdHVhbCkge1xuXHRcdFx0XHRcdHNsaWRlckNvbnRyb2xMYWJlbC5pbm5lckhUTUwgPSBkYXRhW2RdLm9wdGlvbnMubGFiZWwgfHwgZGF0YVtkXS5vcHRpb25zLnR5cGVOYW1lO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGlja09uTGF5ZXI6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwYXVzZSA9IG5vZGUuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnZmEgZmEtcGF1c2UnKVswXTtcblx0XHRcdGlmIChwYXVzZSkge1xuXHRcdFx0XHR0aGlzLl9vblBsYXlQYXVzZShub2RlKTtcblx0XHRcdH1cblx0XHRcdHZhciBkYXRhID0gdGhpcy5faGlzdG9yeUxheWVycztcblx0XHRcdGlmIChub2RlLmNoaWxkcmVuWzFdLnN0eWxlLmRpc3BsYXkgIT0gJ25vbmUnKSB7XG5cdFx0XHRcdG5vZGUuY2hpbGRyZW5bMV0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcblx0XHRcdFx0bm9kZS5jaGlsZHJlblswXS5jaGVja2VkID0gZmFsc2U7XG5cdFx0XHRcdGZvciAodmFyIGQgaW4gZGF0YSkge1xuXHRcdFx0XHRcdGlmIChkYXRhW2RdLmFjdHVhbCkge1xuXG5cdFx0XHRcdFx0XHRkYXRhW2RdLm9uUmVtb3ZlKHRoaXMuZ2V0TWFwKCkpO1xuXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLmNoaWxkcmVuWzFdLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXHRcdFx0XHRub2RlLmNoaWxkcmVuWzBdLmNoZWNrZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKHZhciBkIGluIGRhdGEpIHtcblx0XHRcdFx0XHRpZiAoZGF0YVtkXS5hY3R1YWwpIHtcblx0XHRcdFx0XHRcdGRhdGFbZF0ub25BZGQodGhpcy5nZXRNYXAoKSk7XG5cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0sXG5cblx0XHRfb25QbGF5UGF1c2U6IGZ1bmN0aW9uKG5vZGUsIHRpbWUpIHtcblx0XHRcdHZhciBkYXRhID0gdGhpcy5faGlzdG9yeUxheWVycztcblxuICAgICAgICAgICB2YXIgc2xpZGVyID0gbm9kZS5jaGlsZHJlblsxXS5jaGlsZHJlblswXS5jaGlsZHJlblsyXS5jaGlsZHJlblswXTtcbiAgICAgICAgICAgdmFyIG1heFZhbHVlID0gc2xpZGVyLm1heDtcbiAgICAgICAgICAgdmFyIHNsaWRlckNvbnRyb2xMYWJlbCA9IG5vZGUuY2hpbGRyZW5bMV0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF0uY2hpbGRyZW5bMF07XG4gICAgICAgICAgIHZhciBwbGF5ID0gbm9kZS5jaGlsZHJlblsxXS5jaGlsZHJlblswXS5jaGlsZHJlblsxXS5jaGlsZHJlblswXTtcblxuICAgICAgICAgICAgaWYgKHBsYXkuY2xhc3NOYW1lID09ICdmYSBmYS1wbGF5Jykge1xuICAgICAgICAgICAgICAgIHBsYXkuY2xhc3NOYW1lID0gJ2ZhIGZhLXBhdXNlJztcbiAgICAgICAgICAgICAgICBpZiAoc2xpZGVyLnZhbHVlID09IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgc2xpZGVyLnZhbHVlID0gMDtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHZhciBpID0gcGFyc2VGbG9hdChzbGlkZXIudmFsdWUpO1xuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICB0aGlzLl90aW1lciA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zaG93VGltZURhdGEoaSk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3Nob3dMYWJlbChzbGlkZXJDb250cm9sTGFiZWwpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA8IG1heFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzbGlkZXIudmFsdWUgPSBpO1xuXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHNlbGYuX3RpbWVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYXkuY2xhc3NOYW1lID0gJ2ZhIGZhLXBsYXknO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2xpZGVyLnZhbHVlID0gbWF4VmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpICs9IHBhcnNlRmxvYXQoc2xpZGVyLnN0ZXApO1xuXG4gICAgICAgICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnRpbWUpO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgcGxheS5jbGFzc05hbWUgPSAnZmEgZmEtcGxheSc7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl90aW1lcik7XG4gICAgICAgICAgICB9XG5cdFx0fSxcblxuXHRcdCAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHJlbW92ZSB0aGUgY29udHJvbCBpbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIHJlbW92ZWRcbiAgICAgICAgICovXG5cdFx0b25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuXHRcdFx0dmFyIGRhdGEgPSB0aGlzLl9oaXN0b3J5TGF5ZXJzO1xuXHRcdFx0Zm9yICh2YXIgZCBpbiBkYXRhKSB7XG5cdFx0XHRcdGlmIChkYXRhW2RdLmFjdHVhbCkge1xuXHRcdFx0XHRcdGRhdGFbZF0uX3NsaWRlcm1vdmUgPSBmYWxzZTtcblx0XHRcdFx0XHRkYXRhW2RdLm9uUmVtb3ZlKG1hcCk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9LFxuXG4gXHRcdC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgY29udHJvbCBpbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIGFkZGVkXG4gICAgICAgICAqL1xuXHRcdG9uQWRkOiBmdW5jdGlvbihtYXApIHtcblx0XHRcdFNNQy5sYXllcnMuYWdncmVnYXRpb24uQWdncmVnYXRpbmdMYXllci5wcm90b3R5cGUuYWRkVG8uY2FsbCh0aGlzLCBtYXApO1xuXHRcdFx0dmFyIHZhbHVlO1xuXHRcdFx0aWYgKHRoaXMuX25vZGUgIT0gbnVsbCkge1xuXHRcdFx0XHR2YWx1ZSA9IHRoaXMuX25vZGUuY2hpbGRyZW5bMV0uY2hpbGRyZW5bMF0udmFsdWU7XG5cdFx0XHR9IGVsc2Vcblx0XHRcdFx0dmFsdWUgPSAwO1xuXG5cdFx0XHR2YXIgZGF0YSA9IHRoaXMuX2hpc3RvcnlMYXllcnM7XG5cdFx0XHRmb3IgKHZhciBkIGluIGRhdGEpIHtcblx0XHRcdFx0aWYgKGRhdGFbZF0uYWN0dWFsKSB7XG5cdFx0XHRcdFx0ZGF0YVtkXS5fc2xpZGVybW92ZSA9IGZhbHNlO1xuXHRcdFx0XHRcdGRhdGFbZF0ub25BZGQobWFwKTtcblxuXG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFxuXG5cdFx0fVxuXG5cblxuXHR9KTsiLCIvKipcbiAqIE5hbWVzcGFjZSBmb3IgYWdyZWdnYXRpbmcgbGF5ZXJzLCBlLmcuLCBsYXllcnMgdGhhdCBhcmUgdGhlIHJlc3VsdCBvZiB0aGUgY29tcG9zaXRpb25cbiAqIG9mIHNldmVyYWwgb3RoZXIgbGF5ZXJzLlxuICpcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBTTUMubGF5ZXJzXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMuaGlzdG9yeSA9IHt9OyIsInJlcXVpcmUoXCIuLi9TTUMuanNcIik7XG5yZXF1aXJlKFwiLi4vTWFwLmpzXCIpO1xuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIGxheWVycyB1c2luZyBTTUMncyB2aWV3ZXIgaW5mcmFzY3RydWN0dXJlLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFNNQ1xuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzID0ge307IiwicmVxdWlyZShcIi4vbWFya2Vycy5qc1wiKTtcbnJlcXVpcmUoXCIuL01hcmtlckxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL3Byb3ZpZGVycy9BdG1vc3BoZXJlUlRGZWF0dXJlUHJvdmlkZXIuanNcIik7XG5cblxuLyoqXG4gKiBNYXJrZXIgbGF5ZXIgYWJsZSB0byByZXRyaWV2ZSBhbmQgdXBkYXRlIGl0cyBtYXJrZXJzIGZyb20gYW4gQXRtb3NwaGVyZVxuICogcmVhbCB0aW1lIHNvdXJjZS5cbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgU01DLmxheWVycy5tYXJrZXJzLk1hcmtlckxheWVyXG4gKiBAbWl4ZXMgU01DLnByb3ZpZGVycy5BdG1vc3BoZXJlUlRGZWF0dXJlUHJvdmlkZXJcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChtYXJjb3NAZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMubWFya2Vycy5BdG1vc3BoZXJlUlRNYXJrZXJMYXllciA9IFNNQy5sYXllcnMubWFya2Vycy5NYXJrZXJMYXllci5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLm1hcmtlcnMuQXRtb3NwaGVyZVJUTWFya2VyTGF5ZXIjICovXG4gICAge1xuXG4gICAgICAgIF9tYXJrZXJzTWFwOiB7fSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgY2xhc3Mgd2l0aCBvcHRpb25zIHBhcmFtZXRlclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgU01DLmxheWVycy5tYXJrZXJzLk1hcmtlckxheWVyLnByb3RvdHlwZS5pbml0aWFsaXplLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBTTUMucHJvdmlkZXJzLkF0bW9zcGhlcmVSVEZlYXR1cmVQcm92aWRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgZmVhdHVyZXMgaW50byBtYXJrZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmVzIC0gZmVhdHVyZXMgdG8gYmUgbG9hZGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkZlYXR1cmVzTG9hZGVkOiBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXJrZXJGcm9tRmVhdHVyZShmZWF0dXJlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZW1vdmUgdGhlIGZlYXR1cmVzIGZyb20gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZXMgLSBmZWF0dXJlcyB0byBiZSBkZWxldGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkZlYXR1cmVzRGVsZXRlZDogZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlSWQgPSBmZWF0dXJlW3RoaXMub3B0aW9ucy5mZWF0dXJlSWRdO1xuICAgICAgICAgICAgICAgIHZhciBsYXllciA9IHRoaXMuX21hcmtlcnNNYXBbZmVhdHVyZUlkXTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxheWVyKGxheWVyKTtcblxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYXJrZXJzTWFwW2ZlYXR1cmVJZF07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBzZXQgdGhlIGZlYXR1cmVzIGZyb20gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZXMgLSBmZWF0dXJlcyB0byBiZSB1cGRhdGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkZlYXR1cmVzTW9kaWZpZWQ6IGZ1bmN0aW9uKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICB0aGlzLm9uRmVhdHVyZXNEZWxldGVkKGZlYXR1cmVzKTtcbiAgICAgICAgICAgIHRoaXMub25GZWF0dXJlc0xvYWRlZChmZWF0dXJlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZmVhdHVyZXMgZnJvbSBpdHMgc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRGZWF0dXJlcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgZmVhdHVyZXMgZnJvbSB0aGUgbWFwXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IERlZmVycmVkIG9iamVjdCBmcm9tIGpRdWVyeVxuICAgICAgICAgKi9cbiAgICAgICAgZG9GZWF0dXJlc0xvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuICQuRGVmZXJyZWQoKTtcbiAgICAgICAgfSxcblxuXG4gICAgfSwgW1NNQy5wcm92aWRlcnMuQXRtb3NwaGVyZVJURmVhdHVyZVByb3ZpZGVyXSk7XG4vKipcbiAqIEFQSSBmYWN0b3J5IG1ldGhvZCBmb3IgZWFzZSBjcmVhdGlvbiBvZiBhdG1vc3BoZXJlIHBvd2VyZWQgcmVhbHRpbWUgbWFya2VyIGxheWVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIG1hcmtlciBsYXllciBhbmQgQXRtb3NwaGVyZSBwcm92aWRlci5cbiAqL1xuU01DLmF0bW9zcGhlcmVSVE1hcmtlckxheWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLmxheWVycy5tYXJrZXJzLkF0bW9zcGhlcmVSVE1hcmtlckxheWVyKG9wdGlvbnMpO1xufTtcbiIsInJlcXVpcmUoXCIuL21hcmtlcnMuanNcIik7XG5yZXF1aXJlKFwiLi4vU2luZ2xlTGF5ZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vc3R5bGVycy9NYXJrZXJDc3NTdHlsZXIuanNcIik7XG5cbnJlcXVpcmUoXCIuLi8uLi8uLi9saWIvbGVhZmxldC5tYXJrZXJjbHVzdGVyL2Rpc3QvbGVhZmxldC5tYXJrZXJjbHVzdGVyLXNyYy5qc1wiKTtcbnJlcXVpcmUoXCIuLi8uLi8uLi9saWIvTGVhZmxldEh0bWxJY29uLmpzXCIpO1xuXG5cbi8qKlxuICogQmFzZSBsYXllciBmb3IgYWxsIFNNQyBtYXAgdmlld2VyJ3MgbGF5ZXJzIHJlbmRlcmVkIHVzaW5nIG1hcmtlcnMuXG4gKiBAY2xhc3NcbiAqIEBhYnN0cmFjdFxuICogQG1peGVzIFNNQy5sYXllcnMuU2luZ2xlTGF5ZXJcbiAqIEBtaXhlcyBTTUMubGF5ZXJzLnN0eWxlcnMuTWFya2VyQ3NzU3R5bGVyXG4gKi9cblNNQy5sYXllcnMubWFya2Vycy5NYXJrZXJMYXllciA9IEwuRmVhdHVyZUdyb3VwLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMubWFya2Vycy5NYXJrZXJMYXllciMgKi9cbiAgICB7XG5cbiAgICAgICAgX21hcmtlcnNNYXA6IHt9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBjbGFzcyB3aXRoIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLmNsdXN0ZXJHcm91cCA9IG5ldyBMLk1hcmtlckNsdXN0ZXJHcm91cCh7XG4gICAgICAgICAgICAgICAgcG9seWdvbk9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIHN0cm9rZTogZmFsc2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdGhpcy5ub0NsdXN0ZXJHcm91cCA9IG5ldyBMLkZlYXR1cmVHcm91cCgpO1xuICAgICAgICAgICAgU01DLmxheWVycy5zdHlsZXJzLk1hcmtlckNzc1N0eWxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgU01DLmxheWVycy5TaW5nbGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVtb3ZlIGEgbGF5ZXIgZnJvbSB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLkxheWVycy5MYXllcn0gbGF5ZXIgLSBsYXllciB0byBiZSByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVMYXllcjogZnVuY3Rpb24obGF5ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsdXN0ZXJHcm91cC5oYXNMYXllcihsYXllcikpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsdXN0ZXJHcm91cC5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMubm9DbHVzdGVyR3JvdXAuaGFzTGF5ZXIobGF5ZXIpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub0NsdXN0ZXJHcm91cC5yZW1vdmVMYXllcihsYXllcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0TWFwKCkucmVtb3ZlTGF5ZXIobGF5ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBsb2FkIHRoZSBjb250cm9sIGluIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMuTWFwfSBtYXAgLSBNYXAgdG8gYmUgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgIG9uQWRkOiBmdW5jdGlvbihtYXApIHtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYW5NYXJrZXJzKG1hcCk7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLlNpbmdsZUxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICBMLkZlYXR1cmVHcm91cC5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICBcbiAgICAgICAgICAgIG1hcC5hZGRMYXllcih0aGlzLm5vQ2x1c3Rlckdyb3VwKTtcbiAgICAgICAgICAgIG1hcC5hZGRMYXllcih0aGlzLmNsdXN0ZXJHcm91cCk7XG5cbiAgICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAub24oXCJ6b29tZW5kXCIsIHRoaXMuX29uVmlld0NoYW5nZWQsIHRoaXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVtb3ZlIHRoZSBjb250cm9sIGluIHRoZSBtYXBcbiAgICAgICAgICogQHBhcmFtIHtTTUMuTWFwfSBtYXAgLSBNYXAgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25SZW1vdmU6IGZ1bmN0aW9uKG1hcCkge1xuICAgICAgICAgICAgdGhpcy5fY2xlYW5NYXJrZXJzKG1hcCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NsZWFuTWFya2VyczogZnVuY3Rpb24gKG1hcCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NsaWRlcm1vdmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5vQ2x1c3Rlckdyb3VwLl9zbGlkZXJtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsdXN0ZXJHcm91cC5fc2xpZGVybW92ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICAgICAgICAgIHZhciBjbHVzdGVyR3JvdXAgPSB0aGlzLmNsdXN0ZXJHcm91cC5nZXRMYXllcnMoKTtcbiAgICAgICAgICAgICQuZWFjaChjbHVzdGVyR3JvdXAsIGZ1bmN0aW9uKGluZGV4LCBtYXJrZXIpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIucGFyZW50ID0gc2VsZjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5jbHVzdGVyR3JvdXAuY2xlYXJMYXllcnMoKTtcbiAgICAgICAgICAgIG1hcC5yZW1vdmVMYXllcih0aGlzLmNsdXN0ZXJHcm91cCk7XG5cblxuICAgICAgICAgICAgdmFyIG5vQ2x1c3Rlckdyb3VwID0gdGhpcy5ub0NsdXN0ZXJHcm91cC5nZXRMYXllcnMoKTtcbiAgICAgICAgICAgICQuZWFjaChub0NsdXN0ZXJHcm91cCwgZnVuY3Rpb24oaW5kZXgsIG1hcmtlcikge1xuICAgICAgICAgICAgICAgIG1hcmtlci5wYXJlbnQgPSBzZWxmO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLm5vQ2x1c3Rlckdyb3VwLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICBtYXAucmVtb3ZlTGF5ZXIodGhpcy5ub0NsdXN0ZXJHcm91cCk7XG5cbiAgICAgICAgICAgIEwuRmVhdHVyZUdyb3VwLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgICAgICAgICAgIGlmIChtYXApIHtcbiAgICAgICAgICAgICAgICBtYXAub2ZmKFwiem9vbWVuZFwiLCB0aGlzLl9vblZpZXdDaGFuZ2VkLCB0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGFkZCBsYXllciBvbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLmxheWVycy5MYXllcn0gbGF5ZXIgLSBsYXllciB0byBiZSBhZGRlZFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG5cbiAgICAgICAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIEwuTWFya2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1hcmtlciA9IGxheWVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX2FwcGx5U3R5bGVzKG1hcmtlcik7XG5cbiAgICAgICAgICAgICAgICBtYXJrZXIub24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkZlYXR1cmVDbGlja2VkKG1hcmtlcik7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbWFya2VyO1xuXG4gICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGlzIGlzIG5vdCBhIG1hcmtlclwiKTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9zZW5kRmVhdHVyZXM6IGZ1bmN0aW9uKGZlYXR1cmVzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAkLmVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uKGluZGV4LCBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fYWRkTWFya2VyKGZlYXR1cmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBsb2FkIG1hcmtlcnMgZnJvbSBmZXRhdXJlcyBvbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmZWF0dXJlcyAtIGZlYXR1cmVzIHRvIGJlIGFkZGVkXG4gICAgICAgICAqL1xuICAgICAgICBhZGRNYXJrZXJGcm9tRmVhdHVyZTogZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIGlmIChMLlV0aWwuaXNBcnJheShmZWF0dXJlcykpIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IGZlYXR1cmVzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGZlYXR1cmVzID0gYXJndW1lbnRzO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcyA9IFtmZWF0dXJlc107XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0UHJvcGVydGllcyhmZWF0dXJlc1tpXSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NlbmRGZWF0dXJlcyhmZWF0dXJlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3NldFByb3BlcnRpZXM6IGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRoaXMub3B0aW9ucy5pZEZpZWxkO1xuICAgICAgICAgICAgaWYgKGZlYXR1cmUuaGFzT3duUHJvcGVydHkoaWQpKVxuICAgICAgICAgICAgICAgIGZlYXR1cmUuaWQgPSBmZWF0dXJlW2lkXTtcbiAgICAgICAgICAgIGVsc2Uge1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBmZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWF0dXJlW3Byb3BLZXldLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVhdHVyZS5pZCA9IGZlYXR1cmVbcHJvcEtleV1baWRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FkZE1hcmtlcjogZnVuY3Rpb24oZikge1xuXG4gICAgICAgICAgICBpZiAoIWYuZ2VvbWV0cnkgfHwgIWYuZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKFwiUmVjZWl2ZWQgbm8gRmVhdHVyZSBvYmplY3RcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBGb3IgR2VvSlNPTiBzdGFuZGFyIHRoZSBmaXJzdCBjb29yZGluYXRlIGlzIHRoZSBsb25naXR1ZGVcbiAgICAgICAgICAgIC8vIERvY3VtZW50YXRpb24gaHR0cDovL2dlb2pzb24ub3JnL2dlb2pzb24tc3BlYy5odG1sI3Bvc2l0aW9uc1xuICAgICAgICAgICAgdmFyIG1hcmtlckxvY2F0aW9uO1xuXG4gICAgICAgICAgICB2YXIgZ2VvbWV0cnkgPSBmLmdlb21ldHJ5O1xuICAgICAgICAgICAgdmFyIGNvb3JkaW5hdGVzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgICAgICBpZihnZW9tZXRyeS50eXBlPT09XCJNdWx0aVBvaW50XCIpIHtcbiAgICAgICAgICAgICAgICBjb29yZGluYXRlcyA9IGNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoTC5VdGlsLmlzQXJyYXkoY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyTG9jYXRpb24gPSBuZXcgTC5MYXRMbmcoY29vcmRpbmF0ZXNbMV0sIGNvb3JkaW5hdGVzWzBdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWFya2VyTG9jYXRpb24gPSBuZXcgTC5MYXRMbmcoY29vcmRpbmF0ZXMubGF0aXR1ZGUsIGNvb3JkaW5hdGVzLmxvbmdpdHVkZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBtYXJrZXIgPSBuZXcgTC5NYXJrZXIobWFya2VyTG9jYXRpb24pO1xuICAgICAgICAgICAgLy8gV2Ugc3RvcmUgdGhpcyBoZXJlIHNvIGlzIGF2YWxhaWJsZSBsYXRlciwgb24gcmVzdHlsaW5ncyBiZWNhdXNlIG9mIHpvb20gY2hhbmdlcy5cbiAgICAgICAgICAgIG1hcmtlci5mZWF0dXJlID0gZjtcblxuICAgICAgICAgICAgdmFyIGZlYXR1cmVJZCA9IGZbdGhpcy5vcHRpb25zLmlkRmllbGRdO1xuICAgICAgICAgICAgdGhpcy5fbWFya2Vyc01hcFtmZWF0dXJlSWRdID0gbWFya2VyO1xuXG4gICAgICAgICAgICB0aGlzLmFkZExheWVyKG1hcmtlcik7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBydW4gd2plbiBhIGZlYXR1cmUgaGFzIGJlZW4gY2xpY2tlZFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZSAtIGZlYXR1cmUgY2xpY2tlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25GZWF0dXJlQ2xpY2tlZDogZnVuY3Rpb24oZmVhdHVyZSkge1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoXCJmZWF0dXJlQ2xpY2tcIiwgZmVhdHVyZSk7XG4gICAgICAgICAgICAvL2FsZXJ0KGZlYXR1cmUucHJvcGVydGllcy5uYW1lKTtcbiAgICAgICAgfSxcblxuICAgICAgICBfYXBwbHlTdHlsZXM6IGZ1bmN0aW9uKG1hcmtlciwgaW5DbHVzdGVyKSB7XG4gICAgICAgICAgICBpZiAoIW1hcmtlci5mZWF0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub0NsdXN0ZXJHcm91cC5hZGRMYXllcihtYXJrZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHpvb207XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICB6b29tID0gdGhpcy5nZXRNYXAoKS5nZXRab29tKCk7ICBcbiAgICAgICAgICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuYXBwbHlTdHlsZShtYXJrZXIuZmVhdHVyZSwgem9vbSk7XG4gICAgICAgICAgICBpZiAoc3R5bGUuaWNvbikge1xuICAgICAgICAgICAgICAgIG1hcmtlci5zZXRJY29uKHN0eWxlLmljb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0eWxlLm9wYWNpdHkpIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0T3BhY2l0eShzdHlsZS5vcGFjaXR5KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGluQ2x1c3Rlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuY2x1c3Rlckdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubm9DbHVzdGVyR3JvdXAucmVtb3ZlTGF5ZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgIGlmIChzdHlsZS5kaXNhYmxlQ2x1c3RlcmluZykge1xuICAgICAgICAgICAgICAgIHRoaXMubm9DbHVzdGVyR3JvdXAuYWRkTGF5ZXIobWFya2VyKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbHVzdGVyR3JvdXAuYWRkTGF5ZXIobWFya2VyKTtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLmFkZFBvcFVwKG1hcmtlciwgem9vbSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uVmlld0NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIG1hcmtlcnNDbHVzdGVyID0gdGhpcy5jbHVzdGVyR3JvdXAuZ2V0TGF5ZXJzKCk7XG4gICAgICAgICAgICB2YXIgbWFya2Vyc05vQ2x1c3RlciA9IHRoaXMubm9DbHVzdGVyR3JvdXAuZ2V0TGF5ZXJzKCk7XG5cbiAgICAgICAgICAgIC8vIFJlY29ycmVyIGNsdXN0ZXJcbiAgICAgICAgICAgIHZhciBpLCBtYXJrZXI7XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbWFya2Vyc0NsdXN0ZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIgPSBtYXJrZXJzQ2x1c3RlcltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NsaWRlcm1vdmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hcmtlci5fc2xpZGVybW92ZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYXBwbHlTdHlsZXMobWFya2VyLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBtYXJrZXJzTm9DbHVzdGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyID0gbWFya2Vyc05vQ2x1c3RlcltpXTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5ub0NsdXN0ZXJHcm91cCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fc2xpZGVybW92ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFya2VyLl9zbGlkZXJtb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hcHBseVN0eWxlcyhtYXJrZXIsIGZhbHNlKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHVubG9hZCB0aGUgbGF5ZXIgb24gdGhlIG1hcFxuICAgICAgICAgKi9cbiAgICAgICAgdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5vQ2x1c3Rlckdyb3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5ub0NsdXN0ZXJHcm91cC5jbGVhckxheWVycygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAodGhpcy5jbHVzdGVyR3JvdXApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsdXN0ZXJHcm91cC5jbGVhckxheWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cblxuXG4gICAgfSwgW1NNQy5sYXllcnMuU2luZ2xlTGF5ZXIsIFNNQy5sYXllcnMuc3R5bGVycy5NYXJrZXJDc3NTdHlsZXJdKTtcbiIsInJlcXVpcmUoXCIuL01hcmtlckxheWVyLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL3Byb3ZpZGVycy9XRlNQcm92aWRlci5qc1wiKTtcbnJlcXVpcmUoXCIuLi9FZGl0YWJsZUxheWVyLmpzXCIpO1xuXG4vKipcbiAqIExheWVyIGZvciBhbGwgU01DIG1hcCB2aWV3ZXIncyBXRlMgbGF5ZXJzIHJlbmRlcmVkIHVzaW5nIG1hcmtlcnMuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMubWFya2Vycy5NYXJrZXJMYXllclxuICogQG1peGVzIFNNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXJcbiAqXG4gKiBAYXV0aG9yIE1vaXPDqXMgQXJjb3MgKG1hcmNvc0BlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5tYXJrZXJzLldGU01hcmtlckxheWVyID0gU01DLmxheWVycy5tYXJrZXJzLk1hcmtlckxheWVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMubWFya2Vycy5XRlNNYXJrZXJMYXllciMgKi9cbiAgICB7XG5cbiAgICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gb2JqZWN0IHdpdGggbmVlZCBwYXJhbWV0ZXJzXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBTTUMubGF5ZXJzLm1hcmtlcnMuTWFya2VyTGF5ZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGxvYWQgdGhlIGZlYXR1cmVzIGludG8gbWFya2VyIGxheWVyXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBmZWF0dXJlcyAtIEZlYXR1cmVzIHRvIGJlIGxvYWRlZFxuICAgICAgICAgKi9cbiAgICAgICAgb25GZWF0dXJlc0xvYWRlZDogZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkTWFya2VyRnJvbUZlYXR1cmUoZmVhdHVyZXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXRyaWV2ZXMgdGhlIGZlYXR1cmVzIGZyb20gaXRzIHNvdXJjZS5cbiAgICAgICAgICovXG4gICAgICAgIGxvYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5sb2FkRmVhdHVyZXMoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGNyZWF0ZSBhbiBIVE1MIG5vZGUgZm9yIHRoZSBuYW1lIG9mIHRoZSBsYXllci5cbiAgICAgICAgICogQHJldHVybnMge1N0cmluZ30gSFRNTCBjb2RlIHJlcHJlc2VudGluZyB0aGUgY29kZSB0byBiZSBhZGRlZCB0byB0aGUgbGF5ZXIncyBlbnRyeSBpbiB0aGUgbGF5ZXIgdHJlZS5cbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZU5vZGVIVE1MOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubGFiZWwgfHwgdGhpcy5vcHRpb25zLnR5cGVOYW1lO1xuICAgICAgICB9XG5cbiAgICB9LCBbU01DLnByb3ZpZGVycy5XRlNQcm92aWRlcl0pO1xuLyoqXG4gKiBBUEkgZmFjdG9yeSBtZXRob2QgZm9yIGVhc2UgY3JlYXRpb24gb2Ygd2ZzIGZlYXR1cmVzIHByb3ZpZGVycy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyBmb3Igd2ZzIHRoZSBwcm92aWRlci5cbiAqL1xuU01DLndmc01hcmtlckxheWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLmxheWVycy5tYXJrZXJzLldGU01hcmtlckxheWVyKG9wdGlvbnMpO1xufTtcbiIsInJlcXVpcmUoXCIuL01hcmtlckxheWVyXCIpO1xucmVxdWlyZShcIi4uLy4uL3Byb3ZpZGVycy9XRlNUUHJvdmlkZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vRWRpdGFibGVMYXllclwiKTtcbnJlcXVpcmUoXCIuLi8uLi8uLi9saWIvbGVhZmxldC5kcmF3L2Rpc3QvbGVhZmxldC5kcmF3LXNyYy5qc1wiKTtcbnZhciBlZGl0YWJsZV9sYXllcnMgPSBbXTtcblxuLyoqXG4gKiBMYXllciBmb3IgYWxsIFNNQyBtYXAgdmlld2VyJ3MgV0ZTLVQgbGF5ZXJzIHJlbmRlcmVkIHVzaW5nIG1hcmtlcnMuXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMubWFya2Vycy5NYXJrZXJMYXllclxuICogQG1peGVzIFNNQy5wcm92aWRlcnMuV0ZTVFByb3ZpZGVyXG4gKiBAbWl4ZXMgU01DLmxheWVycy5FZGl0YWJsZUxheWVyXG4gKlxuICogQGF1dGhvciBNb2lzw6lzIEFyY29zIChtYXJjb3NAZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMubWFya2Vycy5XRlNUTWFya2VyTGF5ZXIgPSBTTUMubGF5ZXJzLm1hcmtlcnMuTWFya2VyTGF5ZXIuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmxheWVycy5tYXJrZXJzLldGU1RNYXJrZXJMYXllciMgKi9cbiAgICB7XG4gICAgICAgIGZlYXR1cmVzRWRpdGVkOiBuZXcgTC5MYXllckdyb3VwKCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBvYmplY3Qgd2l0aCBuZWVkIHBhcmFtZXRlcnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5sYXllcnMubWFya2Vycy5NYXJrZXJMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgU01DLnByb3ZpZGVycy5XRlNUUHJvdmlkZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuRWRpdGFibGVMYXllci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgZmVhdHVyZXMgaW50byBtYXJrZXIgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVzIC0gRmVhdHVyZXMgdG8gYmUgbG9hZGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkZlYXR1cmVzTG9hZGVkOiBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICAgICAgdGhpcy5hZGRNYXJrZXJGcm9tRmVhdHVyZShmZWF0dXJlcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZmVhdHVyZXMgZnJvbSBpdHMgc291cmNlLlxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGlzLmxvYWRGZWF0dXJlcygpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gbG9hZCB0aGUgY29udHJvbCBpbiB0aGUgbWFwXG4gICAgICAgICAqIEBwYXJhbSB7U01DLk1hcH0gbWFwIC0gTWFwIHRvIGJlIGFkZGVkXG4gICAgICAgICAqL1xuICAgICAgICBvbkFkZDogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICBlZGl0YWJsZV9sYXllcnMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuRWRpdGFibGVMYXllci5wcm90b3R5cGUub25BZGQuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgU01DLmxheWVycy5tYXJrZXJzLk1hcmtlckxheWVyLnByb3RvdHlwZS5vbkFkZC5jYWxsKHRoaXMsIG1hcCk7XG4gICAgICAgICAgICB0aGlzLl9zZXRCdXR0b25TdGF0ZSh0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byByZW1vdmUgdGhlIGNvbnRyb2wgaW4gdGhlIG1hcFxuICAgICAgICAgKiBAcGFyYW0ge1NNQy5NYXB9IG1hcCAtIE1hcCB0byBiZSByZW1vdmVkXG4gICAgICAgICAqL1xuICAgICAgICBvblJlbW92ZTogZnVuY3Rpb24obWFwKSB7XG4gICAgICAgICAgICB0aGlzLl9lZGl0aW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9maW5pc2hFZGl0Q29udHJvbCh0aGlzLm9wdGlvbnMpO1xuXG4gICAgICAgICAgICB2YXIgaW5kZXggPSB0aGlzLl9nZXRJbmRleEZyb21FZGl0YWJsZUxheWVyKHRoaXMpO1xuICAgICAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICBlZGl0YWJsZV9sYXllcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFNNQy5sYXllcnMuRWRpdGFibGVMYXllci5wcm90b3R5cGUub25SZW1vdmUuY2FsbCh0aGlzLCBtYXApO1xuICAgICAgICAgICAgU01DLmxheWVycy5tYXJrZXJzLk1hcmtlckxheWVyLnByb3RvdHlwZS5vblJlbW92ZS5jYWxsKHRoaXMsIG1hcCk7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0QnV0dG9uU3RhdGU6IGZ1bmN0aW9uKGxheWVyKXtcbiAgICAgICAgICAgIHZhciBlZGl0aW5nO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGl0YWJsZV9sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZihlZGl0YWJsZV9sYXllcnNbaV0uX2VkaXRpbmcpe1xuICAgICAgICAgICAgICAgICAgIGVkaXRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBsYWJlbCA9IGxheWVyLm9wdGlvbnMubGFiZWw7XG4gICAgICAgICAgICB2YXIgbGF5ZXJfZGl2ID0gJChcIltpZD0nXCIgKyBsYWJlbCArIFwiJ11cIilbMF07XG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9ICQoXCJpbnB1dFt0eXBlPWJ1dHRvbl1cIiwgbGF5ZXJfZGl2KTtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBidXR0b25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgaWYoZWRpdGluZyl7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbnNbal0uZGlzYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICBidXR0b25zW2pdLmRpc2FibGVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgfSxcblxuICAgICAgICBfc2V0QnV0dG9uVGV4dDogZnVuY3Rpb24oKXtcbiAgICAgICAgICAgIHZhciBsYWJlbCA9IHRoaXMub3B0aW9ucy5sYWJlbDtcbiAgICAgICAgICAgIHZhciBsYXllcl9kaXYgPSAkKFwiW2lkPSdcIiArIGxhYmVsICsgXCInXVwiKVswXTtcbiAgICAgICAgICAgIHZhciBidXR0b25zID0gJChcImlucHV0W3R5cGU9YnV0dG9uXVwiLCBsYXllcl9kaXYpO1xuICAgICAgICAgICAgYnV0dG9uc1swXS5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lZGl0aW5nID8gdGhpcy5vcHRpb25zLmNvbmZpcm1CdXR0b25MYWJlbCA6IHRoaXMub3B0aW9ucy5lZGl0QnV0dG9uTGFiZWwpO1xuICAgICAgICB9LFxuXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBhZGQgZWRpdCBjb250cm9sIHRvIG1hcFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEV2ZW50IHRvIGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIF9zdGFydEVkaXRDb250cm9sOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbWFwICYmICF0aGlzLl9kcmF3Q29udHJvbCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdGFibGVfbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0YWJsZV9sYXllcnNbaV0uX2xlYWZsZXRfaWQgIT0gdGhpcy5fbGVhZmxldF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZWRpdGFibGVfbGF5ZXJzW2ldLm9wdGlvbnMubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXJfZGl2ID0gJChcIltpZD0nXCIgKyBsYWJlbCArIFwiJ11cIilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9ucyA9ICQoXCJpbnB1dFt0eXBlPWJ1dHRvbl1cIiwgbGF5ZXJfZGl2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9ICQoXCJpbnB1dFt0eXBlPWNoZWNrYm94XVtpZD1cIiArIGVkaXRhYmxlX2xheWVyc1tpXS5fbGVhZmxldF9pZCArIFwiXVwiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBidXR0b25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLmNoZWNrZWQgJiYgIWJ1dHRvbnNbal0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uc1tqXS5kaXNhYmxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXNlIHRoZSBkcmF3IGNvbnRyb2wgYW5kIHBhc3MgaXQgdGhlIEZlYXR1cmVHcm91cCBvZiBlZGl0YWJsZSBsYXllcnNcbiAgICAgICAgICAgICAgICB0aGlzLl9kcmF3Q29udHJvbCA9IG5ldyBMLkNvbnRyb2wuRHJhdyh7XG4gICAgICAgICAgICAgICAgICAgIGRyYXc6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlsaW5lOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvbHlnb246IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVjdGFuZ2xlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmNsZTogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc29jaHJvbmU6IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGVkaXQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVHcm91cDogdGhpcy5ub0NsdXN0ZXJHcm91cFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLmFkZENvbnRyb2wodGhpcy5fZHJhd0NvbnRyb2wpO1xuICAgICAgICAgICAgICAgIC8vIE1hcmtlciBjcmVhdGVkXG4gICAgICAgICAgICAgICAgdGhpcy5fbWFwLm9uKCdkcmF3OmNyZWF0ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXllciA9IGUubGF5ZXI7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYucmVtb3ZlTGF5ZXIoZS5sYXllcik7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgYWRkZWQgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5faW5zZXJ0KGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgXG5cblxuXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTWFya2VyIGVkaXRlZFxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5vbignZHJhdzplZGl0ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXllcnMgPSBlLmxheWVycztcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlZGl0ZWQgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEkLmlzRW1wdHlPYmplY3QobGF5ZXJzLl9sYXllcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl91cGRhdGUobGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgLy9NYXJrZXIgYXR0cmlidXRlcyBlZGl0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAub24oJ2VkaXRBdHRyaWJ1dGVzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXIgPSBlLmxheWVyO1xuICAgICAgICAgICAgICAgICAgICBsYXllci5jbG9zZVBvcHVwKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vT3BlbiBhdHRyaWJ1dGVzIGVkaXRpb24gcG9wdXBcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBzZWxmLl9zZXRBdHRyRWRpdG9yKGxheWVyKTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuYmluZFBvcHVwKGNvbnRlbnQpLm9wZW5Qb3B1cCgpO1xuXG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIC8vU2F2ZSBtYXJrZXIgYXR0cmlidXRlcyBlZGl0ZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAub24oJ2RyYXc6ZWRpdGVkRGF0YScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVycyA9IHNlbGYuZmVhdHVyZXNFZGl0ZWQ7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlZGl0ZWQgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJzLnNhdmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoISQuaXNFbXB0eU9iamVjdChsYXllcnMuX2xheWVycykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZShsYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy9VcGRhdGUgcHJvcGVydGllcyBvZiBjaGFuZ2VkIGxheWVyc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpIGluIGxheWVycy5fbGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcnMuX2xheWVyc1tpXS5wcm9wZXJ0aWVzSW5pY2lhbCA9IGxheWVycy5fbGF5ZXJzW2ldLmZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5vbignZHJhdzplZGl0RGF0YXN0b3AnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVycyA9IHNlbGYuZmVhdHVyZXNFZGl0ZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmICghJC5pc0VtcHR5T2JqZWN0KGxheWVycy5fbGF5ZXJzKSl7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWxheWVycy5zYXZlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBsYXllcnMuX2xheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZiA9IGxheWVycy5fbGF5ZXJzW2ldLmZlYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9wSW5pID0gbGF5ZXJzLl9sYXllcnNbaV0ucHJvcGVydGllc0luaWNpYWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9wSW5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqIGluIGYucHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGYucHJvcGVydGllc1tqXSA9IHByb3BJbmlbal07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllcnMuc2F2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBsYXllcnMuX2xheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVycy5fbGF5ZXJzW2ldLmNsb3NlUG9wdXAoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9hcHBseVN0eWxlcyhsYXllcnMuX2xheWVyc1tpXSwgZmFsc2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gTWFya2VyIHJlbW92ZWRcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAub24oJ2RyYXc6ZGVsZXRlZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVycyA9IGUubGF5ZXJzO1xuICAgICAgICAgICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGRlbGV0ZWQgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5fZGVsZXRlKGxheWVycyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBhZGQgZWRpdCBjb250cm9sIHRvIG1hcFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIEV2ZW50IHRvIGhhbmRsZXJcbiAgICAgICAgICovXG4gICAgICAgIF9maW5pc2hFZGl0Q29udHJvbDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2RyYXdDb250cm9sKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlZGl0YWJsZV9sYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdGFibGVfbGF5ZXJzW2ldLmZlYXR1cmVzRWRpdGVkLmNsZWFyTGF5ZXJzKCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGl0YWJsZV9sYXllcnNbaV0uX2xlYWZsZXRfaWQgIT0gdGhpcy5fbGVhZmxldF9pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gZWRpdGFibGVfbGF5ZXJzW2ldLm9wdGlvbnMubGFiZWw7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgbGF5ZXJfZGl2ID0gJChcIltpZD0nXCIgKyBsYWJlbCArIFwiJ11cIilbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYnV0dG9ucyA9ICQoXCJpbnB1dFt0eXBlPWJ1dHRvbl1cIiwgbGF5ZXJfZGl2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjaGVjayA9ICQoXCJpbnB1dFt0eXBlPWNoZWNrYm94XVtpZD1cIiArIGVkaXRhYmxlX2xheWVyc1tpXS5fbGVhZmxldF9pZCArIFwiXVwiKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBidXR0b25zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoZWNrLmNoZWNrZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJ1dHRvbnNbal0uZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnNbal0uZGlzYWJsZWQgPSBmYWxzZTsgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxhYmVsID0gdGhpcy5vcHRpb25zLmxhYmVsO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGxheWVyX2RpdiA9ICQoXCJbaWQ9J1wiICsgbGFiZWwgKyBcIiddXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbnMgPSAkKFwiaW5wdXRbdHlwZT1idXR0b25dXCIsIGxheWVyX2Rpdik7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgYnV0dG9ucy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ1dHRvbnNbal0uc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgdGhpcy5vcHRpb25zLmVkaXRCdXR0b25MYWJlbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9tYXAucmVtb3ZlQ29udHJvbCh0aGlzLl9kcmF3Q29udHJvbCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fZHJhd0NvbnRyb2wgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ2RyYXc6Y3JlYXRlZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21hcC5vZmYoJ2RyYXc6ZGVsZXRlZCcpO1xuICAgICAgICAgICAgIFxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgXG5cbiAgICAgICAgX3NldEF0dHJFZGl0b3I6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgdmFyIGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgaGVhZGVyLmlubmVySFRNTCA9IGxheWVyLmZlYXR1cmUuaWQ7XG4gICAgICAgICAgICBoZWFkZXIuc3R5bGUuYm9yZGVyQm90dG9tID0gJzFweCAjMDAwIHNvbGlkJztcbiAgICAgICAgICAgIGhlYWRlci5zdHlsZS5mb250V2VpZ2h0ID0gJ2JvbGQnO1xuICAgICAgICAgICAgY29udGVudC5hcHBlbmRDaGlsZChoZWFkZXIpO1xuXG4gICAgICAgICAgICB2YXIgdGFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0YWJsZScpOyAgXG4gICAgICAgICAgICB2YXIgcHJvcCA9IGxheWVyLmZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICAgIHZhciBub0VkaXRhYmxlcyA9IHRoaXMuX2dldE5vdEVkaXRhYmxlcygpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSBpbiBwcm9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vTnVsbCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHZhciB2YWx1ZSA9IHByb3BbaV07XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBub0VkaXRhYmxlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA9PSBub0VkaXRhYmxlc1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9OdWxsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cblxuXG5cbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndHInKTtcbiAgICAgICAgICAgICAgICB2YXIgdGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGRcIik7XG4gICAgICAgICAgICAgICAgdGQuc3R5bGUuZm9udFNpemUgPSBcIjEwcHRcIjtcbiAgICAgICAgICAgICAgICB0ZC5pbm5lckhUTUwgPSBpICsgXCI6IFwiO1xuICAgICAgICAgICAgICAgIHJvdy5hcHBlbmRDaGlsZCh0ZCk7XG4gICAgICAgICAgICAgICAgdmFyIHJvd0lucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaW5wdXQnKTtcbiAgICAgICAgICAgICAgICBpZiAobm9OdWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvd0lucHV0LmRpc2FibGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcm93SW5wdXQudHlwZSA9ICd0ZXh0JztcbiAgICAgICAgICAgICAgICByb3dJbnB1dC52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHJvd0lucHV0LnN0eWxlLndpZHRoID0gJzEyMHB4JztcbiAgICAgICAgICAgICAgICByb3dJbnB1dC5zdHlsZS5mbG9hdCA9ICdyaWdodCc7XG4gICAgICAgICAgICAgICAgcm93SW5wdXQuY2xhc3NOYW1lID0gJ2F0dHJpYnV0ZXMnO1xuICAgICAgICAgICAgICAgIHRkID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRkXCIpO1xuICAgICAgICAgICAgICAgIHRkLmFwcGVuZENoaWxkKHJvd0lucHV0KTtcbiAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodGQpO1xuICAgICAgICAgICAgICAgIHRhYmxlLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQodGFibGUpO1xuXG4gICAgICAgICAgICB2YXIgYnV0dG9ucyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NlbnRlcicpO1xuICAgICAgICAgICAgdmFyIHNhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgc2F2ZS50eXBlID0gJ2J1dHRvbic7XG4gICAgICAgICAgICBzYXZlLnZhbHVlID0gJ1NhdmUgZWRpdGlvbic7XG4gICAgICAgICAgICBzYXZlLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHNlbGYuX3NhdmUobGF5ZXIsIGNvbnRlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnV0dG9ucy5hcHBlbmRDaGlsZChzYXZlKTtcbiAgICAgICAgICAgIHZhciBjYW5jZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpbnB1dCcpO1xuICAgICAgICAgICAgY2FuY2VsLnR5cGUgPSAnYnV0dG9uJztcbiAgICAgICAgICAgIGNhbmNlbC52YWx1ZSA9ICdDYW5jZWwnO1xuICAgICAgICAgICAgY2FuY2VsLm9uY2xpY2sgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBsYXllci5jbG9zZVBvcHVwKCk7XG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJ1dHRvbnMuYXBwZW5kQ2hpbGQoY2FuY2VsKTtcbiAgICAgICAgICAgIGNvbnRlbnQuYXBwZW5kQ2hpbGQoYnV0dG9ucyk7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVzRWRpdGVkLmFkZExheWVyKGxheWVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG5cbiAgICAgICAgfSxcblxuICAgICAgICBfZ2V0Tm90RWRpdGFibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBub0VkaXRhYmxlcyA9IHRoaXMub3B0aW9ucy5yZWFkT25seUZpZWxkcztcbiAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLm9wdGlvbnMuc2VydmVyVVJMICsgXCI/cmVxdWVzdD1EZXNjcmliZUZlYXR1cmVUeXBlJnZlcnNpb249MS4xLjAmdHlwZW5hbWU9XCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwieG1sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBhc3luYzogZmFsc2UsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oeG1sLCBzdGF0dXMsIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IF90aGlzLl9nZXRFbGVtZW50c0J5VGFnTmFtZU5TKF90aGlzLl9nZXRFbGVtZW50c0J5VGFnTmFtZU5TKHhtbCwneHNkJywgJ3NlcXVlbmNlJylbMF0sICd4c2QnLCAnZWxlbWVudCcpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ25pbGxhYmxlJykgPT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9FZGl0YWJsZXMucHVzaChhdHRyaWJ1dGVzW2ldLmdldEF0dHJpYnV0ZSgnbmFtZScpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5vRWRpdGFibGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9zYXZlOiBmdW5jdGlvbihsYXllciwgY29udGVudCkge1xuICAgICAgICAgICAgdmFyIHByb3AgPSBsYXllci5mZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICB2YXIgcHJvcEluaXRpYWwgPSB7fTtcbiAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVzID0gY29udGVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdhdHRyaWJ1dGVzJyk7XG4gICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICBmb3IgKHZhciBqIGluIHByb3ApIHtcbiAgICAgICAgICAgICAgICBwcm9wSW5pdGlhbFtqXSA9IHByb3Bbal07XG4gICAgICAgICAgICAgICAgcHJvcFtqXSA9IGF0dHJpYnV0ZXNbaV0udmFsdWU7XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGF5ZXIucHJvcGVydGllc0luaWNpYWwgPSBwcm9wSW5pdGlhbDtcblxuICAgICAgICAgICAgbGF5ZXIuY2xvc2VQb3B1cCgpO1xuXG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FwcGx5U3R5bGVzOiBmdW5jdGlvbihtYXJrZXIsIGluQ2x1c3Rlcikge1xuICAgICAgICAgICAgaWYgKCFtYXJrZXIuZmVhdHVyZSkge1xuICAgICAgICAgICAgICAgIHRoaXMubm9DbHVzdGVyR3JvdXAuYWRkTGF5ZXIobWFya2VyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHZhciB6b29tID0gdGhpcy5fbWFwLmdldFpvb20oKTtcbiAgICAgICAgICAgIGlmICghem9vbSkge1xuICAgICAgICAgICAgICAgIHZhciB6b29tID0gdGhpcy5nZXRNYXAoKS5nZXRab29tKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLmFwcGx5U3R5bGUobWFya2VyLmZlYXR1cmUsIHpvb20pO1xuICAgICAgICAgICAgaWYgKHN0eWxlLmljb24pIHtcbiAgICAgICAgICAgICAgICBtYXJrZXIuc2V0SWNvbihzdHlsZS5pY29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdHlsZS5vcGFjaXR5KSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnNldE9wYWNpdHkoc3R5bGUub3BhY2l0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5vQ2x1c3Rlckdyb3VwLnJlbW92ZUxheWVyKG1hcmtlcik7XG4gICAgICAgICAgICB0aGlzLm5vQ2x1c3Rlckdyb3VwLmFkZExheWVyKG1hcmtlcik7XG5cbiAgICAgICAgICAgIHRoaXMuYWRkUG9wVXAobWFya2VyLCB6b29tKTtcbiAgICAgICAgfSxcbiAgICAgICAgX2dldEluZGV4RnJvbUVkaXRhYmxlTGF5ZXI6IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSAtMTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZWRpdGFibGVfbGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVkaXRhYmxlX2xheWVyc1tpXS5fbGVhZmxldF9pZCA9PSBsYXllci5fbGVhZmxldF9pZCkge1xuICAgICAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfSxcbiAgICB9LCBbU01DLmxheWVycy5FZGl0YWJsZUxheWVyLCBTTUMucHJvdmlkZXJzLldGU1RQcm92aWRlcl0pO1xuXG4vKipcbiAqIEFQSSBmYWN0b3J5IG1ldGhvZCBmb3IgZWFzZSBjcmVhdGlvbiBvZiB3ZnMgZmVhdHVyZXMgcHJvdmlkZXJzLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB3ZnMgdGhlIHByb3ZpZGVyLlxuICovXG5TTUMud2ZzdE1hcmtlckxheWVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLmxheWVycy5tYXJrZXJzLldGU1RNYXJrZXJMYXllcihvcHRpb25zKTtcbn07XG4iLCJyZXF1aXJlKFwiLi4vbGF5ZXJzLmpzXCIpO1xuLyoqXG4gKiBOYW1lc3BhY2Ugb2YgU01DLlZpZXdlcidzIGxheWVycyBkaXNwbGF5ZWQgdXNpbmcgbWFya2VycyBpbiB0aGUgbWFwLiBcbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBTTUMubGF5ZXJzXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMubWFya2VycyA9IHt9OyIsInJlcXVpcmUoXCIuL3JlbG9hZGVycy5qc1wiKTtcbnJlcXVpcmUoXCIuL1JlbG9hZFRyaWdnZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vLi4vcHJvdmlkZXJzL0F0bW9zcGhlcmVDb25uZWN0b3IuanNcIik7XG5yZXF1aXJlKFwiLi4vLi4vLi4vbGliL2F0bW9zcGhlcmUtanF1ZXJ5L2pxdWVyeS5hdG1vc3BoZXJlLmpzXCIpO1xuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIGEgU01DIHZpZXdlcidzIGxheWVyIHJlbG9hZCB0cmlnZ2VyIHVzaW5nIEF0bW9zcGhlcmUgcHViL3N1YiBqYXZhc2NyaXB0IGNsaWVudCwgc28gd2UgcmVsb2FkIGxheWVyc1xuICogd2hlbiBhIG5vdGlmaWNhdGlvbiBpcyByZWNlaXZlZC5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMucmVsb2FkZXJzLlJlbG9hZFRyaWdnZXJcbiAqIEBtaXhlcyBTTUMucHJvdmlkZXJzLkF0bW9zcGhlcmVDb25uZWN0b3JcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMucmVsb2FkZXJzLkF0bW9zcGhlcmVSVFJlbG9hZFRyaWdnZXIgPSBTTUMubGF5ZXJzLnJlbG9hZGVycy5SZWxvYWRUcmlnZ2VyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMucmVsb2FkZXJzLlRpbWVyUmVsb2FkVHJpZ2dlciMgKi9cbiAgICB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5sYXllcnMucmVsb2FkZXJzLlJlbG9hZFRyaWdnZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5wcm92aWRlcnMuQXRtb3NwaGVyZUNvbm5lY3Rvci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBpbml0VHJpZ2dlciBtZXRob2QgdXNpbmcgc2V0VGltZW91dC5cbiAgICAgICAgICovXG4gICAgICAgIGluaXRUcmlnZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9vbk1lc3NhZ2U6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmRlYnVnKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIHRoaXMuX25vdGlmeVJlbG9hZCgpO1xuICAgICAgICB9XG5cbiAgICB9LCBbU01DLnByb3ZpZGVycy5BdG1vc3BoZXJlQ29ubmVjdG9yXSk7XG4iLCJyZXF1aXJlKFwiLi9yZWxvYWRlcnMuanNcIik7XG5cbi8qKlxuICogTGF5ZXIgcmVsb2FkZXIuIEFsbG93cyBzZXR0aW5nIHRyaWdnZXJzIHNvIGEgbGF5ZXIncyBkYXRhIGNhbiBiZSByZS1yZXRyaWV2ZWQgZnJvbSBpdHMgb3JpZ2luYWwgZGF0YS5cbiAqXG4gKiBJbnRlbmRlZCBmb3IgYmVpbmcgbWl4ZWQgaW4gaW50byBhIFNNQy5sYXllci5TaW5nbGVMYXllci5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIEwuQ2xhc3NcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMucmVsb2FkZXJzLkxheWVyUmVsb2FkZXIgPSBMLkNsYXNzLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMucmVsb2FkZXJzLkxheWVyUmVsb2FkZXIjICovXG4gICAge1xuICAgICAgICBfdHJpZ2dlcnM6IFtdLFxuXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnJlbG9hZFRyaWdnZXJzICYmIG9wdGlvbnMucmVsb2FkVHJpZ2dlcnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5yZWxvYWRUcmlnZ2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJpZ2dlciA9IG9wdGlvbnMucmVsb2FkVHJpZ2dlcnNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWRkUmVsb2FkVHJpZ2dlcih0cmlnZ2VyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgYSBsYXllcidzIGRhdGFcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBsb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMucmVsb2FkZXJzLkxheWVyUmVsb2FkZXI6OmxvYWQgbWV0aG9kIG11c3QgYmUgaW1wbGVtZW50ZWQgYnkgYW4gaW5oZXJpdGluZyBjbGFzc1wiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVW5sb2FkIGEgbGF5ZXIncyBkYXRhXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgdW5sb2FkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMucmVsb2FkZXJzLkxheWVyUmVsb2FkZXI6OnVubG9hZCBtZXRob2QgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhbiBpbmhlcml0aW5nIGNsYXNzXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gcmVsb2FkIHRoZSB0cmlnZ2VyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSB0cmlnZ2VyIC0gdHJpZ2dlciB0byByZWxvYWQgdGhlIGNvbnRyb2xcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJlbG9hZFRyaWdnZXI6IGZ1bmN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdHJpZ2dlci50eXBlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdHJpZ2dlciA9IHRoaXMuX2NyZWF0ZVRyaWdnZXJGcm9tQ29uZmlnKHRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2Vycy5wdXNoKHRyaWdnZXIpO1xuICAgICAgICAgICAgdHJpZ2dlci5vbihcInJlbG9hZFRyaWdnZXJlZFwiLCB0aGlzLl9vblJlbG9hZFRyaWdnZXJlZCwgdGhpcyk7XG4gICAgICAgICAgICB0cmlnZ2VyLmluaXRUcmlnZ2VyKCk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZVRyaWdnZXJGcm9tQ29uZmlnOiBmdW5jdGlvbih0cmlnZ2VyQ29uZmlnKSB7XG4gICAgICAgICAgICBpZiAoIXRyaWdnZXJDb25maWcudHlwZSB8fCB0eXBlb2YgdHJpZ2dlckNvbmZpZy50eXBlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLmxheWVycy5yZWxvYWRlcnMuTGF5ZXJSZWxvYWRlcjo6X2NyZWF0ZVRyaWdnZXJGcm9tQ29uZmlnOiB0cmlnZ2VyQ29uZmlnIG11c3QgaW5jbHVkZSBhIHR5cGUgZmllbGQgKHN0cmluZylcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0cmlnZ2VyQ2xhc3MgPSBTTUMuVXRpbC5nZXRDbGFzcyh0cmlnZ2VyQ29uZmlnLnR5cGUpO1xuXG4gICAgICAgICAgICB2YXIgdHJpZ2dlckNvbnN0cnVjdG9yID0gU01DLlV0aWwuZ2V0Q29uc3RydWN0b3IodHJpZ2dlckNsYXNzKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRyaWdnZXJDb25zdHJ1Y3Rvcih0cmlnZ2VyQ29uZmlnLnBhcmFtcyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uUmVsb2FkVHJpZ2dlcmVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFJlbG9hZHMgdGhlIGxheWVyLlxuICAgICAgICAgICAgdGhpcy51bmxvYWQoKTtcbiAgICAgICAgICAgIHRoaXMubG9hZCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4iLCJyZXF1aXJlKFwiLi9yZWxvYWRlcnMuanNcIik7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU01DIHZpZXdlcidzIGxheWVyIHJlbG9hZGVyIHRyaWdnZXJzLlxuICpcbiAqIEBjbGFzc1xuICogQGFic3RyYWN0XG4gKiBAZXh0ZW5kcyBMLkNsYXNzXG4gKiBAbWl4ZXMgTC5NaXhpbi5FdmVudHNcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMucmVsb2FkZXJzLlJlbG9hZFRyaWdnZXIgPSBMLkNsYXNzLmV4dGVuZChcblx0LyoqIEBsZW5kcyBTTUMubGF5ZXJzLnJlbG9hZGVycy5SZWxvYWRUcmlnZ2VyIyAqL1xuXHR7XG5cdFx0aW5jbHVkZXM6IFtMLk1peGluLkV2ZW50c10sXG5cblxuXHRcdGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuXG5cdFx0fSxcblxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZXMgdGhlIHRyaWdnZXIgc28gaXQgd2lsbCBtb25pdG9yIGZvciB0aGUgbmVlZCBvZiBhIHJlbG9hZC5cblx0XHQgKlxuXHRcdCAqIEBhYnN0cmFjdFxuXHRcdCAqL1xuXHRcdGluaXRUcmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIlJlbG9hZFRyaWdnZXI6OmluaXRUcmlnZ2VyOiBjbGFzc2VzIGV4dGVuZGluZyBSZWxvYWRUcmlnZ2VyIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlwiKTtcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSGVscGVyIG1ldGhvZCB0byBoaWRlIHRoZSBsYXVuY2hpbmcgb2YgdGhlIGV2ZW50IGZyb20gaW1wbGVtZW50aW5nIGNsYXNzZXMuXG5cdFx0ICpcblx0XHQgKiBAcHJvdGVjdGVkXG5cdFx0ICogQGZpcmVzIFNNQy5sYXllcnMucmVsb2FkZXJzLlJlbG9hZFRyaWdnZXIjcmVsb2FkVHJpZ2dlcmVkXG5cdFx0ICovXG5cdFx0X25vdGlmeVJlbG9hZDogZnVuY3Rpb24oKSB7XG5cdFx0XHQvKipcblx0XHRcdCAqIExheWVyIHJlbG9hZCBldmVudC4gU01DLmxheWVycy5yZWxvYWRlcnMuTGF5ZXJSZWxvYWRlciB3aWxsIGxpc3RlbiBmb3IgdGhpcyBldmVudCBhbmQgdGhlbiByZWxvYWQgdGhlIGxheWVyLlxuXHRcdFx0ICpcblx0XHRcdCAqIEBldmVudCBTTUMubGF5ZXJzLnJlbG9hZGVycy5SZWxvYWRUcmlnZ2VyI3JlbG9hZFRyaWdnZXJlZFxuXHRcdFx0ICovXG5cdFx0XHR0aGlzLmZpcmUoXCJyZWxvYWRUcmlnZ2VyZWRcIik7XG5cdFx0fVxuXG5cdH0pO1xuIiwicmVxdWlyZShcIi4vUmVsb2FkVHJpZ2dlci5qc1wiKTtcblxuLyoqXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiBhIFNNQyB2aWV3ZXIncyBsYXllciByZWxvYWQgdHJpZ2dlciB1c2luZyBjYWxscyB0byBKYXZhU2NyaXB0J3Mgc2V0VGltZW91dCBmdW5jdGlvbi5cbiAqXG4gKiBAY2xhc3NcbiAqIEBleHRlbmRzIFNNQy5sYXllcnMucmVsb2FkZXJzLlJlbG9hZFRyaWdnZXJcbiAqIEBwYXJhbSB7U01DLmxheWVycy5yZWxvYWRlcnMuVGltZXJSZWxvYWRUcmlnZ2Vyfm9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNsYXNzXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLnJlbG9hZGVycy5UaW1lclJlbG9hZFRyaWdnZXIgPSBTTUMubGF5ZXJzLnJlbG9hZGVycy5SZWxvYWRUcmlnZ2VyLmV4dGVuZChcblx0LyoqIEBsZW5kcyBTTUMubGF5ZXJzLnJlbG9hZGVycy5UaW1lclJlbG9hZFRyaWdnZXIjICovXG5cdHtcblx0XHQvKipcblx0XHQgKiBAdHlwZWRlZiB7T2JqZWN0fSBTTUMubGF5ZXJzLnJlbG9hZGVycy5UaW1lclJlbG9hZFRyaWdnZXJ+b3B0aW9uc1xuXHRcdCAqIEBwcm9wZXJ0eSB7aW50fSB0cmlnZ2VyRGVsYXk9NTAwMCAtIFRoZSBkZWxheSBiZWV0d2VlbiBhIHJlbG9hZCBpcyB0cmlnZ2VyZWRcblx0XHQgKi9cblx0XHRvcHRpb25zOiB7XG5cdFx0XHR0cmlnZ2VyRGVsYXk6IDUwMDBcblx0XHR9LFxuXG5cdFx0LyoqXG5cdFx0ICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuXHRcdCAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZGVmYXVsdCBvcHRpb25zXG5cdFx0ICovXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0TC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG5cdFx0fSxcblxuXHRcdC8qKlxuXHRcdCAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBpbml0VHJpZ2dlciBtZXRob2QgdXNpbmcgc2V0VGltZW91dC5cblx0XHQgKi9cblx0XHRpbml0VHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLl9ub3RpZnlSZWxvYWQoKTtcblxuXHRcdFx0XHQvLyBXZSBzdGFydCB0aGUgcHJvY2VzcyBhZ2Fpbi5cblx0XHRcdFx0c2VsZi5pbml0VHJpZ2dlcigpO1xuXHRcdFx0fSwgdGhpcy5vcHRpb25zLnRyaWdnZXJEZWxheSk7XG5cdFx0fVxuXG5cdH0pO1xuIiwicmVxdWlyZShcIi4uL2xheWVycy5qc1wiKTtcblxuLyoqXG4gKiBOYW1lc3BhY2UgZm9yIGxheWVyIHJlbG9hZGVycyBmb3IgIFNNQyBWaWV3ZXIncyBsYXllcnMuXG4gKiBAbmFtZXNwYWNlXG4gKiBAbWVtYmVyb2YgU01DLmxheWVyc1xuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5yZWxvYWRlcnMgPSB7fTsiLCJyZXF1aXJlKFwiLi9TdHlsZXIuanNcIik7XG5cblxuLyoqXG4gKiBNYXBDU1Mgc3R5bGVzIHBhcnNlciwgZm9yIHVzZXIgd2l0aCBTTUMgVmlld2VyJ3MgZ2VvbWV0cnkgbGF5ZXJzLlxuICpcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgU01DLmxheWVycy5zdHlsZXJzLlN0eWxlclxuICogQG1peGluIFNNQy5sYXllcnMuc3R5bGVycy5NYXBDc3NTdHlsZXJcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMuc3R5bGVycy5NYXBDc3NTdHlsZXIgPSBTTUMubGF5ZXJzLnN0eWxlcnMuU3R5bGVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5sYXllcnMuc3R5bGVycy5NYXBDc3NTdHlsZXIjICovXG4gICAge1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByb3BlcnR5IHtBcnJheX0gbGFiZWxzIC0gVGhlIGxhYmVscyBhcnJheVxuICAgICAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICAgICAqL1xuICAgICAgICBsYWJlbHM6IFtdLFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIHBhcmFtc1xuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5fcGFyc2VyX3VybCA9IFNNQy5CQVNFX1VSTCArIFwicmVzb3VyY2VzL3BhcnNlci50eHRcIjtcbiAgICAgICAgICAgIFNNQy5sYXllcnMuc3R5bGVycy5TdHlsZXIucHJvdG90eXBlLmluaXRpYWxpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBzdHlsZSBwcm9wZXJ0aWVzIHRvIHRoZSByZWNlaXZlZCBmZWF0dXJlcywgc28gdGhlIGNhbiBiZSByZXByZXNlbnRlZCBhcyBpbnRlbmRlZCBieSB0aGUgc3R5bGUgZm9yIHRoZSBsYXllci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnZW9tZXRyeSBlbGVtZW50IGJlaW5nIHN0eWxlZC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGN0eCAtIEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGNvbnRleHQgZnVuY3Rpb24uXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB6b29tIC0gTnVtYmVyIHRoYXQgcmVwcmVzZW50cyB0aGUgbGV2ZWwgem9vbSB0byBhcHBseSB0aGUgc3R5bGUuXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IHN0eWxlIC0gU3R5bGUgZnJvbSB0aGUgZmVhdHVyZVxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlTdHlsZTogZnVuY3Rpb24oZmVhdHVyZSwgY3R4LCB6b29tKSB7XG5cbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRoaXMuX2NyZWF0ZVN0eWxlcyhmZWF0dXJlLCB6b29tKTtcbiAgICAgICAgICAgIGlmICghc3R5bGUpXG4gICAgICAgICAgICAgICAgc3R5bGUgPSBcIlwiO1xuXG4gICAgICAgICAgICB2YXIgcGF0aDtcbiAgICAgICAgICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT0gJ1BvaW50JyB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChzdHlsZS5zeW1ib2wpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQ2lyY2xlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuZXcgY3R4LmNhbnZhcy5fcGFwZXIuUGF0aC5DaXJjbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czogc3R5bGUucmFkaXVzIHx8IDNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnUmVjdGFuZ2xlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuZXcgY3R4LmNhbnZhcy5fcGFwZXIuUGF0aC5SZWN0YW5nbGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNpemU6IHN0eWxlLnNpemUgfHwgWzEwLCAxMF1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnRWxsaXBzZSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gbmV3IGN0eC5jYW52YXMuX3BhcGVyLlBhdGguRWxsaXBzZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogc3R5bGUuc2l6ZSB8fCBbMTAsIDhdXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1JlZ3VsYXJQb2x5Z29uJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuZXcgY3R4LmNhbnZhcy5fcGFwZXIuUGF0aC5SZWd1bGFyUG9seWdvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2lkZXM6IHN0eWxlLnNpZGVzIHx8IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmFkaXVzOiBzdHlsZS5yYWRpdXMgfHwgNVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTdGFyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhdGggPSBuZXcgY3R4LmNhbnZhcy5fcGFwZXIuUGF0aC5TdGFyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb2ludHM6IHN0eWxlLnBvaW50cyB8fCA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhZGl1czE6IHN0eWxlLnJhZGl1czEgfHwgMyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXMyOiBzdHlsZS5yYWRpdXMyIHx8IDVcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXRoID0gbmV3IGN0eC5jYW52YXMuX3BhcGVyLlBhdGguQ2lyY2xlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYWRpdXM6IDNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICB2YXIgcGF0aFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0cm9rZUNvbG9yOiBzdHlsZS5zdHJva2VDb2xvciB8fCBzdHlsZS5maWxsQ29sb3IgfHwgXCJibGFja1wiLFxuICAgICAgICAgICAgICAgIHN0cm9rZVdpZHRoOiBzdHlsZS5zdHJva2VXaWR0aCB8fCAyLFxuICAgICAgICAgICAgICAgIHN0cm9rZUpvaW46IHN0eWxlLnN0cm9rZUpvaW4gfHwgJ21pdGVyJyxcbiAgICAgICAgICAgICAgICBkYXNoQXJyYXk6IHN0eWxlLmRhc2hBcnJheSB8fCBbXSxcbiAgICAgICAgICAgICAgICBzdHJva2VDYXA6IHN0eWxlLnN0cm9rZUNhcCB8fCAnYnV0dCcsXG4gICAgICAgICAgICAgICAgZGFzaE9mZnNldDogc3R5bGUuZGFzaE9mZnNldCB8fCAwLFxuICAgICAgICAgICAgICAgIG1pdGVyTGltaXQ6IHN0eWxlLm1pdGVyTGltaXQgfHwgMTAsXG4gICAgICAgICAgICAgICAgd2luZGluZ1J1bGU6IHN0eWxlLndpbmRpbmdSdWxlIHx8ICdub256ZXJvJyxcbiAgICAgICAgICAgICAgICBzZWxlY3RlZENvbG9yOiBzdHlsZS5zZWxlY3RlZENvbG9yIHx8ICdhcXVhJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dDb2xvcjogc3R5bGUuc2hhZG93Q29sb3IgfHwgJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dCbHVyOiBzdHlsZS5zaGFkb3dCbHVyIHx8IDAsXG4gICAgICAgICAgICAgICAgc2hhZG93T2Zmc2V0OiBzdHlsZS5zaGFkb3dPZmZzZXQgfHwgW11cblxuICAgICAgICAgICAgfTtcblxuXG4gICAgICAgICAgICBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09ICdMaW5lU3RyaW5nJyB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgICAgICBwYXRoU3R5bGUuc3Ryb2tlQ29sb3IgPSBzdHlsZS5zdHJva2VDb2xvciB8fCBcImJsYWNrXCI7XG4gICAgICAgICAgICAgICAgIHBhdGhTdHlsZS5maWxsQ29sb3IgPSBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXRoU3R5bGUuZmlsbENvbG9yID0gc3R5bGUuZmlsbENvbG9yIHx8ICdyZ2JhKDAsMCwwLDApJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHN0eWxlLm9wYWNpdHkgPyBzdHlsZS5vcGFjaXR5IDogMTtcbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBzdHlsZS5vZmZzZXQgPyBzdHlsZS5vZmZzZXQgOiAwO1xuICAgICAgICAgICAgdmFyIHpJbmRleCA9IHN0eWxlLnpJbmRleCA/IHN0eWxlLnpJbmRleCA6IDA7XG4gICAgICAgICAgICB2YXIgdmlzaWJsZSA9ICFzdHlsZS5pbnZpc2libGUgPyB0cnVlIDogZmFsc2U7XG4gICAgICAgICAgICB2YXIgcG9wVXBTdHlsZSA9IHtcbiAgICAgICAgICAgICAgcG9wVXBUZW1wbGF0ZTogc3R5bGUucG9wVXBUZW1wbGF0ZSxcbiAgICAgICAgICAgICAgcG9wVXBVcmw6IHN0eWxlLnBvcFVwVXJsLFxuICAgICAgICAgICAgICBub1BvcFVwOiBzdHlsZS5ub1BvcFVwLFxuICAgICAgICAgICAgICBvZmZzZXRMZWZ0OiBzdHlsZS5wb3BVcE9mZnNldExlZnQsXG4gICAgICAgICAgICAgIG9mZnNldFRvcDogc3R5bGUucG9wVXBPZmZzZXRUb3BcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZmVhdHVyZS5fc3R5bGVzID0ge1xuICAgICAgICAgICAgICAgIHBvcFVwU3R5bGU6IHBvcFVwU3R5bGUsXG4gICAgICAgICAgICAgICAgcGF0aFN0eWxlOiBwYXRoU3R5bGUsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eSxcbiAgICAgICAgICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHpJbmRleDogekluZGV4LFxuICAgICAgICAgICAgICAgIHZpc2libGU6IHZpc2libGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZS5fc3R5bGVzO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHN0eWxlIGxhYmVsIHRvIHRoZSByZWNlaXZlZCBmZWF0dXJlcywgc28gdGhlIGNhbiBiZSByZXByZXNlbnRlZCBhcyBpbnRlbmRlZCBieSB0aGUgc3R5bGUgZm9yIHRoZSBsYXllci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnZW9tZXRyeSBlbGVtZW50IGJlaW5nIHN0eWxlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpvb20gLSBOdW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBsZXZlbCB6b29tIHRvIGFwcGx5IHRoZSBzdHlsZS5cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gc3R5bGUgLSBTdHlsZSBmcm9tIHRoZSBsYWJlbCBmZWF0dXJlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRMYWJlbFN0eWxlOiBmdW5jdGlvbihmZWF0dXJlLCB6b29tKSB7XG5cbiAgICAgICAgICAgIHZhciBsYWJlbFN0eWxlID0gdGhpcy5fY3JlYXRlTGFiZWwoZmVhdHVyZSwgem9vbSk7XG5cblxuICAgICAgICAgICAgdmFyIGNvbnRlbnQ7XG4gICAgICAgICAgICBpZiAobGFiZWxTdHlsZS5jb250ZW50KSB7XG4gICAgICAgICAgICAgICAgaWYgKGxhYmVsU3R5bGUudW5pcXVlTGFiZWwpIHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMubGFiZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5sYWJlbHMucHVzaChsYWJlbFN0eWxlLmNvbnRlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGxhYmVsU3R5bGUuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleGlzdHMgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlICgoaSA8IHRoaXMubGFiZWxzLmxlbmd0aCkgJiYgIWV4aXN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsYWJlbFN0eWxlLmNvbnRlbnQgPT0gdGhpcy5sYWJlbHNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhYmVscy5wdXNoKGxhYmVsU3R5bGUuY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGxhYmVsU3R5bGUuY29udGVudDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGxhYmVsU3R5bGUuY29udGVudDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0eWxlID0ge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRQb3BVcDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmaWxsQ29sb3I6IGxhYmVsU3R5bGUuZmlsbENvbG9yIHx8ICdibGFjaycsXG4gICAgICAgICAgICAgICAgZm9udEZhbWlseTogbGFiZWxTdHlsZS5mb250RmFtaWx5IHx8ICdzYW5zLXNlcmlmJyxcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBsYWJlbFN0eWxlLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcsXG4gICAgICAgICAgICAgICAgZm9udFNpemU6IGxhYmVsU3R5bGUuZm9udFNpemUgfHwgMTAsXG4gICAgICAgICAgICAgICAgbGVhZGluZzogbGFiZWxTdHlsZS5sZWFkaW5nIHx8IGxhYmVsU3R5bGUuZm9udFNpemUgKiAxLjIsXG4gICAgICAgICAgICAgICAgc2hhZG93Q29sb3I6IGxhYmVsU3R5bGUuc2hhZG93Q29sb3IgfHwgJ2JsYWNrJyxcbiAgICAgICAgICAgICAgICBzaGFkb3dCbHVyOiBsYWJlbFN0eWxlLnNoYWRvd0JsdXIgfHwgMCxcbiAgICAgICAgICAgICAgICBzaGFkb3dPZmZzZXQ6IGxhYmVsU3R5bGUuc2hhZG93T2Zmc2V0IHx8IFtdXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQsXG4gICAgICAgICAgICAgICAgc3R5bGU6IHN0eWxlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVMYWJlbDogZnVuY3Rpb24oZmVhdHVyZSwgem9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBsYWJlbFN0eWxlOiBudWxsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHN0eWxlIHBvcHVwIHRvIHRoZSByZWNlaXZlZCBmZWF0dXJlcywgc28gdGhlIGNhbiBiZSByZXByZXNlbnRlZCBhcyBpbnRlbmRlZCBieSB0aGUgc3R5bGUgZm9yIHRoZSBsYXllci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnZW9tZXRyeSBlbGVtZW50IGJlaW5nIHN0eWxlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpvb20gLSBOdW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBsZXZlbCB6b29tIHRvIGFwcGx5IHRoZSBzdHlsZS5cbiAgICAgICAgICogQHJldHVybnMge29iamVjdH0gc3R5bGUgLSBTdHlsZSBmcm9tIHRoZSBwb3B1cCBmZWF0dXJlXG4gICAgICAgICAqL1xuICAgICAgICBhZGRQb3BVcDogZnVuY3Rpb24oZmVhdHVyZSwgem9vbSkge1xuICAgICAgICAgICAgdmFyIHN0eWxlID0gZmVhdHVyZS5fc3R5bGVzLnBvcFVwU3R5bGU7XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IHN0eWxlLm9mZnNldExlZnQgfHwgMDtcbiAgICAgICAgICAgIHZhciBvZmZzZXRUb3AgPSBzdHlsZS5vZmZzZXRUb3AgfHwgMDtcblxuXG4gICAgICAgICAgICB2YXIgY29udGVudCwgcHJvcEtleTtcbiAgICAgICAgICAgIHZhciBkYXRhID0ge307XG4gICAgICAgICAgICBpZiAoc3R5bGUucG9wVXBUZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSB0aGlzLl9jb250ZW50RnJvbVRlbXBsYXRlKGZlYXR1cmUsIHN0eWxlLnBvcFVwVGVtcGxhdGUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5wb3BVcFVybCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBcIjxpZnJhbWUgc3JjPVwiICsgc3R5bGUucG9wVXBVcmwgKyBcIi8+XCI7XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUubm9Qb3BVcCkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBudWxsO1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIERlZmF1bHQgdGVtcGxhdGUsIG9uZSBlbnRyeSBwZXIgZmllbGRcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fY29udGVudEZyb21UZW1wbGF0ZShmZWF0dXJlLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBvZmZzZXQgPSBbb2Zmc2V0TGVmdCwgb2Zmc2V0VG9wXTtcblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBjb250ZW50OiBjb250ZW50LFxuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSk7XG4iLCJyZXF1aXJlKFwiLi9TdHlsZXIuanNcIik7XG5yZXF1aXJlKFwiLi4vLi4vLi4vbGliL0xlYWZsZXRIdG1sSWNvbi5qc1wiKTtcbnZhciBNdXN0YWNoZSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvbXVzdGFjaGUuanMvbXVzdGFjaGUuanNcIik7XG4vKipcbiAqIFBhcnNlciBvZiBNYXJrZXJDU1MsIGZvciB1c2VyIHdpdGggU01DIFZpZXdlcidzIG1hcmtlciBsYXllcnMuXG4gKlxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTTUMubGF5ZXJzLnN0eWxlcnMuU3R5bGVyXG4gKiBAbWl4aW4gU01DLmxheWVycy5zdHlsZXJzLk1hcmtlckNzc1N0eWxlclxuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLmxheWVycy5zdHlsZXJzLk1hcmtlckNzc1N0eWxlciA9IFNNQy5sYXllcnMuc3R5bGVycy5TdHlsZXIuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLmxheWVycy5zdHlsZXJzLk1hcmtlckNzc1N0eWxlciMgKi9cbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgcGFyYW1zXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLl9wYXJzZXJfdXJsID0gU01DLkJBU0VfVVJMICsgXCJyZXNvdXJjZXMvcGFyc2VyLnR4dFwiO1xuICAgICAgICAgICAgU01DLmxheWVycy5zdHlsZXJzLlN0eWxlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGRzIHN0eWxlIHByb3BlcnRpZXMgdG8gdGhlIHJlY2VpdmVkIGZlYXR1cmVzLCBzbyB0aGUgY2FuIGJlIHJlcHJlc2VudGVkIGFzIGludGVuZGVkIGJ5IHRoZSBzdHlsZSBmb3IgdGhlIGxheWVyLlxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZSAtIEFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIGdlb21ldHJ5IGVsZW1lbnQgYmVpbmcgc3R5bGVkLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gem9vbSAtIE51bWJlciB0aGF0IHJlcHJlc2VudHMgdGhlIGxldmVsIHpvb20gdG8gYXBwbHkgdGhlIHN0eWxlLlxuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBzdHlsZSAtIFN0eWxlIGZyb20gdGhlIG1hcmtlclxuICAgICAgICAgKi9cbiAgICAgICAgYXBwbHlTdHlsZTogZnVuY3Rpb24oZmVhdHVyZSwgem9vbSkge1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBmZWF0dXJlLnByb3BlcnRpZXM7XG4gICAgICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLl9jcmVhdGVTdHlsZXMoZmVhdHVyZSwgem9vbSk7XG4gICAgICAgICAgICBpZiAoIXN0eWxlKSB7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBcIlwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmZWF0dXJlLl9zdHlsZSA9IHN0eWxlO1xuXG5cbiAgICAgICAgICAgIHZhciBpY29uLCB3aWR0aCwgaGVpZ2h0LCBhbmNob3JMZWZ0LCBhbmNob3JUb3A7XG5cbiAgICAgICAgICAgIHdpZHRoID0gc3R5bGUubWFya2VyV2lkdGggfHwgMDtcbiAgICAgICAgICAgIGhlaWdodCA9IHN0eWxlLm1hcmtlckhlaWdodCB8fCAwO1xuXG4gICAgICAgICAgICBhbmNob3JMZWZ0ID0gc3R5bGUuYW5jaG9yTGVmdCB8fCAwO1xuICAgICAgICAgICAgYW5jaG9yVG9wID0gc3R5bGUuYW5jaG9yVG9wIHx8IDA7XG5cbiAgICAgICAgICAgIHZhciBkaXNhYmxlQ2x1c3RlcmluZyA9ICEhc3R5bGUuZGlzYWJsZUNsdXN0ZXJpbmc7XG4gICAgICAgICAgICB2YXIgb3BhY2l0eSA9IHN0eWxlLm9wYWNpdHkgPyBzdHlsZS5vcGFjaXR5IDogMTtcbiAgICAgICAgICAgIC8vdmFyIHZpc2libGUgPSAhc3R5bGUuaW52aXNpYmxlID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgICAgICAgLy8gdmFyIHZpc2libGU7XG4gICAgICAgICAgICAvLyBpZihzdHlsZS5pbnZpc2libGUgPT0gJ2ZhbHNlJyl7XG4gICAgICAgICAgICAvLyAgICAgdmlzaWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvLyB9ZWxzZVxuICAgICAgICAgICAgLy8gdmlzaWJsZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAoc3R5bGUuaWNvblVybCkge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgbm9ybWFsIG1hcmtlciBpY29uIHdpdGggdGhlIHNwZWNpZmllZCB1cmwuXG5cblxuICAgICAgICAgICAgICAgIGljb24gPSBuZXcgTC5pY29uKHtcbiAgICAgICAgICAgICAgICAgICAgaWNvblVybDogc3R5bGUuaWNvblVybCxcbiAgICAgICAgICAgICAgICAgICAgaWNvblNpemU6IFt3aWR0aCwgaGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgaWNvbkFuY2hvcjogW2FuY2hvckxlZnQsIGFuY2hvclRvcF1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS50ZW1wbGF0ZVVybCkge1xuICAgICAgICAgICAgICAgIC8vIExvYWQgdGhlIGdpdmVuIHBhZ2UgZnJvbSBpdHMgdXJsIGluIGFuIGlmcmFtZS5cblxuICAgICAgICAgICAgICAgIGljb24gPSBuZXcgTC5IdG1sSWNvbih7XG4gICAgICAgICAgICAgICAgICAgIC8vaHRtbDogXCI8aWZyYW1lIHNyYz1cIiArIHN0eWxlLnRlbXBsYXRlVXJsICsgJyBzdHlsZT1cIiBib3JkZXI6IG5vbmU7d2lkdGg6JyArIHdpZHRoICsgJ3B4O2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4O21hcmdpbi10b3A6LScgKyBhbmNob3JUb3AgKyAncHg7bWFyZ2luLWxlZnQ6LScgKyBhbmNob3JMZWZ0ICsgJ3B4XCI+PC9pZnJhbWU+JyxcbiAgICAgICAgICAgICAgICAgICAgaHRtbDogdGhpcy5fY3JlYXRlSFRNTEVsZW1lbnQoXCJpZnJhbWVcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJzcmNcIjogc3R5bGUudGVtcGxhdGVVcmxcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXJcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdHM6IFwicHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCItXCIgKyBhbmNob3JUb3AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdHM6IFwicHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLWxlZnRcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBcIi1cIiArIGFuY2hvckxlZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdHM6IFwicHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3R5bGUuaHRtbFRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgLy8gTG9hZCB0aGUgdGVtcGxhdGUgaW50byB0aGUgbWFya2VyLlxuICAgICAgICAgICAgICAgIC8vIFRPRE86IFwiaW5mbGF0ZSB0aGUgdGVtcGxhdGVcIiB1c2luZyBtdXN0YWNoZS5cbiAgICAgICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BLZXkgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW3Byb3BLZXldID0gcHJvcGVydGllc1twcm9wS2V5XTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgICAgIHZhciBvdXRwdXQgPSBNdXN0YWNoZS5yZW5kZXIoc3R5bGUuaHRtbFRlbXBsYXRlLCBkYXRhKTtcblxuXG4gICAgICAgICAgICAgICAgLy92YXIgY29udGFpbmVyID0gJzxkaXYgc3R5bGU9XCIgd2lkdGg6JyArIHdpZHRoICsgJ3B4O2hlaWdodDonICsgaGVpZ2h0ICsgJ3B4O21hcmdpbi10b3A6LScgKyBhbmNob3JUb3AgKyAncHg7bWFyZ2luLWxlZnQ6LScgKyBhbmNob3JMZWZ0ICsgJ3B4XCI+JyArIG91dHB1dCArIFwiPC9kaXY+XCI7XG5cbiAgICAgICAgICAgICAgICBpY29uID0gbmV3IEwuSHRtbEljb24oe1xuICAgICAgICAgICAgICAgICAgICBodG1sOiB0aGlzLl9jcmVhdGVIVE1MRWxlbWVudChcImRpdlwiLCB7XG5cbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJ3aWR0aFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcImhlaWdodFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0czogXCJweFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwibWFyZ2luLXRvcFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IFwiLVwiICsgYW5jaG9yVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogXCItXCIgKyBhbmNob3JMZWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgb3V0cHV0KSxcblxuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLmljb25DbGFzc05hbWUpIHtcblxuICAgICAgICAgICAgICAgIGljb24gPSBuZXcgTC5IdG1sSWNvbih7XG4gICAgICAgICAgICAgICAgICAgIC8vaHRtbDogJzxkaXYgY2xhc3M9XCInK3N0eWxlLmljb25DbGFzc05hbWUrJ1wiIHN0eWxlPVwiIGJvcmRlcjogbm9uZTt3aWR0aDonICsgd2lkdGggKyAncHg7aGVpZ2h0OicgKyBoZWlnaHQgKyAncHg7bWFyZ2luLXRvcDotJyArIGFuY2hvclRvcCArICdweDttYXJnaW4tbGVmdDotJyArIGFuY2hvckxlZnQgKyAncHhcIj48L2Rpdj4nLFxuICAgICAgICAgICAgICAgICAgICBodG1sOiB0aGlzLl9jcmVhdGVIVE1MRWxlbWVudChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBcImNsYXNzXCI6IHN0eWxlLmljb25DbGFzc05hbWVcbiAgICAgICAgICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJib3JkZXJcIjogXCJub25lXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIndpZHRoXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdW5pdHM6IFwicHhcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiaGVpZ2h0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiBcInB4XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgXCJtYXJnaW4tdG9wXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYW5jaG9yVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVuaXRzOiBcInB4XCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBcIm1hcmdpbi1sZWZ0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogYW5jaG9yTGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1bml0czogXCJweFwiXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGljb24gPSBuZXcgTC5pY29uKHtcbiAgICAgICAgICAgICAgICAgICAgaWNvblVybDogTC5JY29uLkRlZmF1bHQuaW1hZ2VQYXRoICsgXCIvbWFya2VyLWljb24ucG5nXCIsXG4gICAgICAgICAgICAgICAgICAgIGljb25BbmNob3I6IFsxMywgNDFdXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaWNvbjogaWNvbixcbiAgICAgICAgICAgICAgICBkaXNhYmxlQ2x1c3RlcmluZzogZGlzYWJsZUNsdXN0ZXJpbmcsXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogb3BhY2l0eVxuICAgICAgICAgICAgfTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9jcmVhdGVIVE1MRWxlbWVudDogZnVuY3Rpb24oZWxlbWVudFR5cGUsIGF0dHJpYnV0ZXMsIHN0eWxlcywgY29udGVudCkge1xuXG4gICAgICAgICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gXCJcIjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXNTdHJpbmcgPSBcIlwiO1xuICAgICAgICAgICAgZm9yICh2YXIgYXR0cktleSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlc1N0cmluZyArPSBhdHRyS2V5ICsgJz1cIicgKyBhdHRyaWJ1dGVzW2F0dHJLZXldICsgJ1wiJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHN0eWxlc1N0cmluZyA9IFwiXCI7XG4gICAgICAgICAgICBmb3IgKHZhciBzdHlsZUtleSBpbiBzdHlsZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgc3R5bGUgPSBzdHlsZXNbc3R5bGVLZXldO1xuICAgICAgICAgICAgICAgIGlmICghc3R5bGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygc3R5bGUgPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUudmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0eWxlc1N0cmluZyArPSBzdHlsZUtleSArIFwiOlwiICsgc3R5bGUudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3R5bGUudW5pdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNTdHJpbmcgKz0gc3R5bGUudW5pdHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHlsZXNTdHJpbmcgKz0gXCI7XCI7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNTdHJpbmcgKz0gc3R5bGVLZXkgKyBcIjpcIiArIHN0eWxlO1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXNTdHJpbmcgKz0gXCI7XCI7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgcmV0dXJuIFwiPFwiICsgZWxlbWVudFR5cGUgKyBcIiBcIiArIGF0dHJpYnV0ZXNTdHJpbmcgKyBcIiBzdHlsZT1cXFwicG9zaXRpb246YWJzb2x1dGU7XCIgKyBzdHlsZXNTdHJpbmcgKyBcIlxcXCI+XCIgKyBjb250ZW50ICsgXCI8L1wiICsgZWxlbWVudFR5cGUgKyBcIj5cIjtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBzdHlsZSBwb3B1cCB0byB0aGUgcmVjZWl2ZWQgZmVhdHVyZXMsIHNvIHRoZSBjYW4gYmUgcmVwcmVzZW50ZWQgYXMgaW50ZW5kZWQgYnkgdGhlIHN0eWxlIGZvciB0aGUgbGF5ZXIuXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtYXJrZXIgLSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnZW9tZXRyeSBlbGVtZW50IGJlaW5nIHN0eWxlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpvb20gLSBOdW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBsZXZlbCB6b29tIHRvIGFwcGx5IHRoZSBzdHlsZS5cbiAgICAgICAgICovXG4gICAgICAgIGFkZFBvcFVwOiBmdW5jdGlvbihtYXJrZXIsIHpvb20pIHtcblxuICAgICAgICAgICAgaWYgKG1hcmtlci5wb3B1cCkge1xuICAgICAgICAgICAgICAgIG1hcmtlci51bmJpbmRQb3B1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHN0eWxlID0gbnVsbDtcbiAgICAgICAgICAgIGlmKG1hcmtlci5mZWF0dXJlICYmIG1hcmtlci5mZWF0dXJlLl9zdHlsZSl7XG4gICAgICAgICAgICAgICAgc3R5bGUgPSBtYXJrZXIuZmVhdHVyZS5fc3R5bGU7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICBzdHlsZSA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2Zmc2V0TGVmdCA9IHN0eWxlLnBvcFVwT2Zmc2V0TGVmdCB8fCAwO1xuICAgICAgICAgICAgdmFyIG9mZnNldFRvcCA9IHN0eWxlLnBvcFVwT2Zmc2V0VG9wIHx8IDA7XG5cblxuICAgICAgICAgICAgdmFyIGNvbnRlbnQsIHByb3BLZXk7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IHt9O1xuICAgICAgICAgICAgaWYgKHN0eWxlLnBvcFVwVGVtcGxhdGUpIHtcblxuXG4gICAgICAgICAgICAgICAgY29udGVudCA9IHRoaXMuX2NvbnRlbnRGcm9tVGVtcGxhdGUobWFya2VyLmZlYXR1cmUsIHN0eWxlLnBvcFVwVGVtcGxhdGUpO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHN0eWxlLnBvcFVwVXJsKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFwiPGlmcmFtZSBzcmM9XCIgKyBzdHlsZS5wb3BVcFVybCArIFwiLz5cIjtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChzdHlsZS5ub1BvcFVwKSB7XG4gICAgICAgICAgICAgICAgbWFya2VyLnVuYmluZFBvcHVwKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRGVmYXVsdCB0ZW1wbGF0ZSwgb25lIGVudHJ5IHBlciBmaWVsZDtcbiAgICAgICAgICAgICAgICBjb250ZW50ID0gdGhpcy5fY29udGVudEZyb21UZW1wbGF0ZShtYXJrZXIuZmVhdHVyZSwgXCJcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgb2Zmc2V0ID0gW29mZnNldExlZnQsIG9mZnNldFRvcF07XG4gICAgICAgICAgICBpZiAoY29udGVudCkge1xuICAgICAgICAgICAgICAgIG1hcmtlci5iaW5kUG9wdXAoY29udGVudCwge1xuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IG9mZnNldFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4iLCJTTUMubGF5ZXJzLnN0eWxlcnMuUEFSU0VSX0ZVTkNUSU9OID0gKGZ1bmN0aW9uKCkge1xuICAvKlxuICAgKiBHZW5lcmF0ZWQgYnkgUEVHLmpzIDAuOC4wLlxuICAgKlxuICAgKiBodHRwOi8vcGVnanMubWFqZGEuY3ovXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHBlZyRzdWJjbGFzcyhjaGlsZCwgcGFyZW50KSB7XG4gICAgZnVuY3Rpb24gY3RvcigpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGNoaWxkOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwYXJlbnQucHJvdG90eXBlO1xuICAgIGNoaWxkLnByb3RvdHlwZSA9IG5ldyBjdG9yKCk7XG4gIH1cblxuICBmdW5jdGlvbiBTeW50YXhFcnJvcihtZXNzYWdlLCBleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgdGhpcy5tZXNzYWdlICA9IG1lc3NhZ2U7XG4gICAgdGhpcy5leHBlY3RlZCA9IGV4cGVjdGVkO1xuICAgIHRoaXMuZm91bmQgICAgPSBmb3VuZDtcbiAgICB0aGlzLm9mZnNldCAgID0gb2Zmc2V0O1xuICAgIHRoaXMubGluZSAgICAgPSBsaW5lO1xuICAgIHRoaXMuY29sdW1uICAgPSBjb2x1bW47XG5cbiAgICB0aGlzLm5hbWUgICAgID0gXCJTeW50YXhFcnJvclwiO1xuICB9XG5cbiAgcGVnJHN1YmNsYXNzKFN5bnRheEVycm9yLCBFcnJvcik7XG5cbiAgZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gYXJndW1lbnRzWzFdIDoge30sXG5cbiAgICAgICAgcGVnJEZBSUxFRCA9IHt9LFxuXG4gICAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbnMgPSB7IHJ1bGVMaXN0OiBwZWckcGFyc2VydWxlTGlzdCB9LFxuICAgICAgICBwZWckc3RhcnRSdWxlRnVuY3Rpb24gID0gcGVnJHBhcnNlcnVsZUxpc3QsXG5cbiAgICAgICAgcGVnJGMwID0gW10sXG4gICAgICAgIHBlZyRjMSA9IGZ1bmN0aW9uKHJ1bGVzKSB7cmV0dXJuIHJ1bGVzLmpvaW4oXCJcXG5cIil9LFxuICAgICAgICBwZWckYzIgPSBwZWckRkFJTEVELFxuICAgICAgICBwZWckYzMgPSBmdW5jdGlvbihjb25kaXRpb25zLCBtZW1iZXJzKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmKGNvbmRpdGlvbnMgIT0gbnVsbCAmJiBjb25kaXRpb25zICE9IFwiXCIpe1xuICAgICAgICAgICAgICAgcmVzdWx0ID0gY29uZGl0aW9ucyArIFwie1wiICsgbWVtYmVycy5qb2luKFwiO1wiKSArIFwiO1wiICsgXCJ9XCI7XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gbWVtYmVycy5qb2luKFwiO1wiKSArIFwiO1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICB9LFxuICAgICAgICBwZWckYzQgPSBmdW5jdGlvbihmaXJzdCwgcmVzdCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICB2YXIgcmVzdWx0X3N0YXJ0ID0gXCJpZihcIjtcbiAgICAgICAgICAgIHZhciByZXN1bHRfZW5kID0gXCIpXCI7XG4gICAgICAgICAgICBpZihyZXN0ICE9IFwiXCIpe1xuICAgICAgICAgICAgICByZXN1bHQgPSByZXN1bHRfc3RhcnQgKyBmaXJzdCArIFwiIHx8IFwiICsgcmVzdC5qb2luKFwiIHx8IFwiKSArIHJlc3VsdF9lbmQ7XG4gICAgICAgICAgICB9ZWxzZSBpZihmaXJzdCAhPSBcIlwiKXtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0X3N0YXJ0ICsgZmlyc3QgKyByZXN1bHRfZW5kO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IFwiXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjNSA9IGZ1bmN0aW9uKGNvbmQpIHsgcmV0dXJuIGNvbmQ7fSxcbiAgICAgICAgcGVnJGM2ID0gbnVsbCxcbiAgICAgICAgcGVnJGM3ID0gZnVuY3Rpb24oZ3QsIHosIHp2LCBhY2wsIGZjKSB7XG4gICAgICAgICAgICB2YXIgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgICAgIGlmKGd0ID09IFwiKlwiKXtcbiAgICAgICAgICAgICAgaWYoenYgIT0gbnVsbCB8fCBhY2wgIT0gXCJcIil7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKFwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHp2ICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSB6djtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihhY2wgIT0gXCJcIiAmJiB6diAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgJiYgXCIgKyBhY2w7XG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhY2w7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoZmMgIT0gbnVsbCAmJiAoYWNsICE9IFwiXCIgfHwgenYgIT0gbnVsbCkpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIiAmJiBcIiArIGZjO1xuICAgICAgICAgICAgICB9ZWxzZSBpZihmYyAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gZmM7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoenYgIT0gbnVsbCB8fCBhY2wgIT0gXCJcIil7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiKVwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgaWYoZ3QgIT0gbnVsbCB8fCB6diAhPSBudWxsIHx8IGFjbCAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCI7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoZ3QgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiZmVhdHVyZS5nZW9tZXRyeS50eXBlID09IFwiICsgXCInXCIgKyBndCArIFwiJ1wiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKHp2ICE9IG51bGwgJiYgZ3QgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiICYmIFwiICsgenY7XG4gICAgICAgICAgICAgIH1lbHNlIGlmKHp2ICE9IG51bGwgJiYgZ3QgPT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IHp2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmKGFjbCAhPSBcIlwiICYmICh6diAhPSBudWxsIHx8IGd0ICE9IG51bGwpKXtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgJiYgXCIgKyBhY2w7XG4gICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBhY2w7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYoZmMgIT0gbnVsbCAmJiAoYWNsICE9IFwiXCIgfHwgenYgIT0gbnVsbCB8fCBndCAhPSBudWxsKSl7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiICYmIFwiICsgZmM7XG4gICAgICAgICAgICAgIH1lbHNlIGlmKGZjICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBmYztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZihndCAhPSBudWxsIHx8IHp2ICE9IG51bGwgfHwgYWNsICE9IG51bGwpe1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjOCA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlKSB7XG4gICAgICAgICAgICAgIHZhciByZXMgPSBudWxsO1xuICAgICAgICAgICAgICBpZihpc05hTih2YWx1ZSkpe1xuICAgICAgICAgICAgICAgIGlmKHZhbHVlLmluZGV4T2YoXCJjbGFzc1wiKSA+IC0xKXtcbiAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZShcImNsYXNzPVwiLCBcImNsYXNzPVxcXCJcIik7XG4gICAgICAgICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoXCI+XCIsIFwiXFxcIj5cIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzID0gXCJzdHlsZS5cIiArIG5hbWUgKyBcIiA9IFwiICsgXCInXCIgKyB2YWx1ZSArIFwiJ1wiO1xuICAgICAgICAgICAgICAgIGlmKHZhbHVlLmluZGV4T2YoXCJbXCIpID4gLTEpe1xuICAgICAgICAgICAgICAgICAgcmVzID0gXCJzdHlsZS5cIiArIG5hbWUgKyBcIiA9IFwiICsgdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9ZWxzZXtcbiAgICAgICAgICAgICAgICByZXMgPSBcInN0eWxlLlwiICsgbmFtZSArIFwiID0gXCIgKyB2YWx1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGM5ID0gL15bYS16QS1aMC05X10vLFxuICAgICAgICBwZWckYzEwID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlthLXpBLVowLTlfXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05X11cIiB9LFxuICAgICAgICBwZWckYzExID0gXCItXCIsXG4gICAgICAgIHBlZyRjMTIgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCItXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCItXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTMgPSBmdW5jdGlvbihmaXJzdCwgc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGlmKHNlY29uZC5sZW5ndGggPiAwKXtcbiAgICAgICAgICAgICAgc2Vjb25kWzBdID0gc2Vjb25kWzBdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHJlcyA9IGZpcnN0LmpvaW4oXCJcIikgKyBzZWNvbmQuam9pbihcIlwiKTtcbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICByZXMgPSBmaXJzdC5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICAgIH0sXG4gICAgICAgIHBlZyRjMTQgPSBmdW5jdGlvbihzdHIpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBcIlwiO1xuICAgICAgICAgICAgaWYoc3RyID09IFwid2lkdGhcIil7XG4gICAgICAgICAgICAgIHJlcyA9IFwic3Ryb2tlV2lkdGhcIjtcbiAgICAgICAgICAgIH1lbHNlIGlmKHN0ciA9PSBcImNvbG9yXCIpe1xuICAgICAgICAgICAgICByZXMgPSBcInN0cm9rZUNvbG9yXCI7XG4gICAgICAgICAgICB9ZWxzZSBpZihzdHIgPT0gXCJkYXNoZXNcIil7XG4gICAgICAgICAgICAgIHJlcyA9IFwiZGFzaEFycmF5XCI7XG4gICAgICAgICAgICB9ZWxzZSBpZihzdHIgPT0gXCJsaW5lY2FwXCIpe1xuICAgICAgICAgICAgICByZXMgPSBcInN0cm9rZUNhcFwiO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHJlcyA9IHN0cjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxNSA9IFwielwiLFxuICAgICAgICBwZWckYzE2ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwielwiLCBkZXNjcmlwdGlvbjogXCJcXFwielxcXCJcIiB9LFxuICAgICAgICBwZWckYzE3ID0gZnVuY3Rpb24obWluLCB6aSwgbWF4KSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGlmKHppICE9IG51bGwpe1xuICAgICAgICAgICAgICBpZihtaW4gIT0gbnVsbCAmJiBtYXggIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmVzID0gXCJ6b29tID4gXCIgKyBtaW4gKyBcIiAmJiB6b29tIDwgXCIgKyBtYXg7XG4gICAgICAgICAgICAgIH1lbHNlIGlmKG1pbiAhPSBudWxsICYmIG1heCA9PSBudWxsKXtcbiAgICAgICAgICAgICAgICByZXMgPSBcInpvb20gPj0gXCIgKyBtaW47XG4gICAgICAgICAgICAgIH1lbHNlIGlmKG1pbiA9PSBudWxsICYmIG1heCAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICByZXMgPSBcInpvb20gPD0gXCIgKyBtYXg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICBpZihtaW4gIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgcmVzID0gXCJ6b29tID09IFwiICsgbWluO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxOCA9IGZ1bmN0aW9uKGF0cl9jb25kaXRpb25zKSB7cmV0dXJuIGF0cl9jb25kaXRpb25zLmpvaW4oXCIgJiYgXCIpO30sXG4gICAgICAgIHBlZyRjMTkgPSBmdW5jdGlvbihjb21wKSB7cmV0dXJuIGNvbXA7fSxcbiAgICAgICAgcGVnJGMyMCA9IGZ1bmN0aW9uKGZpcnN0LCBvcCwgc2Vjb25kKSB7XG4gICAgICAgICAgICB2YXIgcmVzID0gXCJcIjtcbiAgICAgICAgICAgIGlmKGlzTmFOKHNlY29uZCkpe1xuICAgICAgICAgICAgICByZXMgPSBcImZlYXR1cmUucHJvcGVydGllcy5cIiArIGZpcnN0ICsgXCIgXCIgKyBvcCArIFwiICdcIiArIHNlY29uZCArIFwiJ1wiO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHJlcyA9IFwiZmVhdHVyZS5wcm9wZXJ0aWVzLlwiICsgZmlyc3QgKyBcIiBcIiArIG9wICsgXCIgXCIgKyBzZWNvbmQgKyBcIlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMyMSA9IGZ1bmN0aW9uKGZhY3RvciwgZXEpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBudWxsO1xuICAgICAgICAgICAgaWYoZXEgIT0gbnVsbCl7XG4gICAgICAgICAgICAgIHJlcyA9IGZhY3RvciArIFwiPVwiO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHJlcyA9IGZhY3RvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMyMiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCI8XCJ9LFxuICAgICAgICBwZWckYzIzID0gZnVuY3Rpb24oKSB7cmV0dXJuIFwiPlwifSxcbiAgICAgICAgcGVnJGMyNCA9IGZ1bmN0aW9uKCkge3JldHVybiBcIj09XCJ9LFxuICAgICAgICBwZWckYzI1ID0gXCI6XCIsXG4gICAgICAgIHBlZyRjMjYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI6XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI6XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMjcgPSBmdW5jdGlvbihzdHIpIHtyZXR1cm4gXCJmZWF0dXJlLlwiICsgc3RyO30sXG4gICAgICAgIHBlZyRjMjggPSBcIltcIixcbiAgICAgICAgcGVnJGMyOSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIltcIiwgZGVzY3JpcHRpb246IFwiXFxcIltcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzMCA9IFwie1wiLFxuICAgICAgICBwZWckYzMxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwie1wiLCBkZXNjcmlwdGlvbjogXCJcXFwie1xcXCJcIiB9LFxuICAgICAgICBwZWckYzMyID0gXCJdXCIsXG4gICAgICAgIHBlZyRjMzMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJdXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJdXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMzQgPSBcIn1cIixcbiAgICAgICAgcGVnJGMzNSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIn1cIiwgZGVzY3JpcHRpb246IFwiXFxcIn1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGMzNiA9IFwiO1wiLFxuICAgICAgICBwZWckYzM3ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiO1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiO1xcXCJcIiB9LFxuICAgICAgICBwZWckYzM4ID0gXCIsXCIsXG4gICAgICAgIHBlZyRjMzkgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIsXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIsXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDAgPSBcInxcIixcbiAgICAgICAgcGVnJGM0MSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInxcIiwgZGVzY3JpcHRpb246IFwiXFxcInxcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0MiA9IFwiPFwiLFxuICAgICAgICBwZWckYzQzID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiPFwiLCBkZXNjcmlwdGlvbjogXCJcXFwiPFxcXCJcIiB9LFxuICAgICAgICBwZWckYzQ0ID0gXCI+XCIsXG4gICAgICAgIHBlZyRjNDUgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCI+XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCI+XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNDYgPSBcIj1cIixcbiAgICAgICAgcGVnJGM0NyA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIj1cIiwgZGVzY3JpcHRpb246IFwiXFxcIj1cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM0OCA9IHsgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogXCJ3aGl0ZXNwYWNlXCIgfSxcbiAgICAgICAgcGVnJGM0OSA9IC9eWyBcXHRcXG5cXHJdLyxcbiAgICAgICAgcGVnJGM1MCA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIFxcXFx0XFxcXG5cXFxccl1cIiwgZGVzY3JpcHRpb246IFwiWyBcXFxcdFxcXFxuXFxcXHJdXCIgfSxcbiAgICAgICAgcGVnJGM1MSA9IFwiZmFsc2VcIixcbiAgICAgICAgcGVnJGM1MiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImZhbHNlXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJmYWxzZVxcXCJcIiB9LFxuICAgICAgICBwZWckYzUzID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfSxcbiAgICAgICAgcGVnJGM1NCA9IFwibnVsbFwiLFxuICAgICAgICBwZWckYzU1ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwibnVsbFwiLCBkZXNjcmlwdGlvbjogXCJcXFwibnVsbFxcXCJcIiB9LFxuICAgICAgICBwZWckYzU2ID0gZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyAgfSxcbiAgICAgICAgcGVnJGM1NyA9IFwidHJ1ZVwiLFxuICAgICAgICBwZWckYzU4ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidHJ1ZVwiLCBkZXNjcmlwdGlvbjogXCJcXFwidHJ1ZVxcXCJcIiB9LFxuICAgICAgICBwZWckYzU5ID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyAgfSxcbiAgICAgICAgcGVnJGM2MCA9IFwiUG9pbnRcIixcbiAgICAgICAgcGVnJGM2MSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIlBvaW50XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJQb2ludFxcXCJcIiB9LFxuICAgICAgICBwZWckYzYyID0gXCJNdWx0aVBvaW50XCIsXG4gICAgICAgIHBlZyRjNjMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJNdWx0aVBvaW50XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJNdWx0aVBvaW50XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNjQgPSBcIkxpbmVTdHJpbmdcIixcbiAgICAgICAgcGVnJGM2NSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIkxpbmVTdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiXFxcIkxpbmVTdHJpbmdcXFwiXCIgfSxcbiAgICAgICAgcGVnJGM2NiA9IFwiTXVsdGlMaW5lU3RyaW5nXCIsXG4gICAgICAgIHBlZyRjNjcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJNdWx0aUxpbmVTdHJpbmdcIiwgZGVzY3JpcHRpb246IFwiXFxcIk11bHRpTGluZVN0cmluZ1xcXCJcIiB9LFxuICAgICAgICBwZWckYzY4ID0gXCJQb2x5Z29uXCIsXG4gICAgICAgIHBlZyRjNjkgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJQb2x5Z29uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJQb2x5Z29uXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNzAgPSBcIk11bHRpUG9seWdvblwiLFxuICAgICAgICBwZWckYzcxID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiTXVsdGlQb2x5Z29uXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJNdWx0aVBvbHlnb25cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM3MiA9IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgICAgIHBlZyRjNzMgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJHZW9tZXRyeUNvbGxlY3Rpb25cIiwgZGVzY3JpcHRpb246IFwiXFxcIkdlb21ldHJ5Q29sbGVjdGlvblxcXCJcIiB9LFxuICAgICAgICBwZWckYzc0ID0gXCIqXCIsXG4gICAgICAgIHBlZyRjNzUgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIqXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIqXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjNzYgPSB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IFwibnVtYmVyXCIgfSxcbiAgICAgICAgcGVnJGM3NyA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0ZXh0KCkpOyB9LFxuICAgICAgICBwZWckYzc4ID0gZnVuY3Rpb24oZmlyc3QsIHJlc3QpIHtcbiAgICAgICAgICAgIHZhciByZXMgPSBcIlwiO1xuICAgICAgICAgICAgaWYocmVzdCAhPSBcIlwiKXtcbiAgICAgICAgICAgICAgcmVzID0gXCJbXCIgKyBmaXJzdCArIFwiLFwiICsgcmVzdC5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgIHJlcyA9IGZpcnN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICB9LFxuICAgICAgICBwZWckYzc5ID0gZnVuY3Rpb24obikge3JldHVybiBuO30sXG4gICAgICAgIHBlZyRjODAgPSBcIi5cIixcbiAgICAgICAgcGVnJGM4MSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcIi5cIiwgZGVzY3JpcHRpb246IFwiXFxcIi5cXFwiXCIgfSxcbiAgICAgICAgcGVnJGM4MiA9IC9eWzEtOV0vLFxuICAgICAgICBwZWckYzgzID0geyB0eXBlOiBcImNsYXNzXCIsIHZhbHVlOiBcIlsxLTldXCIsIGRlc2NyaXB0aW9uOiBcIlsxLTldXCIgfSxcbiAgICAgICAgcGVnJGM4NCA9IC9eW2VFXS8sXG4gICAgICAgIHBlZyRjODUgPSB7IHR5cGU6IFwiY2xhc3NcIiwgdmFsdWU6IFwiW2VFXVwiLCBkZXNjcmlwdGlvbjogXCJbZUVdXCIgfSxcbiAgICAgICAgcGVnJGM4NiA9IFwiK1wiLFxuICAgICAgICBwZWckYzg3ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiK1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiK1xcXCJcIiB9LFxuICAgICAgICBwZWckYzg4ID0gXCIwXCIsXG4gICAgICAgIHBlZyRjODkgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCIwXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCIwXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjOTAgPSBmdW5jdGlvbihjaGFycykge3JldHVybiBjaGFycy5qb2luKFwiXCIpfSxcbiAgICAgICAgcGVnJGM5MSA9IC9eW2EtekEtWjAtOV9cXC1dLyxcbiAgICAgICAgcGVnJGM5MiA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbYS16QS1aMC05X1xcXFwtXVwiLCBkZXNjcmlwdGlvbjogXCJbYS16QS1aMC05X1xcXFwtXVwiIH0sXG4gICAgICAgIHBlZyRjOTMgPSB7IHR5cGU6IFwib3RoZXJcIiwgZGVzY3JpcHRpb246IFwic3RyaW5nXCIgfSxcbiAgICAgICAgcGVnJGM5NCA9IGZ1bmN0aW9uKGNoYXJzKSB7IHJldHVybiBjaGFycy5qb2luKFwiXCIpOyB9LFxuICAgICAgICBwZWckYzk1ID0gXCJcXFwiXCIsXG4gICAgICAgIHBlZyRjOTYgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFwiXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcIlxcXCJcIiB9LFxuICAgICAgICBwZWckYzk3ID0gXCJcXFxcXCIsXG4gICAgICAgIHBlZyRjOTggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJcXFxcXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJcXFxcXFxcXFxcXCJcIiB9LFxuICAgICAgICBwZWckYzk5ID0gXCIvXCIsXG4gICAgICAgIHBlZyRjMTAwID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiL1wiLCBkZXNjcmlwdGlvbjogXCJcXFwiL1xcXCJcIiB9LFxuICAgICAgICBwZWckYzEwMSA9IFwiYlwiLFxuICAgICAgICBwZWckYzEwMiA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcImJcIiwgZGVzY3JpcHRpb246IFwiXFxcImJcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMDMgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFxiXCI7IH0sXG4gICAgICAgIHBlZyRjMTA0ID0gXCJmXCIsXG4gICAgICAgIHBlZyRjMTA1ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwiZlwiLCBkZXNjcmlwdGlvbjogXCJcXFwiZlxcXCJcIiB9LFxuICAgICAgICBwZWckYzEwNiA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXGZcIjsgfSxcbiAgICAgICAgcGVnJGMxMDcgPSBcIm5cIixcbiAgICAgICAgcGVnJGMxMDggPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJuXCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJuXFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTA5ID0gZnVuY3Rpb24oKSB7IHJldHVybiBcIlxcblwiOyB9LFxuICAgICAgICBwZWckYzExMCA9IFwiclwiLFxuICAgICAgICBwZWckYzExMSA9IHsgdHlwZTogXCJsaXRlcmFsXCIsIHZhbHVlOiBcInJcIiwgZGVzY3JpcHRpb246IFwiXFxcInJcXFwiXCIgfSxcbiAgICAgICAgcGVnJGMxMTIgPSBmdW5jdGlvbigpIHsgcmV0dXJuIFwiXFxyXCI7IH0sXG4gICAgICAgIHBlZyRjMTEzID0gXCJ0XCIsXG4gICAgICAgIHBlZyRjMTE0ID0geyB0eXBlOiBcImxpdGVyYWxcIiwgdmFsdWU6IFwidFwiLCBkZXNjcmlwdGlvbjogXCJcXFwidFxcXCJcIiB9LFxuICAgICAgICBwZWckYzExNSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJcXHRcIjsgfSxcbiAgICAgICAgcGVnJGMxMTYgPSBcInVcIixcbiAgICAgICAgcGVnJGMxMTcgPSB7IHR5cGU6IFwibGl0ZXJhbFwiLCB2YWx1ZTogXCJ1XCIsIGRlc2NyaXB0aW9uOiBcIlxcXCJ1XFxcIlwiIH0sXG4gICAgICAgIHBlZyRjMTE4ID0gZnVuY3Rpb24oZGlnaXRzKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChkaWdpdHMsIDE2KSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgcGVnJGMxMTkgPSBmdW5jdGlvbihzZXF1ZW5jZSkgeyByZXR1cm4gc2VxdWVuY2U7IH0sXG4gICAgICAgIHBlZyRjMTIwID0gL15bIC0hIy1bXFxdLVxcdTEwRkZGRl0vLFxuICAgICAgICBwZWckYzEyMSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbIC0hIy1bXFxcXF0tXFxcXHUxMEZGRkZdXCIsIGRlc2NyaXB0aW9uOiBcIlsgLSEjLVtcXFxcXS1cXFxcdTEwRkZGRl1cIiB9LFxuICAgICAgICBwZWckYzEyMiA9IC9eWzAtOV0vLFxuICAgICAgICBwZWckYzEyMyA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05XVwiLCBkZXNjcmlwdGlvbjogXCJbMC05XVwiIH0sXG4gICAgICAgIHBlZyRjMTI0ID0gL15bMC05YS1mXS9pLFxuICAgICAgICBwZWckYzEyNSA9IHsgdHlwZTogXCJjbGFzc1wiLCB2YWx1ZTogXCJbMC05YS1mXWlcIiwgZGVzY3JpcHRpb246IFwiWzAtOWEtZl1pXCIgfSxcblxuICAgICAgICBwZWckY3VyclBvcyAgICAgICAgICA9IDAsXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyAgICAgID0gMCxcbiAgICAgICAgcGVnJGNhY2hlZFBvcyAgICAgICAgPSAwLFxuICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH0sXG4gICAgICAgIHBlZyRtYXhGYWlsUG9zICAgICAgID0gMCxcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCAgPSBbXSxcbiAgICAgICAgcGVnJHNpbGVudEZhaWxzICAgICAgPSAwLFxuXG4gICAgICAgIHBlZyRyZXN1bHQ7XG5cbiAgICBpZiAoXCJzdGFydFJ1bGVcIiBpbiBvcHRpb25zKSB7XG4gICAgICBpZiAoIShvcHRpb25zLnN0YXJ0UnVsZSBpbiBwZWckc3RhcnRSdWxlRnVuY3Rpb25zKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCBwYXJzaW5nIGZyb20gcnVsZSBcXFwiXCIgKyBvcHRpb25zLnN0YXJ0UnVsZSArIFwiXFxcIi5cIik7XG4gICAgICB9XG5cbiAgICAgIHBlZyRzdGFydFJ1bGVGdW5jdGlvbiA9IHBlZyRzdGFydFJ1bGVGdW5jdGlvbnNbb3B0aW9ucy5zdGFydFJ1bGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRleHQoKSB7XG4gICAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKHBlZyRyZXBvcnRlZFBvcywgcGVnJGN1cnJQb3MpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9mZnNldCgpIHtcbiAgICAgIHJldHVybiBwZWckcmVwb3J0ZWRQb3M7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbGluZSgpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5saW5lO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvbHVtbigpIHtcbiAgICAgIHJldHVybiBwZWckY29tcHV0ZVBvc0RldGFpbHMocGVnJHJlcG9ydGVkUG9zKS5jb2x1bW47XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0ZWQoZGVzY3JpcHRpb24pIHtcbiAgICAgIHRocm93IHBlZyRidWlsZEV4Y2VwdGlvbihcbiAgICAgICAgbnVsbCxcbiAgICAgICAgW3sgdHlwZTogXCJvdGhlclwiLCBkZXNjcmlwdGlvbjogZGVzY3JpcHRpb24gfV0sXG4gICAgICAgIHBlZyRyZXBvcnRlZFBvc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcihtZXNzYWdlKSB7XG4gICAgICB0aHJvdyBwZWckYnVpbGRFeGNlcHRpb24obWVzc2FnZSwgbnVsbCwgcGVnJHJlcG9ydGVkUG9zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckY29tcHV0ZVBvc0RldGFpbHMocG9zKSB7XG4gICAgICBmdW5jdGlvbiBhZHZhbmNlKGRldGFpbHMsIHN0YXJ0UG9zLCBlbmRQb3MpIHtcbiAgICAgICAgdmFyIHAsIGNoO1xuXG4gICAgICAgIGZvciAocCA9IHN0YXJ0UG9zOyBwIDwgZW5kUG9zOyBwKyspIHtcbiAgICAgICAgICBjaCA9IGlucHV0LmNoYXJBdChwKTtcbiAgICAgICAgICBpZiAoY2ggPT09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgIGlmICghZGV0YWlscy5zZWVuQ1IpIHsgZGV0YWlscy5saW5lKys7IH1cbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBkZXRhaWxzLmxpbmUrKztcbiAgICAgICAgICAgIGRldGFpbHMuY29sdW1uID0gMTtcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGV0YWlscy5jb2x1bW4rKztcbiAgICAgICAgICAgIGRldGFpbHMuc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChwZWckY2FjaGVkUG9zICE9PSBwb3MpIHtcbiAgICAgICAgaWYgKHBlZyRjYWNoZWRQb3MgPiBwb3MpIHtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zID0gMDtcbiAgICAgICAgICBwZWckY2FjaGVkUG9zRGV0YWlscyA9IHsgbGluZTogMSwgY29sdW1uOiAxLCBzZWVuQ1I6IGZhbHNlIH07XG4gICAgICAgIH1cbiAgICAgICAgYWR2YW5jZShwZWckY2FjaGVkUG9zRGV0YWlscywgcGVnJGNhY2hlZFBvcywgcG9zKTtcbiAgICAgICAgcGVnJGNhY2hlZFBvcyA9IHBvcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHBlZyRjYWNoZWRQb3NEZXRhaWxzO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRmYWlsKGV4cGVjdGVkKSB7XG4gICAgICBpZiAocGVnJGN1cnJQb3MgPCBwZWckbWF4RmFpbFBvcykgeyByZXR1cm47IH1cblxuICAgICAgaWYgKHBlZyRjdXJyUG9zID4gcGVnJG1heEZhaWxQb3MpIHtcbiAgICAgICAgcGVnJG1heEZhaWxQb3MgPSBwZWckY3VyclBvcztcbiAgICAgICAgcGVnJG1heEZhaWxFeHBlY3RlZCA9IFtdO1xuICAgICAgfVxuXG4gICAgICBwZWckbWF4RmFpbEV4cGVjdGVkLnB1c2goZXhwZWN0ZWQpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRidWlsZEV4Y2VwdGlvbihtZXNzYWdlLCBleHBlY3RlZCwgcG9zKSB7XG4gICAgICBmdW5jdGlvbiBjbGVhbnVwRXhwZWN0ZWQoZXhwZWN0ZWQpIHtcbiAgICAgICAgdmFyIGkgPSAxO1xuXG4gICAgICAgIGV4cGVjdGVkLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgIGlmIChhLmRlc2NyaXB0aW9uIDwgYi5kZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYS5kZXNjcmlwdGlvbiA+IGIuZGVzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHdoaWxlIChpIDwgZXhwZWN0ZWQubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGV4cGVjdGVkW2kgLSAxXSA9PT0gZXhwZWN0ZWRbaV0pIHtcbiAgICAgICAgICAgIGV4cGVjdGVkLnNwbGljZShpLCAxKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBidWlsZE1lc3NhZ2UoZXhwZWN0ZWQsIGZvdW5kKSB7XG4gICAgICAgIGZ1bmN0aW9uIHN0cmluZ0VzY2FwZShzKSB7XG4gICAgICAgICAgZnVuY3Rpb24gaGV4KGNoKSB7IHJldHVybiBjaC5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpOyB9XG5cbiAgICAgICAgICByZXR1cm4gc1xuICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFwvZywgICAnXFxcXFxcXFwnKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1wiL2csICAgICdcXFxcXCInKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx0L2csICAgJ1xcXFx0JylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXG4vZywgICAnXFxcXG4nKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcZi9nLCAgICdcXFxcZicpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFxyL2csICAgJ1xcXFxyJylcbiAgICAgICAgICAgIC5yZXBsYWNlKC9bXFx4MDAtXFx4MDdcXHgwQlxceDBFXFx4MEZdL2csIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgwJyArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xceDEwLVxceDFGXFx4ODAtXFx4RkZdL2csICAgIGZ1bmN0aW9uKGNoKSB7IHJldHVybiAnXFxcXHgnICArIGhleChjaCk7IH0pXG4gICAgICAgICAgICAucmVwbGFjZSgvW1xcdTAxODAtXFx1MEZGRl0vZywgICAgICAgICBmdW5jdGlvbihjaCkgeyByZXR1cm4gJ1xcXFx1MCcgKyBoZXgoY2gpOyB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL1tcXHUxMDgwLVxcdUZGRkZdL2csICAgICAgICAgZnVuY3Rpb24oY2gpIHsgcmV0dXJuICdcXFxcdScgICsgaGV4KGNoKTsgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZXhwZWN0ZWREZXNjcyA9IG5ldyBBcnJheShleHBlY3RlZC5sZW5ndGgpLFxuICAgICAgICAgICAgZXhwZWN0ZWREZXNjLCBmb3VuZERlc2MsIGk7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGV4cGVjdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgZXhwZWN0ZWREZXNjc1tpXSA9IGV4cGVjdGVkW2ldLmRlc2NyaXB0aW9uO1xuICAgICAgICB9XG5cbiAgICAgICAgZXhwZWN0ZWREZXNjID0gZXhwZWN0ZWQubGVuZ3RoID4gMVxuICAgICAgICAgID8gZXhwZWN0ZWREZXNjcy5zbGljZSgwLCAtMSkuam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICAgKyBleHBlY3RlZERlc2NzW2V4cGVjdGVkLmxlbmd0aCAtIDFdXG4gICAgICAgICAgOiBleHBlY3RlZERlc2NzWzBdO1xuXG4gICAgICAgIGZvdW5kRGVzYyA9IGZvdW5kID8gXCJcXFwiXCIgKyBzdHJpbmdFc2NhcGUoZm91bmQpICsgXCJcXFwiXCIgOiBcImVuZCBvZiBpbnB1dFwiO1xuXG4gICAgICAgIHJldHVybiBcIkV4cGVjdGVkIFwiICsgZXhwZWN0ZWREZXNjICsgXCIgYnV0IFwiICsgZm91bmREZXNjICsgXCIgZm91bmQuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBwb3NEZXRhaWxzID0gcGVnJGNvbXB1dGVQb3NEZXRhaWxzKHBvcyksXG4gICAgICAgICAgZm91bmQgICAgICA9IHBvcyA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChwb3MpIDogbnVsbDtcblxuICAgICAgaWYgKGV4cGVjdGVkICE9PSBudWxsKSB7XG4gICAgICAgIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIG1lc3NhZ2UgIT09IG51bGwgPyBtZXNzYWdlIDogYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCksXG4gICAgICAgIGV4cGVjdGVkLFxuICAgICAgICBmb3VuZCxcbiAgICAgICAgcG9zLFxuICAgICAgICBwb3NEZXRhaWxzLmxpbmUsXG4gICAgICAgIHBvc0RldGFpbHMuY29sdW1uXG4gICAgICApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXJ1bGVMaXN0KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VydWxlKCk7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlcnVsZSgpO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMShzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlcnVsZSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZWNvbmRpdGlvbl9saXN0KCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2ViZWdpbl9vYmplY3QoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZW1lbWJlcigpO1xuICAgICAgICAgIHdoaWxlIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZW1lbWJlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlZW5kX29iamVjdCgpO1xuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjMyhzMSwgczMpO1xuICAgICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vjb25kaXRpb25fbGlzdCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlY29uZGl0aW9uKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBbXTtcbiAgICAgICAgczMgPSBwZWckcGFyc2Vjb25kaXRpb25fY29tbWEoKTtcbiAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2Vjb25kaXRpb25fY29tbWEoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNChzMSwgczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vjb25kaXRpb25fY29tbWEoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMjtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlY29tbWFfc2VwYXJhdG9yKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2Vjb25kaXRpb24oKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzUoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vjb25kaXRpb24oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlZ2VvbWV0cnlUeXBlKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckYzY7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2V6b29tKCk7XG4gICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gcGVnJGM2O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlem9vbV92YWx1ZSgpO1xuICAgICAgICAgIGlmIChzMyA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczMgPSBwZWckYzY7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2VhdHRyaWJ1dGVfY29uZGl0aW9uX2xpc3QoKTtcbiAgICAgICAgICAgIGlmIChzNCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRjNjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBzNSA9IHBlZyRwYXJzZWZlYXR1cmVfY29uZGl0aW9uKCk7XG4gICAgICAgICAgICAgIGlmIChzNSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHM1ID0gcGVnJGM2O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzNSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMxID0gcGVnJGM3KHMxLCBzMiwgczMsIHM0LCBzNSk7XG4gICAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW1lbWJlcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXN0cmluZ19tZW1iZXIoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZW5hbWVfc2VwYXJhdG9yKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlb3BlcmFuZCgpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczQgPSBwZWckcGFyc2V2YWx1ZV9zZXBhcmF0b3IoKTtcbiAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgICAgczEgPSBwZWckYzgoczEsIHMzKTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyaW5nX21lbWJlcigpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgczAgPSBwZWckcGFyc2VoeXBoZW5fbWVtYmVyKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2Vjb21wbGV4X21lbWJlcigpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaHlwaGVuX21lbWJlcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgaWYgKHBlZyRjOS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMyID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwKTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBpZiAocGVnJGM5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICBzMiA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwKTsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NSkge1xuICAgICAgICAgIHMyID0gcGVnJGMxMTtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTIpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBpZiAocGVnJGM5LnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgICAgIHM0ID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMCk7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMy5wdXNoKHM0KTtcbiAgICAgICAgICAgIGlmIChwZWckYzkudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICAgICAgICBzNCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzNCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMCk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICAgIHMxID0gcGVnJGMxMyhzMSwgczMpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNvbXBsZXhfbWVtYmVyKCkge1xuICAgICAgdmFyIHMwLCBzMTtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlc3RyaW5nX3dxKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgIHMxID0gcGVnJGMxNChzMSk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlem9vbV92YWx1ZSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMywgczQ7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMikge1xuICAgICAgICBzMSA9IHBlZyRjMTU7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxNik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjNjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZXpvb21faW50ZXJ2YWwoKTtcbiAgICAgICAgICBpZiAoczMgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMzID0gcGVnJGM2O1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgICAgICAgICBpZiAoczQgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczQgPSBwZWckYzY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICAgIHMxID0gcGVnJGMxNyhzMiwgczMsIHM0KTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlYXR0cmlidXRlX2NvbmRpdGlvbl9saXN0KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IFtdO1xuICAgICAgczIgPSBwZWckcGFyc2VhdHRyaWJ1dGVfY29uZGl0aW9uKCk7XG4gICAgICB3aGlsZSAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEucHVzaChzMik7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlYXR0cmlidXRlX2NvbmRpdGlvbigpO1xuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMTgoczEpO1xuICAgICAgfVxuICAgICAgczAgPSBzMTtcblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWF0dHJpYnV0ZV9jb25kaXRpb24oKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZWJlZ2luX2FycmF5KCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2Vjb21wYXJhaXNvbigpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZWVuZF9hcnJheSgpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgICBzMSA9IHBlZyRjMTkoczIpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNvbXBhcmFpc29uKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VvcGVyYW5kKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VvcGVyYXRvcigpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZW9wZXJhbmQoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzIwKHMxLCBzMiwgczMpO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW9wZXJhbmQoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckcGFyc2VudW1iZXJfYXJyYXkoKTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckcGFyc2VzdHJpbmdfd3EoKTtcbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMwID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VvcGVyYXRvcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2VmYWN0b3IoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWVxdWFsX3RoYW4oKTtcbiAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzIxKHMxLCBzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZhY3RvcigpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZWxlc3NfdGhhbigpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICBzMSA9IHBlZyRjMjIoKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2VncmVhdGVyX3RoYW4oKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczA7XG4gICAgICAgICAgczEgPSBwZWckYzIzKCk7XG4gICAgICAgIH1cbiAgICAgICAgczAgPSBzMTtcbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgICBzMSA9IHBlZyRwYXJzZWVxdWFsX3RoYW4oKTtcbiAgICAgICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzI0KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZlYXR1cmVfY29uZGl0aW9uKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczI7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU4KSB7XG4gICAgICAgIHMxID0gcGVnJGMyNTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgICAgfVxuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlc3RyaW5nX3dxKCk7XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgIHMxID0gcGVnJGMyNyhzMik7XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWJlZ2luX2FycmF5KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTEpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjg7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI5KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWJlZ2luX29iamVjdCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyMykge1xuICAgICAgICAgIHMyID0gcGVnJGMzMDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzEpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2V3cygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZW5kX2FycmF5KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTMpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMzI7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzMzKTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWVuZF9vYmplY3QoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMjUpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMzQ7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzM1KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZW5hbWVfc2VwYXJhdG9yKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNld3MoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHMxID0gW3MxLCBzMiwgczNdO1xuICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWZlYXR1cmVfY29uZGl0aW9uX3NlcGFyYXRvcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2V3cygpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNTgpIHtcbiAgICAgICAgICBzMiA9IHBlZyRjMjU7XG4gICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzMiA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzI2KTsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMxID0gW3MxLCBzMl07XG4gICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXZhbHVlX3NlcGFyYXRvcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDU5KSB7XG4gICAgICAgICAgczIgPSBwZWckYzM2O1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMzNyk7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzXTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2Vjb21tYV9zZXBhcmF0b3IoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0NCkge1xuICAgICAgICAgIHMyID0gcGVnJGMzODtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMzkpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2V3cygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlem9vbSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDEyNCkge1xuICAgICAgICAgIHMyID0gcGVnJGM0MDtcbiAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDEpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2V3cygpO1xuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlem9vbV9pbnRlcnZhbCgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNld3MoKTtcbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ1KSB7XG4gICAgICAgICAgczIgPSBwZWckYzExO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMik7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZXdzKCk7XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMSA9IFtzMSwgczIsIHMzXTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VsZXNzX3RoYW4oKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjApIHtcbiAgICAgICAgczAgPSBwZWckYzQyO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDMpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VncmVhdGVyX3RoYW4oKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNjIpIHtcbiAgICAgICAgczAgPSBwZWckYzQ0O1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDUpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VlcXVhbF90aGFuKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDYxKSB7XG4gICAgICAgIHMwID0gcGVnJGM0NjtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzQ3KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNld3MoKSB7XG4gICAgICB2YXIgczAsIHMxO1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gW107XG4gICAgICBpZiAocGVnJGM0OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMxID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMxID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzUwKTsgfVxuICAgICAgfVxuICAgICAgd2hpbGUgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwLnB1c2goczEpO1xuICAgICAgICBpZiAocGVnJGM0OS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgICAgczEgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1MCk7IH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNDgpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VmYWxzZSgpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA1KSA9PT0gcGVnJGM1MSkge1xuICAgICAgICBzMSA9IHBlZyRjNTE7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1Mik7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzUzKCk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbnVsbCgpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA0KSA9PT0gcGVnJGM1NCkge1xuICAgICAgICBzMSA9IHBlZyRjNTQ7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1NSk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzU2KCk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNldHJ1ZSgpIHtcbiAgICAgIHZhciBzMCwgczE7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCA0KSA9PT0gcGVnJGM1Nykge1xuICAgICAgICBzMSA9IHBlZyRjNTc7XG4gICAgICAgIHBlZyRjdXJyUG9zICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM1OCk7IH1cbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzU5KCk7XG4gICAgICB9XG4gICAgICBzMCA9IHMxO1xuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNldmFsdWUoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNlcnVsZSgpO1xuICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMwID0gcGVnJHBhcnNlbnVtYmVyKCk7XG4gICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMwID0gcGVnJHBhcnNlc3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWdlb21ldHJ5VHlwZSgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNSkgPT09IHBlZyRjNjApIHtcbiAgICAgICAgczAgPSBwZWckYzYwO1xuICAgICAgICBwZWckY3VyclBvcyArPSA1O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjEpOyB9XG4gICAgICB9XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzYyKSB7XG4gICAgICAgICAgczAgPSBwZWckYzYyO1xuICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDEwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjMpOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgMTApID09PSBwZWckYzY0KSB7XG4gICAgICAgICAgICBzMCA9IHBlZyRjNjQ7XG4gICAgICAgICAgICBwZWckY3VyclBvcyArPSAxMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY1KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDE1KSA9PT0gcGVnJGM2Nikge1xuICAgICAgICAgICAgICBzMCA9IHBlZyRjNjY7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zICs9IDE1O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNjcpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwZWckY3VyclBvcywgNykgPT09IHBlZyRjNjgpIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNjg7XG4gICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gNztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzY5KTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocGVnJGN1cnJQb3MsIDEyKSA9PT0gcGVnJGM3MCkge1xuICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzcwO1xuICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgKz0gMTI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM3MSk7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBlZyRjdXJyUG9zLCAxOCkgPT09IHBlZyRjNzIpIHtcbiAgICAgICAgICAgICAgICAgICAgczAgPSBwZWckYzcyO1xuICAgICAgICAgICAgICAgICAgICBwZWckY3VyclBvcyArPSAxODtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzczKTsgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHMwID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRjNzQ7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzc1KTsgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VudW1iZXIoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0O1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW1pbnVzKCk7XG4gICAgICBpZiAoczEgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckYzY7XG4gICAgICB9XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBwZWckcGFyc2VpbnQoKTtcbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VmcmFjKCk7XG4gICAgICAgICAgaWYgKHMzID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMyA9IHBlZyRjNjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzNCA9IHBlZyRwYXJzZWV4cCgpO1xuICAgICAgICAgICAgaWYgKHM0ID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJGM2O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgICBzMSA9IHBlZyRjNzcoKTtcbiAgICAgICAgICAgICAgczAgPSBzMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuICAgICAgcGVnJHNpbGVudEZhaWxzLS07XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczEgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjNzYpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VudW1iZXJfYXJyYXkoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczM7XG5cbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlbnVtYmVyX3NlcGFyYXRvcigpO1xuICAgICAgICB3aGlsZSAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICBzMyA9IHBlZyRwYXJzZW51bWJlcl9zZXBhcmF0b3IoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNzgoczEsIHMyKTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbnVtYmVyX3NlcGFyYXRvcigpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBwZWckcGFyc2Vjb21tYV9zZXBhcmF0b3IoKTtcbiAgICAgIGlmIChzMSA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRjNjtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMiA9IHBlZyRwYXJzZW51bWJlcigpO1xuICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgICBzMSA9IHBlZyRjNzkoczIpO1xuICAgICAgICAgIHMwID0gczE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VkZWNpbWFsX3BvaW50KCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQ2KSB7XG4gICAgICAgIHMwID0gcGVnJGM4MDtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzgxKTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZGlnaXQxXzkoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChwZWckYzgyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjODMpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VlKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGM4NC50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg1KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZXhwKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzLCBzNDtcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlZSgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gcGVnJHBhcnNlbWludXMoKTtcbiAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckcGFyc2VwbHVzKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczIgPSBwZWckYzY7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczMgPSBbXTtcbiAgICAgICAgICBzNCA9IHBlZyRwYXJzZURJR0lUKCk7XG4gICAgICAgICAgaWYgKHM0ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICB3aGlsZSAoczQgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgczMucHVzaChzNCk7XG4gICAgICAgICAgICAgIHM0ID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczMgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBbczEsIHMyLCBzM107XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlZnJhYygpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyLCBzMztcblxuICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgIHMxID0gcGVnJHBhcnNlZGVjaW1hbF9wb2ludCgpO1xuICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMyID0gW107XG4gICAgICAgIHMzID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgaWYgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgd2hpbGUgKHMzICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICBzMi5wdXNoKHMzKTtcbiAgICAgICAgICAgIHMzID0gcGVnJHBhcnNlRElHSVQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgczIgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgczEgPSBbczEsIHMyXTtcbiAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgIHMwID0gcGVnJGMyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlaW50KCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBzMCA9IHBlZyRwYXJzZXplcm8oKTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICBzMSA9IHBlZyRwYXJzZWRpZ2l0MV85KCk7XG4gICAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyID0gW107XG4gICAgICAgICAgczMgPSBwZWckcGFyc2VESUdJVCgpO1xuICAgICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczIucHVzaChzMyk7XG4gICAgICAgICAgICBzMyA9IHBlZyRwYXJzZURJR0lUKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgczEgPSBbczEsIHMyXTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlbWludXMoKSB7XG4gICAgICB2YXIgczA7XG5cbiAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gNDUpIHtcbiAgICAgICAgczAgPSBwZWckYzExO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTIpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VwbHVzKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDQzKSB7XG4gICAgICAgIHMwID0gcGVnJGM4NjtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzg3KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlemVybygpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0OCkge1xuICAgICAgICBzMCA9IHBlZyRjODg7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM4OSk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXN0cmluZ193cSgpIHtcbiAgICAgIHZhciBzMCwgczEsIHMyO1xuXG4gICAgICBzMCA9IHBlZyRjdXJyUG9zO1xuICAgICAgczEgPSBbXTtcbiAgICAgIHMyID0gcGVnJHBhcnNlY2hhcl93cSgpO1xuICAgICAgd2hpbGUgKHMyICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgIHMxLnB1c2goczIpO1xuICAgICAgICBzMiA9IHBlZyRwYXJzZWNoYXJfd3EoKTtcbiAgICAgIH1cbiAgICAgIGlmIChzMSAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMDtcbiAgICAgICAgczEgPSBwZWckYzkwKHMxKTtcbiAgICAgIH1cbiAgICAgIHMwID0gczE7XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VjaGFyX3dxKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGM5MS50ZXN0KGlucHV0LmNoYXJBdChwZWckY3VyclBvcykpKSB7XG4gICAgICAgIHMwID0gaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzkyKTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlc3RyaW5nKCkge1xuICAgICAgdmFyIHMwLCBzMSwgczIsIHMzO1xuXG4gICAgICBwZWckc2lsZW50RmFpbHMrKztcbiAgICAgIHMwID0gcGVnJGN1cnJQb3M7XG4gICAgICBzMSA9IHBlZyRwYXJzZXF1b3RhdGlvbl9tYXJrKCk7XG4gICAgICBpZiAoczEgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczIgPSBbXTtcbiAgICAgICAgczMgPSBwZWckcGFyc2VjaGFyKCk7XG4gICAgICAgIHdoaWxlIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMyLnB1c2goczMpO1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlY2hhcigpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzMiAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgIHMzID0gcGVnJHBhcnNlcXVvdGF0aW9uX21hcmsoKTtcbiAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzk0KHMyKTtcbiAgICAgICAgICAgIHMwID0gczE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgICBzMCA9IHBlZyRjMjtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGVnJGN1cnJQb3MgPSBzMDtcbiAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICB9XG4gICAgICBwZWckc2lsZW50RmFpbHMtLTtcbiAgICAgIGlmIChzMCA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICBzMSA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5Myk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWNoYXIoKSB7XG4gICAgICB2YXIgczAsIHMxLCBzMiwgczMsIHM0LCBzNSwgczYsIHM3LCBzOCwgczk7XG5cbiAgICAgIHMwID0gcGVnJHBhcnNldW5lc2NhcGVkKCk7XG4gICAgICBpZiAoczAgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgczAgPSBwZWckY3VyclBvcztcbiAgICAgICAgczEgPSBwZWckcGFyc2Vlc2NhcGUoKTtcbiAgICAgICAgaWYgKHMxICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAzNCkge1xuICAgICAgICAgICAgczIgPSBwZWckYzk1O1xuICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzk2KTsgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBlZyRjdXJyUG9zKSA9PT0gOTIpIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckYzk3O1xuICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgczIgPSBwZWckRkFJTEVEO1xuICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjOTgpOyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoczIgPT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA0Nykge1xuICAgICAgICAgICAgICAgIHMyID0gcGVnJGM5OTtcbiAgICAgICAgICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHMyID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTAwKTsgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgIHMyID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5OCkge1xuICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzEwMTtcbiAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMDIpOyB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMTAzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzEwNDtcbiAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwNSk7IH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzEwNigpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDExMCkge1xuICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMxMDc7XG4gICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzEwOCk7IH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMTA5KCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgczIgPSBwZWckY3VyclBvcztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDExNCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzExMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMTEpOyB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMTEyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHMyID09PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSAxMTYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzExMztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJEZBSUxFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzExNCk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMyAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwZWckcmVwb3J0ZWRQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgczMgPSBwZWckYzExNSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgczIgPSBzMztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzMiA9PT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDExNykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMzID0gcGVnJGMxMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRGQUlMRUQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzExNyk7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczMgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNCA9IHBlZyRjdXJyUG9zO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM1ID0gcGVnJGN1cnJQb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgczYgPSBwZWckcGFyc2VIRVhESUcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczYgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM3ID0gcGVnJHBhcnNlSEVYRElHKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczcgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczggPSBwZWckcGFyc2VIRVhESUcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM4ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczkgPSBwZWckcGFyc2VIRVhESUcoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoczkgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM2ID0gW3M2LCBzNywgczgsIHM5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHM1ID0gczY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzNTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgczUgPSBwZWckYzI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHM1ICE9PSBwZWckRkFJTEVEKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNSA9IGlucHV0LnN1YnN0cmluZyhzNCwgcGVnJGN1cnJQb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzNCA9IHM1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzNCAhPT0gcGVnJEZBSUxFRCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJHJlcG9ydGVkUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMyA9IHBlZyRjMTE4KHM0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMyID0gczM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlZyRjdXJyUG9zID0gczI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVnJGN1cnJQb3MgPSBzMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzMiA9IHBlZyRjMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoczIgIT09IHBlZyRGQUlMRUQpIHtcbiAgICAgICAgICAgIHBlZyRyZXBvcnRlZFBvcyA9IHMwO1xuICAgICAgICAgICAgczEgPSBwZWckYzExOShzMik7XG4gICAgICAgICAgICBzMCA9IHMxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwZWckY3VyclBvcyA9IHMwO1xuICAgICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBlZyRjdXJyUG9zID0gczA7XG4gICAgICAgICAgczAgPSBwZWckYzI7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZWVzY2FwZSgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocGVnJGN1cnJQb3MpID09PSA5Mikge1xuICAgICAgICBzMCA9IHBlZyRjOTc7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGM5OCk7IH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHMwO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHBlZyRwYXJzZXF1b3RhdGlvbl9tYXJrKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwZWckY3VyclBvcykgPT09IDM0KSB7XG4gICAgICAgIHMwID0gcGVnJGM5NTtcbiAgICAgICAgcGVnJGN1cnJQb3MrKztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMwID0gcGVnJEZBSUxFRDtcbiAgICAgICAgaWYgKHBlZyRzaWxlbnRGYWlscyA9PT0gMCkgeyBwZWckZmFpbChwZWckYzk2KTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNldW5lc2NhcGVkKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGMxMjAudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMjEpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwZWckcGFyc2VESUdJVCgpIHtcbiAgICAgIHZhciBzMDtcblxuICAgICAgaWYgKHBlZyRjMTIyLnRlc3QoaW5wdXQuY2hhckF0KHBlZyRjdXJyUG9zKSkpIHtcbiAgICAgICAgczAgPSBpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpO1xuICAgICAgICBwZWckY3VyclBvcysrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgczAgPSBwZWckRkFJTEVEO1xuICAgICAgICBpZiAocGVnJHNpbGVudEZhaWxzID09PSAwKSB7IHBlZyRmYWlsKHBlZyRjMTIzKTsgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gczA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGVnJHBhcnNlSEVYRElHKCkge1xuICAgICAgdmFyIHMwO1xuXG4gICAgICBpZiAocGVnJGMxMjQudGVzdChpbnB1dC5jaGFyQXQocGVnJGN1cnJQb3MpKSkge1xuICAgICAgICBzMCA9IGlucHV0LmNoYXJBdChwZWckY3VyclBvcyk7XG4gICAgICAgIHBlZyRjdXJyUG9zKys7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzMCA9IHBlZyRGQUlMRUQ7XG4gICAgICAgIGlmIChwZWckc2lsZW50RmFpbHMgPT09IDApIHsgcGVnJGZhaWwocGVnJGMxMjUpOyB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBzMDtcbiAgICB9XG5cbiAgICBwZWckcmVzdWx0ID0gcGVnJHN0YXJ0UnVsZUZ1bmN0aW9uKCk7XG5cbiAgICBpZiAocGVnJHJlc3VsdCAhPT0gcGVnJEZBSUxFRCAmJiBwZWckY3VyclBvcyA9PT0gaW5wdXQubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gcGVnJHJlc3VsdDtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHBlZyRyZXN1bHQgIT09IHBlZyRGQUlMRUQgJiYgcGVnJGN1cnJQb3MgPCBpbnB1dC5sZW5ndGgpIHtcbiAgICAgICAgcGVnJGZhaWwoeyB0eXBlOiBcImVuZFwiLCBkZXNjcmlwdGlvbjogXCJlbmQgb2YgaW5wdXRcIiB9KTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgcGVnJGJ1aWxkRXhjZXB0aW9uKG51bGwsIHBlZyRtYXhGYWlsRXhwZWN0ZWQsIHBlZyRtYXhGYWlsUG9zKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIFN5bnRheEVycm9yOiBTeW50YXhFcnJvcixcbiAgICBwYXJzZTogICAgICAgcGFyc2VcbiAgfTtcbn0pKCk7XG4iLCJyZXF1aXJlKFwiLi9zdHlsZXJzLmpzXCIpO1xuLyoqXG4gKiBHbG9iYWwgdmFyaWFibGUgdGhhdCByZXByZXNlbnRzIFBFRyBsaWJyYXJ5IGZ1bmN0aW9uYWxpdHkgdG8gcGFyc2VyIGEgc3R5bGUgc3RyaW5nXG4gKiBAcHJvcGVydHkge1BFR30gLSBQRUcgdmFyaWFibGVcbiAqL1xudmFyIFBFRyA9IHJlcXVpcmUoXCIuLi8uLi8uLi9saWIvcGVnanMvbGliL3BlZy5qc1wiKTtcblxuLyoqXG4gKiBHbG9iYWwgdmFyaWFibGUgdGhhdCByZXByZXNlbnRzIG11c3RhY2hlIGxpYnJhcnkgZnVuY3Rpb25hbGl0eVxuICogQHByb3BlcnR5IHttdXN0YWNoZX0gLSBtdXN0YWNoZSB2YXJpYWJsZVxuICovXG52YXIgTXVzdGFjaGUgPSByZXF1aXJlKFwiLi4vLi4vLi4vbGliL211c3RhY2hlLmpzL211c3RhY2hlLmpzXCIpO1xuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGZlYXR1cmUgbGF5ZXJzJyBzdHlsZXMgcHJvY2Vzc29ycy5cbiAqXG4gKiBAY2xhc3NcbiAqIEBhYnN0cmFjdFxuICogQGV4dGVuZHMgTC5DbGFzc1xuICogQHBhcmFtIHtTTUMubGF5ZXJzLnN0eWxlcnMuU3R5bGVyfm9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNsYXNzXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMubGF5ZXJzLnN0eWxlcnMuU3R5bGVyID0gTC5DbGFzcy5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMubGF5ZXJzLnN0eWxlcnMuU3R5bGVyIyAqL1xuICAgIHtcblxuICAgICAgICBfZ3JhbW1hcjogbnVsbCxcbiAgICAgICAgX3BhcnNlcl91cmw6IG51bGwsXG4gICAgICAgIHBhcnNlckluaXRpYWxpemVkOiBmYWxzZSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5sYXllcnMuc3R5bGVycy5TdHlsZXJ+b3B0aW9uc1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGVzaGVldD1udWxsIC0gVGhlIHN0eWxlIHNldCB0byBhcHBseVxuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc3R5bGVzaGVldFVSTD1udWxsIC0gVGhlIHN0eWxlIHNldCB1cmwgdG8gYXBwbHlcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHN0eWxlc2hlZXQ6IG51bGwsXG4gICAgICAgICAgICBzdHlsZXNoZWV0VVJMOiBudWxsXG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIG9iamVjdCB3aXRoIHRoZSBwYXJhbXNcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdmFyIHNjb3BlID0gdGhpcztcblxuICAgICAgICAgICAgaWYgKCFTTUMubGF5ZXJzLnN0eWxlcnMuUEFSU0VSX0ZVTkNUSU9OKSB7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLl9wYXJzZXJfdXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiAnZ2V0JyxcbiAgICAgICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl9ncmFtbWFyID0gUEVHLmJ1aWxkUGFyc2VyKHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlLl9wYXJzZVN0eWxlcygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXHR0aGlzLl9ncmFtbWFyID0gU01DLmxheWVycy5zdHlsZXJzLlBBUlNFUl9GVU5DVElPTjtcbiAgICAgICAgICAgIFx0c2NvcGUuX3BhcnNlU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX3BhcnNlU3R5bGVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgXHR2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zdHlsZXNoZWV0VVJMKSB7XG4gICAgICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLm9wdGlvbnMuc3R5bGVzaGVldFVSTCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ2dldCcsXG4gICAgICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wYXJzZShyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5vcHRpb25zLnN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcnNlKHRoaXMub3B0aW9ucy5zdHlsZXNoZWV0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgcmV0dXJuIGRlZmF1bHQgZW1wdHkgc3R5bGVzIGlmIHdlIGhhdmUgbm8gY29uZmlnLlxuICAgICAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN0eWxlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ3JlYXRlIGEgc3R5bGUgdG8gcGFzcyB0byBmZWF0dXJlIGFuZCBkZXBlbmRzIG9uIHpvb21cbiAgICAgICAgICpcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmZWF0dXJlIC0gQW4gb2JqZWN0IHRoYXQgcmVwcmVzZW50cyB0aGUgZ2VvbWV0cnkgZWxlbWVudC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpvb20gLSBOdW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBsZXZlbCB6b29tIHRvIGFwcGx5IHRoZSBzdHlsZS5cbiAgICAgICAgICovXG4gICAgICAgIF9jcmVhdGVTdHlsZXM6IGZ1bmN0aW9uKGZlYXR1cmUsIHpvb20pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5sYXllcnMuc3R5bGVycy5TdHlsZXI6Ol9jcmVhdGVTdHlsZXM6IEVycm9yLCBubyBfY3JlYXRlU3R5bGVzIHN0eWxlcyB3YXMgZm91bmQsIGRpZCB5b3Ugc3BlY2lmeSBhIHBhcnNlciB3aXRoIGEgZGVyaXZhdGUgY2xhc3M/XCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkcyBhIHN0eWxlc2hlZXQgZGVmaW5pdGlvbiBpbnRlcnByZXRpbmcgdGhlIHJ1bGVzIHNvIGl0IGNhbiBiZSBhcHBsaWVkIHRvIGZlYXR1cmVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBNdXN0IGJlIGltcGxlbWVudGVkIGluIGRlcml2ZWQgY2xhc3Nlcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZXNoZWV0IC0gQSBzdHJpbmcgY29udGFpbmluZyB0aGUgc3R5bGVzaGVldCBvciBhbiB1cmwgdG8gbG9hZCB0aGUgc3R5bGVzaGVldCBmcm9tLlxuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uKHN0eWxlc2hlZXQpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZXNGdW5jQm9keTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3R5bGVzRnVuY0JvZHkgPSB0aGlzLl9ncmFtbWFyLnBhcnNlKHN0eWxlc2hlZXQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZGVidWcoZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhcnNlckluaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuX2NyZWF0ZVN0eWxlcyA9IG5ldyBGdW5jdGlvbihcImZlYXR1cmVcIiwgXCJ6b29tXCIsIFwidmFyIHN0eWxlID0ge307XCIgKyBzdHlsZXNGdW5jQm9keSArIFwicmV0dXJuIHN0eWxlO1wiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQWRkcyBzdHlsZSBwcm9wZXJ0aWVzIHRvIHRoZSByZWNlaXZlZCBmZWF0dXJlcywgc28gdGhlIGNhbiBiZSByZXByZXNlbnRlZCBhcyBpbnRlbmRlZCBieSB0aGUgc3R5bGUgZm9yIHRoZSBsYXllci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmUgLSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBnZW9tZXRyeSBlbGVtZW50IGJlaW5nIHN0eWxlZC5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHpvb20gLSBOdW1iZXIgdGhhdCByZXByZXNlbnRzIHRoZSBsZXZlbCB6b29tIHRvIGFwcGx5IHRoZSBzdHlsZS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBhcHBseVN0eWxlOiBmdW5jdGlvbihmZWF0dXJlLCB6b29tKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTTUMubGF5ZXJzLnN0eWxlcnMuU3R5bGVyOjphcHBseVN0eWxlOiBEZXJpdmF0ZSBjbGFzc2VzIG11c3QgaW1wbGVtZW50IHRoaXMgbWV0aG9kLlwiKTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIF9jb250ZW50RnJvbVRlbXBsYXRlOiBmdW5jdGlvbihmZWF0dXJlLCB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgdmFyIGRlZmF1bHRUZW1wbGF0ZSA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKCF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIGRlZmF1bHRUZW1wbGF0ZSA9IHRydWU7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgdmFyIGRhdGEgPSB7fTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZmVhdHVyZUlkKSB7XG4gICAgICAgICAgICAgICAgZGF0YS4kaWQgPSBmZWF0dXJlW3RoaXMub3B0aW9ucy5mZWF0dXJlSWRdO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gXCIkaWQ6IDxiPnt7JGlkfX08L2I+PGJyPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcEtleSBpbiBmZWF0dXJlLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICBkYXRhW3Byb3BLZXldID0gZmVhdHVyZS5wcm9wZXJ0aWVzW3Byb3BLZXldO1xuICAgICAgICAgICAgICAgIGlmIChkZWZhdWx0VGVtcGxhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUgKz0gcHJvcEtleSArIFwiOiA8Yj57e1wiICsgcHJvcEtleSArIFwifX08L2I+PGJyPlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIG91dHB1dCA9IE11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgZGF0YSk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgICB9XG4gICAgfSk7XG4iLCJyZXF1aXJlKFwiLi4vbGF5ZXJzLmpzXCIpO1xuXG4vKipcbiAqIE5hbWVzcGFjZSBmb3IgU01DIFZpZXdlcidzIHN0eWxlc2hlZXQgcHJvY2Vzc29ycy5cbiAqIEBuYW1lc3BhY2VcbiAqIEBtZW1iZXJvZiBTTUMubGF5ZXJzXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5sYXllcnMuc3R5bGVycyA9IHt9O1xuIiwicmVxdWlyZShcIi4vcHJvdmlkZXJzLmpzXCIpO1xucmVxdWlyZShcIi4uLy4uL2xpYi9hdG1vc3BoZXJlLWpxdWVyeS9qcXVlcnkuYXRtb3NwaGVyZS5qc1wiKTtcblxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGxheWVyIGRhdGEgcHJvdmlkZXJzIGNhcGFibGEgb2YgcmVjZWl2aW5nIHVwZGF0ZXMgdG8gdGhlIGZlYXR1cmVzXG4gKiByZXRyaWV2ZWQgaW5pdGlhbGx5IGZyb20gYSBSZWFsIFRpbWUgc291cmNlLlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIFNNQy5wcm92aWRlcnMuUlRGZWF0dXJlUHJvdmlkZXJcbiAqIEBwYXJhbSB7U01DLnByb3ZpZGVycy5BdG1vc3BoZXJlUlRGZWF0dXJlUHJvdmlkZXJ+b3B0aW9uc30gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2xhc3NcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5wcm92aWRlcnMuQXRtb3NwaGVyZUNvbm5lY3RvciA9IEwuQ2xhc3MuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLnByb3ZpZGVycy5BdG1vc3BoZXJlUlRGZWF0dXJlUHJvdmlkZXIjICovXG4gICAge1xuXG4gICAgICAgIGluY2x1ZGVzOiBbTC5NaXhpbi5FdmVudHNdLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTTUMucHJvdmlkZXJzLkF0bW9zcGhlcmVSVEZlYXR1cmVQcm92aWRlcn5vcHRpb25zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB0b3BpYz1cIlwiIC0gVGhlIGRlZmF1bHQgdG9waWMgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICB1cmw6IFwiXCIsXG4gICAgICAgICAgICB0b3BpYzogXCJcIlxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTb2NrZXRcbiAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNvY2tldCAtIFRoZSBkZWZhdWx0IHNvY2tldCB2YWx1ZS5cbiAgICAgICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAgICAgKi9cbiAgICAgICAgc29ja2V0OiBudWxsLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBvYmplY3Qgd2l0aCB0aGUgb3B0aW9uIHBhcmFtZXRlclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2NyZWF0ZVN1YnNjcmlwdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTTUMucHJvdmlkZXJzLkF0bW9zcGhlcmVDb25uZWN0b3I6Ol9jcmVhdGVTdWJzY3JpcHRpb246IEEgdmFsaWQgdXJsIGZpZWxkIGlzIHJlcXVpcmVkIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBvcHRpb25zIGFyZ3VtZW50XCIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy51cmwgKyAodGhpcy5vcHRpb25zLnRvcGljID8gKFwiL1wiICsgdGhpcy5vcHRpb25zLnRvcGljKSA6IFwiXCIpLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICBsb2dMZXZlbDogJ2RlYnVnJyxcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQ6ICd3ZWJzb2NrZXQnLFxuICAgICAgICAgICAgICAgIHRyYWNrTWVzc2FnZUxlbmd0aDogdHJ1ZSxcbiAgICAgICAgICAgICAgICBmYWxsYmFja1RyYW5zcG9ydDogJ2xvbmctcG9sbGluZydcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHJlcXVlc3Qub25PcGVuID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZpcmVFdmVudChcInNvY2tldE9wZW5lZFwiLCBzZWxmLnNvY2tldCk7XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICByZXF1ZXN0Lm9uTWVzc2FnZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fb25NZXNzYWdlKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHJlcXVlc3Qub25DbG9zZSA9IGZ1bmN0aW9uKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5maXJlRXZlbnQoXCJzb2NrZXRDbG9zZWRcIiwgc2VsZi5zb2NrZXQpO1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgcmVxdWVzdC5vbkVycm9yID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKHJlc3BvbnNlKTtcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIHRoaXMuc29ja2V0ID0gJC5hdG1vc3BoZXJlLnN1YnNjcmliZShyZXF1ZXN0KTtcbiAgICAgICAgfSxcblxuICAgICAgICBfb25NZXNzYWdlOiBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLnByb3ZpZGVycy5BdG1vc3BoZXJlQ29ubmVjdG9yOjpfY3JlYXRlU3Vic2NyaXB0aW9uIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gZGVyaXZhdGUgY2xhc3Nlcy5cIik7XG4gICAgICAgIH1cbiAgICB9XG4pO1xuIiwicmVxdWlyZShcIi4vcHJvdmlkZXJzLmpzXCIpO1xucmVxdWlyZShcIi4vUlRGZWF0dXJlUHJvdmlkZXIuanNcIik7XG5yZXF1aXJlKFwiLi9BdG1vc3BoZXJlQ29ubmVjdG9yLmpzXCIpO1xuXG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgbGF5ZXIgZGF0YSBwcm92aWRlcnMgY2FwYWJsYSBvZiByZWNlaXZpbmcgdXBkYXRlcyB0byB0aGUgZmVhdHVyZXNcbiAqIHJldHJpZXZlZCBpbml0aWFsbHkgZnJvbSBhIFJlYWwgVGltZSBzb3VyY2UuXG4gKiBAY2xhc3NcbiAqIEBhYnN0cmFjdFxuICogQGV4dGVuZHMgU01DLnByb3ZpZGVycy5SVEZlYXR1cmVQcm92aWRlclxuICogQG1peGVzIFNNQy5wcm92aWRlcnMuQXRtb3NwaGVyZUNvbm5lY3RvclxuICogQHBhcmFtIHtTTUMucHJvdmlkZXJzLkF0bW9zcGhlcmVSVEZlYXR1cmVQcm92aWRlcn5vcHRpb25zfSBvcHRpb25zIC0gVGhlIGNvbmZpZ3VyYXRpb24gZm9yIHRoZSBjbGFzc1xuICpcbiAqIEBhdXRob3IgTHVpcyBSb23DoW4gKGxyb21hbkBlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLnByb3ZpZGVycy5BdG1vc3BoZXJlUlRGZWF0dXJlUHJvdmlkZXIgPSBTTUMucHJvdmlkZXJzLlJURmVhdHVyZVByb3ZpZGVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5wcm92aWRlcnMuQXRtb3NwaGVyZVJURmVhdHVyZVByb3ZpZGVyIyAqL1xuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggdGhlIG9wdGlvbiBwYXJhbWV0ZXJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5wcm92aWRlcnMuUlRGZWF0dXJlUHJvdmlkZXIucHJvdG90eXBlLmluaXRpYWxpemUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgICAgIFNNQy5wcm92aWRlcnMuQXRtb3NwaGVyZUNvbm5lY3Rvci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgX29uTWVzc2FnZTogZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIHZhciBmZWF0dXJlc0FkZGVkID0gW107XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXNEZWxldGVkID0gW107XG4gICAgICAgICAgICB2YXIgZmVhdHVyZXNNb2RpZmllZCA9IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXNwb25zZS5tZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gSlNPTi5wYXJzZShyZXNwb25zZS5tZXNzYWdlc1tpXSk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtZXNzYWdlLmZlYXR1cmVDb2xsZWN0aW9uLmZlYXR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gbWVzc2FnZS5mZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcIkFERFwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlYXR1cmVzQWRkZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJERUxFVEVcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc0RlbGV0ZWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJNT0RJRllcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlc01vZGlmaWVkLnB1c2goZmVhdHVyZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5wcm92aWRlcnMuQXRtb3NwaGVyZVJURmVhdHVyZVByb3ZpZGVyOjpfb25NZXNzYWdlOiBVbnN1cHBvcnRlZCBhY3Rpb24gXCIgKyBtZXNzYWdlLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB0aGlzLm9uRmVhdHVyZXNMb2FkZWQoZmVhdHVyZXNBZGRlZCk7XG4gICAgICAgICAgICB0aGlzLm9uRmVhdHVyZXNEZWxldGVkKGZlYXR1cmVzRGVsZXRlZCk7XG4gICAgICAgICAgICB0aGlzLm9uRmVhdHVyZXNNb2RpZmllZChmZWF0dXJlc01vZGlmaWVkKTtcbiAgICAgICAgfVxuICAgIH0sIFtTTUMucHJvdmlkZXJzLkF0bW9zcGhlcmVDb25uZWN0b3JdKTtcbiIsInJlcXVpcmUoXCIuL3Byb3ZpZGVycy5qc1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXllciBkYXRhIHByb3ZpZGVycyByZXR1cm5pbmcgYXJyYXlzIG9mIEZlYXR1cmVzLlxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIEwuQ2xhc3NcbiAqIEBtaXhlcyBMLk1peGluLkV2ZW50c1xuICogQHBhcmFtIHtTTUMucHJvdmlkZXJzLkZlYXR1cmVzUHJvdmlkZXJ+b3B0aW9uc30gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2xhc3NcbiAqXG4gKiBAYXV0aG9yIEx1aXMgUm9tw6FuIChscm9tYW5AZW1lcmd5YS5jb20pXG4gKi9cblNNQy5wcm92aWRlcnMuRmVhdHVyZXNQcm92aWRlciA9IEwuQ2xhc3MuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLnByb3ZpZGVycy5GZWF0dXJlc1Byb3ZpZGVyIyAqL1xuICAgIHtcblxuICAgICAgICBpbmNsdWRlczogTC5NaXhpbi5FdmVudHMsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5wcm92aWRlcnMuRmVhdHVyZXNQcm92aWRlcn5vcHRpb25zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmZWF0dXJlSWQ9XCJpZFwiIC0gVGhlIGRlZmF1bHQgaWQgdG8gdGhlIGZlYXR1cmVcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGlkRmllbGQ6IFwiaWRcIlxuICAgICAgICB9LFxuICAgICAgICAvKiogXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIGNsYXNzIFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucyAtIFRoZSBkZWZhdWx0IG9wdGlvbnMgdG8gdGhlIGZlYXR1cmVcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIEwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0cmlldmVzIHRoZSBmZWF0dXJlcyBmcm9tIGl0cyBzb3VyY2UuXG4gICAgICAgICAqIEBmaXJlcyBTTUMucHJvdmlkZXJzLkZlYXR1cmVzUHJvdmlkZXIjZmVhdHVyZXNMb2FkZWRcbiAgICAgICAgICovXG4gICAgICAgIGxvYWRGZWF0dXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgdGlzID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZG9GZWF0dXJlc0xvYWRpbmcoKS50aGVuKGZ1bmN0aW9uKGZlYXR1cmVDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgdGlzLm9uRmVhdHVyZXNMb2FkZWQoZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXMpO1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIEZlYXR1cmVzIGxvYWRlZCBldmVudC5cbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBldmVudCBTTUMucHJvdmlkZXJzLkZlYXR1cmVzUHJvdmlkZXIjZmVhdHVyZXNMb2FkZWRcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7b2JqZWN0fSBmZWF0dXJlcyAtIFRoZSBsb2FkZWQgZmVhdHVyZXMuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdGlzLmZpcmUoXCJmZWF0dXJlc0xvYWRlZFwiLCBmZWF0dXJlQ29sbGVjdGlvbi5mZWF0dXJlcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbnMgb2YgRmVhdHVyZVByb3ZpZGVyIG11c3QgY29udGFpbiBhbiBvdmVycmlkZSBvZiB0aGlzIG1ldGhvZCwgc28gZmVhdHVyZXMgY2FuIGJlIGxvYWRlZCBmcm9tIHRoZWlyIHNvdXJjZS5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBkb0ZlYXR1cmVzTG9hZGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGZWF0dXJlc1Byb3ZpZGVyOjpkb0ZlYXR1cmVzTG9hZGluZyBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGRlcml2YXRlIGNsYXNzZXMuXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbXBsZW1lbnRhdGlvbnMgb3IgdXNlcnMgb2YgRmVhdHVyZVByb3ZpZGVyIG11c3QgcHJvdmlkZSBhbiBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzIGNsYXNzIHNvIHJldHJpZXZlZCBmZWF0dXJlcyBjYW4gYmUgdXNlZC5cbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBmZWF0dXJlcyAtIFRoZSBmZWF0dXJlcyByZXRyaWV2ZWQgYnkgdGhlIHByb3ZpZGVyLlxuICAgICAgICAgKi9cbiAgICAgICAgb25GZWF0dXJlc0xvYWRlZDogZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZlYXR1cmVzUHJvdmlkZXI6Om9uRmVhdHVyZXNMb2FkZWQgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmF0ZSBjbGFzc2VzLlwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4vKipcbiAqIEFQSSBmYWN0b3J5IG1ldGhvZCBmb3IgZWFzZSBjcmVhdGlvbiBvZiBmZWF0dXJlcyBwcm92aWRlcnMuXG4gKiBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgcHJvdmlkZXIuXG4gKi9cblNNQy5mZWF0dXJlc1Byb3ZpZGVyID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBTTUMucHJvdmlkZXJzLkZlYXR1cmVzUHJvdmlkZXIoKTtcbn07XG4iLCJyZXF1aXJlKFwiLi9wcm92aWRlcnMuanNcIik7XG5yZXF1aXJlKFwiLi9VUkxGZWF0dXJlUHJvdmlkZXIuanNcIik7XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBsYXllciBkYXRhIHByb3ZpZGVycyBjYXBhYmxhIG9mIHJlY2VpdmluZyB1cGRhdGVzIHRvIHRoZSBmZWF0dXJlc1xuICogcmV0cmlldmVkIGluaXRpYWxseSBmcm9tIGEgUmVhbCBUaW1lIHNvdXJjZS5cblxuICogQGNsYXNzXG4gKiBAYWJzdHJhY3RcbiAqIEBleHRlbmRzIFNNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyXG4gKlxuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMucHJvdmlkZXJzLlJURmVhdHVyZVByb3ZpZGVyID0gU01DLnByb3ZpZGVycy5VUkxGZWF0dXJlUHJvdmlkZXIuZXh0ZW5kKFxuICAgIC8qKiBAbGVuZHMgU01DLnByb3ZpZGVycy5SVEZlYXR1cmVQcm92aWRlciMgKi9cbiAgICB7XG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgb2JqZWN0IHdpdGggb3B0aW9ucyBwYXJhbWV0ZXJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyLnByb3RvdHlwZS5pbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJldHJpZXZlcyB0aGUgZmVhdHVyZXMgZnJvbSBpdHMgc291cmNlXG4gICAgICAgICAqIEBmaXJlcyBTTUMucHJvdmlkZXJzLkZlYXR1cmVzUHJvdmlkZXIjZmVhdHVyZXNMb2FkZWRcbiAgICAgICAgICovXG4gICAgICAgIGxvYWRGZWF0dXJlczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBTTUMucHJvdmlkZXJzLlVSTEZlYXR1cmVQcm92aWRlci5wcm90b3R5cGUubG9hZEZlYXR1cmVzLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGlzLl9jcmVhdGVTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBjcmVhdGUgYSBzdWJjcmlwdGlvblxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIF9jcmVhdGVTdWJzY3JpcHRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLnByb3ZpZGVycy5SVEZlYXR1cmVQcm92aWRlcjo6X2NyZWF0ZVN1YnNjcmlwdGlvbjogbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBkZXJpdmF0ZSBjbGFzc2VzLlwiKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGV4ZWN1dGUgd2hlbiBhIGZlYXR1cmUgaGF2ZSBiZWVuIG1vZGlmaWVkLiBJbXBsZW1lbnRhdGlvbnMgb2YgUlRGZWF0dXJlUHJvdmlkZXIgbXVzdCBjb250YWluIGFuIG92ZXJyaWRlIG9mIHRoaXMgbWV0aG9kXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZmVhdHVyZXMgLSBGZWF0dXJlcyB0byBiZSBtb2RpZmllZCBcbiAgICAgICAgICovXG4gICAgICAgIG9uRmVhdHVyZXNNb2RpZmllZDogZnVuY3Rpb24oZmVhdHVyZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNNQy5wcm92aWRlcnMuUlRGZWF0dXJlUHJvdmlkZXI6Om9uRmVhdHVyZXNNb2RpZmllZCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGRlcml2YXRlIGNsYXNzZXMuXCIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZXhlY3V0ZSB3aGVuIGEgZmVhdHVyZSBoYXZlIGJlZW4gZGVsZXRlZC4gSW1wbGVtZW50YXRpb25zIG9mIFJURmVhdHVyZVByb3ZpZGVyIG11c3QgY29udGFpbiBhbiBvdmVycmlkZSBvZiB0aGlzIG1ldGhvZFxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IGZlYXR1cmVzIC0gRmVhdHVyZXMgdG8gYmUgZGVsZXRlZCBcbiAgICAgICAgICovXG4gICAgICAgIG9uRmVhdHVyZXNEZWxldGVkOiBmdW5jdGlvbihmZWF0dXJlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU01DLnByb3ZpZGVycy5SVEZlYXR1cmVQcm92aWRlcjo6b25GZWF0dXJlc0RlbGV0ZWQgbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBkZXJpdmF0ZSBjbGFzc2VzLlwiKTtcbiAgICAgICAgfVxuXG4gICAgfSk7XG4iLCJyZXF1aXJlKFwiLi9VUkxGZWF0dXJlUHJvdmlkZXIuanNcIik7XG5cblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBhIFNvbHIgcHJvdmlkZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgU01DLnByb3ZpZGVycy5VUkxGZWF0dXJlUHJvdmlkZXJcbiAqIEBtaXhlcyBMLk1peGluLkV2ZW50c1xuICogQHBhcmFtIHtTTUMucHJvdmlkZXJzLlNvbHJIaXN0b3J5UHJvdmlkZXJ+b3B0aW9uc30gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2xhc3NcbiAqXG4gKi9cblNNQy5wcm92aWRlcnMuU29sckhpc3RvcnlQcm92aWRlciA9IFNNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5wcm92aWRlcnMuU29sckhpc3RvcnlQcm92aWRlciMgKi9cbiAgICB7XG4gICAgICAgIF9mZWF0dXJlc0ZvckxheWVyOiB7fSxcbiAgICAgICAgZmVhdHVyZXM6IFtdLFxuICAgICAgIC8qKlxuICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5wcm92aWRlcnMuU29sckhpc3RvcnlQcm92aWRlcn5vcHRpb25zXG4gICAgICAgICogQHByb3BlcnR5IHtTTUMucHJvdmlkZXJzLlNvbHJIaXN0b3J5UHJvdmlkZXJ+cmVxdWVzdFBhcmFtc30gcmVxdWVzdFBhcmFtcyAtIERlZmF1bHQgc29sciByZXF1ZXN0IHBhcmFtZXRlcnNcbiAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VydmVyVVJMPW51bGwgLSBUaGUgc29sciBzZXJ2ZXIgdXJsIHBhdGggcGFyYW1ldGVyXG4gICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHRpbWVGaWVsZD0ndGltZScgLSBUaGUgZmllbGQgZm9yIGRlZmluZSBoaXN0b3J5IGxheWVyc1xuICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBnZW9tRmllbGQ9J2xvY2F0aW9uJyAtIFRoZSBnZW9tZXRyeSBmaWVsZCBcbiAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdGltZT01MDAgLSBUaW1lIGZvciBzbGlkZXIgaW4gbWlsbGlzZWNvbmRzIFxuICAgICAgICAqL1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAvKiogQHR5cGVkZWYge09iamVjdH0gU01DLnByb3ZpZGVycy5Tb2xySGlzdG9yeVByb3ZpZGVyfnJlcXVlc3RQYXJhbXMgLSBEZWZhdWx0IHNvbHIgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcT1cIio6KlwiIC0gTWFpbiBxdWVyeSBmb3IgdGhlIHJlcXVlc3RcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmcT1udWxsIC0gRmlsdGVyIHF1ZXJ5IHRoYXQgd2lsbCBiZSB1c2VkIHRvIHJlc3RyaWN0IHRoZSBzZXQgb2YgZG9jdW1lbnRzIHRoYXQgd2lsbCBiZSByZXR1cm5lZFxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNvcnQ9bnVsbCAtIE9yZGVyIGZvciB0aGUgcmV0dXJuZWQgZG9jdW1lbnRzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmw9bnVsbCAtIFBhcmFtZXRlciBmb3IgdG8gc3BlY2lmeSBhIHNldCBvZiBmaWVsZHMgdG8gcmV0dXJuXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZGY9bnVsbCAtIFBhcmFtZXRlciB0aGF0IG92ZXJyaWRlIHRoZSBkZWZhdWx0IGZpZWxkIGRlZmluZWQgaW4gU29sciBzY2hlbWEgeG1sXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gcm93cz1udWxsIC0gUGFyYW1ldGVyIGZvciBzcGVjaWZ5IHRoZSBtYXhpbXVuIG51bWJlciBvZiBkb2N1bWVudHMgcmV0dXJuZWRcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB3dD0nanNvbicgLSBEZWZhdWx0IHNvbHIgb3V0cHV0IGZvcm1hdCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBpbmRlbnQ9dHJ1ZSAtIERlZmF1bHQgaW5kZW50aW5nIHRoZSByZXNwb25zZSAgICAgIFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXF1ZXN0UGFyYW1zOntcbiAgICAgICAgICAgICAgIHE6Jyo6KicsXG4gICAgICAgICAgICAgICBmcTpudWxsLFxuICAgICAgICAgICAgICAgc29ydDogbnVsbCxcbiAgICAgICAgICAgICAgIGZsOiBudWxsLFxuICAgICAgICAgICAgICAgZGY6IG51bGwsXG4gICAgICAgICAgICAgICByb3dzOiBudWxsLFxuICAgICAgICAgICAgICAgd3Q6ICdqc29uJyxcbiAgICAgICAgICAgICAgIGluZGVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgIFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNlcnZlclVSTDogbnVsbCxcbiAgICAgICAgICAgIHRpbWVGaWVsZDogJ3RpbWUnLFxuICAgICAgICAgICAgZ2VvbUZpZWxkOiAnbG9jYXRpb24nLFxuICAgICAgICAgICAgdGltZTogNTAwXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgY2xhc3Mgd2l0aCBvcHRpb25zIHBhcmFtZXRlclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTZW5kIFNvbHIgcmVxdWVzdCB0byBnZXQgdGhlIGdyb3VwIGxheWVyc1xuICAgICAgICAgKi9cbiAgICAgICAgZG9GZWF0dXJlc0xvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBcdFxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgXG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5vcHRpb25zLnNlcnZlclVSTCArIFwiP2pzb24ud3JmPT8mZ3JvdXA9dHJ1ZSZncm91cC5maWVsZD1cIiArIHRoaXMub3B0aW9ucy50aW1lRmllbGQsXG4gICAgICAgICAgICAgICAgZGF0YTogdGhpcy5nZXRQYXJhbXNGcm9tT3B0aW9ucygpLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOidqc29ucCcsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24ocmVzdWx0KXtcbiAgICAgICAgICAgICAgICAgICB2YXIgbnVtUm93cyA9IHJlc3VsdC5ncm91cGVkW3NlbGYub3B0aW9ucy50aW1lRmllbGRdLm1hdGNoZXM7XG4gICAgICAgICAgICAgICAgICAgdmFyIHZhbHVlcyA9IFtdO1xuICAgICAgICAgICAgICAgICAgIHZhciBncm91cHMgPXJlc3VsdC5ncm91cGVkW3NlbGYub3B0aW9ucy50aW1lRmllbGRdLmdyb3VwcztcbiAgICAgICAgICAgICAgICAgICBmb3IodmFyIGkgaW4gZ3JvdXBzKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlcy5wdXNoKGdyb3Vwc1tpXS5ncm91cFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vc2VsZi5fYWdncmVnYXRpbmdMYXllcnNbZ3JvdXBzW2ldLmdyb3VwVmFsdWVdID0gbmV3IFNNQy5sYXllcnMuZ2VvbWV0cnkuR2VvbWV0cnlMYXllcihzZWxmLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIHNlbGYuZG9MYXllcnNHcm91cExvYWRpbmcobnVtUm93cywgdmFsdWVzKTtcbiAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFxuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcGFyYW1zIGZyb20gb3B0aW9ucyBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSBTb2xyIHBhcmFtcyB0byBzZW5kXG4gICAgICAgICAqL1xuICAgICAgICBnZXRQYXJhbXNGcm9tT3B0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBvcHRpb24gaW4gdGhpcy5vcHRpb25zLnJlcXVlc3RQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZih0aGlzLm9wdGlvbnNbb3B0aW9uXSl7XG4gICAgICAgICAgICAgICAgICAgICBwYXJhbXNbb3B0aW9uXSA9IHRoaXMub3B0aW9uc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtc1tvcHRpb25dICE9PSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zW29wdGlvbl0gPSB0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtc1tvcHRpb25dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgU29sciByZXF1ZXN0IHRvIGdldCB0aGUgZmVhdHVyZXNcbiAgICAgICAgICovXG4gICAgICAgIGRvTGF5ZXJzR3JvdXBMb2FkaW5nOmZ1bmN0aW9uKHJvd3MsIHZhbHVlcyl7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7IFxuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnJlcXVlc3RQYXJhbXMucm93cyA9IHJvd3M7XG4gICAgICAgICAgICB2YXIgYWxsRmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5vcHRpb25zLnNlcnZlclVSTCArIFwiP2pzb24ud3JmPT9cIixcbiAgICAgICAgICAgICAgICBkYXRhOiB0aGlzLmdldFBhcmFtc0Zyb21PcHRpb25zKCksXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6J2pzb25wJyxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbihyZXN1bHQpe1xuICAgICAgICAgICAgICAgICAgIHZhciBkb2NzID0gcmVzdWx0LnJlc3BvbnNlLmRvY3M7XG4gICAgICAgXG4gICAgICAgICAgICAgICAgICAgZm9yKHZhciBpIGluIGRvY3Mpe1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGYgPSB7fTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgZi5nZW9tZXRyeSA9IEpTT04ucGFyc2UoZG9jc1tpXVtzZWxmLm9wdGlvbnMuZ2VvbUZpZWxkXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmLnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgcCBpbiBkb2NzW2ldKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZihwID09IHNlbGYub3B0aW9ucy5nZW9tRmllbGQpe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZi5wcm9wZXJ0aWVzW3BdID0gZG9jc1tpXVtwXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgYWxsRmVhdHVyZXMucHVzaChmKTtcblxuICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgIGZvcih2YXIgaiBpbiB2YWx1ZXMpe1xuICAgICAgICAgICAgICAgICAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvcih2YXIgayBpbiBhbGxGZWF0dXJlcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYoYWxsRmVhdHVyZXNba10ucHJvcGVydGllc1tzZWxmLm9wdGlvbnMudGltZUZpZWxkXSA9PSB2YWx1ZXNbal0pe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmZWF0dXJlcy5wdXNoKGFsbEZlYXR1cmVzW2tdKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9mZWF0dXJlc0ZvckxheWVyW3ZhbHVlc1tqXV0gPSBmZWF0dXJlcztcbiAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHNlbGYuX2ZlYXR1cmVzRm9yTGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgIC8vb3ZlcnJpZGUgdHJlZSBub2RlIGZvciBsYXllclxuICAgICAgICAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ25vZGVfJytzZWxmLl9sZWFmbGV0X2lkKTtcbiAgICAgICAgICAgICAgICAgICBpZihub2RlKXtcbiAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5hcHBlbmRDaGlsZChzZWxmLmNyZWF0ZU5vZGVIVE1MKCkpO1xuICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgIH1cbiAgIFxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgfVxuXG59KTtcbi8qKlxuICogQVBJIGZhY3RvcnkgbWV0aG9kIGZvciBlYXNlIGNyZWF0aW9uIG9mIFNvbHIgZmVhdHVyZXMgcHJvdmlkZXJzLlxuICogQHBhcmFtcyB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBpbml0aWFsaXplIHRoZSBTb2xyIHByb3ZpZGVyXG4gKi9cblNNQy53ZnNQcm92aWRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXIob3B0aW9ucyk7XG59O1xuIiwicmVxdWlyZShcIi4vRmVhdHVyZXNQcm92aWRlci5qc1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBhIGZlYXR1cmUgcHJvdmlkZXIgd2l0aCB1cmxcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgU01DLnByb3ZpZGVycy5GZWF0dXJlc1Byb3ZpZGVyXG4gKiBAcGFyYW0ge1NNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyfm9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNsYXNzXG4gKlxuICogQGF1dGhvciBNb2lzw6lzIEFyY29zIChtYXJjb3NAZW1lcmd5YS5jb20pXG4gKi9cblNNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyID0gU01DLnByb3ZpZGVycy5GZWF0dXJlc1Byb3ZpZGVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyIyAqL1xuICAgIHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGVkZWYge09iamVjdH0gU01DLnByb3ZpZGVycy5VUkxGZWF0dXJlUHJvdmlkZXJ+b3B0aW9uc1xuICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdXJsPW51bGwgLSBUaGUgZGVmYXVsdCB1cmwgdG8gdGhlIGZlYXR1cmUgcHJvdmlkZXJcbiAgICAgICAgICovXG4gICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCJcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEluaXRpYWxpemUgdGhlIGNsYXNzIHdpdGggb3B0aW9ucyBwYXJhbWV0ZXJcbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IG9wdGlvbnMgLSBkZWZhdWx0IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIFNNQy5wcm92aWRlcnMuRmVhdHVyZXNQcm92aWRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgcmVxdWVzdCB0byBnZXQgdGhlIGZlYXR1cmVzXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IERlZmVycmVkIG9iamVjdCBmcm9tIGpRdWVyeVxuICAgICAgICAgKi9cbiAgICAgICAgZG9GZWF0dXJlc0xvYWRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy51cmwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJC5hamF4KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLm9wdGlvbnMudXJsLFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgICAgICBkYXRhVHlwZTogdGhpcy5vcHRpb25zLmRhdGFUeXBlXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpO1xuICAgICAgICB9XG4gICAgfVxuKTtcbiIsInJlcXVpcmUoXCIuL1VSTEZlYXR1cmVQcm92aWRlci5qc1wiKTtcblxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBhIFdGUyBwcm92aWRlclxuICogQGNsYXNzXG4gKiBAZXh0ZW5kcyBTTUMucHJvdmlkZXJzLlVSTEZlYXR1cmVQcm92aWRlclxuICogQG1peGVzIEwuTWl4aW4uRXZlbnRzXG4gKiBAcGFyYW0ge1NNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXJ+b3B0aW9uc30gb3B0aW9ucyAtIFRoZSBjb25maWd1cmF0aW9uIGZvciB0aGUgY2xhc3NcbiAqXG4gKiBAYXV0aG9yIE1vaXPDqXMgQXJjb3MgKG1hcmNvc0BlbWVyZ3lhLmNvbSlcbiAqL1xuU01DLnByb3ZpZGVycy5XRlNQcm92aWRlciA9IFNNQy5wcm92aWRlcnMuVVJMRmVhdHVyZVByb3ZpZGVyLmV4dGVuZChcbiAgICAvKiogQGxlbmRzIFNNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXIjICovXG4gICAge1xuICAgICAgIC8qKlxuICAgICAgICAqIEB0eXBlZGVmIHtPYmplY3R9IFNNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXJ+b3B0aW9uc1xuICAgICAgICAqIEBwcm9wZXJ0eSB7U01DLnByb3ZpZGVycy5XRlNQcm92aWRlcn5yZXF1ZXN0UGFyYW1zfSByZXF1ZXN0UGFyYW1zIC0gRGVmYXVsdCB3ZnMgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHNlcnZlclVSTD1udWxsIC0gVGhlIHdmcyBzZXJ2ZXIgdXJsIHBhdGggcGFyYW1ldGVyXG4gICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IGJib3g9bnVsbCAtIFRoZSBiYm94IHBhcmFtZXRlclxuICAgICAgICAqL1xuICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICAvKiogQHR5cGVkZWYge09iamVjdH0gU01DLnByb3ZpZGVycy5XRlNQcm92aWRlcn5yZXF1ZXN0UGFyYW1zIC0gRGVmYXVsdCB3ZnMgcmVxdWVzdCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc2VydmljZT1cIndmc1wiIC0gRGVmYXVsdCB3ZnMgc2VydmljZVxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHZlcnNpb249XCIxLjEuMFwiIC0gRGVmYXVsdCB3ZnMgdmVyc2lvblxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHJlcXVlc3Q9XCJHZXRGZWF0dXJlXCIgLSBEZWZhdWx0IHdmcyByZXF1ZXN0XG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gdHlwZU5hbWU9XCJuYW1lc3BhY2U6ZmVhdHVyZXR5cGVcIiAtIERlZmF1bHQgd2ZzIHR5cGVuYW1lXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gZmVhdHVyZUlEPW51bGwgLSBEZWZhdWx0IHdmcyBmZWF0dXJlIGlkXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY291bnQ9bnVsbCAtIERlZmF1bHQgd2ZzIGNvdW50IHBhcmFtZXRlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG1heEZlYXR1cmVzPW51bGwgLSBEZWZhdWx0IHdmcyBtYXggZmVhdHVyZXMgcGFyYW1ldGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gc29ydEJ5PW51bGwgLSBEZWZhdWx0IHdmcyBzb3J0IGJ5IHBhcmFtZXRlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IHByb3BlcnR5TmFtZT1udWxsIC0gRGVmYXVsdCB3ZnMgcHJvcGVydHkgbmFtZSBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBzcnNOYW1lPVwiRVBTRzo0MzI2XCIgLSBEZWZhdWx0IHdmcyBjb29yZGluYXRlIHJlZmVyZW5jZSBzeXN0ZW0gcGFyYW1ldGVyXG4gICAgICAgICAgICAgKiBAcHJvcGVydHkge3N0cmluZ30gY3FsRmlsdGVyPW51bGwgLSBEZWZhdWx0IHdmcyBjcWwgZmlsdGVyIHBhcmFtZXRlclxuICAgICAgICAgICAgICogQHByb3BlcnR5IHtzdHJpbmd9IG91dHB1dEZvcm1hdD1cInRleHQvamF2YXNjcmlwdFwiIC0gRGVmYXVsdCB3ZnMgb3V0cHV0IGZvcm1hdCBwYXJhbWV0ZXJcbiAgICAgICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBmb3JtYXRfb3B0aW9ucz1udWxsIC0gRGVmYXVsdCB3ZnMgZm9ybWF0IG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHJlcXVlc3RQYXJhbXM6e1xuICAgICAgICAgICAgICAgIHNlcnZpY2U6IFwid2ZzXCIsXG4gICAgICAgICAgICAgICAgdmVyc2lvbjogXCIxLjEuMFwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IFwiR2V0RmVhdHVyZVwiLFxuICAgICAgICAgICAgICAgIHR5cGVOYW1lOiBcIm5hbWVzcGFjZTpmZWF0dXJldHlwZVwiLFxuICAgICAgICAgICAgICAgIGZlYXR1cmVJRDogbnVsbCxcbiAgICAgICAgICAgICAgICBjb3VudDogbnVsbCxcbiAgICAgICAgICAgICAgICBtYXhGZWF0dXJlczogbnVsbCxcbiAgICAgICAgICAgICAgICBzb3J0Qnk6IG51bGwsXG4gICAgICAgICAgICAgICAgcHJvcGVydHlOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgIHNyc05hbWU6IFwiRVBTRzo0MzI2XCIsXG4gICAgICAgICAgICAgICAgY3FsX2ZpbHRlcjogbnVsbCxcbiAgICAgICAgICAgICAgICBvdXRwdXRGb3JtYXQ6IFwidGV4dC9qYXZhc2NyaXB0XCIsXG4gICAgICAgICAgICAgICAgZm9ybWF0X29wdGlvbnM6IG51bGxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXJ2ZXJVUkw6IG51bGwsXG4gICAgICAgICAgICBiYm94OiBudWxsLFxuICAgICAgICAgICAgXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbml0aWFsaXplIHRoZSBjbGFzcyB3aXRoIG9wdGlvbnMgcGFyYW1ldGVyXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zIC0gZGVmYXVsdCBvcHRpb25zXG4gICAgICAgICAqL1xuICAgICAgICBpbml0aWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAgICAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNlbmQgV0ZTIHJlcXVlc3QgdG8gZ2V0IHRoZSBmZWF0dXJlc1xuICAgICAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBEZWZlcnJlZCBvYmplY3QgZnJvbSBqUXVlcnlcbiAgICAgICAgICovXG4gICAgICAgIGRvRmVhdHVyZXNMb2FkaW5nOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgXHR2YXIganNvbnBSYW5kb20gPSB0aGlzLl9tYWtlaWQoKTtcbiAgICAgICAgXHR0aGlzLm9wdGlvbnMuZm9ybWF0X29wdGlvbnMgPSBcImNhbGxiYWNrOlwiICsganNvbnBSYW5kb207XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2VydmVyVVJMICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlcXVlc3REYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICB1cmw6IHRoaXMub3B0aW9ucy5zZXJ2ZXJVUkwsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZ2V0UGFyYW1zRnJvbU9wdGlvbnMoKSxcbiAgICAgICAgICAgICAgICAgICAganNvbnBDYWxsYmFjazoganNvbnBSYW5kb20sXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCIsXG4gICAgICAgICAgICAgICAgICAgIGpzb25wOiBmYWxzZVxuICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgIC8qIGlmKGJvdW5kcyl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtcy5jcWxfZmlsdGVyID0gcmVxdWVzdERhdGEuZGF0YS5jcWxfZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYocmVxdWVzdERhdGEuZGF0YS5jcWxfZmlsdGVyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLmRhdGEuY3FsX2ZpbHRlciA9ICB0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtcy5jcWxfZmlsdGVyICsgJyBBTkQgJyArIHRoaXMub3B0aW9ucy5iYm94O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZXtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0RGF0YS5kYXRhLmNxbF9maWx0ZXIgPSB0aGlzLm9wdGlvbnMuYmJveDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIH0qL1xuXG4gICAgICAgICAgICAgICAgaWYoYm91bmRzKXsgIFxuICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLmJib3ggPSAnYmJveCgnK3RoaXMub3B0aW9ucy5maWVsZEdlb20gKycsJyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBib3VuZHNbMV0rICcsJ1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArIGJvdW5kc1swXSsgJywnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICsgYm91bmRzWzNdKyAnLCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKyBib3VuZHNbMl1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKycpJztcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3REYXRhLmRhdGFbJyddID0gdGhpcy5vcHRpb25zLmJib3g7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuICQuYWpheChyZXF1ZXN0RGF0YSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gJC5EZWZlcnJlZCgpO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgcGFyYW1zIGZyb20gb3B0aW9ucyBhdHRyaWJ1dGVzXG4gICAgICAgICAqIEByZXR1cm5zIHtvYmplY3R9IE9iamVjdCB3aXRoIHRoZSB3ZnMgcGFyYW1zIHRvIHNlbmRcbiAgICAgICAgICovXG4gICAgICAgIGdldFBhcmFtc0Zyb21PcHRpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwYXJhbXMgPSB7fTtcbiAgICAgICAgICAgIGZvciAodmFyIG9wdGlvbiBpbiB0aGlzLm9wdGlvbnMucmVxdWVzdFBhcmFtcykge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmKHRoaXMub3B0aW9uc1tvcHRpb25dKXtcbiAgICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvcHRpb25dID0gdGhpcy5vcHRpb25zW29wdGlvbl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5yZXF1ZXN0UGFyYW1zW29wdGlvbl0gIT09IG51bGwgJiYgb3B0aW9uICE9ICdjcWxfZmlsdGVyJyl7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtc1tvcHRpb25dID0gdGhpcy5vcHRpb25zLnJlcXVlc3RQYXJhbXNbb3B0aW9uXTtcbiAgICAgICAgICAgICAgICB9ICAgIFxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXRob2QgdG8gZ2V0IGFuIGlkXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICBfbWFrZWlkOiBmdW5jdGlvbigpe1xuICAgICAgICBcdHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgICAgXHR2YXIgcG9zc2libGUgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIjtcbiAgICAgICAgXHRmb3IoIHZhciBpPTA7IGkgPCA1OyBpKysgKVxuICAgIFx0ICAgICAgICB0ZXh0ICs9IHBvc3NpYmxlLmNoYXJBdChNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBwb3NzaWJsZS5sZW5ndGgpKTtcbiAgICAgICAgXHRyZXR1cm4gdGV4dDtcbiAgICBcdH1cbiAgICB9XG4pO1xuLyoqXG4gKiBBUEkgZmFjdG9yeSBtZXRob2QgZm9yIGVhc2UgY3JlYXRpb24gb2Ygd2ZzIGZlYXR1cmVzIHByb3ZpZGVycy5cbiAqIEBwYXJhbXMge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gaW5pdGlhbGl6ZSB0aGUgV0ZTIHByb3ZpZGVyXG4gKi9cblNNQy53ZnNQcm92aWRlciA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXIob3B0aW9ucyk7XG59O1xuIiwicmVxdWlyZShcIi4vV0ZTUHJvdmlkZXJcIik7XG4vKipcbiAqIEJhc2UgY2xhc3MgdG8gY3JlYXRlIGEgV0ZTLVQgcHJvdmlkZXJcbiAqIEBjbGFzc1xuICogQGV4dGVuZHMgU01DLnByb3ZpZGVycy5XRlNQcm92aWRlclxuICogQG1peGVzIEwuTWl4aW4uRXZlbnRzXG4gKiBAcGFyYW0ge1NNQy5wcm92aWRlcnMuV0ZTVFByb3ZpZGVyfm9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgY29uZmlndXJhdGlvbiBmb3IgdGhlIGNsYXNzXG4gKlxuICogQGF1dGhvciBNb2lzw6lzIEFyY29zIChtYXJjb3NAZW1lcmd5YS5jb20pXG4gKi9cblNNQy5wcm92aWRlcnMuV0ZTVFByb3ZpZGVyID0gU01DLnByb3ZpZGVycy5XRlNQcm92aWRlci5leHRlbmQoXG4gICAgLyoqIEBsZW5kcyBTTUMucHJvdmlkZXJzLldGU1RQcm92aWRlciMgKi9cbiAgICB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBTTUMucHJvdmlkZXJzLldGU1RQcm92aWRlcn5vcHRpb25zXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBkZWZhdWx0TmV3VmFsdWVzPW51bGwgLSBUaGUgZGVmYXVsdCB2YWx1ZXMgIHRvIHRoZSBmaWVsZHMgZnJvbSBmZWF0dXJlXG4gICAgICAgICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSByZWFkT25seUZpZWxkcz1udWxsIC0gVGhlIGRlZmF1bHQgbm8gZWRpdGFibGUgZmllbGRzIGZyb20gZmVhdHVyZVxuICAgICAgICAgKi9cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZGVmYXVsdE5ld1ZhbHVlczoge30sXG4gICAgICAgICAgICByZWFkT25seUZpZWxkczogW11cbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogSW5pdGlhbGl6ZSB0aGUgY2xhc3Mgd2l0aCBvcHRpb25zIHBhcmFtZXRlclxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gb3B0aW9ucyAtIGRlZmF1bHQgb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICAgICAgU01DLnByb3ZpZGVycy5XRlNQcm92aWRlci5wcm90b3R5cGUuaW5pdGlhbGl6ZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIF9nZXRFbGVtZW50c0J5VGFnTmFtZU5TOiBmdW5jdGlvbihlbGVtZW50LCBuYW1lc3BhY2UsIHRhZ05hbWUpIHtcbiAgICAgICAgICAgIHZhciBlbGVtZW50cyA9IGVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSk7XG4gICAgICAgICAgICBpZighZWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZWxlbWVudHMgPSBlbGVtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWVzcGFjZSArXCI6XCIrdGFnTmFtZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiBlbGVtZW50cztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHByZXBhcmUgV0ZTLVQgcmVxdWVzdCBwYXlsb2FkIHRvIGluc2VydCBhIGdlb21ldHJ5XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBnZW9tZXRyeSAtIGVsZW1lbnQgdG8gYmUgYWRkZWRcbiAgICAgICAgICovXG4gICAgICAgIF9pbnNlcnQ6IGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICB2YXIgZ2VvbV90eXBlID0gdGhpcy5fZ2V0R2VvbVR5cGUoZ2VvbWV0cnkpO1xuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIHVybDogdGhpcy5vcHRpb25zLnNlcnZlclVSTCArIFwiP3JlcXVlc3Q9RGVzY3JpYmVGZWF0dXJlVHlwZSZ2ZXJzaW9uPTEuMS4wJnR5cGVuYW1lPVwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnR5cGVOYW1lLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcInhtbFwiLFxuICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlOiBcInRleHQveG1sXCIsXG4gICAgICAgICAgICAgICAgc3VjY2VzczogZnVuY3Rpb24oeG1sLCBzdGF0dXMsIG9iamVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc2NoZW1hID0gc2VsZi5fZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyh4bWwsIFwieHNkXCIsIFwic2NoZW1hXCIpWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0TmFtZXNwYWNlID0gc2NoZW1hLmdldEF0dHJpYnV0ZShcInRhcmdldE5hbWVzcGFjZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG5hbWVzcGFjZSA9IHNlbGYub3B0aW9ucy50eXBlTmFtZS5zcGxpdChcIjpcIilbMF07XG4gICAgICAgICAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IHNlbGYub3B0aW9ucy50eXBlTmFtZS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcnNOYW1lID0gc2VsZi5vcHRpb25zLnNyc05hbWUgP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vcHRpb25zLnJlcXVlc3RQYXJhbXMuc3JzTmFtZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICBcIkVQU0c6NDMyNlwiO1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlcyA9IHNlbGYuX2dldEVsZW1lbnRzQnlUYWdOYW1lTlMoc2VsZi5fZ2V0RWxlbWVudHNCeVRhZ05hbWVOUyh4bWwsIFwieHNkXCIsXCJzZXF1ZW5jZVwiKVswXSxcInhzZFwiLCdlbGVtZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0aGVHZW9tID0gJ3RoZV9nZW9tJztcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0cmlidXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PSBcImdtbDpHZW9tZXRyeVByb3BlcnR5VHlwZVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhlR2VvbSA9IGF0dHJpYnV0ZXNbaV0uZ2V0QXR0cmlidXRlKCduYW1lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIHBvc3REYXRhID1cbiAgICAgICAgICAgICAgICAgICAgICAgICc8d2ZzOlRyYW5zYWN0aW9uIHZlcnNpb249XCIxLjEuMFwiIHNlcnZpY2U9XCJXRlNcIlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3htbG5zOndmcz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2ZzXCJcXG4nICsgJ3htbG5zOicgKyBuYW1lc3BhY2UgKyAnPVwiJyArXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROYW1lc3BhY2UgKyAnXCI+XFxuJyArICcgICA8d2ZzOkluc2VydD5cXG4nICsgJyAgICAgICA8JyArIHNlbGYub3B0aW9ucy50eXBlTmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHhtbG5zOmZlYXR1cmU9XCInICsgc2VsZi5vcHRpb25zLnNlcnZlclVSTCArICdcIj5cXG4nICsgJyAgICAgICAgICAgPCcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbmFtZXNwYWNlICsgJzonICsgdGhlR2VvbSArICc+XFxuJyArICcgICAgICAgICAgICAgICA8Z21sOicgKyBnZW9tX3R5cGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyB4bWxuczpnbWw9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L2dtbFwiIHNyc05hbWU9XCInICsgc3JzTmFtZSArICdcIj5cXG4nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICcgICAgICAgICAgICAgICAgICAgPGdtbDpwb3M+JyArIGdlb21ldHJ5LmdldExhdExuZygpLmxuZyArICcgJyArIGdlb21ldHJ5LmdldExhdExuZygpXG4gICAgICAgICAgICAgICAgICAgICAgICAubGF0ICsgJzwvZ21sOnBvcz5cXG4nICsgJyAgICAgICAgICAgICAgIDwvZ21sOicgKyBnZW9tX3R5cGUgKyAnPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgICAgICAgICAgPC8nICsgbmFtZXNwYWNlICsgJzonICsgdGhlR2VvbSArICc+XFxuJyArICcgICAgICAgPC8nICsgc2VsZi5vcHRpb25zXG4gICAgICAgICAgICAgICAgICAgICAgICAudHlwZU5hbWUgKyAnPlxcbicgKyAnICAgPC93ZnM6SW5zZXJ0PlxcbicgKyAnPC93ZnM6VHJhbnNhY3Rpb24+XFxuJztcblxuICAgICAgICAgICAgICAgICAgIHNlbGYuX3NlbmRSZXF1ZXN0KFwiUE9TVFwiLCBzZWxmLm9wdGlvbnMuc2VydmVyVVJMLCBwb3N0RGF0YSwgZnVuY3Rpb24oeG1sKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZWxmLl9nZXRFbGVtZW50c0J5VGFnTmFtZU5TKHhtbCwgXCJvZ2NcIiwgJ0ZlYXR1cmVJZCcpWzBdLmdldEF0dHJpYnV0ZSgnZmlkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLl9sb2FkTWFya2VyKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgIF9sb2FkTWFya2VyOiBmdW5jdGlvbihpZCkge1xuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgdmFyIHNyc05hbWUgPSB0aGlzLm9wdGlvbnMuc3JzTmFtZSA/IHNlbGYub3B0aW9ucy5yZXF1ZXN0UGFyYW1zLnNyc05hbWUgOiBcIkVQU0c6NDMyNlwiO1xuICAgICAgICAgICAgdmFyIGpzb25wUmFuZG9tID0gdGhpcy5fbWFrZWlkKCk7XG4gICAgICAgICAgICB2YXIgZm9ybWF0T3B0aW9ucyA9IFwiY2FsbGJhY2s6XCIgKyBqc29ucFJhbmRvbTtcblxuICAgICAgICAgICAgJC5hamF4KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcIkdFVFwiLFxuICAgICAgICAgICAgICAgIHVybDogdGhpcy5vcHRpb25zLnNlcnZlclVSTCArIFwiP3NlcnZpY2U9d2ZzJnZlcnNpb249MS4xLjAmcmVxdWVzdD1HZXRGZWF0dXJlJnR5cGVuYW1lPVwiICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vcHRpb25zLnR5cGVOYW1lICsgXCImc3JzTmFtZT1cIiArIHNyc05hbWUgK1xuICAgICAgICAgICAgICAgICAgICBcIiZvdXRwdXRGb3JtYXQ9dGV4dC9qYXZhc2NyaXB0JmZlYXR1cmVJZD1cIiArIGlkICsgXCImZm9ybWF0X29wdGlvbnM9XCIgK1xuICAgICAgICAgICAgICAgICAgICBmb3JtYXRPcHRpb25zLFxuICAgICAgICAgICAgICAgIGRhdGFUeXBlOiBcImpzb25wXCIsXG4gICAgICAgICAgICAgICAganNvbnBDYWxsYmFjazoganNvbnBSYW5kb20sXG4gICAgICAgICAgICAgICAganNvbnA6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IGZ1bmN0aW9uKGZlYXR1cmVDb2xsZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmZWF0dXJlID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXM7ICBcbiAgICAgICAgICAgICAgICAgICAgZmVhdHVyZSA9IHNlbGYuX3NldERlZmF1bHRWYWx1ZXMoZmVhdHVyZSk7IFxuICAgICAgICAgICAgICAgICAgICBmZWF0dXJlLmdlb21fdHlwZSA9ICdQb2ludCc7XG4gICAgICAgICAgICAgICAgICAgIGZlYXR1cmUuZmVhdHVyZSA9IGZlYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuX3VwZGF0ZShmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5hZGRNYXJrZXJGcm9tRmVhdHVyZShmZWF0dXJlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG4gICAgICAgICBfc2V0RGVmYXVsdFZhbHVlczogZnVuY3Rpb24oZmVhdHVyZSl7XG4gICAgICAgICAgICB2YXIgZGVmYXVsdFZhbHVlcyA9IHRoaXMub3B0aW9ucy5kZWZhdWx0TmV3VmFsdWVzO1xuICAgICAgICAgICAgdmFyIHByb3AgPSBmZWF0dXJlWzBdLnByb3BlcnRpZXM7XG4gICAgICAgICAgICBmb3IodmFyIGkgaW4gcHJvcCl7XG4gICAgICAgICAgICAgICAgaWYoZGVmYXVsdFZhbHVlc1tpXSl7XG4gICAgICAgICAgICAgICAgICAgcHJvcFtpXSA9IGRlZmF1bHRWYWx1ZXNbaV07XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmVhdHVyZVswXTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBwcmVwYXJlIFdGUy1UIHJlcXVlc3QgcGF5bG9hZCB0byB1cGRhdGUgYSBnZW9tZXRyeVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge29iamVjdH0gZ2VvbWV0cnkgLSBlbGVtZW50IHRvIGJlIHVwZGF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIF91cGRhdGU6IGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiR0VUXCIsXG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLm9wdGlvbnMuc2VydmVyVVJMICsgXCI/cmVxdWVzdD1EZXNjcmliZUZlYXR1cmVUeXBlJnZlcnNpb249MS4xLjAmdHlwZW5hbWU9XCIgK1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMudHlwZU5hbWUsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwieG1sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiBmdW5jdGlvbih4bWwsIHN0YXR1cywgb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBzcnNOYW1lID0gc2VsZi5vcHRpb25zLnNyc05hbWUgPyBzZWxmLm9wdGlvbnMucmVxdWVzdFBhcmFtcy5zcnNOYW1lIDogXCJFUFNHOjQzMjZcIjtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzZWxmLl9nZXRFbGVtZW50c0J5VGFnTmFtZU5TKHNlbGYuX2dldEVsZW1lbnRzQnlUYWdOYW1lTlMoeG1sLCBcInhzZFwiLFwic2VxdWVuY2VcIilbMF0sXCJ4c2RcIiwnZWxlbWVudCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciB3ZnNfZWxlbWVudHMgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBpZighZ2VvbWV0cnkuZWFjaExheWVyKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHdmc19lbGVtZW50cyA9IHNlbGYuX2dldFdGU1VwZGF0ZShnZW9tZXRyeSwgc3JzTmFtZSwgYXR0cmlidXRlcyk7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNle1xuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnkuZWFjaExheWVyKGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSBlZGl0ZWQgZmVhdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3ZnNfZWxlbWVudHMgKz0gc2VsZi5fZ2V0V0ZTVXBkYXRlKGxheWVyLCBzcnNOYW1lLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHZhciBwb3N0RGF0YSA9XG4gICAgICAgICAgICAgICAgICAgICAgICAnPHdmczpUcmFuc2FjdGlvblxcbicgKyAndmVyc2lvbj1cIjEuMS4wXCJcXG4nICsgJ3NlcnZpY2U9XCJXRlNcIlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3htbG5zOndmcz1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvd2ZzXCI+XFxuJyArIHdmc19lbGVtZW50cyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnPC93ZnM6VHJhbnNhY3Rpb24+XFxuJztcblxuICAgICAgICAgICAgICAgICAgICBzZWxmLl9zZW5kUmVxdWVzdChcIlBPU1RcIiwgc2VsZi5vcHRpb25zLnNlcnZlclVSTCwgcG9zdERhdGEpO1xuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9LFxuXG5cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIHByZXBhcmUgV0ZTLVQgcmVxdWVzdCBwYXlsb2FkIHRvIGRlbGV0ZSBhIGdlb21ldHJ5XG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqIEBwYXJhbSB7b2JqZWN0fSBnZW9tZXRyeSAtIGVsZW1lbnQgdG8gYmUgcmVtb3ZlZFxuICAgICAgICAgKi9cbiAgICAgICAgX2RlbGV0ZTogZnVuY3Rpb24oZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHZhciB0eXBlTmFtZSA9IHNlbGYub3B0aW9ucy50eXBlTmFtZS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgICAgICB2YXIgd2ZzX2VsZW1lbnRzID0gXCJcIjtcbiAgICAgICAgICAgIGdlb21ldHJ5LmVhY2hMYXllcihmdW5jdGlvbihsYXllcikge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgZWRpdGVkIGZlYXR1cmVzXG4gICAgICAgICAgICAgICAgd2ZzX2VsZW1lbnRzICs9IHNlbGYuX2dldFdGU0RlbGV0ZSh0eXBlTmFtZSwgbGF5ZXIuZmVhdHVyZS5pZCk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIHBvc3REYXRhID1cbiAgICAgICAgICAgICAgICAnPHdmczpUcmFuc2FjdGlvblxcbicgKyAndmVyc2lvbj1cIjEuMS4wXCJcXG4nICsgJ3NlcnZpY2U9XCJXRlNcIlxcbicgK1xuICAgICAgICAgICAgICAgICd4bWxuczp3ZnM9XCJodHRwOi8vd3d3Lm9wZW5naXMubmV0L3dmc1wiPlxcbicgKyB3ZnNfZWxlbWVudHMgKyAnPC93ZnM6VHJhbnNhY3Rpb24+XFxuJztcblxuICAgICAgICAgICAgdGhpcy5fc2VuZFJlcXVlc3QoXCJQT1NUXCIsIHRoaXMub3B0aW9ucy5zZXJ2ZXJVUkwsIHBvc3REYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBzZW5kIFdGUy1UIHJlcXVlc3RcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHVybCBzZXJ2ZXIgd2hlcmUgc2VuZCByZXF1ZXN0XG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkYXRhIC0gcmVxdWVzdCBwYXlsb2FkXG4gICAgICAgICAqL1xuICAgICAgICBfc2VuZFJlcXVlc3Q6IGZ1bmN0aW9uKHR5cGUsIHVybCwgZGF0YSwgbWV0aG9kKSB7XG4gICAgICAgICAgICAkLmFqYXgoe1xuICAgICAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgICAgICAgICAgZGF0YVR5cGU6IFwieG1sXCIsXG4gICAgICAgICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC94bWxcIixcbiAgICAgICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IG1ldGhvZFxuICAgICAgICAgICAgfSkuZmFpbChmdW5jdGlvbih4aHIsIHN0YXR1cywgZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmRlYnVnKGVycm9yKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogTWV0aG9kIHRvIGdldCB0aGUgZ2VvbWV0cnkgdHlwZVxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvbWV0cnkgLSBHZW9tZXRyeSB0byBnZXQgdHlwZVxuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBnZW9tZXRyeSB0eXBlXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0R2VvbVR5cGU6IGZ1bmN0aW9uKGdlb21ldHJ5KSB7XG4gICAgICAgICAgICB2YXIgZ2VvbV90eXBlID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChnZW9tZXRyeSBpbnN0YW5jZW9mIEwuTWFya2VyIHx8IGdlb21ldHJ5IGluc3RhbmNlb2YgTC5Qb2ludCkge1xuICAgICAgICAgICAgICAgIGdlb21fdHlwZSA9IFwiUG9pbnRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKGdlb21ldHJ5Lmdlb21fdHlwZSl7XG4gICAgICAgICAgICAgICAgZ2VvbV90eXBlID0gZ2VvbWV0cnkuZ2VvbV90eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGdlb21fdHlwZTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBnZXQgdGhlIHdmcyBkZWxldGUgcmVxdWVzdFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZU5hbWUgLSB0eXBlIG5hbWUgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGZlYXR1cmVJZCAtIGlkIGZyb20gdGhlIGVsZW1lbnQgdG8gcmVtb3ZlXG4gICAgICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IHJlcXVlc3QgZmlsdGVyIHRvIHJlbW92ZSBlbGVtZW50c1xuICAgICAgICAgKi9cbiAgICAgICAgX2dldFdGU0RlbGV0ZTogZnVuY3Rpb24odHlwZU5hbWUsIGZlYXR1cmVJZCkge1xuICAgICAgICAgICAgdmFyIHJlcyA9XG4gICAgICAgICAgICAgICAgJyAgIDx3ZnM6RGVsZXRlIHR5cGVOYW1lPVwiZmVhdHVyZTonICsgdHlwZU5hbWUgKyAnXCIgeG1sbnM6ZmVhdHVyZT1cImh0dHA6Ly9vcGVuZ2VvLm9yZ1wiPlxcbicgK1xuICAgICAgICAgICAgICAgICcgICAgICAgPG9nYzpGaWx0ZXIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIj5cXG4nICtcbiAgICAgICAgICAgICAgICAnICAgICAgICAgICA8b2djOkZlYXR1cmVJZCBmaWQ9XCInICsgZmVhdHVyZUlkICsgJ1wiLz5cXG4nICsgJyAgICAgICA8L29nYzpGaWx0ZXI+XFxuJyArXG4gICAgICAgICAgICAgICAgJyAgIDwvd2ZzOkRlbGV0ZT5cXG4nO1xuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1ldGhvZCB0byBnZXQgdGhlIHdmcyB1cGRhdGUgcmVxdWVzdFxuICAgICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gZ2VvbWV0cnkgLSB0eXBlIG5hbWUgbGF5ZXJcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHNyc05hbWUgLSBsYXllciBzcnNcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gcmVxdWVzdCBmaWx0ZXIgdG8gdXBkYXRlIGVsZW1lbnRzXG4gICAgICAgICAqL1xuICAgICAgICBfZ2V0V0ZTVXBkYXRlOiBmdW5jdGlvbihnZW9tZXRyeSwgc3JzTmFtZSwgYXR0cmlidXRlcykge1xuICAgICAgICAgICAgdmFyIGdlb21fdHlwZSA9IHRoaXMuX2dldEdlb21UeXBlKGdlb21ldHJ5KTtcbiAgICAgICAgICAgIHZhciBsYXQsIGxuZztcbiAgICAgICAgICAgIGlmKGdlb21ldHJ5LmdldExhdExuZyl7XG4gICAgICAgICAgICAgICAgbGF0ID0gZ2VvbWV0cnkuZ2V0TGF0TG5nKCkubGF0O1xuICAgICAgICAgICAgICAgIGxuZyA9IGdlb21ldHJ5LmdldExhdExuZygpLmxuZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2V7XG4gICAgICAgICAgICAgICAgbGF0ID0gZ2VvbWV0cnkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgbG5nID0gZ2VvbWV0cnkuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgdHlwZU5hbWUgPSB0aGlzLm9wdGlvbnMudHlwZU5hbWUuc3BsaXQoXCI6XCIpWzFdO1xuICAgICAgICAgICAgdmFyIHJlcyA9ICcgPHdmczpVcGRhdGUgdHlwZU5hbWU9XCJmZWF0dXJlOicgKyB0eXBlTmFtZSArICdcIiB4bWxuczpmZWF0dXJlPVwiaHR0cDovL29wZW5nZW8ub3JnXCI+XFxuJztcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBuYW1lID0gYXR0cmlidXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ25hbWUnKTtcbiAgICAgICAgICAgICAgICByZXMgKz0gJyAgICAgICA8d2ZzOlByb3BlcnR5PlxcbidcblxuICAgICAgICAgICAgICAgICsgJyAgICAgICAgICAgPHdmczpOYW1lPicgKyBuYW1lICsgJzwvd2ZzOk5hbWU+XFxuJ1xuXG4gICAgICAgICAgICAgICAgKyAnICAgICAgICAgICA8d2ZzOlZhbHVlPlxcbic7XG4gICAgICAgICAgICAgICAgaWYgKGF0dHJpYnV0ZXNbaV0uZ2V0QXR0cmlidXRlKCd0eXBlJykgPT0gJ2dtbDpHZW9tZXRyeVByb3BlcnR5VHlwZScgfHwgYXR0cmlidXRlc1tpXS5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PSAnZ21sOlBvaW50UHJvcGVydHlUeXBlJykge1xuICAgICAgICAgICAgICAgICAgICByZXMgKz0gJyAgICAgICAgICAgICAgIDxnbWw6JyArIGdlb21fdHlwZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnIHhtbG5zOmdtbD1cImh0dHA6Ly93d3cub3Blbmdpcy5uZXQvZ21sXCIgc3JzTmFtZT1cIicgKyBzcnNOYW1lICsgJ1wiPlxcbicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJyAgICAgICAgICAgICAgICAgICA8Z21sOnBvcz4nICsgbG5nICsgJyAnICsgbGF0ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICc8L2dtbDpwb3M+XFxuJyArICcgICAgICAgICAgICAgICA8L2dtbDonICsgZ2VvbV90eXBlICsgJz5cXG4nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkuZmVhdHVyZS5wcm9wZXJ0aWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzICs9IGdlb21ldHJ5LmZlYXR1cmUucHJvcGVydGllc1tuYW1lXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzICs9ICcgICAgICAgICAgIDwvd2ZzOlZhbHVlPlxcbidcblxuICAgICAgICAgICAgICAgICsgJyAgICAgICA8L3dmczpQcm9wZXJ0eT5cXG4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzICs9ICcgICAgICAgPG9nYzpGaWx0ZXIgeG1sbnM6b2djPVwiaHR0cDovL3d3dy5vcGVuZ2lzLm5ldC9vZ2NcIj5cXG4nICtcbiAgICAgICAgICAgICAgICAnICAgICAgICAgICA8b2djOkZlYXR1cmVJZCBmaWQ9XCInICsgZ2VvbWV0cnkuZmVhdHVyZS5pZCArICdcIi8+XFxuJyArICcgICAgICAgPC9vZ2M6RmlsdGVyPlxcbicgK1xuICAgICAgICAgICAgICAgICcgICA8L3dmczpVcGRhdGU+XFxuJztcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIH0sXG4gICAgfSwgW1NNQy5wcm92aWRlcnMuV0ZTUHJvdmlkZXJdKTtcbi8qKlxuICogQVBJIGZhY3RvcnkgbWV0aG9kIGZvciBlYXNlIGNyZWF0aW9uIG9mIHdmcyBmZWF0dXJlcyBwcm92aWRlcnMuXG4gKiBAcGFyYW1zIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIGluaXRpYWxpemUgdGhlIFdGUyBwcm92aWRlclxuICovXG5TTUMud2ZzdFByb3ZpZGVyID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgU01DLnByb3ZpZGVycy5XRlNUUHJvdmlkZXIob3B0aW9ucyk7XG59O1xuIiwicmVxdWlyZShcIi4uL1NNQy5qc1wiKTtcblxuLyoqXG4gKiBOYW1lc3BhY2Ugb2YgU01DLlZpZXdlcidzIGRhdGEgcHJvdmlkZXJzIGZvciB1c2UgYnkgbGF5ZXJzLlxuICogQG5hbWVzcGFjZVxuICogQG1lbWJlcm9mIFNNQ1xuICogQGF1dGhvciBMdWlzIFJvbcOhbiAobHJvbWFuQGVtZXJneWEuY29tKVxuICovXG5TTUMucHJvdmlkZXJzID0ge307Il19
